[
  {
    "instruction": "Write a Zig function similar to build from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: build.zig",
    "response": "pub fn build(b: *Build) void {\n    const target = b.standardTargetOptions(.{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "build.zig",
      "type": "function",
      "name": "build",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn deinit(self: AnimationFrame, allocator: std.mem.Allocator) void {\n        self.pixels.deinit(allocator);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn deinit(self: *Animation, allocator: std.mem.Allocator) void {\n        // Animation share its first frame with the pixels in Image, we don't want to free it twice\n        if (self.frames.items.len >= 2) {\n            for (self.frames.items[1..]) |frame| {\n                frame.pixels.deinit(allocator);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn deinit(self: *Image, allocator: std.mem.Allocator) void {\n    self.pixels.deinit(allocator);\n    self.animation.deinit(allocator);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to detectFormatFromFilePath from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn detectFormatFromFilePath(file_path: []const u8, read_buffer: []u8) !Format {\n    var file = try std.fs.cwd().openFile(file_path, .{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "detectFormatFromFilePath",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to detectFormatFromFile from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn detectFormatFromFile(file: std.fs.File, read_buffer: []u8) !Format {\n    var read_stream = io.ReadStream.initFile(file, read_buffer);\n    return internalDetectFormat(&read_stream);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "detectFormatFromFile",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to detectFormatFromMemory from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn detectFormatFromMemory(buffer: []const u8) !Format {\n    var read_stream = io.ReadStream.initMemory(buffer);\n    return internalDetectFormat(&read_stream);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "detectFormatFromMemory",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromFilePath from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn fromFilePath(allocator: std.mem.Allocator, file_path: []const u8, read_buffer: []u8) !Image {\n    var file = try std.fs.cwd().openFile(file_path, .{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "fromFilePath",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromFile from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn fromFile(allocator: std.mem.Allocator, file: std.fs.File, read_buffer: []u8) !Image {\n    var read_stream = io.ReadStream.initFile(file, read_buffer);\n    return internalRead(allocator, &read_stream);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "fromFile",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromMemory from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn fromMemory(allocator: std.mem.Allocator, buffer: []const u8) !Image {\n    var read_stream = io.ReadStream.initMemory(buffer);\n    return internalRead(allocator, &read_stream);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "fromMemory",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromRawPixelsOwned from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn fromRawPixelsOwned(width: usize, height: usize, pixels: []const u8, pixel_format: PixelFormat) !Image {\n    return .{\n        .width = width,\n        .height = height,\n        .pixels = try color.PixelStorage.initRawPixels(pixels, pixel_format),\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "fromRawPixelsOwned",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromRawPixels from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn fromRawPixels(allocator: std.mem.Allocator, width: usize, height: usize, pixels: []const u8, pixel_format: PixelFormat) !Image {\n    return .{\n        .width = width,\n        .height = height,\n        .pixels = try color.PixelStorage.initRawPixels(try allocator.dupe(u8, pixels), pixel_format),\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "fromRawPixels",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to create from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn create(allocator: std.mem.Allocator, width: usize, height: usize, pixel_format: PixelFormat) !Image {\n    const result = Image{\n        .width = width,\n        .height = height,\n        .pixels = try color.PixelStorage.init(allocator, pixel_format, width * height),\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "create",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to pixelFormat from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn pixelFormat(self: Image) PixelFormat {\n    return std.meta.activeTag(self.pixels);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "pixelFormat",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rawBytes from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn rawBytes(self: Image) []const u8 {\n    return self.pixels.asBytes();\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "rawBytes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rowByteSize from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn rowByteSize(self: Image) usize {\n    return self.imageByteSize() / self.height;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "rowByteSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to imageByteSize from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn imageByteSize(self: Image) usize {\n    return self.rawBytes().len;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "imageByteSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isAnimation from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn isAnimation(self: Image) bool {\n    return self.animation.frames.items.len > 0;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "isAnimation",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toManaged from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn toManaged(self: Image, allocator: std.mem.Allocator) Managed {\n    return .{\n        .allocator = allocator,\n        .width = self.width,\n        .height = self.height,\n        .pixels = self.pixels,\n        .animation = self.animation,\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "toManaged",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeToFilePath from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn writeToFilePath(self: Image, allocator: std.mem.Allocator, file_path: []const u8, write_buffer: []u8, encoder_options: EncoderOptions) WriteError!void {\n    var file = try std.fs.cwd().createFile(file_path, .{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "writeToFilePath",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeToFile from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn writeToFile(self: Image, allocator: std.mem.Allocator, file: std.fs.File, write_buffer: []u8, encoder_options: EncoderOptions) WriteError!void {\n    var write_stream = io.WriteStream.initFile(file, write_buffer);\n\n    try self.internalWrite(allocator, &write_stream, encoder_options);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "writeToFile",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeToMemory from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn writeToMemory(self: Image, allocator: std.mem.Allocator, write_buffer: []u8, encoder_options: EncoderOptions) WriteError![]u8 {\n    var write_stream = io.WriteStream.initMemory(write_buffer);\n\n    try self.internalWrite(allocator, &write_stream, encoder_options);\n\n    return write_stream.memory.buffered();\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "writeToMemory",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to convert from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn convert(self: *Image, allocator: std.mem.Allocator, destination_format: PixelFormat) ConvertError!void {\n    // Do nothing if the format is the same\n    if (std.meta.activeTag(self.pixels) == destination_format) {\n        return;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "convert",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to convertNoFree from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn convertNoFree(self: *Image, allocator: std.mem.Allocator, destination_format: PixelFormat) ConvertError!void {\n    // Do nothing if the format is the same\n    if (std.meta.activeTag(self.pixels) == destination_format) {\n        return;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "convertNoFree",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to flipVertically from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn flipVertically(self: *const Image, allocator: std.mem.Allocator) Editor.Error!void {\n    try Editor.flipVertically(&self.pixels, self.height, allocator);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "flipVertically",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to crop from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn crop(self: *const Image, allocator: std.mem.Allocator, area: Editor.Box) Editor.Error!Image {\n    return Editor.crop(self, allocator, area);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "crop",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to iterator from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub fn iterator(self: *const Image) color.PixelStorageIterator {\n    return color.PixelStorageIterator.init(&self.pixels);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "iterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to internalDetectFormat from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "fn internalDetectFormat(read_stream: *io.ReadStream) !Format {\n    for (all_interface_funcs, 0..) |intefaceFn, format_index| {\n        const formatInterface = intefaceFn();\n\n        const found = try formatInterface.formatDetect(read_stream);\n        if (found) {\n            return @enumFromInt(format_index);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "internalDetectFormat",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to internalRead from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "fn internalRead(allocator: std.mem.Allocator, read_stream: *io.ReadStream) !Image {\n    const format_interface = try findImageInterfaceFromStream(read_stream);\n\n    return try format_interface.readImage(allocator, read_stream);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "internalRead",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to internalWrite from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "fn internalWrite(self: Image, allocator: std.mem.Allocator, write_stream: *io.WriteStream, encoder_options: EncoderOptions) WriteError!void {\n    const image_format = std.meta.activeTag(encoder_options);\n\n    var format_interface = try findImageInterfaceFromImageFormat(image_format);\n\n    try format_interface.writeImage(allocator, write_stream, self, encoder_options);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "internalWrite",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to findImageInterfaceFromStream from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "fn findImageInterfaceFromStream(read_stream: *io.ReadStream) !FormatInterface {\n    for (all_interface_funcs) |intefaceFn| {\n        const formatInterface = intefaceFn();\n\n        const found = try formatInterface.formatDetect(read_stream);\n        if (found) {\n            return formatInterface;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "findImageInterfaceFromStream",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to findImageInterfaceFromImageFormat from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "fn findImageInterfaceFromImageFormat(image_format: Format) !FormatInterface {\n    return all_interface_funcs[@intFromEnum(image_format)]();\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "function",
      "name": "findImageInterfaceFromImageFormat",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to SupportedFormats from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "const SupportedFormats = struct {\n    pub const bmp = formats.bmp.BMP;\n    pub const farbfeld = formats.farbfeld.Farbfeld;\n    pub const gif = formats.gif.GIF;\n    pub const iff = formats.iff.IFF;\n    pub const jpeg = formats.jpeg.JPEG;\n    pub const pam = formats.pam.PAM;\n    pub const pbm = formats.netpbm.PBM;\n    pub const pcx = formats.pcx.PCX;\n    pub const pgm = formats.netpbm.PGM;\n    pub const png = formats.png.PNG;\n    pub const ppm = formats.netpbm.PPM;\n    pub const qoi = formats.qoi.QOI;\n    pub const ras = formats.ras.RAS;\n    pub const sgi = formats.sgi.SGI;\n    pub const tga = formats.tga.TGA;\n    pub const tiff = formats.tiff.TIFF;\n    pub const xbm = formats.xbm.XBM;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "struct",
      "name": "SupportedFormats",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to AnimationFrame from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub const AnimationFrame = struct {\n    pixels: color.PixelStorage,\n    duration: f32,\n\n    pub fn deinit(self: AnimationFrame, allocator: std.mem.Allocator) void {\n        self.pixels.deinit(allocator);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "struct",
      "name": "AnimationFrame",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Animation from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image.zig",
    "response": "pub const Animation = struct {\n    frames: FrameList = .{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image.zig",
      "type": "struct",
      "name": "Animation",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to flipVertically from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Editor.zig",
    "response": "pub fn flipVertically(pixels: *const color.PixelStorage, height: usize, allocator: std.mem.Allocator) Error!void {\n    var image_data = pixels.asBytes();\n    const row_size = image_data.len / height;\n\n    const temp = try allocator.alloc(u8, row_size);\n    defer allocator.free(temp);\n    while (image_data.len > row_size) : (image_data = image_data[row_size..(image_data.len - row_size)]) {\n        const row1_data = image_data[0..row_size];\n        const row2_data = image_data[image_data.len - row_size .. image_data.len];\n        @memcpy(temp, row1_data);\n        @memcpy(row1_data, row2_data);\n        @memcpy(row2_data, temp);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Editor.zig",
      "type": "function",
      "name": "flipVertically",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to crop from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Editor.zig",
    "response": "pub fn crop(image: *const Image, allocator: std.mem.Allocator, crop_area: Box) Error!Image {\n    const box = crop_area.clamp(image.width, image.height);\n\n    var cropped_pixels = try color.PixelStorage.init(\n        allocator,\n        image.pixelFormat(),\n        box.width * box.height,\n    );\n\n    if (image.pixelFormat().isIndexed()) {\n        const source_palette = image.pixels.getPalette().?;\n        cropped_pixels.resizePalette(source_palette.len);\n\n        const destination_palette = cropped_pixels.getPalette().?;\n\n        @memcpy(destination_palette, source_palette);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Editor.zig",
      "type": "function",
      "name": "crop",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to clamp from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Editor.zig",
    "response": "pub fn clamp(area: Box, image_width: usize, image_height: usize) Box {\n        var box = area;\n        if (box.x + box.width > image_width) box.width = image_width - box.x;\n        if (box.y + box.height > image_height) box.height = image_height - box.y;\n        return box;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Editor.zig",
      "type": "function",
      "name": "clamp",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Box from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Editor.zig",
    "response": "pub const Box = struct {\n    x: usize = 0,\n    y: usize = 0,\n    width: usize = 0,\n    height: usize = 0,\n\n    /// If the crop area falls partially outside the image boundary,\n    /// adjust the crop region.\n    pub fn clamp(area: Box, image_width: usize, image_height: usize) Box {\n        var box = area;\n        if (box.x + box.width > image_width) box.width = image_width - box.x;\n        if (box.y + box.height > image_height) box.height = image_height - box.y;\n        return box;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Editor.zig",
      "type": "struct",
      "name": "Box",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn init(allocator: std.mem.Allocator) Managed {\n    return Managed{\n        .allocator = allocator,\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn deinit(self: *Managed) void {\n    Image.deinit(@ptrCast(self), self.allocator);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to detectFormatFromFilePath from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn detectFormatFromFilePath(file_path: []const u8, read_buffer: []u8) !Format {\n    return Image.detectFormatFromFilePath(file_path, read_buffer);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "detectFormatFromFilePath",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to detectFormatFromFile from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn detectFormatFromFile(file: std.fs.File, read_buffer: []u8) !Format {\n    return Image.detectFormatFromFile(file, read_buffer);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "detectFormatFromFile",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to detectFormatFromMemory from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn detectFormatFromMemory(buffer: []const u8) !Format {\n    return Image.detectFormatFromMemory(buffer);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "detectFormatFromMemory",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromFilePath from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn fromFilePath(allocator: std.mem.Allocator, file_path: []const u8, read_buffer: []u8) !Managed {\n    return (try Image.fromFilePath(allocator, file_path, read_buffer)).toManaged(allocator);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "fromFilePath",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromFile from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn fromFile(allocator: std.mem.Allocator, file: std.fs.File, read_buffer: []u8) !Managed {\n    return (try Image.fromFile(allocator, file, read_buffer)).toManaged(allocator);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "fromFile",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromMemory from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn fromMemory(allocator: std.mem.Allocator, buffer: []const u8) !Managed {\n    return (try Image.fromMemory(allocator, buffer)).toManaged(allocator);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "fromMemory",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromRawPixels from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn fromRawPixels(allocator: std.mem.Allocator, width: usize, height: usize, pixels: []const u8, pixel_format: PixelFormat) !Managed {\n    return .{\n        .allocator = allocator,\n        .width = width,\n        .height = height,\n        .pixels = try color.PixelStorage.initRawPixels(try allocator.dupe(u8, pixels), pixel_format),\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "fromRawPixels",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to create from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn create(allocator: std.mem.Allocator, width: usize, height: usize, pixel_format: PixelFormat) !Managed {\n    const result = Managed{\n        .allocator = allocator,\n        .width = width,\n        .height = height,\n        .pixels = try color.PixelStorage.init(allocator, pixel_format, width * height),\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "create",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to pixelFormat from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn pixelFormat(self: Managed) PixelFormat {\n    return std.meta.activeTag(self.pixels);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "pixelFormat",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rawBytes from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn rawBytes(self: Managed) []const u8 {\n    return self.pixels.asBytes();\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "rawBytes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rowByteSize from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn rowByteSize(self: Managed) usize {\n    return self.imageByteSize() / self.height;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "rowByteSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to imageByteSize from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn imageByteSize(self: Managed) usize {\n    return self.rawBytes().len;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "imageByteSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isAnimation from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn isAnimation(self: Managed) bool {\n    return self.animation.frames.items.len > 0;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "isAnimation",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeToFilePath from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn writeToFilePath(self: Managed, file_path: []const u8, write_buffer: []u8, encoder_options: EncoderOptions) WriteError!void {\n    return Image.writeToFilePath(self.toUnmanaged(), self.allocator, file_path, write_buffer, encoder_options);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "writeToFilePath",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeToFile from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn writeToFile(self: Managed, file: std.fs.File, write_buffer: []u8, encoder_options: EncoderOptions) WriteError!void {\n    return Image.writeToFile(self.toUnmanaged(), self.allocator, file, write_buffer, encoder_options);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "writeToFile",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeToMemory from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn writeToMemory(self: Managed, write_buffer: []u8, encoder_options: EncoderOptions) WriteError![]u8 {\n    return Image.writeToMemory(self.toUnmanaged(), self.allocator, write_buffer, encoder_options);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "writeToMemory",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to convert from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn convert(self: *Managed, destination_format: PixelFormat) ConvertError!void {\n    return Image.convert(@ptrCast(self), self.allocator, destination_format);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "convert",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to flipVertically from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn flipVertically(self: *const Managed) Image.Editor.Error!void {\n    try Image.flipVertically(@ptrCast(self), self.allocator);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "flipVertically",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to crop from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn crop(self: *const Managed, allocator: std.mem.Allocator, area: Image.Editor.Box) Image.Editor.Error!Managed {\n    return (try Image.crop(@ptrCast(self), allocator, area)).toManaged(allocator);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "crop",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to iterator from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn iterator(self: *const Managed) color.PixelStorageIterator {\n    return color.PixelStorageIterator.init(&self.pixels);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "iterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toUnmanaged from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/Image/Managed.zig",
    "response": "pub fn toUnmanaged(self: Managed) Image {\n    return .{\n        .width = self.width,\n        .height = self.height,\n        .pixels = self.pixels,\n        .animation = self.animation,\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/Image/Managed.zig",
      "type": "function",
      "name": "toUnmanaged",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "pub fn init(allocator: std.mem.Allocator) OctTreeQuantizer {\n    var result = OctTreeQuantizer{\n        .area_allocator = std.heap.ArenaAllocator.init(allocator),\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "pub fn deinit(self: *OctTreeQuantizer) void {\n    self.area_allocator.deinit();\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to allocateNode from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "pub fn allocateNode(self: *OctTreeQuantizer) Error!*Node {\n    return try self.area_allocator.allocator().create(Node);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "allocateNode",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to addLevelNode from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "pub fn addLevelNode(self: *OctTreeQuantizer, level: i32, node: *Node) void {\n    node.level_next = self.levels[@intCast(level)];\n    self.levels[@intCast(level)] = node;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "addLevelNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "pub fn addColor(self: *OctTreeQuantizer, color_value: anytype) Error!void {\n    try self.root_node.addColor(color_value, 0, self);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "addColor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getPaletteIndex from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "pub fn getPaletteIndex(self: OctTreeQuantizer, color_value: anytype) Error!usize {\n    return try self.root_node.getPaletteIndex(color_value, 0);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "getPaletteIndex",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to makePalette from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "pub fn makePalette(self: *OctTreeQuantizer, color_count: u32, palette: []color.Rgba32) []color.Rgba32 {\n    var leaf_count = self.root_node.countLeafNodes();\n\n    var level: u8 = MaxDepth - 1;\n    while (level > 0) : (level -= 1) {\n        var node_it = self.levels[level];\n\n        while (node_it) |node| {\n            leaf_count -= @intCast(node.removeLeaves());\n            if (leaf_count <= color_count) {\n                break;\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "makePalette",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to anyColorToRgb24 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "fn anyColorToRgb24(color_value: anytype) color.Rgb24 {\n    const T = @TypeOf(color_value);\n\n    if (T == color.Rgb24) {\n        return color_value;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "anyColorToRgb24",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "pub fn init(self: *Node, level: i32, parent: *OctTreeQuantizer) void {\n        self.* = Node{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isLeaf from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "pub fn isLeaf(self: Node) bool {\n        return self.reference_count > 0;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "isLeaf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "pub fn getColor(self: Node) color.Rgba32 {\n        return color.Rgba32.from.rgb(@intCast(self.red / self.reference_count), @intCast(self.green / self.reference_count), @intCast(self.blue / self.reference_count));\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "getColor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "pub fn addColor(self: *Node, source_color: anytype, level: i32, parent: *OctTreeQuantizer) Error!void {\n        if (level >= MaxDepth) {\n            const color_value = anyColorToRgb24(source_color);\n\n            self.red += color_value.r;\n            self.green += color_value.g;\n            self.blue += color_value.b;\n            self.reference_count += 1;\n            return;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "addColor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getPaletteIndex from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "pub fn getPaletteIndex(self: Node, source_color: anytype, level: i32) Error!usize {\n        if (self.isLeaf()) {\n            return self.palette_index;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "getPaletteIndex",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to countLeafNodes from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "pub fn countLeafNodes(self: Node) usize {\n        if (self.isLeaf()) {\n            return 1;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "countLeafNodes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to makePalette from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "pub fn makePalette(self: *Node, context: *MakePaletteContext) void {\n        if (self.isLeaf()) {\n            if (context.palette_index >= context.color_count) {\n                return;\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "makePalette",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to removeLeaves from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "pub fn removeLeaves(self: *Node) i32 {\n        var result: i32 = 0;\n        for (self.children, 0..) |child_opt, index| {\n            if (child_opt) |child| {\n                self.red +%= child.red;\n                self.green +%= child.green;\n                self.blue +%= child.blue;\n                self.reference_count +%= child.reference_count;\n                result += 1;\n                self.children[index] = null;\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "removeLeaves",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getColorIndex from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "fn getColorIndex(source_color: anytype, level: i32) usize {\n        const color_value = anyColorToRgb24(source_color);\n\n        var index: usize = 0;\n        const mask = @as(u8, 0b10000000) >> @intCast(level);\n        if (color_value.r & mask != 0) {\n            index |= 0b100;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "function",
      "name": "getColorIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to MakePaletteContext from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "const MakePaletteContext = struct {\n    palette: []color.Rgba32,\n    palette_index: u32 = 0,\n    color_count: u32 = 0,\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "struct",
      "name": "MakePaletteContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Node from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/OctTreeQuantizer.zig",
    "response": "const Node = struct {\n    red: u32 = 0,\n    green: u32 = 0,\n    blue: u32 = 0,\n    reference_count: u32 = 0,\n    palette_index: u32 = 0,\n    children: [8]?*Node = @splat(null),\n    level_next: ?*Node = null,\n\n    pub fn init(self: *Node, level: i32, parent: *OctTreeQuantizer) void {\n        self.* = Node{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/OctTreeQuantizer.zig",
      "type": "struct",
      "name": "Node",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to convert from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "pub fn convert(allocator: std.mem.Allocator, source: *const color.PixelStorage, destination_format: PixelFormat) Image.ConvertError!color.PixelStorage {\n    if (std.meta.activeTag(source.*) == destination_format) {\n        return Image.ConvertError.NoConversionNeeded;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "convert",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to conversionId from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn conversionId(source_format: PixelFormat, destination_format: PixelFormat) u64 {\n    return @as(u64, @intFromEnum(source_format)) | @as(u64, @intFromEnum(destination_format)) << 32;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "conversionId",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getFieldNameFromPixelFormat from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn getFieldNameFromPixelFormat(comptime source_format: PixelFormat) []const u8 {\n    const enum_fields = std.meta.fields(PixelFormat);\n    inline for (enum_fields) |field| {\n        if (field.value == @intFromEnum(source_format)) {\n            return field.name;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "getFieldNameFromPixelFormat",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rgbToRgb from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn rgbToRgb(comptime T: type, rgb: anytype) T {\n    return T.from.color(rgb);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "rgbToRgb",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to rgbToRgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn rgbToRgba(comptime T: type, rgb: anytype) T {\n    return T.from.color(rgb);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "rgbToRgba",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to rgbaToRgb from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn rgbaToRgb(comptime T: type, rgba: anytype) T {\n    return T.from.color(rgba.to.premultipliedAlpha());\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "rgbaToRgb",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to rgbaToRgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn rgbaToRgba(comptime T: type, rgba: anytype) T {\n    return T.from.color(rgba);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "rgbaToRgba",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to grayscaleToGrayscale from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn grayscaleToGrayscale(comptime T: type, gray: anytype) T {\n    const scaleValue = color.ScaleValue(std.meta.fieldInfo(T, .value).type);\n    return .{ .value = scaleValue(gray.value) }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "grayscaleToGrayscale",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to grayscaleAlphaToGrayscale from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn grayscaleAlphaToGrayscale(comptime T: type, gray: anytype) T {\n    const toF32 = color.ScaleValue(f32);\n    const scaleValue = color.ScaleValue(std.meta.fieldInfo(T, .value).type);\n    return .{ .value = scaleValue(toF32(gray.value) * toF32(gray.alpha)) }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "grayscaleAlphaToGrayscale",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to grayscaleAlphaToGrayscaleAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn grayscaleAlphaToGrayscaleAlpha(comptime T: type, gray: anytype) T {\n    const scaleValue = color.ScaleValue(std.meta.fieldInfo(T, .value).type);\n    const scaleAlpha = color.ScaleValue(std.meta.fieldInfo(T, .alpha).type);\n    return .{\n        .value = scaleValue(gray.value),\n        .alpha = scaleAlpha(gray.alpha),\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "grayscaleAlphaToGrayscaleAlpha",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to grayscaleToRgb from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn grayscaleToRgb(comptime T: type, gray: anytype) T {\n    return T.from.grayscale(gray);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "grayscaleToRgb",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to grayscaleToRgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn grayscaleToRgba(comptime T: type, gray: anytype) T {\n    return T.from.grayscale(gray);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "grayscaleToRgba",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to grayscaleAlphaToRgb from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn grayscaleAlphaToRgb(comptime T: type, gray: anytype) T {\n    return T.from.grayscale(grayscaleAlphaToGrayscale(color.Grayscalef32, gray));\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "grayscaleAlphaToRgb",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to grayscaleAlphaToRgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn grayscaleAlphaToRgba(comptime T: type, gray: anytype) T {\n    return T.from.grayscale(gray);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "grayscaleAlphaToRgba",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to IndexedSmallToLarge from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn IndexedSmallToLarge(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_indexed = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_indexed = @field(destination, getFieldNameFromPixelFormat(destination_format));\n\n            for (0..source_indexed.palette.len) |index| {\n                destination_indexed.palette[index] = source_indexed.palette[index];\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "IndexedSmallToLarge",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to IndexedLargeToSmall from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn IndexedLargeToSmall(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(allocator: std.mem.Allocator, source: *const color.PixelStorage, destination: *color.PixelStorage) Image.ConvertError!void {\n            const source_indexed = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_indexed = @field(destination, getFieldNameFromPixelFormat(destination_format));\n\n            var quantizer = OctTreeQuantizer.init(allocator);\n            defer quantizer.deinit();\n\n            // First pass: read all color in the palette and fill in the quantizer\n            for (source_indexed.palette) |entry| {\n                quantizer.addColor(entry) catch |err| {\n                    return switch (err) {\n                        std.mem.Allocator.Error.OutOfMemory => std.mem.Allocator.Error.OutOfMemory,\n                        else => Image.ConvertError.QuantizeError,\n                    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "IndexedLargeToSmall",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to IndexedToRgbColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn IndexedToRgbColor(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_indexed = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n            const destination_type = @TypeOf(destination_pixels[0]);\n\n            for (0..source_indexed.indices.len) |index| {\n                destination_pixels[index] = rgbaToRgb(destination_type, source_indexed.palette[source_indexed.indices[index]]);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "IndexedToRgbColor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to IndexedToRgbaColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn IndexedToRgbaColor(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_indexed = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n            const destination_type = @TypeOf(destination_pixels[0]);\n\n            for (0..source_indexed.indices.len) |index| {\n                destination_pixels[index] = rgbaToRgba(destination_type, source_indexed.palette[source_indexed.indices[index]]);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "IndexedToRgbaColor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to indexedToRgba32 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn indexedToRgba32(comptime source_format: PixelFormat, source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n    const source_indexed = @field(source, getFieldNameFromPixelFormat(source_format));\n\n    for (0..source_indexed.indices.len) |index| {\n        destination.rgba32[index] = source_indexed.palette[source_indexed.indices[index]];\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "indexedToRgba32",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to indexedToColorf32 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn indexedToColorf32(comptime source_format: PixelFormat, source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n    const source_indexed = @field(source, getFieldNameFromPixelFormat(source_format));\n\n    for (0..source_indexed.indices.len) |index| {\n        destination.float32[index] = source_indexed.palette[source_indexed.indices[index]].to.color(color.Colorf32);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "indexedToColorf32",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to GrayscaleToGrayscale from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn GrayscaleToGrayscale(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_grayscale = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n            const destination_type = @TypeOf(destination_pixels[0]);\n\n            for (0..source_grayscale.len) |index| {\n                destination_pixels[index] = grayscaleToGrayscale(destination_type, source_grayscale[index]);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "GrayscaleToGrayscale",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to GrayscaleAlphaToGrayscale from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn GrayscaleAlphaToGrayscale(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_grayscale = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n            const destination_type = @TypeOf(destination_pixels[0]);\n\n            for (0..source_grayscale.len) |index| {\n                destination_pixels[index] = grayscaleAlphaToGrayscale(destination_type, source_grayscale[index]);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "GrayscaleAlphaToGrayscale",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to GrayscaleAlphaToGrayscaleAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn GrayscaleAlphaToGrayscaleAlpha(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_grayscale = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n            const destination_type = @TypeOf(destination_pixels[0]);\n\n            for (0..source_grayscale.len) |index| {\n                destination_pixels[index] = grayscaleAlphaToGrayscaleAlpha(destination_type, source_grayscale[index]);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "GrayscaleAlphaToGrayscaleAlpha",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to GrayscaleToRgbColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn GrayscaleToRgbColor(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_grayscale = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n            const destination_type = @TypeOf(destination_pixels[0]);\n\n            for (0..source_grayscale.len) |index| {\n                destination_pixels[index] = grayscaleToRgb(destination_type, source_grayscale[index]);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "GrayscaleToRgbColor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to GrayscaleToRgbaColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn GrayscaleToRgbaColor(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_grayscale = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n            const destination_type = @TypeOf(destination_pixels[0]);\n\n            for (0..source_grayscale.len) |index| {\n                destination_pixels[index] = grayscaleToRgba(destination_type, source_grayscale[index]);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "GrayscaleToRgbaColor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to GrayscaleAlphaToRgbColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn GrayscaleAlphaToRgbColor(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_grayscale = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n            const destination_type = @TypeOf(destination_pixels[0]);\n\n            for (0..source_grayscale.len) |index| {\n                destination_pixels[index] = grayscaleAlphaToRgb(destination_type, source_grayscale[index]);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "GrayscaleAlphaToRgbColor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to GrayscaleAlphaToRgbaColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn GrayscaleAlphaToRgbaColor(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_grayscale = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n            const destination_type = @TypeOf(destination_pixels[0]);\n\n            for (0..source_grayscale.len) |index| {\n                destination_pixels[index] = grayscaleAlphaToRgba(destination_type, source_grayscale[index]);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "GrayscaleAlphaToRgbaColor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to grayscaleToColorf32 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn grayscaleToColorf32(comptime source_format: PixelFormat, source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n    const source_grayscale = @field(source, getFieldNameFromPixelFormat(source_format));\n\n    for (0..source_grayscale.len) |index| {\n        destination.float32[index] = source_grayscale[index].toColorf32();\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "grayscaleToColorf32",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to GrayscaleToIndexed from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn GrayscaleToIndexed(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(allocator: std.mem.Allocator, source: *const color.PixelStorage, destination: *color.PixelStorage) Image.ConvertError!void {\n            const source_grayscale = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n\n            var quantizer = OctTreeQuantizer.init(allocator);\n            defer quantizer.deinit();\n\n            // First pass: read all pixels and fill in the quantizer\n            for (source_grayscale) |pixel| {\n                const rgba_pixel = grayscaleToRgb(color.Rgb24, pixel);\n\n                quantizer.addColor(rgba_pixel) catch |err| {\n                    return switch (err) {\n                        std.mem.Allocator.Error.OutOfMemory => std.mem.Allocator.Error.OutOfMemory,\n                        else => Image.ConvertError.QuantizeError,\n                    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "GrayscaleToIndexed",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to GrayscaleAlphaToIndexed from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn GrayscaleAlphaToIndexed(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(allocator: std.mem.Allocator, source: *const color.PixelStorage, destination: *color.PixelStorage) Image.ConvertError!void {\n            const source_grayscale = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n\n            var quantizer = OctTreeQuantizer.init(allocator);\n            defer quantizer.deinit();\n\n            // First pass: read all pixels and fill in the quantizer\n            for (source_grayscale) |pixel| {\n                const rgba_pixel = grayscaleAlphaToRgba(color.Rgba32, pixel);\n\n                quantizer.addColor(rgba_pixel) catch |err| {\n                    return switch (err) {\n                        std.mem.Allocator.Error.OutOfMemory => std.mem.Allocator.Error.OutOfMemory,\n                        else => Image.ConvertError.QuantizeError,\n                    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "GrayscaleAlphaToIndexed",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to RgbColorToGrayscale from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn RgbColorToGrayscale(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_rgb = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n            const DestinationType = @TypeOf(destination_pixels[0]);\n\n            const scaleValue = color.ScaleValue(std.meta.fieldInfo(DestinationType, .value).type);\n\n            for (0..source_rgb.len) |index| {\n                const source_float4 = source_rgb[index].to.float4();\n\n                const converted_float4 = GrayscaleFactors * source_float4;\n\n                const grayscale = scaleValue(\n                    (converted_float4[0] + converted_float4[1] + converted_float4[2]) * converted_float4[3],\n                );\n\n                destination_pixels[index] = .{ .value = grayscale }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "RgbColorToGrayscale",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to RgbColorToGrayscaleAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn RgbColorToGrayscaleAlpha(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_rgb = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n            const DestinationType = @TypeOf(destination_pixels[0]);\n\n            const scaleValue = color.ScaleValue(std.meta.fieldInfo(DestinationType, .value).type);\n            const scaleAlpha = color.ScaleValue(std.meta.fieldInfo(DestinationType, .alpha).type);\n\n            for (0..source_rgb.len) |index| {\n                const source_float4 = source_rgb[index].to.float4();\n\n                const converted_float4 = GrayscaleFactors * source_float4;\n\n                const grayscale = scaleValue(converted_float4[0] + converted_float4[1] + converted_float4[2]);\n\n                destination_pixels[index] = DestinationType{\n                    .value = grayscale,\n                    .alpha = scaleAlpha(converted_float4[3]),\n                }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "RgbColorToGrayscaleAlpha",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to RgbColorToRgbColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn RgbColorToRgbColor(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_rgb = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n            const destination_type = @TypeOf(destination_pixels[0]);\n\n            for (0..source_rgb.len) |index| {\n                destination_pixels[index] = rgbToRgb(destination_type, source_rgb[index]);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "RgbColorToRgbColor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to RgbColorToRgbaColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn RgbColorToRgbaColor(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_rgb = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n            const destination_type = @TypeOf(destination_pixels[0]);\n\n            for (0..source_rgb.len) |index| {\n                destination_pixels[index] = rgbToRgba(destination_type, source_rgb[index]);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "RgbColorToRgbaColor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to RgbaColorToRgbColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn RgbaColorToRgbColor(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_rgb = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n            const destination_type = @TypeOf(destination_pixels[0]);\n\n            for (0..source_rgb.len) |index| {\n                destination_pixels[index] = rgbaToRgb(destination_type, source_rgb[index]);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "RgbaColorToRgbColor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to RgbaColorToRgbaColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn RgbaColorToRgbaColor(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_rgb = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n            const destination_type = @TypeOf(destination_pixels[0]);\n\n            for (0..source_rgb.len) |index| {\n                destination_pixels[index] = rgbaToRgba(destination_type, source_rgb[index]);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "RgbaColorToRgbaColor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to rgbColorToColorf32 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn rgbColorToColorf32(comptime source_format: PixelFormat, source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n    const source_rgb = @field(source, getFieldNameFromPixelFormat(source_format));\n\n    for (0..source_rgb.len) |index| {\n        destination.float32[index] = source_rgb[index].to.color(color.Colorf32);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "rgbColorToColorf32",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to FastRgba32Shuffle from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn FastRgba32Shuffle(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n            const source_pixels = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n            const destination_type = @TypeOf(destination_pixels[0]);\n\n            const vector_length = std.simd.suggestVectorLength(u8) orelse 4;\n            const color_count = vector_length / 4;\n            const VectorType = @Vector(vector_length, u8);\n\n            var index: usize = 0;\n\n            const shuffle_mask: @Vector(vector_length, i32) = comptime blk: {\n                var result: @Vector(vector_length, i32) = @splat(0);\n\n                for (0..color_count) |i| {\n                    const stride = i * 4;\n                    result[stride + 0] = stride + 2;\n                    result[stride + 1] = stride + 1;\n                    result[stride + 2] = stride + 0;\n                    result[stride + 3] = stride + 3;\n                }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "FastRgba32Shuffle",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to rgba32ToColorf32 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn rgba32ToColorf32(comptime source_format: PixelFormat, source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n    const source_pixels = @field(source, getFieldNameFromPixelFormat(source_format));\n    var destination_pixels = destination.float32;\n    var destination_f32: [*]f32 = @ptrCast(@alignCast(destination_pixels.ptr));\n\n    const vector_length = std.simd.suggestVectorLength(u8) orelse 4;\n    const color_count = vector_length / 4;\n    const ByteVectorType = @Vector(vector_length, u8);\n    const FloatVectorType = @Vector(vector_length, f32);\n\n    var index: usize = 0;\n    // Process with SIMD as much as possible\n    while (index < source_pixels.len and ((index + color_count) <= source_pixels.len)) {\n        const source_vector = simd.load(u8, std.mem.sliceAsBytes(source_pixels[index..]), ByteVectorType, vector_length);\n\n        const float_vector = simd.intToFloat(f32, source_vector, vector_length);\n        const conversion_vector: FloatVectorType = @splat(255.0);\n\n        const destination_vector = float_vector / conversion_vector;\n\n        simd.store(f32, destination_f32[(index * 4)..(index * 4 + color_count * 4)], destination_vector, vector_length);\n\n        index += color_count;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "rgba32ToColorf32",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to bgra32ToColorf32 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn bgra32ToColorf32(comptime source_format: PixelFormat, source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n    const source_pixels = @field(source, getFieldNameFromPixelFormat(source_format));\n    var destination_pixels = destination.float32;\n    var destination_f32: [*]f32 = @ptrCast(@alignCast(destination_pixels.ptr));\n\n    const vector_length = std.simd.suggestVectorLength(u8) orelse 4;\n    const color_count = vector_length / 4;\n    const ByteVectorType = @Vector(vector_length, u8);\n    const FloatVectorType = @Vector(vector_length, f32);\n\n    const shuffle_mask: @Vector(vector_length, i32) = comptime blk: {\n        var result: @Vector(vector_length, i32) = @splat(0);\n\n        for (0..color_count) |i| {\n            const stride = i * 4;\n            result[stride + 0] = stride + 2;\n            result[stride + 1] = stride + 1;\n            result[stride + 2] = stride + 0;\n            result[stride + 3] = stride + 3;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "bgra32ToColorf32",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to RgbColorToIndexed from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn RgbColorToIndexed(comptime source_format: PixelFormat, comptime destination_format: PixelFormat) type {\n    return struct {\n        pub fn convert(allocator: std.mem.Allocator, source: *const color.PixelStorage, destination: *color.PixelStorage) Image.ConvertError!void {\n            const source_rgb = @field(source, getFieldNameFromPixelFormat(source_format));\n            var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n\n            var quantizer = OctTreeQuantizer.init(allocator);\n            defer quantizer.deinit();\n\n            // First pass: read all pixels and fill in the quantizer\n            for (source_rgb) |pixel| {\n                quantizer.addColor(pixel) catch |err| {\n                    return switch (err) {\n                        std.mem.Allocator.Error.OutOfMemory => std.mem.Allocator.Error.OutOfMemory,\n                        else => Image.ConvertError.QuantizeError,\n                    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "RgbColorToIndexed",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to colorf32ToRgb from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn colorf32ToRgb(comptime T: type, source: color.Colorf32) T {\n    return T.from.color(source);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "colorf32ToRgb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to colorf32ToRgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn colorf32ToRgba(comptime T: type, source: color.Colorf32) T {\n    return T.from.color(source);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "colorf32ToRgba",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to colorf32ToRgbColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn colorf32ToRgbColor(comptime destination_format: PixelFormat, source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n    const source_pixels = source.float32;\n\n    var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n    const destination_type = @TypeOf(destination_pixels[0]);\n\n    for (0..source_pixels.len) |index| {\n        destination_pixels[index] = colorf32ToRgb(destination_type, source_pixels[index]);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "colorf32ToRgbColor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to colorf32ToRgbaColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn colorf32ToRgbaColor(comptime destination_format: PixelFormat, source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n    const source_pixels = source.float32;\n\n    var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n    const destination_type = @TypeOf(destination_pixels[0]);\n\n    for (0..source_pixels.len) |index| {\n        destination_pixels[index] = colorf32ToRgba(destination_type, source_pixels[index]);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "colorf32ToRgbaColor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to colorf32ToRgba32 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn colorf32ToRgba32(comptime destination_format: PixelFormat, source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n    const source_pixels = source.float32;\n    var source_f32: [*]f32 = @ptrCast(@alignCast(source_pixels.ptr));\n\n    var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n    const destination_type = @TypeOf(destination_pixels[0]);\n\n    const vector_length = std.simd.suggestVectorLength(u8) orelse 4;\n    const color_count = vector_length / 4;\n    const FloatVectorType = @Vector(vector_length, f32);\n\n    var index: usize = 0;\n    // Process with SIMD as much as possible\n    while (index < source_pixels.len and ((index + color_count) <= source_pixels.len)) {\n        const source_vector = simd.load(f32, source_f32[(index * 4)..(index * 4 + color_count * 4)], FloatVectorType, vector_length);\n\n        const conversion_vector: FloatVectorType = @splat(255.0);\n        const converted_vector = source_vector * conversion_vector;\n\n        const destination_vector = simd.floatToInt(u8, converted_vector, vector_length);\n\n        simd.store(u8, std.mem.sliceAsBytes(destination_pixels[index..]), destination_vector, vector_length);\n\n        index += color_count;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "colorf32ToRgba32",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to colorf32ToBgra32 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn colorf32ToBgra32(comptime destination_format: PixelFormat, source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n    const source_pixels = source.float32;\n    var source_f32: [*]f32 = @ptrCast(@alignCast(source_pixels.ptr));\n\n    var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n    const destination_type = @TypeOf(destination_pixels[0]);\n\n    const vector_length = std.simd.suggestVectorLength(u8) orelse 4;\n    const color_count = vector_length / 4;\n    const FloatVectorType = @Vector(vector_length, f32);\n\n    const shuffle_mask: @Vector(vector_length, i32) = comptime blk: {\n        var result: @Vector(vector_length, i32) = @splat(0);\n\n        for (0..color_count) |i| {\n            const stride = i * 4;\n            result[stride + 0] = stride + 2;\n            result[stride + 1] = stride + 1;\n            result[stride + 2] = stride + 0;\n            result[stride + 3] = stride + 3;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "colorf32ToBgra32",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to colorf32ToGrayscale from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn colorf32ToGrayscale(comptime destination_format: PixelFormat, source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n    const source_pixels = source.float32;\n\n    var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n    const DestinationType = @TypeOf(destination_pixels[0]);\n\n    const scaleValue = color.ScaleValue(std.meta.fieldInfo(DestinationType, .value).type);\n\n    for (0..source_pixels.len) |index| {\n        const source_float4 = source_pixels[index].to.float4();\n\n        const converted_float4 = GrayscaleFactors * source_float4;\n\n        const grayscale = scaleValue(\n            (converted_float4[0] + converted_float4[1] + converted_float4[2]) * converted_float4[3],\n        );\n\n        destination_pixels[index] = DestinationType{ .value = grayscale }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "colorf32ToGrayscale",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to colorf32ToGrayscaleAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "fn colorf32ToGrayscaleAlpha(comptime destination_format: PixelFormat, source: *const color.PixelStorage, destination: *color.PixelStorage) void {\n    const source_pixels = source.float32;\n\n    var destination_pixels = @field(destination, getFieldNameFromPixelFormat(destination_format));\n    const DestinationType = @TypeOf(destination_pixels[0]);\n\n    const scaleValue = color.ScaleValue(std.meta.fieldInfo(DestinationType, .value).type);\n    const scaleAlpha = color.ScaleValue(std.meta.fieldInfo(DestinationType, .alpha).type);\n\n    for (0..source_pixels.len) |index| {\n        const source_float4 = source_pixels[index].to.float4();\n\n        const converted_float4 = GrayscaleFactors * source_float4;\n\n        const grayscale = scaleValue(converted_float4[0] + converted_float4[1] + converted_float4[2]);\n\n        destination_pixels[index] = DestinationType{\n            .value = grayscale,\n            .alpha = scaleAlpha(converted_float4[3]),\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "function",
      "name": "colorf32ToGrayscaleAlpha",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to GrayscaleFactors from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "const GrayscaleFactors: math.float4 = .{ 0.2125, 0.7154, 0.0721, 1.0 };",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "const",
      "name": "GrayscaleFactors",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to color_count from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "const color_count: u32 = @as(u32, 1) << @as(u5, @truncate(destination_format.bitsPerChannel()));",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "const",
      "name": "color_count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to color_count from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "const color_count: u32 = @as(u32, 1) << @as(u5, @truncate(destination_format.bitsPerChannel()));",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "const",
      "name": "color_count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to color_count from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "const color_count: u32 = @as(u32, 1) << @as(u5, @truncate(destination_format.bitsPerChannel()));",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "const",
      "name": "color_count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to shuffle_mask from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "const shuffle_mask: @Vector(vector_length, i32) = comptime blk: {\n                var result: @Vector(vector_length, i32) = @splat(0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "const",
      "name": "shuffle_mask",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to conversion_vector from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "const conversion_vector: FloatVectorType = @splat(255.0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "const",
      "name": "conversion_vector",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to shuffle_mask from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "const shuffle_mask: @Vector(vector_length, i32) = comptime blk: {\n        var result: @Vector(vector_length, i32) = @splat(0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "const",
      "name": "shuffle_mask",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to conversion_vector from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "const conversion_vector: FloatVectorType = @splat(255.0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "const",
      "name": "conversion_vector",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to color_count from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "const color_count: u32 = @as(u32, 1) << @as(u5, @truncate(destination_format.bitsPerChannel()));",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "const",
      "name": "color_count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to conversion_vector from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "const conversion_vector: FloatVectorType = @splat(255.0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "const",
      "name": "conversion_vector",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to shuffle_mask from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "const shuffle_mask: @Vector(vector_length, i32) = comptime blk: {\n        var result: @Vector(vector_length, i32) = @splat(0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "const",
      "name": "shuffle_mask",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to conversion_vector from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/PixelFormatConverter.zig",
    "response": "const conversion_vector: FloatVectorType = @splat(255.0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/PixelFormatConverter.zig",
      "type": "const",
      "name": "conversion_vector",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isAll8BitColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn isAll8BitColor(comptime red_type: type, comptime green_type: type, comptime blue_type: type, comptime alpha_type: type) bool {\n    return red_type == u8 and green_type == u8 and blue_type == u8 and (alpha_type == u8 or alpha_type == void);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "isAll8BitColor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ScaleValue from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn ScaleValue(comptime T: type) fn (anytype) T {\n    switch (@typeInfo(T)) {\n        else => @compileError(\"ScaleValue only works with numeric types. Got \" ++ @typeName(T) ++ \".\"),\n\n        .int => |info| {\n            if (info.signedness != .unsigned) {\n                @compileError(\"ScaleValue only works with unsigned integer types. Got \" ++ @typeName(T) ++ \".\");\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "ScaleValue",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to scaleValue from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn scaleValue(value: anytype) T {\n                    const ValueT = @TypeOf(value);\n                    if (ValueT == comptime_int) return @as(T, value);\n                    switch (@typeInfo(ValueT)) {\n                        else => @compileError(\"scaleValue only works with numeric types. Got \" ++ @typeName(ValueT) ++ \".\"),\n\n                        .int => |value_info| {\n                            if (value_info.signedness != .unsigned) {\n                                @compileError(\"scaleValue only works with unsigned integer types. Got \" ++ @typeName(ValueT) ++ \".\");\n                            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "scaleValue",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to scaleValue from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn scaleValue(value: anytype) T {\n                    const ValueT = @TypeOf(value);\n                    if (ValueT == comptime_int) {\n                        @compileError(\"scaleValue cannot create a float from a comptime_int, since it has no max value.\");\n                    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "scaleValue",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to FromMethods from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn FromMethods(comptime T: type) type {\n    const has_alpha = @hasField(T, \"a\");\n\n    const RedT: type = @FieldType(T, \"r\");\n    const GreenT: type = @FieldType(T, \"g\");\n    const BlueT: type = @FieldType(T, \"b\");\n    const AlphaT: type =\n        if (has_alpha)\n            @FieldType(T, \"a\")\n        else\n            void;\n\n    const multiple_channel_types =\n        RedT != GreenT or\n        RedT != BlueT or\n        (RedT != AlphaT and AlphaT != void);\n\n    const scaleRed = ScaleValue(RedT);\n    const scaleGreen = ScaleValue(GreenT);\n    const scaleBlue = ScaleValue(BlueT);\n    const scaleAlpha: if (has_alpha) fn (anytype) AlphaT else void =\n        if (has_alpha)\n            ScaleValue(AlphaT)\n        else {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "FromMethods",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to rgb from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn rgb(r: RedT, g: GreenT, b: BlueT) T {\n            return .{\n                .r = r,\n                .g = g,\n                .b = b,\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "rgb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn rgba(r: RedT, g: GreenT, b: BlueT, a: AlphaT) T {\n            var res: T = .{\n                .r = r,\n                .g = g,\n                .b = b,\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "rgba",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to color from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn color(other_color: anytype) T {\n            var res: T = .{\n                .r = scaleRed(other_color.r),\n                .g = scaleGreen(other_color.g),\n                .b = scaleBlue(other_color.b),\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "color",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to grayscale from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn grayscale(gray: anytype) T {\n            var res: T = .{\n                .r = scaleRed(gray.value),\n                .g = scaleGreen(gray.value),\n                .b = scaleBlue(gray.value),\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "grayscale",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to u32Rgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn u32Rgba(value: u32) T {\n            var res: T = .{\n                .r = scaleRed(@as(u8, @truncate(value >> 24))),\n                .g = scaleGreen(@as(u8, @truncate(value >> 16))),\n                .b = scaleBlue(@as(u8, @truncate(value >> 8))),\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "u32Rgba",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to u32Rgb from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn u32Rgb(value: u32) T {\n            return .{\n                .r = scaleRed(@as(u8, @truncate(value >> 16))),\n                .g = scaleGreen(@as(u8, @truncate(value >> 8))),\n                .b = scaleBlue(@as(u8, @truncate(value))),\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "u32Rgb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to u64Rgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn u64Rgba(value: u64) T {\n            var res: T = .{\n                .r = scaleRed(@as(u16, @truncate(value >> 48))),\n                .g = scaleGreen(@as(u16, @truncate(value >> 32))),\n                .b = scaleBlue(@as(u16, @truncate(value >> 16))),\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "u64Rgba",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to u64Rgb from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn u64Rgb(value: u64) T {\n            return .{\n                .r = scaleRed(@as(u16, @truncate(value >> 32))),\n                .g = scaleGreen(@as(u16, @truncate(value >> 16))),\n                .b = scaleBlue(@as(u16, @truncate(value))),\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "u64Rgb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to array from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn array(arr: [4]RedT) T {\n            if (comptime multiple_channel_types) {\n                @compileError(\"Color.from.array may only be used when all channels in the color are the same type.\");\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "array",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to float4 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn float4(value: math.float4) T {\n            var res: T = .{\n                .r = scaleRed(value[0]),\n                .g = scaleGreen(value[1]),\n                .b = scaleBlue(value[2]),\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "float4",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to htmlHex from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn htmlHex(hex_string: []const u8) !T {\n            if (comptime !isAll8BitColor(RedT, GreenT, BlueT, AlphaT)) {\n                @compileError(\n                    \"Color.from.htmlHex can only be used on colors with 8-bit channels. \" ++\n                        @typeName(T) ++ \" has at least one channel which is not u8.\",\n                );\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "htmlHex",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to ToMethods from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn ToMethods(\n    comptime T: type,\n    comptime RedT: type,\n    comptime GreenT: type,\n    comptime BlueT: type,\n    comptime AlphaT: type,\n) type {\n    const has_alpha = AlphaT != void;\n\n    const multiple_channel_types =\n        RedT != GreenT or\n        RedT != BlueT or\n        (RedT != AlphaT and AlphaT != void);\n\n    const scaleRed = ScaleValue(RedT);\n    const scaleGreen = ScaleValue(GreenT);\n    const scaleBlue = ScaleValue(BlueT);\n    // const scaleAlpha: if (has_alpha) fn (anytype) AlphaT else void =\n    //     if (has_alpha)\n    //         ScaleValue(AlphaT)\n    //     else {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "ToMethods",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getSelf from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn getSelf(to: *const To) *align(1) const T {\n            // @fieldParentPtr is broken for packed structs.\n            // See: https://github.com/ziglang/zig/issues/20458\n            if (@typeInfo(T).@\"struct\".layout == .@\"packed\") {\n                const ptr: usize = @intFromPtr(to);\n                const off: usize = @bitOffsetOf(T, \"to\");\n                return @ptrFromInt(ptr - off / 8);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "getSelf",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to color from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn color(to: *const To, ColorT: type) ColorT {\n            return ColorT.from.color(to.getSelf().*);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "color",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to u32Rgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn u32Rgba(to: *const To) u32 {\n            const self = to.getSelf();\n            return @as(u32, toU8(self.r)) << 24 |\n                @as(u32, toU8(self.g)) << 16 |\n                @as(u32, toU8(self.b)) << 8 |\n                if (has_alpha) toU8(self.a) else 0xff;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "u32Rgba",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to u32Rgb from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn u32Rgb(to: *const To) u32 {\n            const self = to.getSelf();\n            return @as(u32, toU8(self.r)) << 16 |\n                @as(u32, toU8(self.g)) << 8 |\n                toU8(self.b);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "u32Rgb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to u64Rgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn u64Rgba(to: *const To) u64 {\n            const self = to.getSelf();\n            return @as(u64, toU16(self.r)) << 48 |\n                @as(u64, toU16(self.g)) << 32 |\n                @as(u64, toU16(self.b)) << 16 |\n                if (has_alpha) toU16(self.a) else 0xffff;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "u64Rgba",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to u64Rgb from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn u64Rgb(to: *const To) u64 {\n            const self = to.getSelf();\n            return @as(u64, toU16(self.r)) << 32 |\n                @as(u64, toU16(self.g)) << 16 |\n                toU16(self.b);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "u64Rgb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to array from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn array(to: *const To) [4]RedT {\n            if (comptime multiple_channel_types) {\n                @compileError(\"Color.to.array may only be used when all channels in the color are the same type.\");\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "array",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to float4 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn float4(to: *const To) math.float4 {\n            const self = to.getSelf();\n\n            return .{\n                toF32(self.r),\n                toF32(self.g),\n                toF32(self.b),\n                if (has_alpha)\n                    toF32(self.a)\n                else\n                    1.0,\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "float4",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to premultipliedAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn premultipliedAlpha(to: *const To) T {\n            const self = to.getSelf();\n            var res = self.*;\n            if (!has_alpha) return res;\n\n            const alpha = if (@typeInfo(AlphaT) == .int)\n                toF32(res.a)\n            else\n                res.a;\n\n            res.r = if (@typeInfo(RedT) == .int)\n                scaleRed(toF32(res.r) * alpha)\n            else\n                res.r * alpha;\n\n            res.g = if (@typeInfo(GreenT) == .int)\n                scaleGreen(toF32(res.g) * alpha)\n            else\n                res.g * alpha;\n\n            res.b = if (@typeInfo(BlueT) == .int)\n                scaleBlue(toF32(res.b) * alpha)\n            else\n                res.b * alpha;\n\n            return res;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "premultipliedAlpha",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to RgbColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn RgbColor(comptime T: type) type {\n    return extern struct {\n        pub const from = FromMethods(@This());\n\n        to: ToMethods(@This(), T, T, T, void) = .{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "RgbColor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to RgbaColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn RgbaColor(comptime T: type) type {\n    return extern struct {\n        pub const from = FromMethods(@This());\n\n        to: ToMethods(@This(), T, T, T, T) = .{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "RgbaColor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to BgrColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn BgrColor(comptime T: type) type {\n    return extern struct {\n        pub const from = FromMethods(@This());\n\n        to: ToMethods(@This(), T, T, T, void) = .{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "BgrColor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to BgraColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn BgraColor(comptime T: type) type {\n    return extern struct {\n        pub const from = FromMethods(@This());\n\n        to: ToMethods(@This(), T, T, T, T) = .{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "BgraColor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to IndexedStorage from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn IndexedStorage(comptime T: type) type {\n    return struct {\n        palette: []Rgba32,\n        indices: []T,\n\n        pub const PaletteSize = 1 << @bitSizeOf(T);\n\n        const Self = @This();\n\n        pub fn init(allocator: Allocator, pixel_count: usize) !Self {\n            return initPaletteSize(allocator, pixel_count, PaletteSize);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "IndexedStorage",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to initPaletteSize from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn initPaletteSize(allocator: Allocator, pixel_count: usize, palette_size: usize) !Self {\n            std.debug.assert(palette_size <= PaletteSize);\n\n            // Allocate the full capacity of the palette but reduce its length to the requested size\n            var result = Self{\n                .indices = try allocator.alloc(T, pixel_count),\n                .palette = try allocator.alloc(Rgba32, PaletteSize),\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "initPaletteSize",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn deinit(self: Self, allocator: Allocator) void {\n            var full_palette = self.palette;\n            full_palette.len = PaletteSize;\n            allocator.free(full_palette);\n            allocator.free(self.indices);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resizePalette from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn resizePalette(self: *Self, new_palette_size: usize) void {\n            std.debug.assert(new_palette_size <= PaletteSize);\n            self.palette.len = new_palette_size;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "resizePalette",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to Grayscale from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn Grayscale(comptime T: type) type {\n    const toF32 = ScaleValue(f32);\n\n    return struct {\n        value: T,\n\n        const Self = @This();\n\n        pub fn toColorf32(self: Self) Colorf32 {\n            const gray = toF32(self.value);\n            return Colorf32{\n                .r = gray,\n                .g = gray,\n                .b = gray,\n                .a = 1.0,\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "Grayscale",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to GrayscaleAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn GrayscaleAlpha(comptime T: type) type {\n    const toF32 = ScaleValue(f32);\n\n    return struct {\n        value: T,\n        alpha: T =\n            if (@typeInfo(T) == .int)\n                std.math.maxInt(T)\n            else\n                1.0,\n\n        const Self = @This();\n\n        pub fn toColorf32(self: Self) Colorf32 {\n            const gray = toF32(self.value);\n            return Colorf32{\n                .r = gray,\n                .g = gray,\n                .b = gray,\n                .a = toF32(self.alpha),\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "GrayscaleAlpha",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn init(allocator: Allocator, format: PixelFormat, pixel_count: usize) !PixelStorage {\n        return switch (format) {\n            .invalid => {\n                return .{\n                    .invalid = void{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to initRawPixels from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn initRawPixels(pixels: []const u8, pixel_format: PixelFormat) !PixelStorage {\n        return switch (pixel_format) {\n            .grayscale1 => {\n                return .{\n                    .grayscale1 = @constCast(std.mem.bytesAsSlice(Grayscale1, pixels)),\n                }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "initRawPixels",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn deinit(self: PixelStorage, allocator: Allocator) void {\n        switch (self) {\n            .invalid => {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to len from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn len(self: PixelStorage) usize {\n        return switch (self) {\n            .invalid => 0,\n            .indexed1 => |data| data.indices.len,\n            .indexed2 => |data| data.indices.len,\n            .indexed4 => |data| data.indices.len,\n            .indexed8 => |data| data.indices.len,\n            .indexed16 => |data| data.indices.len,\n            .grayscale1 => |data| data.len,\n            .grayscale2 => |data| data.len,\n            .grayscale4 => |data| data.len,\n            .grayscale8 => |data| data.len,\n            .grayscale8Alpha => |data| data.len,\n            .grayscale16 => |data| data.len,\n            .grayscale16Alpha => |data| data.len,\n            .rgb24 => |data| data.len,\n            .rgba32 => |data| data.len,\n            .rgb332 => |data| data.len,\n            .rgb565 => |data| data.len,\n            .rgb555 => |data| data.len,\n            .bgr555 => |data| data.len,\n            .bgr24 => |data| data.len,\n            .bgra32 => |data| data.len,\n            .rgb48 => |data| data.len,\n            .rgba64 => |data| data.len,\n            .float32 => |data| data.len,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "len",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isIndexed from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn isIndexed(self: PixelStorage) bool {\n        return switch (self) {\n            .indexed1 => true,\n            .indexed2 => true,\n            .indexed4 => true,\n            .indexed8 => true,\n            .indexed16 => true,\n            else => false,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "isIndexed",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getPalette from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn getPalette(self: PixelStorage) ?[]Rgba32 {\n        return switch (self) {\n            .indexed1 => |data| data.palette,\n            .indexed2 => |data| data.palette,\n            .indexed4 => |data| data.palette,\n            .indexed8 => |data| data.palette,\n            .indexed16 => |data| data.palette,\n            else => null,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "getPalette",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resizePalette from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn resizePalette(self: *PixelStorage, new_palette_size: usize) void {\n        switch (self.*) {\n            .indexed1 => |*data| data.resizePalette(new_palette_size),\n            .indexed2 => |*data| data.resizePalette(new_palette_size),\n            .indexed4 => |*data| data.resizePalette(new_palette_size),\n            .indexed8 => |*data| data.resizePalette(new_palette_size),\n            .indexed16 => |*data| data.resizePalette(new_palette_size),\n            else => {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "resizePalette",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to asBytes from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn asBytes(self: PixelStorage) []u8 {\n        return switch (self) {\n            .invalid => &[_]u8{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "asBytes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to asConstBytes from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn asConstBytes(self: PixelStorage) []const u8 {\n        return switch (self) {\n            .invalid => &[_]u8{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "asConstBytes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to slice from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn slice(self: PixelStorage, begin: usize, end: usize) PixelStorage {\n        return switch (self) {\n            .invalid => .invalid,\n            .indexed1 => |data| .{ .indexed1 = .{ .palette = data.palette, .indices = data.indices[begin..end] }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "slice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn init(pixels: *const PixelStorage) Self {\n        return Self{\n            .pixels = pixels,\n            .end = pixels.len(),\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn next(self: *Self) ?Colorf32 {\n        if (self.current_index >= self.end) {\n            return null;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromRgb from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromRgb(rgb: Colorf32) Hsl {\n        const maximum = @max(rgb.r, @max(rgb.g, rgb.b)); // V\n        const minimum = @min(rgb.r, @min(rgb.g, rgb.b)); // V - C\n        const range = maximum - minimum; // C := 2(V - L)\n        const luminance = (maximum + minimum) / 2.0; // V - C/2\n\n        var hue: f32 = 0.0;\n\n        if (range == 0.0) {\n            hue = 0.0;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromRgb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toRgb from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toRgb(self: Hsl) Colorf32 {\n        return .{\n            .r = self.getRgbComponent(0),\n            .g = self.getRgbComponent(8),\n            .b = self.getRgbComponent(4),\n            .a = 1.0,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toRgb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toHsv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toHsv(self: Hsl) Hsv {\n        const value = self.luminance + self.saturation * @min(self.luminance, 1.0 - self.luminance);\n\n        return .{\n            .hue = self.hue,\n            .saturation = if (value == 0.0) 0.0 else 2.0 * (1.0 - (self.luminance / value)),\n            .value = value,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toHsv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getRgbComponent from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn getRgbComponent(self: Hsl, n: f32) f32 {\n        const a = self.saturation * @min(self.luminance, 1.0 - self.luminance);\n        const k = @mod(n + self.hue / 30, 12);\n\n        return self.luminance - a * @max(-1, @min(k - 3.0, @min(9.0 - k, 1.0)));\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "getRgbComponent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromRgb from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromRgb(rgb: Colorf32) Hsv {\n        const maximum = @max(rgb.r, @max(rgb.g, rgb.b)); // V\n        const minimum = @min(rgb.r, @min(rgb.g, rgb.b)); // V - C\n        const range = maximum - minimum; // C := 2(V - L)\n\n        var hue: f32 = 0.0;\n\n        if (range == 0.0) {\n            hue = 0.0;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromRgb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toRgb from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toRgb(self: Hsv) Colorf32 {\n        return .{\n            .r = self.getRgbComponent(5),\n            .g = self.getRgbComponent(3),\n            .b = self.getRgbComponent(1),\n            .a = 1.0,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toRgb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toHsl from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toHsl(self: Hsv) Hsl {\n        const luminance = self.value * (1.0 - (self.saturation / 2.0));\n        return .{\n            .hue = self.hue,\n            .saturation = if (luminance == 0.0) 0.0 else (self.value - luminance) / @min(luminance, 1.0 - luminance),\n            .luminance = luminance,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toHsl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getRgbComponent from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn getRgbComponent(self: Hsv, n: f32) f32 {\n        const k = @mod(n + (self.hue / 60), 6);\n\n        return self.value - (self.value * self.saturation * @max(0.0, @min(k, @min(4.0 - k, 1))));\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "getRgbComponent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromColorf32 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromColorf32(value: Colorf32) Cmykf32 {\n        const max = @max(value.r, @max(value.g, value.b));\n        const k = 1.0 - max;\n\n        const minus_k = 1.0 - k;\n        if (std.math.approxEqAbs(f32, minus_k, 0.0, std.math.floatEps(f32))) {\n            return .{\n                .k = k,\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromColorf32",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toColorF32 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toColorF32(self: Cmykf32) Colorf32 {\n        const minus_k = 1.0 - self.k;\n        return .{\n            .r = (1.0 - self.c) * minus_k,\n            .g = (1.0 - self.m) * minus_k,\n            .b = (1.0 - self.y) * minus_k,\n            .a = 1.0,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toColorF32",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromFloat4 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromFloat4(value: math.float4) CIEXYZAlpha {\n        return @bitCast(value);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromFloat4",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toFloat4 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toFloat4(self: CIEXYZAlpha) math.float4 {\n        return @bitCast(self);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toFloat4",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toXYZ from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toXYZ(self: CIEXYZAlpha) CIEXYZ {\n        return .{\n            .x = self.x,\n            .y = self.y,\n            .z = self.z,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toXYZ",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromXYZ from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromXYZ(xyz: CIEXYZ, white_point: CIExyY) CIELab {\n        return CIELab.fromXYZPrecomputedWhitePoint(xyz, white_point.toXYZ(1.0));\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromXYZ",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromXYZPrecomputedWhitePoint from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromXYZPrecomputedWhitePoint(xyz: CIEXYZ, white_point_xyz: CIEXYZ) CIELab {\n        // Math from http://www.brucelindbloom.com/Eqn_XYZ_to_Lab.html\n        const relative_x = xyz.x / white_point_xyz.x;\n        const relative_y = xyz.y / white_point_xyz.y;\n        const relative_z = xyz.z / white_point_xyz.z;\n\n        const factor_x = factor(relative_x);\n        const factor_y = factor(relative_y);\n        const factor_z = factor(relative_z);\n\n        const l = 116.0 * factor_y - 16.0;\n        const a = 500.0 * (factor_x - factor_y);\n        const b = 200.0 * (factor_y - factor_z);\n\n        // Normalize to 0 to 1 or -1.0 to 1.0\n        return .{\n            .l = l / 100.0,\n            .a = a / 100.0,\n            .b = b / 100.0,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromXYZPrecomputedWhitePoint",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toXYZ from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toXYZ(self: CIELab, white_point: CIExyY) CIEXYZ {\n        return self.toXYZPrecomputedWhitePoint(white_point.toXYZ(1.0));\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toXYZ",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toXYZPrecomputedWhitePoint from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toXYZPrecomputedWhitePoint(self: CIELab, white_point_xyz: CIEXYZ) CIEXYZ {\n        // Math from http://www.brucelindbloom.com/Eqn_Lab_to_XYZ.html\n        const scaled_l = self.l * 100.0;\n        const scaled_a = self.a * 100.0;\n        const scaled_b = self.b * 100.0;\n\n        const factor_y = (scaled_l + 16.0) / 116.0;\n        const factor_z = factor_y - (scaled_b / 200.0);\n        const factor_x = (scaled_a / 500.0) + factor_y;\n\n        const cubic_factor_x = factor_x * factor_x * factor_x;\n        const cubic_factor_z = factor_z * factor_z * factor_z;\n\n        const result_x = if (cubic_factor_x > CIEConstants.epsilon) cubic_factor_x else ((116.0 * factor_x) - 16.0) / CIEConstants.kappa;\n        const result_y = if (scaled_l > (CIEConstants.kappa * CIEConstants.epsilon)) std.math.pow(f32, (scaled_l + 16.0) / 116.0, 3.0) else scaled_l / CIEConstants.kappa;\n        const result_z = if (cubic_factor_z > CIEConstants.epsilon) cubic_factor_z else ((116.0 * factor_z) - 16.0) / CIEConstants.kappa;\n\n        return .{\n            .x = result_x * white_point_xyz.x,\n            .y = result_y * white_point_xyz.y,\n            .z = result_z * white_point_xyz.z,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toXYZPrecomputedWhitePoint",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromLCHab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromLCHab(value: CIELCHab) CIELab {\n        return value.toLab();\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromLCHab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLCHab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toLCHab(self: CIELab) CIELCHab {\n        return CIELCHab.fromLab(self);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLCHab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to factor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn factor(t: f32) f32 {\n        if (t > CIEConstants.epsilon) {\n            return std.math.cbrt(t);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "factor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromXYZAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromXYZAlpha(xyza: CIEXYZAlpha, white_point: CIExyY) CIELabAlpha {\n        return fromXYZAlphaPrecomputedWhitePoint(xyza, white_point.toXYZ(1.0));\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromXYZAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromXYZAlphaPrecomputedWhitePoint from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromXYZAlphaPrecomputedWhitePoint(xyza: CIEXYZAlpha, white_point_xyz: CIEXYZ) CIELabAlpha {\n        const lab = CIELab.fromXYZPrecomputedWhitePoint(xyza.toXYZ(), white_point_xyz);\n\n        return .{\n            .l = lab.l,\n            .a = lab.a,\n            .b = lab.b,\n            .alpha = xyza.a,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromXYZAlphaPrecomputedWhitePoint",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toXYZAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toXYZAlpha(self: CIELabAlpha, white_point: CIExyY) CIEXYZAlpha {\n        return self.toXYZAlphaPrecomputedWhitePoint(white_point.toXYZ(1.0));\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toXYZAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toXYZAlphaPrecomputedWhitePoint from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toXYZAlphaPrecomputedWhitePoint(self: CIELabAlpha, white_point_xyz: CIEXYZ) CIEXYZAlpha {\n        const xyz = CIELab.toXYZPrecomputedWhitePoint(self.toLab(), white_point_xyz);\n\n        return .{\n            .x = xyz.x,\n            .y = xyz.y,\n            .z = xyz.z,\n            .a = self.alpha,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toXYZAlphaPrecomputedWhitePoint",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLab(self: CIELabAlpha) CIELab {\n        return .{\n            .l = self.l,\n            .a = self.a,\n            .b = self.b,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromLCHabAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromLCHabAlpha(value: CIELCHabAlpha) CIELabAlpha {\n        return value.toLabAlpha();\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromLCHabAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLCHabAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toLCHabAlpha(self: CIELabAlpha) CIELCHabAlpha {\n        return CIELCHabAlpha.fromLabAlpha(self);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLCHabAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromFloat4 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromFloat4(value: math.float4) CIELabAlpha {\n        return @bitCast(value);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromFloat4",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toFloat4 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toFloat4(self: CIELabAlpha) math.float4 {\n        return @bitCast(self);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toFloat4",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromLab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromLab(value: CIELab) CIELCHab {\n        const c = std.math.sqrt(value.a * value.a + value.b * value.b);\n        var h = std.math.atan2(value.b, value.a);\n        if (h < 0.0) {\n            h += 2.0 * std.math.pi;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromLab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLab(self: CIELCHab) CIELab {\n        return .{\n            .l = self.l,\n            .a = self.c * @cos(self.h),\n            .b = self.c * @sin(self.h),\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromLabAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromLabAlpha(lab_alpha: CIELabAlpha) CIELCHabAlpha {\n        const lch = CIELCHab.fromLab(lab_alpha.toLab());\n\n        return .{\n            .l = lch.l,\n            .c = lch.c,\n            .h = lch.h,\n            .alpha = lab_alpha.alpha,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromLabAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLabAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLabAlpha(self: CIELCHabAlpha) CIELabAlpha {\n        const lab = CIELCHab.toLab(self.toLCHab());\n\n        return .{\n            .l = lab.l,\n            .a = lab.a,\n            .b = lab.b,\n            .alpha = self.alpha,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLabAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLCHab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLCHab(self: CIELCHabAlpha) CIELCHab {\n        return .{\n            .l = self.l,\n            .c = self.c,\n            .h = self.h,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLCHab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromXYZ from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromXYZ(xyz: CIEXYZ, white_point: CIExyY) CIELuv {\n        return fromXYZPrecomputedWhitePoint(xyz, white_point.toXYZ(1.0));\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromXYZ",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromXYZPrecomputedWhitePoint from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromXYZPrecomputedWhitePoint(xyz: CIEXYZ, white_point_xyz: CIEXYZ) CIELuv {\n        // Math from: http://www.brucelindbloom.com/index.html?Eqn_XYZ_to_Luv.html\n        const y_relative = xyz.y / white_point_xyz.y;\n\n        const value_denominator = xyz.x + 15.0 * xyz.y + 3.0 * xyz.z;\n        const is_value_zero = std.math.approxEqAbs(f32, value_denominator, 0.0, std.math.floatEps(f32));\n        const u_prime = if (!is_value_zero) (4.0 * xyz.x) / value_denominator else 0.0;\n        const v_prime = if (!is_value_zero) (9.0 * xyz.y) / value_denominator else 0.0;\n\n        const white_denominator = (white_point_xyz.x + 15.0 * white_point_xyz.y + 3.0 * white_point_xyz.z);\n        const white_u_prime = (4.0 * white_point_xyz.x) / white_denominator;\n        const white_v_prime = (9.0 * white_point_xyz.y) / white_denominator;\n\n        const l = if (y_relative > CIEConstants.epsilon) (116.0 * std.math.cbrt(y_relative)) - 16.0 else CIEConstants.kappa * y_relative;\n        const u = 13.0 * l * (u_prime - white_u_prime);\n        const v = 13.0 * l * (v_prime - white_v_prime);\n\n        // Normalize the result\n        return .{\n            .l = l / 100.0,\n            .u = u / 100.0,\n            .v = v / 100.0,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromXYZPrecomputedWhitePoint",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toXYZ from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toXYZ(self: CIELuv, white_point: CIExyY) CIEXYZ {\n        return self.toXYZPrecomputedWhitePoint(white_point.toXYZ(1.0));\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toXYZ",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toXYZPrecomputedWhitePoint from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toXYZPrecomputedWhitePoint(self: CIELuv, white_point_xyz: CIEXYZ) CIEXYZ {\n        // Math from: http://www.brucelindbloom.com/index.html?Eqn_Luv_to_XYZ.html\n        const scaled_l = self.l * 100.0;\n        const scaled_u = self.u * 100.0;\n        const scaled_v = self.v * 100.0;\n\n        if (std.math.approxEqAbs(f32, scaled_l, 0.0, std.math.floatEps(f32))) {\n            return .{\n                .x = 0.0,\n                .y = 0.0,\n                .z = 0.0,\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toXYZPrecomputedWhitePoint",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromLCHuv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromLCHuv(value: CIELCHuv) CIELuv {\n        return value.toLuv();\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromLCHuv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLCHuv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toLCHuv(self: CIELuv) CIELCHuv {\n        return CIELCHuv.fromLuv(self);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLCHuv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromXYZAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromXYZAlpha(xyza: CIEXYZAlpha, white_point: CIExyY) CIELuvAlpha {\n        return fromXYZAlphaPrecomputedWhitePoint(xyza, white_point.toXYZ(1.0));\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromXYZAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromXYZAlphaPrecomputedWhitePoint from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromXYZAlphaPrecomputedWhitePoint(xyza: CIEXYZAlpha, white_point_xyz: CIEXYZ) CIELuvAlpha {\n        const luv = CIELuv.fromXYZPrecomputedWhitePoint(xyza.toXYZ(), white_point_xyz);\n\n        return .{\n            .l = luv.l,\n            .u = luv.u,\n            .v = luv.v,\n            .alpha = xyza.a,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromXYZAlphaPrecomputedWhitePoint",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toXYZAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toXYZAlpha(self: CIELuvAlpha, white_point: CIExyY) CIEXYZAlpha {\n        return self.toXYZAlphaPrecomputedWhitePoint(white_point.toXYZ(1.0));\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toXYZAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toXYZAlphaPrecomputedWhitePoint from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toXYZAlphaPrecomputedWhitePoint(self: CIELuvAlpha, white_point_xyz: CIEXYZ) CIEXYZAlpha {\n        const xyz = CIELuv.toXYZPrecomputedWhitePoint(self.toLuv(), white_point_xyz);\n\n        return .{\n            .x = xyz.x,\n            .y = xyz.y,\n            .z = xyz.z,\n            .a = self.alpha,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toXYZAlphaPrecomputedWhitePoint",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLuv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLuv(self: CIELuvAlpha) CIELuv {\n        return .{\n            .l = self.l,\n            .u = self.u,\n            .v = self.v,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLuv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromLCHuvAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromLCHuvAlpha(value: CIELCHuvAlpha) CIELuvAlpha {\n        return value.toLuvAlpha();\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromLCHuvAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLCHuvAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toLCHuvAlpha(self: CIELuvAlpha) CIELCHuvAlpha {\n        return CIELCHuvAlpha.fromLuvAlpha(self);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLCHuvAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromFloat4 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromFloat4(value: math.float4) CIELuvAlpha {\n        return @bitCast(value);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromFloat4",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toFloat4 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toFloat4(self: CIELuvAlpha) math.float4 {\n        return @bitCast(self);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toFloat4",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromLuv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromLuv(value: CIELuv) CIELCHuv {\n        const c = std.math.sqrt(value.u * value.u + value.v * value.v);\n        var h = std.math.atan2(value.v, value.u);\n        if (h < 0.0) {\n            h += 2.0 * std.math.pi;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromLuv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLuv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLuv(self: CIELCHuv) CIELuv {\n        return .{\n            .l = self.l,\n            .u = self.c * @cos(self.h),\n            .v = self.c * @sin(self.h),\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLuv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromLuvAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromLuvAlpha(luv_alpha: CIELuvAlpha) CIELCHuvAlpha {\n        const lch = CIELCHuv.fromLuv(luv_alpha.toLuv());\n\n        return .{\n            .l = lch.l,\n            .c = lch.c,\n            .h = lch.h,\n            .alpha = luv_alpha.alpha,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromLuvAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLuvAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLuvAlpha(self: CIELCHuvAlpha) CIELuvAlpha {\n        const luv = CIELCHuv.toLuv(self.toLCHuv());\n\n        return .{\n            .l = luv.l,\n            .u = luv.u,\n            .v = luv.v,\n            .alpha = self.alpha,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLuvAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLCHuv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLCHuv(self: CIELCHuvAlpha) CIELCHuv {\n        return .{\n            .l = self.l,\n            .c = self.c,\n            .h = self.h,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLCHuv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to intersect from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn intersect(left: Line, right: Line) f32 {\n            return (left.b - right.b) / (right.a - left.a);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "intersect",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rayLengthUntilIntersect from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn rayLengthUntilIntersect(self: Line, angle: f32) f32 {\n            return self.b / (@sin(angle) - self.a * @cos(angle));\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "rayLengthUntilIntersect",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromCIELChuv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromCIELChuv(lch: CIELCHuv, xyz_to_rgb_matrix: math.float4x4) HSLuv {\n        var s: f32 = 0.0;\n\n        // White and black: disambiguate saturation\n        if (lch.l > 0.99999999999 or lch.l < 0.00000001) {\n            s = 0.0;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromCIELChuv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toCIELCHuv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toCIELCHuv(self: HSLuv, xyz_to_rgb_matrix: math.float4x4) CIELCHuv {\n        var c: f32 = 0.0;\n\n        // White and black: disambiguate chroma\n        if (self.l > 0.99999999999 or self.l < 0.00000001) {\n            c = 0.0;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toCIELCHuv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to maxChromaForLH from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn maxChromaForLH(l: f32, h: f32, xyz_to_rgb_matrix: math.float4x4) f32 {\n        var minimum_length = std.math.floatMax(f32);\n        var bounds: [6]Line = undefined;\n\n        getBounds(l, bounds[0..], xyz_to_rgb_matrix);\n\n        for (bounds) |bound| {\n            const length = bound.rayLengthUntilIntersect(h);\n            if (length >= 0 and length < minimum_length) {\n                minimum_length = length;\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "maxChromaForLH",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getBounds from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn getBounds(l: f32, bounds: []Line, xyz_to_rgb_matrix: math.float4x4) void {\n        const scaled_l = l * 100.0;\n\n        const tl = scaled_l + 16.0;\n        const sub1 = (tl * tl * tl) / 1560896.0;\n        const sub2 = if (sub1 > CIEConstants.epsilon) sub1 else (1.0 / CIEConstants.kappa);\n\n        for (0..3) |channel| {\n            const m1 = xyz_to_rgb_matrix.matrix[channel][0];\n            const m2 = xyz_to_rgb_matrix.matrix[channel][1];\n            const m3 = xyz_to_rgb_matrix.matrix[channel][2];\n\n            for (0..2) |t| {\n                const top1 = (284517.0 * m1 - 94839.0 * m3) * sub2;\n                const top2 = (838422.0 * m3 + 769860.0 * m2 + 731718.0 * m1) * scaled_l * sub2 - 769860.0 * @as(f32, @floatFromInt(t)) * scaled_l;\n                const bottom = (632260.0 * m3 - 126452.0 * m2) * sub2 + 126452.0 * @as(f32, @floatFromInt(t));\n\n                bounds[channel * 2 + t].a = top1 / bottom;\n                bounds[channel * 2 + t].b = top2 / bottom;\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "getBounds",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromCIELChuvAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromCIELChuvAlpha(lch: CIELCHuvAlpha, xyz_to_rgb_matrix: math.float4x4) HSLuvAlpha {\n        const hsl = HSLuv.fromCIELChuv(lch.toLCHuv(), xyz_to_rgb_matrix);\n\n        return .{\n            .h = hsl.h,\n            .s = hsl.s,\n            .l = hsl.l,\n            .alpha = lch.alpha,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromCIELChuvAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toCIELCHuvAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toCIELCHuvAlpha(self: HSLuvAlpha, xyz_to_rgb_matrix: math.float4x4) CIELCHuvAlpha {\n        const lch = HSLuv.toCIELCHuv(self.toHSLuv(), xyz_to_rgb_matrix);\n\n        return .{\n            .l = lch.l,\n            .c = lch.c,\n            .h = lch.h,\n            .alpha = self.alpha,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toCIELCHuvAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toHSLuv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toHSLuv(self: HSLuvAlpha) HSLuv {\n        return .{\n            .h = self.h,\n            .s = self.s,\n            .l = self.l,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toHSLuv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromFloat4 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromFloat4(value: math.float4) CIELuvAlpha {\n        return @bitCast(value);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromFloat4",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toFloat4 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toFloat4(self: CIELuvAlpha) math.float4 {\n        return @bitCast(self);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toFloat4",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromXYZ from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromXYZ(xyz: CIEXYZ) Oklab {\n        const labAlpha = OklabAlpha.fromXYZAlpha(CIEXYZAlpha{ .x = xyz.x, .y = xyz.y, .z = xyz.z, .a = 1.0 }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromXYZ",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toXYZ from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toXYZ(self: Oklab) CIEXYZ {\n        const xyza = OklabAlpha.toXYZAlpha(self.toOklabAlpha());\n        return xyza.toXYZ();\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toXYZ",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toOklabAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toOklabAlpha(self: Oklab) OklabAlpha {\n        return .{\n            .l = self.l,\n            .a = self.a,\n            .b = self.b,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toOklabAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toOkLCh from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toOkLCh(self: Oklab) OkLCh {\n        return OkLCh.fromOklab(self);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toOkLCh",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromXYZAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromXYZAlpha(xyza: CIEXYZAlpha) OklabAlpha {\n        var lmsa = XYZAtoLMS.mulVector(xyza.toFloat4());\n\n        lmsa[0] = std.math.cbrt(lmsa[0]);\n        lmsa[1] = std.math.cbrt(lmsa[1]);\n        lmsa[2] = std.math.cbrt(lmsa[2]);\n\n        const lab_a = LMSPrimeToLab.mulVector(lmsa);\n        return .{\n            .l = lab_a[0],\n            .a = lab_a[1],\n            .b = lab_a[2],\n            .alpha = xyza.a,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromXYZAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toXYZAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toXYZAlpha(self: OklabAlpha) CIEXYZAlpha {\n        var lmsa_prime = LabToLMSPrime.mulVector(self.toFloat4());\n\n        lmsa_prime[0] = lmsa_prime[0] * lmsa_prime[0] * lmsa_prime[0];\n        lmsa_prime[1] = lmsa_prime[1] * lmsa_prime[1] * lmsa_prime[1];\n        lmsa_prime[2] = lmsa_prime[2] * lmsa_prime[2] * lmsa_prime[2];\n\n        const xyza_float4 = LMSToXYZA.mulVector(lmsa_prime);\n\n        return CIEXYZAlpha.fromFloat4(xyza_float4);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toXYZAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toOklab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toOklab(self: OklabAlpha) Oklab {\n        return .{\n            .l = self.l,\n            .a = self.a,\n            .b = self.b,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toOklab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toOkLChAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toOkLChAlpha(self: OklabAlpha) OkLChAlpha {\n        return OkLChAlpha.fromOklabAlpha(self);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toOkLChAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromFloat4 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromFloat4(value: math.float4) OklabAlpha {\n        return @bitCast(value);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromFloat4",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toFloat4 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toFloat4(self: OklabAlpha) math.float4 {\n        return @bitCast(self);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toFloat4",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromOklab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromOklab(value: Oklab) OkLCh {\n        const c = std.math.sqrt(value.a * value.a + value.b * value.b);\n        var h = std.math.atan2(value.b, value.a);\n        if (h < 0.0) {\n            h += 2.0 * std.math.pi;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromOklab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toOklab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toOklab(self: OkLCh) Oklab {\n        return .{\n            .l = self.l,\n            .a = self.c * @cos(self.h),\n            .b = self.c * @sin(self.h),\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toOklab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromOklabAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromOklabAlpha(lab_alpha: OklabAlpha) OkLChAlpha {\n        const lch = OkLCh.fromOklab(lab_alpha.toOklab());\n\n        return .{\n            .l = lch.l,\n            .c = lch.c,\n            .h = lch.h,\n            .alpha = lab_alpha.alpha,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromOklabAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toOkLabAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toOkLabAlpha(self: OkLChAlpha) OklabAlpha {\n        const lab = OkLCh.toOklab(self.toOkLCh());\n\n        return .{\n            .l = lab.l,\n            .a = lab.a,\n            .b = lab.b,\n            .alpha = self.alpha,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toOkLabAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toOkLCh from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toOkLCh(self: OkLChAlpha) OkLCh {\n        return .{\n            .l = self.l,\n            .c = self.c,\n            .h = self.h,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toOkLCh",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to z from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn z(self: CIExyY) f32 {\n        return 1.0 - self.x - self.y;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "z",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toXYZ from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toXYZ(self: CIExyY, Y: f32) CIEXYZ {\n        return .{\n            .x = (self.x / self.y) * Y,\n            .y = Y,\n            .z = (self.z() / self.y) * Y,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toXYZ",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to equals from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn equals(self: CIExyY, right: CIExyY) bool {\n        return self.x == right.x and self.y == right.y;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "equals",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn init(args: InitArgs) RgbColorspace {\n        var result = RgbColorspace{\n            .red = args.red,\n            .green = args.green,\n            .blue = args.blue,\n            .white = args.white,\n            .rgba_to_xyza = undefined,\n            .xyza_to_rgba = undefined,\n            .to_gamma = args.to_gamma,\n            .to_gamma_fast = args.to_gamma_fast,\n            .to_linear = args.to_linear,\n            .to_linear_fast = args.to_linear_fast,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toGamma from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toGamma(self: RgbColorspace, color: Colorf32) Colorf32 {\n        return .{\n            .r = self.to_gamma(color.r),\n            .g = self.to_gamma(color.g),\n            .b = self.to_gamma(color.b),\n            .a = color.a,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toGamma",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toGammaFast from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toGammaFast(self: RgbColorspace, color: Colorf32) Colorf32 {\n        return .{\n            .r = self.to_gamma_fast(color.r),\n            .g = self.to_gamma_fast(color.g),\n            .b = self.to_gamma_fast(color.b),\n            .a = color.a,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toGammaFast",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLinear from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLinear(self: RgbColorspace, color: Colorf32) Colorf32 {\n        return .{\n            .r = self.to_linear(color.r),\n            .g = self.to_linear(color.g),\n            .b = self.to_linear(color.b),\n            .a = color.a,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLinear",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLinearFast from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLinearFast(self: RgbColorspace, color: Colorf32) Colorf32 {\n        return .{\n            .r = self.to_linear_fast(color.r),\n            .g = self.to_linear_fast(color.g),\n            .b = self.to_linear_fast(color.b),\n            .a = color.a,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLinearFast",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromXYZ from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromXYZ(self: RgbColorspace, xyz: CIEXYZ) Colorf32 {\n        const xyz_float4 = math.float4{ xyz.x, xyz.y, xyz.z, 1.0 }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromXYZ",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toXYZ from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toXYZ(self: RgbColorspace, color: Colorf32) CIEXYZ {\n        const result = self.rgba_to_xyza.mulVector(color.to.float4());\n\n        return .{\n            .x = result[0],\n            .y = result[1],\n            .z = result[2],\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toXYZ",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromXYZAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromXYZAlpha(self: RgbColorspace, xyza: CIEXYZAlpha) Colorf32 {\n        const result = self.xyza_to_rgba.mulVector(xyza.toFloat4());\n\n        return Colorf32.from.float4(result);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromXYZAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toXYZAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toXYZAlpha(self: RgbColorspace, color: Colorf32) CIEXYZAlpha {\n        const result = self.rgba_to_xyza.mulVector(color.to.float4());\n\n        return CIEXYZAlpha.fromFloat4(result);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toXYZAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromLab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromLab(self: RgbColorspace, lab: CIELab, post_conversion_behavior: PostConversionBehavior) Colorf32 {\n        const xyz = lab.toXYZ(self.white);\n        var result = self.fromXYZ(xyz);\n\n        switch (post_conversion_behavior) {\n            .none => {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromLab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLab(self: RgbColorspace, color: Colorf32) CIELab {\n        return CIELab.fromXYZ(self.toXYZ(color), self.white);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromLCHab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromLCHab(self: RgbColorspace, lch_ab: CIELCHab, post_conversion_behavior: PostConversionBehavior) Colorf32 {\n        return self.fromLab(lch_ab.toLab(), post_conversion_behavior);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromLCHab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLCHab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toLCHab(self: RgbColorspace, color: Colorf32) CIELCHab {\n        return self.toLab(color).toLCHab();\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLCHab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromLabAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromLabAlpha(self: RgbColorspace, lab: CIELabAlpha, post_conversion_behavior: PostConversionBehavior) Colorf32 {\n        const xyza = lab.toXYZAlpha(self.white);\n\n        var result = self.fromXYZAlpha(xyza);\n\n        switch (post_conversion_behavior) {\n            .none => {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromLabAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLabAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLabAlpha(self: RgbColorspace, color: Colorf32) CIELabAlpha {\n        return CIELabAlpha.fromXYZAlpha(self.toXYZAlpha(color), self.white);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLabAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromLCHabAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromLCHabAlpha(self: RgbColorspace, lch_ab_alpha: CIELCHabAlpha, post_conversion_behavior: PostConversionBehavior) Colorf32 {\n        return self.fromLabAlpha(lch_ab_alpha.toLabAlpha(), post_conversion_behavior);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromLCHabAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLCHabAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toLCHabAlpha(self: RgbColorspace, color: Colorf32) CIELCHabAlpha {\n        return self.toLabAlpha(color).toLCHabAlpha();\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLCHabAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromLuv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromLuv(self: RgbColorspace, luv: CIELuv, post_conversion_behavior: PostConversionBehavior) Colorf32 {\n        const xyz = luv.toXYZ(self.white);\n        var result = self.fromXYZ(xyz);\n\n        switch (post_conversion_behavior) {\n            .none => {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromLuv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLuv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLuv(self: RgbColorspace, color: Colorf32) CIELuv {\n        return CIELuv.fromXYZ(self.toXYZ(color), self.white);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLuv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromLCHuv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromLCHuv(self: RgbColorspace, lch_uv: CIELCHuv, post_conversion_behavior: PostConversionBehavior) Colorf32 {\n        return self.fromLuv(lch_uv.toLuv(), post_conversion_behavior);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromLCHuv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLCHuv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toLCHuv(self: RgbColorspace, color: Colorf32) CIELCHuv {\n        return self.toLuv(color).toLCHuv();\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLCHuv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromLuvAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromLuvAlpha(self: RgbColorspace, luv: CIELuvAlpha, post_conversion_behavior: PostConversionBehavior) Colorf32 {\n        const xyza = luv.toXYZAlpha(self.white);\n        var result = self.fromXYZAlpha(xyza);\n\n        switch (post_conversion_behavior) {\n            .none => {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromLuvAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLuvAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLuvAlpha(self: RgbColorspace, color: Colorf32) CIELuvAlpha {\n        return CIELuvAlpha.fromXYZAlpha(self.toXYZAlpha(color), self.white);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLuvAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromLCHuvAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromLCHuvAlpha(self: RgbColorspace, lch_uv: CIELCHuvAlpha, post_conversion_behavior: PostConversionBehavior) Colorf32 {\n        return self.fromLuvAlpha(lch_uv.toLuvAlpha(), post_conversion_behavior);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromLCHuvAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLCHuvAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toLCHuvAlpha(self: RgbColorspace, color: Colorf32) CIELCHuvAlpha {\n        return self.toLuvAlpha(color).toLCHuvAlpha();\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLCHuvAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromHSLuv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromHSLuv(self: RgbColorspace, hsluv: HSLuv, post_conversion_behavior: PostConversionBehavior) Colorf32 {\n        const lch = hsluv.toCIELCHuv(self.xyza_to_rgba);\n\n        return self.fromLCHuv(lch, post_conversion_behavior);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromHSLuv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toHSLuv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toHSLuv(self: RgbColorspace, color: Colorf32) HSLuv {\n        const lch = self.toLCHuv(color);\n\n        return HSLuv.fromCIELChuv(lch, self.xyza_to_rgba);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toHSLuv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromHSLuvAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromHSLuvAlpha(self: RgbColorspace, hsluv: HSLuvAlpha, post_conversion_behavior: PostConversionBehavior) Colorf32 {\n        const lch = hsluv.toCIELCHuvAlpha(self.xyza_to_rgba);\n\n        return self.fromLCHuvAlpha(lch, post_conversion_behavior);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromHSLuvAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toHSLuvAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toHSLuvAlpha(self: RgbColorspace, color: Colorf32) HSLuvAlpha {\n        const lch = self.toLCHuvAlpha(color);\n\n        return HSLuvAlpha.fromCIELChuvAlpha(lch, self.xyza_to_rgba);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toHSLuvAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromOkLab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromOkLab(self: RgbColorspace, oklab: Oklab, post_conversion_behavior: PostConversionBehavior) Colorf32 {\n        const xyz = oklab.toXYZ();\n        var result = self.fromXYZ(xyz);\n\n        switch (post_conversion_behavior) {\n            .none => {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromOkLab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toOklab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toOklab(self: RgbColorspace, color: Colorf32) Oklab {\n        return Oklab.fromXYZ(self.toXYZ(color));\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toOklab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromOkLabAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn fromOkLabAlpha(self: RgbColorspace, oklab: OklabAlpha, post_conversion_behavior: PostConversionBehavior) Colorf32 {\n        const xyza = oklab.toXYZAlpha();\n        var result = self.fromXYZAlpha(xyza);\n\n        switch (post_conversion_behavior) {\n            .none => {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromOkLabAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toOklabAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toOklabAlpha(self: RgbColorspace, color: Colorf32) OklabAlpha {\n        return OklabAlpha.fromXYZAlpha(self.toXYZAlpha(color));\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toOklabAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromOkLCh from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromOkLCh(self: RgbColorspace, lch: OkLCh, post_conversion_behavior: PostConversionBehavior) Colorf32 {\n        return self.fromOkLab(lch.toOklab(), post_conversion_behavior);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromOkLCh",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toOkLCh from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toOkLCh(self: RgbColorspace, color: Colorf32) OkLCh {\n        return self.toOklab(color).toOkLCh();\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toOkLCh",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromOkLChAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn fromOkLChAlpha(self: RgbColorspace, lch: OkLChAlpha, post_conversion_behavior: PostConversionBehavior) Colorf32 {\n        return self.fromOkLabAlpha(lch.toOkLabAlpha(), post_conversion_behavior);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "fromOkLChAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toOkLChAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toOkLChAlpha(self: RgbColorspace, color: Colorf32) OkLChAlpha {\n        return self.toOklabAlpha(color).toOkLChAlpha();\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toOkLChAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sliceFromXYZAlphaInPlace from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn sliceFromXYZAlphaInPlace(self: RgbColorspace, slice_xyza: []CIEXYZAlpha) []Colorf32 {\n        const slice_rgba: []Colorf32 = @ptrCast(slice_xyza);\n\n        for (slice_rgba) |*rgba| {\n            rgba.* = Colorf32.from.float4(self.xyza_to_rgba.mulVector(rgba.to.float4()));\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "sliceFromXYZAlphaInPlace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sliceToXYZAlphaInPlace from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn sliceToXYZAlphaInPlace(self: RgbColorspace, colors: []Colorf32) []CIEXYZAlpha {\n        const slice_xyza: []CIEXYZAlpha = @ptrCast(colors);\n\n        for (slice_xyza) |*xyza| {\n            xyza.* = CIEXYZAlpha.fromFloat4(self.rgba_to_xyza.mulVector(xyza.toFloat4()));\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "sliceToXYZAlphaInPlace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sliceFromXYZAlphaCopy from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn sliceFromXYZAlphaCopy(self: RgbColorspace, allocator: std.mem.Allocator, slice_xyza: []const CIEXYZAlpha) ![]Colorf32 {\n        const slice_rgba: []Colorf32 = try allocator.alloc(Colorf32, slice_xyza.len);\n\n        for (0..slice_xyza.len) |index| {\n            slice_rgba[index] = Colorf32.from.float4(self.xyza_to_rgba.mulVector(slice_xyza[index].toFloat4()));\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "sliceFromXYZAlphaCopy",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to sliceToXYZAlphaCopy from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn sliceToXYZAlphaCopy(self: RgbColorspace, allocator: std.mem.Allocator, colors: []const Colorf32) ![]CIEXYZAlpha {\n        const slice_xyza: []CIEXYZAlpha = try allocator.alloc(CIEXYZAlpha, colors.len);\n\n        for (0..colors.len) |index| {\n            slice_xyza[index] = CIEXYZAlpha.fromFloat4(self.rgba_to_xyza.mulVector(colors[index].to.float4()));\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "sliceToXYZAlphaCopy",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to sliceFromLabAlphaInPlace from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn sliceFromLabAlphaInPlace(self: RgbColorspace, slice_lab: []CIELabAlpha, post_conversion_behavior: PostConversionBehavior) []Colorf32 {\n        const slice_rgba: []Colorf32 = @ptrCast(slice_lab);\n\n        const white_point_xyz = self.white.toXYZ(1.0);\n\n        const all_zeroes: math.float4 = @splat(0.0);\n        const all_ones: math.float4 = @splat(1.0);\n\n        for (slice_rgba) |*rgba| {\n            const lab_alpha: CIELabAlpha = @bitCast(rgba.*);\n\n            const xyza = lab_alpha.toXYZAlphaPrecomputedWhitePoint(white_point_xyz);\n\n            rgba.* = Colorf32.from.float4(self.xyza_to_rgba.mulVector(xyza.toFloat4()));\n\n            switch (post_conversion_behavior) {\n                .none => {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "sliceFromLabAlphaInPlace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sliceToLabAlphaInPlace from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn sliceToLabAlphaInPlace(self: RgbColorspace, colors: []Colorf32) []CIELabAlpha {\n        const slice_lab: []CIELabAlpha = @ptrCast(colors);\n\n        const white_point_xyz = self.white.toXYZ(1.0);\n\n        for (slice_lab) |*lab_alpha| {\n            const xyza = CIEXYZAlpha.fromFloat4(self.rgba_to_xyza.mulVector(lab_alpha.toFloat4()));\n\n            lab_alpha.* = CIELabAlpha.fromXYZAlphaPrecomputedWhitePoint(xyza, white_point_xyz);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "sliceToLabAlphaInPlace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sliceFromLabAlphaCopy from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn sliceFromLabAlphaCopy(self: RgbColorspace, allocator: std.mem.Allocator, slice_lab: []const CIELabAlpha, post_conversion_behavior: PostConversionBehavior) ![]Colorf32 {\n        const slice_rgba: []Colorf32 = try allocator.alloc(Colorf32, slice_lab.len);\n\n        const white_point_xyz = self.white.toXYZ(1.0);\n\n        const all_zeroes: math.float4 = @splat(0.0);\n        const all_ones: math.float4 = @splat(1.0);\n\n        for (0..slice_lab.len) |index| {\n            const xyza = slice_lab[index].toXYZAlphaPrecomputedWhitePoint(white_point_xyz);\n\n            slice_rgba[index] = Colorf32.from.float4(self.xyza_to_rgba.mulVector(xyza.toFloat4()));\n\n            switch (post_conversion_behavior) {\n                .none => {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "sliceFromLabAlphaCopy",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to sliceToLabAlphaCopy from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn sliceToLabAlphaCopy(self: RgbColorspace, allocator: std.mem.Allocator, colors: []const Colorf32) ![]CIELabAlpha {\n        const slice_lab: []CIELabAlpha = try allocator.alloc(CIELabAlpha, colors.len);\n\n        const white_point_xyz = self.white.toXYZ(1.0);\n\n        for (0..colors.len) |index| {\n            const xyza = CIEXYZAlpha.fromFloat4(self.rgba_to_xyza.mulVector(colors[index].to.float4()));\n\n            slice_lab[index] = CIELabAlpha.fromXYZAlphaPrecomputedWhitePoint(xyza, white_point_xyz);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "sliceToLabAlphaCopy",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to sliceFromLuvAlphaInPlace from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn sliceFromLuvAlphaInPlace(self: RgbColorspace, slice_luv: []CIELuvAlpha, post_conversion_behavior: PostConversionBehavior) []Colorf32 {\n        const slice_rgba: []Colorf32 = @ptrCast(slice_luv);\n\n        const white_point_xyz = self.white.toXYZ(1.0);\n\n        const all_zeroes: math.float4 = @splat(0.0);\n        const all_ones: math.float4 = @splat(1.0);\n\n        for (slice_rgba) |*rgba| {\n            const luv_alpha: CIELuvAlpha = @bitCast(rgba.*);\n\n            const xyza = luv_alpha.toXYZAlphaPrecomputedWhitePoint(white_point_xyz);\n\n            rgba.* = Colorf32.from.float4(self.xyza_to_rgba.mulVector(xyza.toFloat4()));\n\n            switch (post_conversion_behavior) {\n                .none => {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "sliceFromLuvAlphaInPlace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sliceToLuvAlphaInPlace from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn sliceToLuvAlphaInPlace(self: RgbColorspace, colors: []Colorf32) []CIELuvAlpha {\n        const slice_luv: []CIELuvAlpha = @ptrCast(colors);\n\n        const white_point_xyz = self.white.toXYZ(1.0);\n\n        for (slice_luv) |*luv_alpha| {\n            const xyza = CIEXYZAlpha.fromFloat4(self.rgba_to_xyza.mulVector(luv_alpha.toFloat4()));\n\n            luv_alpha.* = CIELuvAlpha.fromXYZAlphaPrecomputedWhitePoint(xyza, white_point_xyz);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "sliceToLuvAlphaInPlace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sliceFromLuvAlphaCopy from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn sliceFromLuvAlphaCopy(self: RgbColorspace, allocator: std.mem.Allocator, slice_luv: []const CIELuvAlpha, post_conversion_behavior: PostConversionBehavior) ![]Colorf32 {\n        const slice_rgba: []Colorf32 = try allocator.alloc(Colorf32, slice_luv.len);\n\n        const white_point_xyz = self.white.toXYZ(1.0);\n\n        const all_zeroes: math.float4 = @splat(0.0);\n        const all_ones: math.float4 = @splat(1.0);\n\n        for (0..slice_luv.len) |index| {\n            const luv_alpha = slice_luv[index];\n\n            const xyza = luv_alpha.toXYZAlphaPrecomputedWhitePoint(white_point_xyz);\n\n            slice_rgba[index] = Colorf32.from.float4(self.xyza_to_rgba.mulVector(xyza.toFloat4()));\n\n            switch (post_conversion_behavior) {\n                .none => {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "sliceFromLuvAlphaCopy",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to sliceToLuvAlphaCopy from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn sliceToLuvAlphaCopy(self: RgbColorspace, allocator: std.mem.Allocator, colors: []const Colorf32) ![]CIELuvAlpha {\n        const slice_luv: []CIELuvAlpha = try allocator.alloc(CIELuvAlpha, colors.len);\n\n        const white_point_xyz = self.white.toXYZ(1.0);\n\n        for (0..colors.len) |index| {\n            const xyza = CIEXYZAlpha.fromFloat4(self.rgba_to_xyza.mulVector(colors[index].to.float4()));\n\n            slice_luv[index] = CIELuvAlpha.fromXYZAlphaPrecomputedWhitePoint(xyza, white_point_xyz);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "sliceToLuvAlphaCopy",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to sliceFromOkLabAlphaInPlace from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn sliceFromOkLabAlphaInPlace(self: RgbColorspace, slice_lab: []OklabAlpha, post_conversion_behavior: PostConversionBehavior) []Colorf32 {\n        const slice_rgba: []Colorf32 = @ptrCast(slice_lab);\n\n        const all_zeroes: math.float4 = @splat(0.0);\n        const all_ones: math.float4 = @splat(1.0);\n\n        for (slice_rgba) |*rgba| {\n            const lab_alpha: OklabAlpha = @bitCast(rgba.*);\n\n            const xyza = lab_alpha.toXYZAlpha();\n\n            rgba.* = Colorf32.from.float4(self.xyza_to_rgba.mulVector(xyza.toFloat4()));\n\n            switch (post_conversion_behavior) {\n                .none => {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "sliceFromOkLabAlphaInPlace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sliceToOklabAlphaInPlace from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn sliceToOklabAlphaInPlace(self: RgbColorspace, colors: []Colorf32) []OklabAlpha {\n        const slice_lab: []OklabAlpha = @ptrCast(colors);\n\n        for (slice_lab) |*lab_alpha| {\n            const xyza = CIEXYZAlpha.fromFloat4(self.rgba_to_xyza.mulVector(lab_alpha.toFloat4()));\n\n            lab_alpha.* = OklabAlpha.fromXYZAlpha(xyza);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "sliceToOklabAlphaInPlace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sliceFromOkLabAlphaCopy from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn sliceFromOkLabAlphaCopy(self: RgbColorspace, allocator: std.mem.Allocator, slice_lab: []const OklabAlpha, post_conversion_behavior: PostConversionBehavior) ![]Colorf32 {\n        const slice_rgba: []Colorf32 = try allocator.alloc(Colorf32, slice_lab.len);\n\n        const all_zeroes: math.float4 = @splat(0.0);\n        const all_ones: math.float4 = @splat(1.0);\n\n        for (0..slice_lab.len) |index| {\n            const lab_alpha: OklabAlpha = slice_lab[index];\n\n            const xyza = lab_alpha.toXYZAlpha();\n\n            slice_rgba[index] = Colorf32.from.float4(self.xyza_to_rgba.mulVector(xyza.toFloat4()));\n\n            switch (post_conversion_behavior) {\n                .none => {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "sliceFromOkLabAlphaCopy",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to sliceToOklabAlphaCopy from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn sliceToOklabAlphaCopy(self: RgbColorspace, allocator: std.mem.Allocator, colors: []const Colorf32) ![]OklabAlpha {\n        const slice_lab: []OklabAlpha = try allocator.alloc(OklabAlpha, colors.len);\n\n        for (0..colors.len) |index| {\n            const xyza = CIEXYZAlpha.fromFloat4(self.rgba_to_xyza.mulVector(colors[index].to.float4()));\n\n            slice_lab[index] = OklabAlpha.fromXYZAlpha(xyza);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "sliceToOklabAlphaCopy",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to convertColor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn convertColor(source: RgbColorspace, target: RgbColorspace, color: Colorf32) Colorf32 {\n        const conversion_matrix = computeConversionMatrix(source, target);\n\n        const color_float4 = color.to.float4();\n        const result = conversion_matrix.mulVector(color_float4);\n\n        return Colorf32.from.float4(result);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "convertColor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to convertColors from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn convertColors(source: RgbColorspace, target: RgbColorspace, colors: []Colorf32) void {\n        const conversion_matrix = computeConversionMatrix(source, target);\n\n        for (colors) |*color| {\n            const color_float4 = color.to.float4();\n            color.* = Colorf32.from.float4(conversion_matrix.mulVector(color_float4));\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "convertColors",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toXYZConversionMatrix from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn toXYZConversionMatrix(self: RgbColorspace) ConversionMatrix {\n        // Adapted from http://docs-hoffmann.de/ciexyz29082000.pdf\n        const D = (self.red.x - self.blue.x) * (self.green.y - self.blue.y) - (self.red.y - self.blue.y) * (self.green.x - self.blue.x);\n        const U = (self.white.x - self.blue.x) * (self.green.y - self.blue.y) - (self.white.y - self.blue.y) * (self.green.x - self.blue.x);\n        const V = (self.red.x - self.blue.x) * (self.white.y - self.blue.y) - (self.red.y - self.blue.y) * (self.white.x - self.blue.x);\n\n        const u = U / D;\n        const v = V / D;\n        const w = 1.0 - u - v;\n\n        return ConversionMatrix.fromArray(.{\n            u * (self.red.x / self.white.y),   v * (self.green.x / self.white.y),   w * (self.blue.x / self.white.y),   0.0,\n            u * (self.red.y / self.white.y),   v * (self.green.y / self.white.y),   w * (self.blue.y / self.white.y),   0.0,\n            u * (self.red.z() / self.white.y), v * (self.green.z() / self.white.y), w * (self.blue.z() / self.white.y), 0.0,\n            0.0,                               0.0,                                 0.0,                                1.0,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toXYZConversionMatrix",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to computeConversionMatrix from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn computeConversionMatrix(source: RgbColorspace, target: RgbColorspace) math.float4x4 {\n        const source_to_xyz_matrix = source.rgba_to_xyza;\n        const target_to_rgb_matrix = target.xyza_to_rgba;\n\n        if (source.white.equals(target.white)) {\n            return target_to_rgb_matrix.mul(source_to_xyz_matrix);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "computeConversionMatrix",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to gammaNoTransfer from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn gammaNoTransfer(value: f32) f32 {\n        return value;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "gammaNoTransfer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applyGamma from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn applyGamma(value: f32, gamma: f32) f32 {\n    return std.math.pow(f32, value, 1.0 / gamma);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "applyGamma",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to removeGamma from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "fn removeGamma(value: f32, gamma: f32) f32 {\n    return std.math.pow(f32, value, gamma);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "removeGamma",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to NonLinearGammaTransferFunctions from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn NonLinearGammaTransferFunctions(comptime params: GammaFunctionsParameters) type {\n    return struct {\n        const alpha_minus_1 = params.alpha - 1.0;\n\n        pub fn toGamma(value: f32) f32 {\n            if (value <= params.beta) {\n                return value * params.delta;\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "NonLinearGammaTransferFunctions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toGammaFast from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toGammaFast(value: f32) f32 {\n            return applyGamma(value, params.display_gamma);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toGammaFast",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLinear from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLinear(value: f32) f32 {\n            if (value <= params.transition_point) {\n                return value / params.delta;\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLinear",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLinearFast from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLinearFast(value: f32) f32 {\n            return removeGamma(value, params.display_gamma);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLinearFast",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to CurveGammaTransferFunctions from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn CurveGammaTransferFunctions(comptime gamma: f32) type {\n    return struct {\n        pub fn toGamma(value: f32) f32 {\n            return applyGamma(value, gamma);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "CurveGammaTransferFunctions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toGammaFast from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toGammaFast(value: f32) f32 {\n            return applyGamma(value, gamma);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toGammaFast",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLinear from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLinear(value: f32) f32 {\n            return removeGamma(value, gamma);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLinear",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toLinearFast from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub fn toLinearFast(value: f32) f32 {\n            return removeGamma(value, gamma);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "function",
      "name": "toLinearFast",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to PixelStorageIterator from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub const PixelStorageIterator = struct {\n    pixels: *const PixelStorage = undefined,\n    current_index: usize = 0,\n    end: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(pixels: *const PixelStorage) Self {\n        return Self{\n            .pixels = pixels,\n            .end = pixels.len(),\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "struct",
      "name": "PixelStorageIterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Hsl from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub const Hsl = struct {\n    hue: f32 = 0.0, // angle in degrees (0-360)\n    saturation: f32 = 0.0, // range from 0 to 1\n    luminance: f32 = 0.0, // range from 0 to 1\n\n    pub fn fromRgb(rgb: Colorf32) Hsl {\n        const maximum = @max(rgb.r, @max(rgb.g, rgb.b)); // V\n        const minimum = @min(rgb.r, @min(rgb.g, rgb.b)); // V - C\n        const range = maximum - minimum; // C := 2(V - L)\n        const luminance = (maximum + minimum) / 2.0; // V - C/2\n\n        var hue: f32 = 0.0;\n\n        if (range == 0.0) {\n            hue = 0.0;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "struct",
      "name": "Hsl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Hsv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub const Hsv = struct {\n    hue: f32 = 0.0, // angle in degrees(0-360)\n    saturation: f32 = 0.0, // range from 0 to 1\n    value: f32 = 0.0, // range from 0 to 1\n\n    pub fn fromRgb(rgb: Colorf32) Hsv {\n        const maximum = @max(rgb.r, @max(rgb.g, rgb.b)); // V\n        const minimum = @min(rgb.r, @min(rgb.g, rgb.b)); // V - C\n        const range = maximum - minimum; // C := 2(V - L)\n\n        var hue: f32 = 0.0;\n\n        if (range == 0.0) {\n            hue = 0.0;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "struct",
      "name": "Hsv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to CIEConstants from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub const CIEConstants = struct {\n    const epsilon: f32 = 216.0 / 24389.0;\n    const kappa: f32 = 24389.0 / 27.0;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "struct",
      "name": "CIEConstants",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Line from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const Line = struct {\n        a: f32 = 0.0,\n        b: f32 = 0.0,\n\n        pub fn intersect(left: Line, right: Line) f32 {\n            return (left.b - right.b) / (right.a - left.a);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "struct",
      "name": "Line",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to CIExyY from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub const CIExyY = struct {\n    x: f32 = 0.0,\n    y: f32 = 0.0,\n\n    pub inline fn z(self: CIExyY) f32 {\n        return 1.0 - self.x - self.y;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "struct",
      "name": "CIExyY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to RgbColorspace from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub const RgbColorspace = struct {\n    red: CIExyY,\n    green: CIExyY,\n    blue: CIExyY,\n    white: CIExyY,\n    rgba_to_xyza: math.float4x4,\n    xyza_to_rgba: math.float4x4,\n    to_gamma: *const fn (f32) f32,\n    to_gamma_fast: *const fn (f32) f32,\n    to_linear: *const fn (f32) f32,\n    to_linear_fast: *const fn (f32) f32,\n\n    pub const PostConversionBehavior = enum {\n        none, // Keep value as-is\n        clamp, // Clamp values inside of the color in case of color being outside the colorspace\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "struct",
      "name": "RgbColorspace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to InitArgs from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub const InitArgs = struct {\n        red: CIExyY = .{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "struct",
      "name": "InitArgs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to GammaFunctionsParameters from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub const GammaFunctionsParameters = struct {\n    alpha: f32 = 0.0,\n    beta: f32 = 0.0,\n    delta: f32 = 0.0,\n    gamma: f32 = 1.0,\n    transition_point: f32 = 0.0,\n    display_gamma: f32 = 1.0,\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "struct",
      "name": "GammaFunctionsParameters",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to WhitePoints from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub const WhitePoints = struct {\n    pub const A = CIExyY{ .x = 0.44758, .y = 0.40745 }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "struct",
      "name": "WhitePoints",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to DCIP3 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "pub const DCIP3 = struct {\n    // Display P3 usee the same transfer function as sRGB\n    pub const Display = RgbColorspace.init(.{\n        .red = .{ .x = 0.680, .y = 0.320 }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "struct",
      "name": "DCIP3",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to in_max from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const in_max: T = @floatFromInt(std.math.maxInt(ValueT));",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "in_max",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to RedT from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const RedT: type = @FieldType(T, \"r\");",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "RedT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to GreenT from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const GreenT: type = @FieldType(T, \"g\");",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "GreenT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to BlueT from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const BlueT: type = @FieldType(T, \"b\");",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "BlueT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to AlphaT from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const AlphaT: type =\n        if (has_alpha)\n            @FieldType(T, \"a\")\n        else\n            void;",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "AlphaT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to scaleAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const scaleAlpha: if (has_alpha) fn (anytype) AlphaT else void =\n        if (has_alpha)\n            ScaleValue(AlphaT)\n        else {};",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "scaleAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to scaleAlpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const scaleAlpha: if (has_alpha) fn (anytype) AlphaT else void =\n    //     if (has_alpha)\n    //         ScaleValue(AlphaT)\n    //     else {};",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "scaleAlpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const ptr: usize = @intFromPtr(to);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to off from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const off: usize = @bitOffsetOf(T, \"to\");",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "off",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to epsilon from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const epsilon: f32 = 216.0 / 24389.0;",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "epsilon",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to kappa from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const kappa: f32 = 24389.0 / 27.0;",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "kappa",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice_rgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const slice_rgba: []Colorf32 = @ptrCast(slice_xyza);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "slice_rgba",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice_xyza from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const slice_xyza: []CIEXYZAlpha = @ptrCast(colors);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "slice_xyza",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice_rgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const slice_rgba: []Colorf32 = try allocator.alloc(Colorf32, slice_xyza.len);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "slice_rgba",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice_xyza from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const slice_xyza: []CIEXYZAlpha = try allocator.alloc(CIEXYZAlpha, colors.len);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "slice_xyza",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice_rgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const slice_rgba: []Colorf32 = @ptrCast(slice_lab);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "slice_rgba",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to all_zeroes from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const all_zeroes: math.float4 = @splat(0.0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "all_zeroes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to all_ones from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const all_ones: math.float4 = @splat(1.0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "all_ones",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to lab_alpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const lab_alpha: CIELabAlpha = @bitCast(rgba.*);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "lab_alpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice_lab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const slice_lab: []CIELabAlpha = @ptrCast(colors);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "slice_lab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice_rgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const slice_rgba: []Colorf32 = try allocator.alloc(Colorf32, slice_lab.len);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "slice_rgba",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to all_zeroes from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const all_zeroes: math.float4 = @splat(0.0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "all_zeroes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to all_ones from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const all_ones: math.float4 = @splat(1.0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "all_ones",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice_lab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const slice_lab: []CIELabAlpha = try allocator.alloc(CIELabAlpha, colors.len);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "slice_lab",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice_rgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const slice_rgba: []Colorf32 = @ptrCast(slice_luv);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "slice_rgba",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to all_zeroes from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const all_zeroes: math.float4 = @splat(0.0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "all_zeroes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to all_ones from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const all_ones: math.float4 = @splat(1.0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "all_ones",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to luv_alpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const luv_alpha: CIELuvAlpha = @bitCast(rgba.*);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "luv_alpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice_luv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const slice_luv: []CIELuvAlpha = @ptrCast(colors);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "slice_luv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice_rgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const slice_rgba: []Colorf32 = try allocator.alloc(Colorf32, slice_luv.len);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "slice_rgba",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to all_zeroes from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const all_zeroes: math.float4 = @splat(0.0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "all_zeroes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to all_ones from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const all_ones: math.float4 = @splat(1.0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "all_ones",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice_luv from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const slice_luv: []CIELuvAlpha = try allocator.alloc(CIELuvAlpha, colors.len);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "slice_luv",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice_rgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const slice_rgba: []Colorf32 = @ptrCast(slice_lab);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "slice_rgba",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to all_zeroes from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const all_zeroes: math.float4 = @splat(0.0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "all_zeroes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to all_ones from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const all_ones: math.float4 = @splat(1.0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "all_ones",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to lab_alpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const lab_alpha: OklabAlpha = @bitCast(rgba.*);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "lab_alpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice_lab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const slice_lab: []OklabAlpha = @ptrCast(colors);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "slice_lab",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice_rgba from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const slice_rgba: []Colorf32 = try allocator.alloc(Colorf32, slice_lab.len);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "slice_rgba",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to all_zeroes from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const all_zeroes: math.float4 = @splat(0.0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "all_zeroes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to all_ones from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const all_ones: math.float4 = @splat(1.0);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "all_ones",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to lab_alpha from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const lab_alpha: OklabAlpha = slice_lab[index];",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "lab_alpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice_lab from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const slice_lab: []OklabAlpha = try allocator.alloc(OklabAlpha, colors.len);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "slice_lab",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to source_white_float4 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const source_white_float4: math.float4 = .{ source_white_xyz.x, source_white_xyz.y, source_white_xyz.z, 1.0 };",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "source_white_float4",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to target_white_float4 from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/color.zig",
    "response": "const target_white_float4: math.float4 = .{ target_white_xyz.x, target_white_xyz.y, target_white_xyz.z, 1.0 };",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/color.zig",
      "type": "const",
      "name": "target_white_float4",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/ccitt.zig",
    "response": "pub fn init(width: usize, num_rows: usize, white_value: u1) !Decoder {\n        return .{ .width = width, .num_rows = num_rows, .white_value = white_value }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/ccitt.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/ccitt.zig",
    "response": "pub fn decode(self: *Decoder, reader: *std.Io.Reader, writer: *std.Io.Writer) !void {\n        var bit_reader: io.BitReader(.big) = .{\n            .reader = reader,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/ccitt.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_run_length from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/ccitt.zig",
    "response": "pub fn get_run_length(self: *Decoder, code: u13, length: u8) ?u16 {\n        const rle = self.get_make_up_code(code, length);\n\n        if (rle == null) {\n            return self.get_terminating_code(code, length);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/ccitt.zig",
      "type": "function",
      "name": "get_run_length",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_make_up_code from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/ccitt.zig",
    "response": "pub fn get_make_up_code(self: *Decoder, code: u13, length: u8) ?u16 {\n        for (additional_make_up_codes) |makeup| {\n            if (makeup.code == code and makeup.code_length == length)\n                return makeup.run_length;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/ccitt.zig",
      "type": "function",
      "name": "get_make_up_code",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_terminating_code from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/ccitt.zig",
    "response": "pub fn get_terminating_code(self: *Decoder, code: u13, length: u8) ?u16 {\n        const terminating_codes = if (self.current_color == .white) &white_terminating_codes else &black_terminating_codes;\n\n        for (terminating_codes) |makeup| {\n            if (makeup.code == code and makeup.code_length == length) {\n                self.should_reverse = true;\n                return makeup.run_length;\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/ccitt.zig",
      "type": "function",
      "name": "get_terminating_code",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Code from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/ccitt.zig",
    "response": "const Code = struct {\n    run_length: u16,\n    code: u16,\n    code_length: u8,\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/ccitt.zig",
      "type": "struct",
      "name": "Code",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Decoder from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/ccitt.zig",
    "response": "pub const Decoder = struct {\n    current_color: Color = .white,\n    should_reverse: bool = false,\n    width: usize = 0,\n    num_rows: usize = 0,\n    white_value: u1 = 0,\n\n    pub fn init(width: usize, num_rows: usize, white_value: u1) !Decoder {\n        return .{ .width = width, .num_rows = num_rows, .white_value = white_value }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/ccitt.zig",
      "type": "struct",
      "name": "Decoder",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to bits_remainder from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/ccitt.zig",
    "response": "const bits_remainder: u16 = decoded_bits % 8;",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/ccitt.zig",
      "type": "const",
      "name": "bits_remainder",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn get(level: Level) LevelArgs {\n        // zig fmt: off\n        return switch (level) {\n            .fast,    .level_4 => .{ .good =  4, .lazy =   4, .nice =  16, .chain =   16 }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "get",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to compress from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn compress(comptime container: Container, reader: *std.Io.Writer, writer: *std.Io.Writer, buffer: []u8, options: Options) !void {\n    var c = try compressor(container, writer, buffer, options);\n    try c.compress(reader);\n    try c.finish();\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "compress",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to compressor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn compressor(comptime container: Container, writer: *std.Io.Writer, buffer: []u8, options: Options) !Compressor(container) {\n    return try Compressor(container).init(writer, buffer, options);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "compressor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to Compressor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn Compressor(comptime container: Container) type {\n    return Deflate(container);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "Compressor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to Deflate from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn Deflate(comptime container: Container) type {\n    return struct {\n        lookup: Lookup = .{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "Deflate",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn init(wrt: *std.Io.Writer, buffer: []u8, options: Options) !Self {\n            const self = Self{\n                .source_writer = wrt,\n                .block_writer = BlockWriter.init(wrt),\n                .level = LevelArgs.get(options.level),\n                .writer = .{\n                    .buffer = buffer,\n                    .vtable = &std.Io.Writer.VTable{\n                        .drain = drain,\n                        .flush = flush,\n                    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to tokenize from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn tokenize(self: *Self, flush_opt: FlushOption) !void {\n            // flush - process all data from window\n            const should_flush = (flush_opt != .none);\n\n            // While there is data in active lookahead buffer.\n            while (self.win.activeLookahead(should_flush)) |lh| {\n                var step: u16 = 1; // 1 in the case of literal, match length otherwise\n                const pos: u16 = self.win.pos();\n                const literal = lh[0]; // literal at current position\n                const min_len: u16 = if (self.prev_match) |m| m.length() else 0;\n\n                // Try to find match at least min_len long.\n                if (self.findMatch(pos, lh, min_len)) |match| {\n                    // Found better match than previous.\n                    try self.addPrevLiteral();\n\n                    // Is found match length good enough?\n                    if (match.length() >= self.level.lazy) {\n                        // Don't try to lazy find better match, use this.\n                        step = try self.addMatch(match);\n                    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "tokenize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to windowAdvance from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn windowAdvance(self: *Self, step: u16, lh: []const u8, pos: u16) void {\n            // current position is already added in findMatch\n            self.lookup.bulkAdd(lh[1..], step - 1, pos + 1);\n            self.win.advance(step);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "windowAdvance",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addPrevLiteral from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn addPrevLiteral(self: *Self) !void {\n            if (self.prev_literal) |l| try self.addToken(Token.initLiteral(l));\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "addPrevLiteral",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addMatch from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn addMatch(self: *Self, m: Token) !u16 {\n            try self.addToken(m);\n            self.prev_literal = null;\n            self.prev_match = null;\n            return m.length();\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "addMatch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addToken from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn addToken(self: *Self, token: Token) !void {\n            self.tokens.add(token);\n            if (self.tokens.full()) try self.flushTokens(.none);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "addToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findMatch from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn findMatch(self: *Self, pos: u16, lh: []const u8, min_len: u16) ?Token {\n            var len: u16 = min_len;\n            // Previous location with the same hash (same 4 bytes).\n            var prev_pos = self.lookup.add(lh, pos);\n            // Last found match.\n            var match: ?Token = null;\n\n            // How much back-references to try, performance knob.\n            var chain: usize = self.level.chain;\n            if (len >= self.level.good) {\n                // If we've got a match that's good enough, only look in 1/4 the chain.\n                chain >>= 2;\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "findMatch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to flushTokens from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn flushTokens(self: *Self, flush_opt: FlushOption) !void {\n            // Pass tokens to the token writer\n            try self.block_writer.write(self.tokens.tokens(), flush_opt == .final, self.win.tokensBuffer());\n            // Stored block ensures byte alignment.\n            // It has 3 bits (final, block_type) and then padding until byte boundary.\n            // After that everything is aligned to the boundary in the stored block.\n            // Empty stored block is Ob000 + (0-7) bits of padding + 0x00 0x00 0xFF 0xFF.\n            // Last 4 bytes are byte aligned.\n            if (flush_opt == .flush) {\n                try self.block_writer.storedBlock(\"\", false);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "flushTokens",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to slide from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn slide(self: *Self) void {\n            const n = self.win.slide();\n            self.lookup.slide(n);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "slide",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to compress from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn compress(self: *Self, reader: *std.Io.Reader) !void {\n            while (true) {\n                // Fill window from reader\n                const buf = self.win.writable();\n                if (buf.len == 0) {\n                    try self.tokenize(.none);\n                    self.slide();\n                    continue;\n                }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "compress",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to finish from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn finish(self: *Self) !void {\n            try self.tokenize(.final);\n            try container.writeFooter(&self.hasher, self.source_writer);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "finish",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to setWriter from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn setWriter(self: *Self, new_writer: *std.Io.Writer) void {\n            self.block_writer.setWriter(new_writer);\n            self.source_writer = new_writer;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "setWriter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn write(self: *Self, input: []const u8) !usize {\n            var fixed_reader = std.Io.Reader.fixed(input);\n            try self.compress(&fixed_reader);\n            return input.len;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "write",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to drain from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn drain(w: *std.Io.Writer, data: []const []const u8, splat: usize) std.Io.Writer.Error!usize {\n            const self: *Self = @alignCast(@fieldParentPtr(\"writer\", w));\n\n            if (data.len == 0) {\n                return 0;\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "drain",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to flush from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn flush(w: *std.Io.Writer) std.Io.Writer.Error!void {\n            const self: *Self = @alignCast(@fieldParentPtr(\"writer\", w));\n\n            try w.defaultFlush();\n\n            self.finish() catch return std.Io.Writer.Error.WriteFailed;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "flush",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to add from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn add(self: *Tokens, t: Token) void {\n        self.list[self.pos] = t;\n        self.pos += 1;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "add",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to full from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn full(self: *Tokens) bool {\n        return self.pos == self.list.len;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "full",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reset from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn reset(self: *Tokens) void {\n        self.pos = 0;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "reset",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tokens from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn tokens(self: *Tokens) []const Token {\n        return self.list[0..self.pos];\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "tokens",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to compress from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn compress(comptime container: Container, reader: *std.Io.Reader, writer: *std.Io.Writer) !void {\n        var c = try huffman.compressor(container, writer);\n        try c.compress(reader);\n        try c.finish();\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "compress",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to Compressor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn Compressor(comptime container: Container) type {\n        return SimpleCompressor(.huffman, container);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "Compressor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to compressor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn compressor(comptime container: Container, writer: *std.Io.Writer) !huffman.Compressor(container) {\n        return try huffman.Compressor(container).init(writer);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "compressor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to compress from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn compress(comptime container: Container, reader: *std.Io.Reader, writer: *std.Io.Writer) !void {\n        var c = try store.compressor(container, writer);\n        try c.compress(reader);\n        try c.finish();\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "compress",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to Compressor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn Compressor(comptime container: Container) type {\n        return SimpleCompressor(.store, container);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "Compressor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to compressor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn compressor(comptime container: Container, writer: *std.Io.Writer) !store.Compressor(container) {\n        return try store.Compressor(container).init(writer);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "compressor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to simpleCompressor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn simpleCompressor(\n    comptime kind: SimpleCompressorKind,\n    comptime container: Container,\n    writer: *std.Io.Writer,\n) !SimpleCompressor(kind, container) {\n    return try SimpleCompressor(kind, container).init(writer);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "simpleCompressor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to SimpleCompressor from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn SimpleCompressor(\n    comptime kind: SimpleCompressorKind,\n    comptime container: Container,\n) type {\n    return struct {\n        buffer: [65535]u8 = undefined, // because store blocks are limited to 65535 bytes\n        wp: usize = 0,\n\n        wrt: *std.Io.Writer,\n        block_writer: BlockWriter,\n        hasher: container.Hasher() = .{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "SimpleCompressor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn init(wrt: *std.Io.Writer) !Self {\n            const self = Self{\n                .wrt = wrt,\n                .block_writer = BlockWriter.init(wrt),\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to flush from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn flush(self: *Self) !void {\n            try self.flushBuffer(false);\n            try self.block_writer.storedBlock(\"\", false);\n            try self.block_writer.flush();\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "flush",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to finish from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn finish(self: *Self) !void {\n            try self.flushBuffer(true);\n            try self.block_writer.flush();\n            try container.writeFooter(&self.hasher, self.wrt);\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "finish",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to flushBuffer from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "fn flushBuffer(self: *Self, final: bool) !void {\n            const buf = self.buffer[0..self.wp];\n            switch (kind) {\n                .huffman => try self.block_writer.huffmanBlock(buf, final),\n                .store => try self.block_writer.storedBlock(buf, final),\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "flushBuffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to compress from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn compress(self: *Self, reader: *std.Io.Reader) !void {\n            while (true) {\n                // read from rdr into buffer\n                const buf = self.buffer[self.wp..];\n                if (buf.len == 0) {\n                    try self.flushBuffer(false);\n                    continue;\n                }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "compress",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub fn write(self: *Self, input: []const u8) !usize {\n            var fixed_reader = std.Io.Reader.fixed(input);\n            try self.compress(&fixed_reader);\n            return input.len;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "function",
      "name": "write",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Options from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub const Options = struct {\n    level: Level = .default,\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "struct",
      "name": "Options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to LevelArgs from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "const LevelArgs = struct {\n    good: u16, // Do less lookups if we already have match of this length.\n    nice: u16, // Stop looking for better match if we found match with at least this length.\n    lazy: u16, // Don't do lazy match find if got match with at least this length.\n    chain: u16, // How many lookups for previous match to perform.\n\n    pub fn get(level: Level) LevelArgs {\n        // zig fmt: off\n        return switch (level) {\n            .fast,    .level_4 => .{ .good =  4, .lazy =   4, .nice =  16, .chain =   16 }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "struct",
      "name": "LevelArgs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Tokens from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "const Tokens = struct {\n    list: [consts.deflate.tokens]Token = undefined,\n    pos: usize = 0,\n\n    fn add(self: *Tokens, t: Token) void {\n        self.list[self.pos] = t;\n        self.pos += 1;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "struct",
      "name": "Tokens",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to huffman from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub const huffman = struct {\n    pub fn compress(comptime container: Container, reader: *std.Io.Reader, writer: *std.Io.Writer) !void {\n        var c = try huffman.compressor(container, writer);\n        try c.compress(reader);\n        try c.finish();\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "struct",
      "name": "huffman",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to store from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "pub const store = struct {\n    pub fn compress(comptime container: Container, reader: *std.Io.Reader, writer: *std.Io.Writer) !void {\n        var c = try store.compressor(container, writer);\n        try c.compress(reader);\n        try c.finish();\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "struct",
      "name": "store",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to pos from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "const pos: u16 = self.win.pos();",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "const",
      "name": "pos",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to min_len from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "const min_len: u16 = if (self.prev_match) |m| m.length() else 0;",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "const",
      "name": "min_len",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "const self: *Self = @alignCast(@fieldParentPtr(\"writer\", w));",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate.zig",
    "response": "const self: *Self = @alignCast(@fieldParentPtr(\"writer\", w));",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BitWriter.zig",
    "response": "pub fn init(writer: *std.Io.Writer) BitWriter {\n    return .{ .inner_writer = writer }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BitWriter.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to setWriter from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BitWriter.zig",
    "response": "pub fn setWriter(self: *BitWriter, new_writer: *std.Io.Writer) void {\n    //assert(self.bits == 0 and self.nbits == 0 and self.nbytes == 0);\n    self.inner_writer = new_writer;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BitWriter.zig",
      "type": "function",
      "name": "setWriter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to flush from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BitWriter.zig",
    "response": "pub fn flush(self: *BitWriter) Error!void {\n    var n = self.nbytes;\n    while (self.nbits != 0) {\n        self.bytes[n] = @as(u8, @truncate(self.bits));\n        self.bits >>= 8;\n        if (self.nbits > 8) { // Avoid underflow\n            self.nbits -= 8;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BitWriter.zig",
      "type": "function",
      "name": "flush",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeBits from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BitWriter.zig",
    "response": "pub fn writeBits(self: *BitWriter, b: u32, nb: u32) Error!void {\n    self.bits |= @as(u64, @intCast(b)) << @as(u6, @intCast(self.nbits));\n    self.nbits += nb;\n    if (self.nbits < 48)\n        return;\n\n    var n = self.nbytes;\n    std.mem.writeInt(u64, self.bytes[n..][0..8], self.bits, .little);\n    n += 6;\n    if (n >= buffer_flush_size) {\n        _ = try self.inner_writer.write(self.bytes[0..n]);\n        n = 0;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BitWriter.zig",
      "type": "function",
      "name": "writeBits",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeBytes from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BitWriter.zig",
    "response": "pub fn writeBytes(self: *BitWriter, bytes: []const u8) Error!void {\n    var n = self.nbytes;\n    if (self.nbits & 7 != 0) {\n        return error.UnfinishedBits;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BitWriter.zig",
      "type": "function",
      "name": "writeBytes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "pub fn init(writer: *std.Io.Writer) BlockWriter {\n    return .{\n        .bit_writer = BitWriter.init(writer),\n        .fixed_literal_encoding = hc.fixedLiteralEncoder(),\n        .fixed_distance_encoding = hc.fixedDistanceEncoder(),\n        .huff_distance = hc.huffmanDistanceEncoder(),\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to flush from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "pub fn flush(self: *BlockWriter) Error!void {\n    try self.bit_writer.flush();\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "flush",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to setWriter from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "pub fn setWriter(self: *BlockWriter, new_writer: *std.Io.Writer) void {\n    self.bit_writer.setWriter(new_writer);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "setWriter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeCode from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "fn writeCode(self: *BlockWriter, c: hc.HuffCode) Error!void {\n    try self.bit_writer.writeBits(c.code, c.len);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "writeCode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateCodegen from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "fn generateCodegen(\n    self: *BlockWriter,\n    num_literals: u32,\n    num_distances: u32,\n    lit_enc: *hc.LiteralEncoder,\n    dist_enc: *hc.DistanceEncoder,\n) void {\n    for (self.codegen_freq, 0..) |_, i| {\n        self.codegen_freq[i] = 0;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "generateCodegen",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dynamicSize from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "fn dynamicSize(\n    self: *BlockWriter,\n    lit_enc: *hc.LiteralEncoder, // literal encoder\n    dist_enc: *hc.DistanceEncoder, // distance encoder\n    extra_bits: u32,\n) DynamicSize {\n    var num_codegens = self.codegen_freq.len;\n    while (num_codegens > 4 and self.codegen_freq[codegen_order[num_codegens - 1]] == 0) {\n        num_codegens -= 1;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "dynamicSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fixedSize from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "fn fixedSize(self: *BlockWriter, extra_bits: u32) u32 {\n    return 3 +\n        self.fixed_literal_encoding.bitLength(&self.literal_freq) +\n        self.fixed_distance_encoding.bitLength(&self.distance_freq) +\n        extra_bits;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "fixedSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to storedSizeFits from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "fn storedSizeFits(in: ?[]const u8) StoredSize {\n    if (in == null) {\n        return .{ .size = 0, .storable = false }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "storedSizeFits",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dynamicHeader from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "fn dynamicHeader(\n    self: *BlockWriter,\n    num_literals: u32,\n    num_distances: u32,\n    num_codegens: u32,\n    eof: bool,\n) Error!void {\n    const first_bits: u32 = if (eof) 5 else 4;\n    try self.bit_writer.writeBits(first_bits, 3);\n    try self.bit_writer.writeBits(num_literals - 257, 5);\n    try self.bit_writer.writeBits(num_distances - 1, 5);\n    try self.bit_writer.writeBits(num_codegens - 4, 4);\n\n    var i: u32 = 0;\n    while (i < num_codegens) : (i += 1) {\n        const value = self.codegen_encoding.codes[codegen_order[i]].len;\n        try self.bit_writer.writeBits(value, 3);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "dynamicHeader",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to storedHeader from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "fn storedHeader(self: *BlockWriter, length: usize, eof: bool) Error!void {\n    assert(length <= 65535);\n    const flag: u32 = if (eof) 1 else 0;\n    try self.bit_writer.writeBits(flag, 3);\n    try self.flush();\n    const l: u16 = @intCast(length);\n    try self.bit_writer.writeBits(l, 16);\n    try self.bit_writer.writeBits(~l, 16);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "storedHeader",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fixedHeader from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "fn fixedHeader(self: *BlockWriter, eof: bool) Error!void {\n    // Indicate that we are a fixed Huffman block\n    var value: u32 = 2;\n    if (eof) {\n        value = 3;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "fixedHeader",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "pub fn write(self: *BlockWriter, tokens: []const Token, eof: bool, input: ?[]const u8) Error!void {\n    const lit_and_dist = self.indexTokens(tokens);\n    const num_literals = lit_and_dist.num_literals;\n    const num_distances = lit_and_dist.num_distances;\n\n    var extra_bits: u32 = 0;\n    const ret = storedSizeFits(input);\n    const stored_size = ret.size;\n    const storable = ret.storable;\n\n    if (storable) {\n        // We only bother calculating the costs of the extra bits required by\n        // the length of distance fields (which will be the same for both fixed\n        // and dynamic encoding), if we need to compare those two encodings\n        // against stored encoding.\n        var length_code: u16 = Token.length_codes_start + 8;\n        while (length_code < num_literals) : (length_code += 1) {\n            // First eight length codes have extra size = 0.\n            extra_bits += @as(u32, @intCast(self.literal_freq[length_code])) *\n                @as(u32, @intCast(Token.lengthExtraBits(length_code)));\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "write",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to storedBlock from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "pub fn storedBlock(self: *BlockWriter, input: []const u8, eof: bool) Error!void {\n    try self.storedHeader(input.len, eof);\n    try self.bit_writer.writeBytes(input);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "storedBlock",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dynamicBlock from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "fn dynamicBlock(\n    self: *BlockWriter,\n    tokens: []const Token,\n    eof: bool,\n    input: ?[]const u8,\n) Error!void {\n    const total_tokens = self.indexTokens(tokens);\n    const num_literals = total_tokens.num_literals;\n    const num_distances = total_tokens.num_distances;\n\n    // Generate codegen and codegenFrequencies, which indicates how to encode\n    // the literal_encoding and the distance_encoding.\n    self.generateCodegen(\n        num_literals,\n        num_distances,\n        &self.literal_encoding,\n        &self.distance_encoding,\n    );\n    self.codegen_encoding.generate(self.codegen_freq[0..], 7);\n    const dynamic_size = self.dynamicSize(&self.literal_encoding, &self.distance_encoding, 0);\n    const size = dynamic_size.size;\n    const num_codegens = dynamic_size.num_codegens;\n\n    // Store bytes, if we don't get a reasonable improvement.\n\n    const stored_size = storedSizeFits(input);\n    const ssize = stored_size.size;\n    const storable = stored_size.storable;\n    if (storable and ssize < (size + (size >> 4))) {\n        try self.storedBlock(input.?, eof);\n        return;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "dynamicBlock",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to indexTokens from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "fn indexTokens(self: *BlockWriter, tokens: []const Token) TotalIndexedTokens {\n    var num_literals: u32 = 0;\n    var num_distances: u32 = 0;\n\n    for (self.literal_freq, 0..) |_, i| {\n        self.literal_freq[i] = 0;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "indexTokens",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeTokens from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "fn writeTokens(\n    self: *BlockWriter,\n    tokens: []const Token,\n    le_codes: []hc.HuffCode,\n    oe_codes: []hc.HuffCode,\n) Error!void {\n    for (tokens) |t| {\n        if (t.kind == Token.Kind.literal) {\n            try self.writeCode(le_codes[t.literal()]);\n            continue;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "writeTokens",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to huffmanBlock from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "pub fn huffmanBlock(self: *BlockWriter, input: []const u8, eof: bool) Error!void {\n    // Add everything as literals\n    histogram(input, &self.literal_freq);\n\n    self.literal_freq[consts.end_block_marker] = 1;\n\n    const num_literals = consts.end_block_marker + 1;\n    self.distance_freq[0] = 1;\n    const num_distances = 1;\n\n    self.literal_encoding.generate(&self.literal_freq, 15);\n\n    // Figure out smallest code.\n    // Always use dynamic Huffman or Store\n    var num_codegens: u32 = 0;\n\n    // Generate codegen and codegenFrequencies, which indicates how to encode\n    // the literal_encoding and the distance_encoding.\n    self.generateCodegen(\n        num_literals,\n        num_distances,\n        &self.literal_encoding,\n        &self.huff_distance,\n    );\n    self.codegen_encoding.generate(self.codegen_freq[0..], 7);\n    const dynamic_size = self.dynamicSize(&self.literal_encoding, &self.huff_distance, 0);\n    const size = dynamic_size.size;\n    num_codegens = dynamic_size.num_codegens;\n\n    // Store bytes, if we don't get a reasonable improvement.\n    const stored_size_ret = storedSizeFits(input);\n    const ssize = stored_size_ret.size;\n    const storable = stored_size_ret.storable;\n\n    if (storable and ssize < (size + (size >> 4))) {\n        try self.storedBlock(input, eof);\n        return;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "huffmanBlock",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to histogram from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "fn histogram(b: []const u8, h: *[286]u16) void {\n    // Clear histogram\n    for (h, 0..) |_, i| {\n        h[i] = 0;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "function",
      "name": "histogram",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to DynamicSize from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "const DynamicSize = struct {\n    size: u32,\n    num_codegens: u32,\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "struct",
      "name": "DynamicSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to StoredSize from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "const StoredSize = struct {\n    size: u32,\n    storable: bool,\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "struct",
      "name": "StoredSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to TotalIndexedTokens from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "const TotalIndexedTokens = struct {\n    num_literals: u32,\n    num_distances: u32,\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "struct",
      "name": "TotalIndexedTokens",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to first_bits from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "const first_bits: u32 = if (eof) 5 else 4;",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "const",
      "name": "first_bits",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to code_word from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "const code_word: u32 = @as(u32, @intCast(self.codegen[i]));",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "const",
      "name": "code_word",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to flag from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "const flag: u32 = if (eof) 1 else 0;",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "const",
      "name": "flag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to l from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/BlockWriter.zig",
    "response": "const l: u16 = @intCast(length);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/BlockWriter.zig",
      "type": "const",
      "name": "l",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to add from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Lookup.zig",
    "response": "pub fn add(self: *Self, data: []const u8, pos: u16) u16 {\n    if (data.len < 4) return 0;\n    const h = hash(data[0..4]);\n    return self.set(h, pos);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Lookup.zig",
      "type": "function",
      "name": "add",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to prev from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Lookup.zig",
    "response": "pub fn prev(self: *Self, pos: u16) u16 {\n    return self.chain[pos];\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Lookup.zig",
      "type": "function",
      "name": "prev",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to set from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Lookup.zig",
    "response": "fn set(self: *Self, h: u32, pos: u16) u16 {\n    const p = self.head[h];\n    self.head[h] = pos;\n    self.chain[pos] = p;\n    return p;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Lookup.zig",
      "type": "function",
      "name": "set",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to slide from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Lookup.zig",
    "response": "pub fn slide(self: *Self, n: u16) void {\n    for (&self.head) |*v| {\n        v.* -|= n;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Lookup.zig",
      "type": "function",
      "name": "slide",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to bulkAdd from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Lookup.zig",
    "response": "pub fn bulkAdd(self: *Self, data: []const u8, len: u16, pos: u16) void {\n    if (len == 0 or data.len < consts.match.min_length) {\n        return;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Lookup.zig",
      "type": "function",
      "name": "bulkAdd",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Lookup.zig",
    "response": "fn hash(b: *const [4]u8) u32 {\n    return hashu(@as(u32, b[3]) |\n        @as(u32, b[2]) << 8 |\n        @as(u32, b[1]) << 16 |\n        @as(u32, b[0]) << 24);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Lookup.zig",
      "type": "function",
      "name": "hash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hashu from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Lookup.zig",
    "response": "fn hashu(v: u32) u32 {\n    return @intCast((v *% prime4) >> consts.lookup.shift);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Lookup.zig",
      "type": "function",
      "name": "hashu",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/SlidingWindow.zig",
    "response": "pub fn write(self: *Self, buf: []const u8) usize {\n    if (self.rp >= max_rp) return 0; // need to slide\n\n    const n = @min(buf.len, buffer_len - self.wp);\n    @memcpy(self.buffer[self.wp .. self.wp + n], buf[0..n]);\n    self.wp += n;\n    return n;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/SlidingWindow.zig",
      "type": "function",
      "name": "write",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to slide from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/SlidingWindow.zig",
    "response": "pub fn slide(self: *Self) u16 {\n    assert(self.rp >= max_rp and self.wp >= self.rp);\n    const n = self.wp - hist_len;\n    @memcpy(self.buffer[0..n], self.buffer[hist_len..self.wp]);\n    self.rp -= hist_len;\n    self.wp -= hist_len;\n    self.fp -= hist_len;\n    return @intCast(n);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/SlidingWindow.zig",
      "type": "function",
      "name": "slide",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lookahead from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/SlidingWindow.zig",
    "response": "fn lookahead(self: *Self) []const u8 {\n    assert(self.wp >= self.rp);\n    return self.buffer[self.rp..self.wp];\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/SlidingWindow.zig",
      "type": "function",
      "name": "lookahead",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to activeLookahead from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/SlidingWindow.zig",
    "response": "pub fn activeLookahead(self: *Self, should_flush: bool) ?[]const u8 {\n    const min: usize = if (should_flush) 0 else min_lookahead;\n    const lh = self.lookahead();\n    return if (lh.len > min) lh else null;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/SlidingWindow.zig",
      "type": "function",
      "name": "activeLookahead",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to advance from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/SlidingWindow.zig",
    "response": "pub fn advance(self: *Self, n: u16) void {\n    assert(self.wp >= self.rp + n);\n    self.rp += n;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/SlidingWindow.zig",
      "type": "function",
      "name": "advance",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writable from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/SlidingWindow.zig",
    "response": "pub fn writable(self: *Self) []u8 {\n    return self.buffer[self.wp..];\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/SlidingWindow.zig",
      "type": "function",
      "name": "writable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to written from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/SlidingWindow.zig",
    "response": "pub fn written(self: *Self, n: usize) void {\n    self.wp += n;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/SlidingWindow.zig",
      "type": "function",
      "name": "written",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to match from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/SlidingWindow.zig",
    "response": "pub fn match(self: *Self, prev_pos: u16, curr_pos: u16, min_len: u16) u16 {\n    const max_len: usize = @min(self.wp - curr_pos, consts.match.max_length);\n    // lookahead buffers from previous and current positions\n    const prev_lh = self.buffer[prev_pos..][0..max_len];\n    const curr_lh = self.buffer[curr_pos..][0..max_len];\n\n    // If we already have match (min_len > 0),\n    // test the first byte above previous len a[min_len] != b[min_len]\n    // and then all the bytes from that position to zero.\n    // That is likely positions to find difference than looping from first bytes.\n    var i: usize = min_len;\n    if (i > 0) {\n        if (max_len <= i) return 0;\n        while (true) {\n            if (prev_lh[i] != curr_lh[i]) return 0;\n            if (i == 0) break;\n            i -= 1;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/SlidingWindow.zig",
      "type": "function",
      "name": "match",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pos from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/SlidingWindow.zig",
    "response": "pub fn pos(self: *Self) u16 {\n    return @intCast(self.rp);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/SlidingWindow.zig",
      "type": "function",
      "name": "pos",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to flush from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/SlidingWindow.zig",
    "response": "pub fn flush(self: *Self) void {\n    self.fp = @intCast(self.rp);\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/SlidingWindow.zig",
      "type": "function",
      "name": "flush",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tokensBuffer from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/SlidingWindow.zig",
    "response": "pub fn tokensBuffer(self: *Self) ?[]const u8 {\n    assert(self.fp <= self.rp);\n    if (self.fp < 0) return null;\n    return self.buffer[@intCast(self.fp)..self.rp];\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/SlidingWindow.zig",
      "type": "function",
      "name": "tokensBuffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to min from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/SlidingWindow.zig",
    "response": "const min: usize = if (should_flush) 0 else min_lookahead;",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/SlidingWindow.zig",
      "type": "const",
      "name": "min",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to max_len from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/SlidingWindow.zig",
    "response": "const max_len: usize = @min(self.wp - curr_pos, consts.match.max_length);",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/SlidingWindow.zig",
      "type": "const",
      "name": "max_len",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to literal from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "pub fn literal(t: Token) u8 {\n    return t.len_lit;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "function",
      "name": "literal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to distance from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "pub fn distance(t: Token) u16 {\n    return @as(u16, t.dist) + consts.min_distance;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "function",
      "name": "distance",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to length from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "pub fn length(t: Token) u16 {\n    return @as(u16, t.len_lit) + consts.base_length;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "function",
      "name": "length",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to initLiteral from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "pub fn initLiteral(lit: u8) Token {\n    return .{ .kind = .literal, .len_lit = lit }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "function",
      "name": "initLiteral",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to initMatch from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "pub fn initMatch(dist: u16, len: u16) Token {\n    assert(len >= consts.min_length and len <= consts.max_length);\n    assert(dist >= consts.min_distance and dist <= consts.max_distance);\n    return .{\n        .kind = .match,\n        .dist = @intCast(dist - consts.min_distance),\n        .len_lit = @intCast(len - consts.base_length),\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "function",
      "name": "initMatch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "pub fn eql(t: Token, o: Token) bool {\n    return t.kind == o.kind and\n        t.dist == o.dist and\n        t.len_lit == o.len_lit;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lengthCode from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "pub fn lengthCode(t: Token) u16 {\n    return match_lengths[match_lengths_index[t.len_lit]].code;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "function",
      "name": "lengthCode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lengthEncoding from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "pub fn lengthEncoding(t: Token) MatchLength {\n    var c = match_lengths[match_lengths_index[t.len_lit]];\n    c.extra_length = t.len_lit - c.base_scaled;\n    return c;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "function",
      "name": "lengthEncoding",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to distanceCode from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "pub fn distanceCode(t: Token) u8 {\n    var dist: u16 = t.dist;\n    if (dist < match_distances_index.len) {\n        return match_distances_index[dist];\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "function",
      "name": "distanceCode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to distanceEncoding from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "pub fn distanceEncoding(t: Token) MatchDistance {\n    var c = match_distances[t.distanceCode()];\n    c.extra_distance = t.dist - c.base_scaled;\n    return c;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "function",
      "name": "distanceEncoding",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lengthExtraBits from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "pub fn lengthExtraBits(code: u32) u8 {\n    return match_lengths[code - length_codes_start].extra_bits;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "function",
      "name": "lengthExtraBits",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to matchLength from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "pub fn matchLength(code: u8) MatchLength {\n    return match_lengths[code];\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "function",
      "name": "matchLength",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to matchDistance from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "pub fn matchDistance(code: u8) MatchDistance {\n    return match_distances[code];\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "function",
      "name": "matchDistance",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to distanceExtraBits from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "pub fn distanceExtraBits(code: u32) u8 {\n    return match_distances[code].extra_bits;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "function",
      "name": "distanceExtraBits",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to show from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "pub fn show(t: Token) void {\n    if (t.kind == .literal) {\n        print(\"L('{c}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "function",
      "name": "show",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to MatchLength from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "const MatchLength = struct {\n    code: u16,\n    base_scaled: u8, // base - 3, scaled to fit into u8 (0-255), same as lit_len field in Token.\n    base: u16, // 3-258\n    extra_length: u8 = 0,\n    extra_bits: u4,\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "struct",
      "name": "MatchLength",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to MatchDistance from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/Token.zig",
    "response": "const MatchDistance = struct {\n    base_scaled: u16, // base - 1, same as Token dist field\n    base: u16,\n    extra_distance: u16 = 0,\n    code: u8,\n    extra_bits: u4,\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/Token.zig",
      "type": "struct",
      "name": "MatchDistance",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to deflate from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/consts.zig",
    "response": "pub const deflate = struct {\n    // Number of tokens to accumulate in deflate before starting block encoding.\n    //\n    // In zlib this depends on memlevel: 6 + memlevel, where default memlevel is\n    // 8 and max 9 that gives 14 or 15 bits.\n    pub const tokens = 1 << 15;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/consts.zig",
      "type": "struct",
      "name": "deflate",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to match from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/consts.zig",
    "response": "pub const match = struct {\n    pub const base_length = 3; // smallest match length per the RFC section 3.2.5\n    pub const min_length = 4; // min length used in this algorithm\n    pub const max_length = 258;\n\n    pub const min_distance = 1;\n    pub const max_distance = 32768;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/consts.zig",
      "type": "struct",
      "name": "match",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to history from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/consts.zig",
    "response": "pub const history = struct {\n    pub const len = match.max_distance;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/consts.zig",
      "type": "struct",
      "name": "history",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to lookup from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/consts.zig",
    "response": "pub const lookup = struct {\n    pub const bits = 15;\n    pub const len = 1 << bits;\n    pub const shift = 32 - bits;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/consts.zig",
      "type": "struct",
      "name": "lookup",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to huffman from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/consts.zig",
    "response": "pub const huffman = struct {\n    // The odd order in which the codegen code sizes are written.\n    pub const codegen_order = [_]u32{ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/consts.zig",
      "type": "struct",
      "name": "huffman",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to size from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/container.zig",
    "response": "pub fn size(w: Container) usize {\n        return headerSize(w) + footerSize(w);\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/container.zig",
      "type": "function",
      "name": "size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to headerSize from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/container.zig",
    "response": "pub fn headerSize(w: Container) usize {\n        return switch (w) {\n            .gzip => 10,\n            .zlib => 2,\n            .raw => 0,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/container.zig",
      "type": "function",
      "name": "headerSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to footerSize from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/container.zig",
    "response": "pub fn footerSize(w: Container) usize {\n        return switch (w) {\n            .gzip => 8,\n            .zlib => 4,\n            .raw => 0,\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/container.zig",
      "type": "function",
      "name": "footerSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeHeader from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/container.zig",
    "response": "pub fn writeHeader(comptime wrap: Container, writer: *std.Io.Writer) !void {\n        switch (wrap) {\n            .gzip => {\n                // GZIP 10 byte header (https://datatracker.ietf.org/doc/html/rfc1952#page-5):\n                //  - ID1 (IDentification 1), always 0x1f\n                //  - ID2 (IDentification 2), always 0x8b\n                //  - CM (Compression Method), always 8 = deflate\n                //  - FLG (Flags), all set to 0\n                //  - 4 bytes, MTIME (Modification time), not used, all set to zero\n                //  - XFL (eXtra FLags), all set to zero\n                //  - OS (Operating System), 03 = Unix\n                const gzipHeader = [_]u8{ 0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03 }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/container.zig",
      "type": "function",
      "name": "writeHeader",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeFooter from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/container.zig",
    "response": "pub fn writeFooter(comptime wrap: Container, hasher: *Hasher(wrap), writer: *std.Io.Writer) !void {\n        switch (wrap) {\n            .gzip => {\n                // GZIP 8 bytes footer\n                //  - 4 bytes, CRC32 (CRC-32)\n                //  - 4 bytes, ISIZE (Input SIZE) - size of the original (uncompressed) input data modulo 2^32\n                try writer.writeInt(u32, hasher.chksum(), .little);\n                try writer.writeInt(u32, hasher.bytesRead(), .little);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/container.zig",
      "type": "function",
      "name": "writeFooter",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseHeader from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/container.zig",
    "response": "pub fn parseHeader(comptime wrap: Container, reader: *std.Io.Reader) !void {\n        switch (wrap) {\n            .gzip => try parseGzipHeader(reader),\n            .zlib => try parseZlibHeader(reader),\n            .raw => {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/container.zig",
      "type": "function",
      "name": "parseHeader",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseGzipHeader from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/container.zig",
    "response": "fn parseGzipHeader(reader: *std.Io.Reader) !void {\n        const magic1 = try reader.takeByte();\n        const magic2 = try reader.takeByte();\n        const method = try reader.takeByte();\n        const flags = try reader.takeByte();\n        try reader.discardAll(6); // mtime(4), xflags, os\n        if (magic1 != 0x1f or magic2 != 0x8b or method != 0x08)\n            return error.BadGzipHeader;\n        // Flags description: https://www.rfc-editor.org/rfc/rfc1952.html#page-5\n        if (flags != 0) {\n            if (flags & 0b0000_0100 != 0) { // FEXTRA\n                const extra_len = try reader.takeInt(u16, .little);\n                try reader.discardAll(extra_len);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/container.zig",
      "type": "function",
      "name": "parseGzipHeader",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseZlibHeader from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/container.zig",
    "response": "fn parseZlibHeader(reader: *std.Io.Reader) !void {\n        const cm = try reader.takeInt(u4, .big);\n        const cinfo = try reader.takeInt(u4, .big);\n        _ = try reader.takeByte();\n        if (cm != 8 or cinfo > 7) {\n            return error.BadZlibHeader;\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/container.zig",
      "type": "function",
      "name": "parseZlibHeader",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseFooter from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/container.zig",
    "response": "pub fn parseFooter(comptime wrap: Container, hasher: *Hasher(wrap), reader: *std.Io.Reader) !void {\n        switch (wrap) {\n            .gzip => {\n                try reader.fill(0);\n                if (try reader.takeInt(u32, .little) != hasher.chksum()) return error.WrongGzipChecksum;\n                if (try reader.takeInt(u32, .little) != hasher.bytesRead()) return error.WrongGzipSize;\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/container.zig",
      "type": "function",
      "name": "parseFooter",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to Hasher from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/container.zig",
    "response": "pub fn Hasher(comptime wrap: Container) type {\n        const HasherType = switch (wrap) {\n            .gzip => std.hash.Crc32,\n            .zlib => std.hash.Adler32,\n            .raw => struct {\n                pub fn init() @This() {\n                    return .{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/container.zig",
      "type": "function",
      "name": "Hasher",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to update from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/container.zig",
    "response": "pub fn update(self: *Self, buf: []const u8) void {\n                switch (wrap) {\n                    .raw => {}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/container.zig",
      "type": "function",
      "name": "update",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to chksum from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/container.zig",
    "response": "pub fn chksum(self: *Self) u32 {\n                return switch (wrap) {\n                    .raw => 0,\n                    .zlib => self.hasher.adler,\n                    else => self.hasher.final(),\n                }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/container.zig",
      "type": "function",
      "name": "chksum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to bytesRead from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/container.zig",
    "response": "pub fn bytesRead(self: *Self) u32 {\n                return @truncate(self.bytes);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/container.zig",
      "type": "function",
      "name": "bytesRead",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to chksum from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/container.zig",
    "response": "const chksum: u32 = @byteSwap(hasher.chksum());",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/container.zig",
      "type": "const",
      "name": "chksum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to set from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "fn set(self: *HuffCode, code: u16, length: u16) void {\n        self.len = length;\n        self.code = code;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "function",
      "name": "set",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to HuffmanEncoder from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "pub fn HuffmanEncoder(comptime size: usize) type {\n    return struct {\n        codes: [size]HuffCode = undefined,\n        // Reusable buffer with the longest possible frequency table.\n        freq_cache: [consts.max_num_frequencies + 1]LiteralNode = undefined,\n        bit_count: [17]u32 = undefined,\n        lns: []LiteralNode = undefined, // sorted by literal, stored to avoid repeated allocation in generate\n        lfs: []LiteralNode = undefined, // sorted by frequency, stored to avoid repeated allocation in generate\n\n        const Self = @This();\n\n        // Update this Huffman Code object to be the minimum code for the specified frequency count.\n        //\n        // freq  An array of frequencies, in which frequency[i] gives the frequency of literal i.\n        // max_bits  The maximum number of bits to use for any literal.\n        pub fn generate(self: *Self, freq: []u16, max_bits: u32) void {\n            var list = self.freq_cache[0 .. freq.len + 1];\n            // Number of non-zero literals\n            var count: u32 = 0;\n            // Set list to be the set of all non-zero literals and their frequencies\n            for (freq, 0..) |f, i| {\n                if (f != 0) {\n                    list[count] = LiteralNode{ .literal = @as(u16, @intCast(i)), .freq = f }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "function",
      "name": "HuffmanEncoder",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to bitLength from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "pub fn bitLength(self: *Self, freq: []u16) u32 {\n            var total: u32 = 0;\n            for (freq, 0..) |f, i| {\n                if (f != 0) {\n                    total += @as(u32, @intCast(f)) * @as(u32, @intCast(self.codes[i].len));\n                }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "function",
      "name": "bitLength",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to bitCounts from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "fn bitCounts(self: *Self, list: []LiteralNode, max_bits_to_use: usize) []u32 {\n            var max_bits = max_bits_to_use;\n            const n = list.len;\n            const max_bits_limit = 16;\n\n            assert(max_bits < max_bits_limit);\n\n            // The tree can't have greater depth than n - 1, no matter what. This\n            // saves a little bit of work in some small cases\n            max_bits = @min(max_bits, n - 1);\n\n            // Create information about each of the levels.\n            // A bogus \"Level 0\" whose sole purpose is so that\n            // level1.prev.needed == 0.  This makes level1.next_pair_freq\n            // be a legitimate value that never gets chosen.\n            var levels: [max_bits_limit]LevelInfo = mem.zeroes([max_bits_limit]LevelInfo);\n            // leaf_counts[i] counts the number of literals at the left\n            // of ancestors of the rightmost node at level i.\n            // leaf_counts[i][j] is the number of literals at the left\n            // of the level j ancestor.\n            var leaf_counts: [max_bits_limit][max_bits_limit]u32 = mem.zeroes([max_bits_limit][max_bits_limit]u32);\n\n            {\n                var level = @as(u32, 1);\n                while (level <= max_bits) : (level += 1) {\n                    // For every level, the first two items are the first two characters.\n                    // We initialize the levels as if we had already figured this out.\n                    levels[level] = LevelInfo{\n                        .level = level,\n                        .last_freq = list[1].freq,\n                        .next_char_freq = list[2].freq,\n                        .next_pair_freq = list[0].freq + list[1].freq,\n                        .needed = 0,\n                    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "function",
      "name": "bitCounts",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to assignEncodingAndSize from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "fn assignEncodingAndSize(self: *Self, bit_count: []u32, list_arg: []LiteralNode) void {\n            var code = @as(u16, 0);\n            var list = list_arg;\n\n            for (bit_count, 0..) |bits, n| {\n                code <<= 1;\n                if (n == 0 or bits == 0) {\n                    continue;\n                }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "function",
      "name": "assignEncodingAndSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to maxNode from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "fn maxNode() LiteralNode {\n    return LiteralNode{\n        .literal = math.maxInt(u16),\n        .freq = math.maxInt(u16),\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "function",
      "name": "maxNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to huffmanEncoder from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "pub fn huffmanEncoder(comptime size: u32) HuffmanEncoder(size) {\n    return .{}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "function",
      "name": "huffmanEncoder",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fixedLiteralEncoder from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "pub fn fixedLiteralEncoder() LiteralEncoder {\n    var h: LiteralEncoder = undefined;\n    var ch: u16 = 0;\n\n    while (ch < consts.max_num_frequencies) : (ch += 1) {\n        var bits: u16 = undefined;\n        var size: u16 = undefined;\n        switch (ch) {\n            0...143 => {\n                // size 8, 000110000  .. 10111111\n                bits = ch + 48;\n                size = 8;\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "function",
      "name": "fixedLiteralEncoder",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fixedDistanceEncoder from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "pub fn fixedDistanceEncoder() DistanceEncoder {\n    var h: DistanceEncoder = undefined;\n    for (h.codes, 0..) |_, ch| {\n        h.codes[ch] = HuffCode{ .code = bitReverse(u16, @as(u16, @intCast(ch)), 5), .len = 5 }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "function",
      "name": "fixedDistanceEncoder",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to huffmanDistanceEncoder from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "pub fn huffmanDistanceEncoder() DistanceEncoder {\n    var distance_freq = [1]u16{0}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "function",
      "name": "huffmanDistanceEncoder",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to byLiteral from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "fn byLiteral(context: void, a: LiteralNode, b: LiteralNode) bool {\n    _ = context;\n    return a.literal < b.literal;\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "function",
      "name": "byLiteral",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to byFreq from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "fn byFreq(context: void, a: LiteralNode, b: LiteralNode) bool {\n    _ = context;\n    if (a.freq == b.freq) {\n        return a.literal < b.literal;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "function",
      "name": "byFreq",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to bitReverse from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "fn bitReverse(comptime T: type, value: T, n: usize) T {\n    const r = @bitReverse(value);\n    return r >> @as(math.Log2Int(T), @intCast(@typeInfo(T).int.bits - n));\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "function",
      "name": "bitReverse",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to LiteralNode from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "const LiteralNode = struct {\n    literal: u16,\n    freq: u16,\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "struct",
      "name": "LiteralNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to LevelInfo from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "const LevelInfo = struct {\n    // Our level.  for better printing\n    level: u32,\n\n    // The frequency of the last node at this level\n    last_freq: u32,\n\n    // The frequency of the next character to add to this level\n    next_char_freq: u32,\n\n    // The frequency of the next pair (from level below) to add to this level.\n    // Only valid if the \"needed\" value of the next lower level is 0.\n    next_pair_freq: u32,\n\n    // The number of chains remaining to generate for this level before moving\n    // up to the next level\n    needed: u32,\n}",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "struct",
      "name": "LevelInfo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to HuffCode from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "pub const HuffCode = struct {\n    code: u16 = 0,\n    len: u16 = 0,\n\n    // set sets the code and length of an hcode.\n    fn set(self: *HuffCode, code: u16, length: u16) void {\n        self.len = length;\n        self.code = code;\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "struct",
      "name": "HuffCode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ReverseBitsTest from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/deflate/huffman_encoder.zig",
    "response": "const ReverseBitsTest = struct {\n        in: u16,\n        bit_count: u5,\n        out: u16,\n    }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/deflate/huffman_encoder.zig",
      "type": "struct",
      "name": "ReverseBitsTest",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to Decoder from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/lzw.zig",
    "response": "pub fn Decoder(comptime endian: std.builtin.Endian) type {\n    return struct {\n        area_allocator: std.heap.ArenaAllocator,\n        code_size: u8 = 0,\n        clear_code: u13 = 0,\n        initial_code_size: u8 = 0,\n        end_information_code: u13 = 0,\n        next_code: u13 = 0,\n        previous_code: ?u13 = null,\n        dictionary: std.AutoArrayHashMap(u13, []const u8),\n\n        remaining_data: ?u13 = null,\n        remaining_bits: u4 = 0,\n\n        // Some LZW encoders (eg. TIFF) increase the code size too early\n        early_change: u8 = 0,\n\n        const MaxCodeSize = 12;\n\n        const Self = @This();\n\n        pub fn init(allocator: std.mem.Allocator, initial_code_size: u8, early_change: u8) !Self {\n            var result = Self{\n                .area_allocator = std.heap.ArenaAllocator.init(allocator),\n                .code_size = initial_code_size,\n                .dictionary = std.AutoArrayHashMap(u13, []const u8).init(allocator),\n                .initial_code_size = initial_code_size,\n                .clear_code = @as(u13, 1) << @intCast(initial_code_size),\n                .end_information_code = (@as(u13, 1) << @intCast(initial_code_size)) + 1,\n                .next_code = (@as(u13, 1) << @intCast(initial_code_size)) + 2,\n                .early_change = early_change,\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/lzw.zig",
      "type": "function",
      "name": "Decoder",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/lzw.zig",
    "response": "pub fn deinit(self: *Self) void {\n            self.area_allocator.deinit();\n            self.dictionary.deinit();\n        }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/lzw.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/lzw.zig",
    "response": "pub fn decode(self: *Self, reader: *std.Io.Reader, writer: *std.Io.Writer) !void {\n            var bit_reader: io.BitReader(endian) = .{\n                .reader = reader,\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/lzw.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to resetDictionary from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/lzw.zig",
    "response": "fn resetDictionary(self: *Self) !void {\n            self.dictionary.clearRetainingCapacity();\n            self.area_allocator.deinit();\n\n            self.code_size = self.initial_code_size;\n            self.next_code = (@as(u13, 1) << @intCast(self.initial_code_size)) + 2;\n\n            self.area_allocator = std.heap.ArenaAllocator.init(self.area_allocator.child_allocator);\n            var allocator = self.area_allocator.allocator();\n\n            const roots_size = @as(usize, 1) << @intCast(self.code_size);\n\n            var index: u13 = 0;\n\n            while (index < roots_size) : (index += 1) {\n                var data = try allocator.alloc(u8, 1);\n                data[0] = @as(u8, @truncate(index));\n\n                try self.dictionary.put(index, data);\n            }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/lzw.zig",
      "type": "function",
      "name": "resetDictionary",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/packbits.zig",
    "response": "pub fn decode(read_stream: *io.ReadStream, temp_buffer: []u8, length: u32) !void {\n    const reader = read_stream.reader();\n\n    var output_offset: u32 = 0;\n    var input_offset: u32 = 0;\n\n    while (input_offset < length - 1) {\n        const control: usize = try reader.takeByte();\n        input_offset += 1;\n        if (control < 128) {\n            for (0..control + 1) |_| {\n                if (input_offset >= length) {\n                    return;\n                }",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/packbits.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to control from zigimg/zigimg",
    "context": "Repository: zigimg/zigimg (690 ⭐)\nFile: src/compressions/packbits.zig",
    "response": "const control: usize = try reader.takeByte();",
    "metadata": {
      "repo": "zigimg/zigimg",
      "stars": 690,
      "file": "src/compressions/packbits.zig",
      "type": "const",
      "name": "control",
      "difficulty": "easy"
    }
  }
]