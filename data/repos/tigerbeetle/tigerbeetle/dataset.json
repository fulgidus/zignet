[
  {
    "instruction": "Write a Zig function similar to resolve_target from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn resolve_target(b: *std.Build, target_requested: ?[]const u8) !std.Build.ResolvedTarget {\n    const target_host = @tagName(builtin.target.cpu.arch) ++ \"-\" ++ @tagName(builtin.target.os.tag);\n    const target = target_requested orelse target_host;\n    const triples = .{\n        \"aarch64-linux\",\n        \"aarch64-macos\",\n        \"x86_64-linux\",\n        \"x86_64-macos\",\n        \"x86_64-windows\",\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "resolve_target",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_vsr_module from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_vsr_module(b: *std.Build, options: struct {\n    stdx_module: *std.Build.Module,\n    git_commit: [40]u8,\n    config_verify: bool,\n    config_release: ?[]const u8,\n    config_release_client_min: ?[]const u8,\n    config_aof_recovery: bool,\n}) struct { *std.Build.Step.Options, *std.Build.Module }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_vsr_module",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_ci from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_ci(\n    b: *std.Build,\n    step_ci: *std.Build.Step,\n    options: struct {\n        scripts: *std.Build.Step.Compile,\n        git_commit: []const u8,\n    },\n) void {\n    const CIMode = enum {\n        smoke, // Quickly check formatting and such.\n        @\"test\", // Main test suite, excluding VOPR and clients.\n        fuzz, // Smoke tests for fuzzers and VOPR.\n        aof, // Dedicated test for AOF, which is somewhat slow to run.\n\n        clients, // Tests for all language clients below.\n        dotnet,\n        go,\n        rust,\n        java,\n        node,\n        python,\n\n        devhub, // Things that run on known-good commit on main branch after merge.\n        @\"devhub-dry-run\",\n        amqp,\n        default, // smoke + test + building Zig parts of clients.\n        all,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_ci",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_ci_step from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_ci_step(\n    b: *std.Build,\n    step_ci: *std.Build.Step,\n    command: anytype,\n) void {\n    const argv = .{ b.graph.zig_exe, \"build\" }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_ci_step",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_ci_script from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_ci_script(\n    b: *std.Build,\n    step_ci: *std.Build.Step,\n    scripts: *std.Build.Step.Compile,\n    argv: []const []const u8,\n) void {\n    const run_artifact = b.addRunArtifact(scripts);\n    run_artifact.addArgs(argv);\n    run_artifact.setEnvironmentVariable(\"ZIG_EXE\", b.graph.zig_exe);\n    hide_stderr(run_artifact);\n    step_ci.dependOn(&run_artifact.step);\n}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_ci_script",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hide_stderr from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn hide_stderr(run: *std.Build.Step.Run) void {\n    const b = run.step.owner;\n\n    run.addCheck(.{ .expect_term = .{ .Exited = 0 }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "hide_stderr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to make from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn make(step: *std.Build.Step, options: std.Build.Step.MakeOptions) anyerror!void {\n            const original = global_map.get(@intFromPtr(step)).?;\n            try original(step, options);\n            assert(step.result_error_msgs.items.len == 0);\n            step.result_stderr = \"\";\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "make",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_check from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_check(\n    b: *std.Build,\n    step_check: *std.Build.Step,\n    options: struct {\n        stdx_module: *std.Build.Module,\n        vsr_module: *std.Build.Module,\n        target: std.Build.ResolvedTarget,\n        mode: std.builtin.OptimizeMode,\n    },\n) void {\n    const tigerbeetle = b.addExecutable(.{\n        .name = \"tigerbeetle\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/tigerbeetle/main.zig\"),\n            .target = options.target,\n            .optimize = options.mode,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_check",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_tigerbeetle from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_tigerbeetle(\n    b: *std.Build,\n    steps: struct {\n        run: *std.Build.Step,\n        install: *std.Build.Step,\n    },\n    options: struct {\n        stdx_module: *std.Build.Module,\n        vsr_module: *std.Build.Module,\n        vsr_options: *std.Build.Step.Options,\n        llvm_objcopy: ?[]const u8,\n        target: std.Build.ResolvedTarget,\n        mode: std.builtin.OptimizeMode,\n        multiversion: ?[]const u8,\n        multiversion_file: ?[]const u8,\n        emit_llvm_ir: bool,\n    },\n) void {\n    const multiversion_file: ?std.Build.LazyPath = if (options.multiversion_file) |path|\n        .{ .cwd_relative = path }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_tigerbeetle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_tigerbeetle_executable from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_tigerbeetle_executable(b: *std.Build, options: struct {\n    vsr_module: *std.Build.Module,\n    vsr_options: *std.Build.Step.Options,\n    target: std.Build.ResolvedTarget,\n    mode: std.builtin.OptimizeMode,\n}) *std.Build.Step.Compile {\n    const root_module = b.createModule(.{\n        .root_source_file = b.path(\"src/tigerbeetle/main.zig\"),\n        .target = options.target,\n        .optimize = options.mode,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_tigerbeetle_executable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_tigerbeetle_executable_multiversion from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_tigerbeetle_executable_multiversion(b: *std.Build, options: struct {\n    stdx_module: *std.Build.Module,\n    vsr_module: *std.Build.Module,\n    vsr_options: *std.Build.Step.Options,\n    llvm_objcopy: ?[]const u8,\n    tigerbeetle_previous: std.Build.LazyPath,\n    target: std.Build.ResolvedTarget,\n    mode: std.builtin.OptimizeMode,\n}) std.Build.LazyPath {\n    // build_multiversion a custom step that would take care of packing several releases into one\n    const build_multiversion_exe = b.addExecutable(.{\n        .name = \"build_multiversion\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/build_multiversion.zig\"),\n            // Enable aes extensions for vsr.checksum on the host.\n            .target = resolve_target(b, null) catch @panic(\"unsupported host\"),\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_tigerbeetle_executable_multiversion",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_tigerbeetle_executable_get_objcopy from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_tigerbeetle_executable_get_objcopy(b: *std.Build) std.Build.LazyPath {\n    switch (b.graph.host.result.os.tag) {\n        .linux => {\n            switch (b.graph.host.result.cpu.arch) {\n                .x86_64 => {\n                    return fetch(b, .{\n                        .url = \"https://github.com/tigerbeetle/dependencies/releases/download/\" ++\n                            \"18.1.8/llvm-objcopy-x86_64-linux.zip\",\n                        .file_name = \"llvm-objcopy\",\n                        .hash = \"N-V-__8AAFCWcgAxBPUOMe_uJrFGfQ2Ri_SsbNp77pPYZdAe\",\n                    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_tigerbeetle_executable_get_objcopy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_aof from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_aof(\n    b: *std.Build,\n    step_aof: *std.Build.Step,\n    options: struct {\n        stdx_module: *std.Build.Module,\n        vsr_options: *std.Build.Step.Options,\n        target: std.Build.ResolvedTarget,\n        mode: std.builtin.OptimizeMode,\n    },\n) void {\n    const aof = b.addExecutable(.{\n        .name = \"aof\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/aof.zig\"),\n            .target = options.target,\n            .optimize = options.mode,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_aof",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_test from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_test(\n    b: *std.Build,\n    steps: struct {\n        test_unit: *std.Build.Step,\n        test_unit_build: *std.Build.Step,\n        test_integration: *std.Build.Step,\n        test_integration_build: *std.Build.Step,\n        test_fmt: *std.Build.Step,\n        @\"test\": *std.Build.Step,\n    },\n    options: struct {\n        llvm_objcopy: ?[]const u8,\n        stdx_module: *std.Build.Module,\n        vsr_options: *std.Build.Step.Options,\n        tb_client_header: *Generated,\n        target: std.Build.ResolvedTarget,\n        mode: std.builtin.OptimizeMode,\n    },\n) !void {\n    const stdx_unit_tests = b.addTest(.{\n        .name = \"test-stdx\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/stdx/stdx.zig\"),\n            .target = options.target,\n            .optimize = options.mode,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_test",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_test_integration from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_test_integration(\n    b: *std.Build,\n    steps: struct {\n        test_integration: *std.Build.Step,\n        test_integration_build: *std.Build.Step,\n    },\n    options: struct {\n        tb_client_header: std.Build.LazyPath,\n        llvm_objcopy: ?[]const u8,\n        stdx_module: *std.Build.Module,\n        target: std.Build.ResolvedTarget,\n        mode: std.builtin.OptimizeMode,\n    },\n) void {\n    // For integration tests, we build an independent copy of TigerBeetle with \"real\" config and\n    // multiversioning.\n    const vsr_options, const vsr_module = build_vsr_module(b, .{\n        .stdx_module = options.stdx_module,\n        .git_commit = \"bee71e0000000000000000000000000000bee71e\".*, // Beetle-hash!\n        .config_verify = true,\n        .config_release = \"0.16.99\",\n        .config_release_client_min = \"0.16.4\",\n        .config_aof_recovery = false,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_test_integration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_test_jni from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_test_jni(\n    b: *std.Build,\n    step_test_jni: *std.Build.Step,\n    options: struct {\n        target: std.Build.ResolvedTarget,\n        mode: std.builtin.OptimizeMode,\n    },\n) !void {\n    const java_home = b.graph.env_map.get(\"JAVA_HOME\") orelse {\n        step_test_jni.dependOn(&b.addFail(\n            \"can't build jni tests tests, JAVA_HOME is not set\",\n        ).step);\n        return;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_test_jni",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_vopr from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_vopr(\n    b: *std.Build,\n    steps: struct {\n        vopr_build: *std.Build.Step,\n        vopr_run: *std.Build.Step,\n    },\n    options: struct {\n        stdx_module: *std.Build.Module,\n        vsr_options: *std.Build.Step.Options,\n        target: std.Build.ResolvedTarget,\n        mode: std.builtin.OptimizeMode,\n        print_exe: bool,\n        vopr_state_machine: VoprStateMachine,\n        vopr_log: VoprLog,\n    },\n) void {\n    const vopr_options = b.addOptions();\n\n    vopr_options.addOption(VoprStateMachine, \"state_machine\", options.vopr_state_machine);\n    vopr_options.addOption(VoprLog, \"log\", options.vopr_log);\n\n    const vopr = b.addExecutable(.{\n        .name = \"vopr\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/vopr.zig\"),\n            .target = options.target,\n            // When running without a SEED, default to release.\n            .optimize = if (b.args == null) .ReleaseSafe else options.mode,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_vopr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_fuzz from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_fuzz(\n    b: *std.Build,\n    steps: struct {\n        fuzz: *std.Build.Step,\n        fuzz_build: *std.Build.Step,\n    },\n    options: struct {\n        stdx_module: *std.Build.Module,\n        vsr_options: *std.Build.Step.Options,\n        target: std.Build.ResolvedTarget,\n        mode: std.builtin.OptimizeMode,\n        print_exe: bool,\n    },\n) void {\n    const fuzz_exe = b.addExecutable(.{\n        .name = \"fuzz\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/fuzz_tests.zig\"),\n            .target = options.target,\n            .optimize = options.mode,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_fuzz",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_scripts from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_scripts(\n    b: *std.Build,\n    steps: struct {\n        scripts: *std.Build.Step,\n        scripts_build: *std.Build.Step,\n    },\n    options: struct {\n        stdx_module: *std.Build.Module,\n        vsr_options: *std.Build.Step.Options,\n        target: std.Build.ResolvedTarget,\n    },\n) *std.Build.Step.Compile {\n    const scripts_exe = b.addExecutable(.{\n        .name = \"scripts\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/scripts.zig\"),\n            .target = options.target,\n            .optimize = .Debug,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_scripts",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_vortex from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_vortex(\n    b: *std.Build,\n    steps: struct {\n        vortex_build: *std.Build.Step,\n        vortex_run: *std.Build.Step,\n    },\n    options: struct {\n        tb_client_header: std.Build.LazyPath,\n        stdx_module: *std.Build.Module,\n        vsr_module: *std.Build.Module,\n        vsr_options: *std.Build.Step.Options,\n        target: std.Build.ResolvedTarget,\n        mode: std.builtin.OptimizeMode,\n        print_exe: bool,\n    },\n) void {\n    const vortex = build_vortex_executable(b, .{\n        .tb_client_header = options.tb_client_header,\n        .stdx_module = options.stdx_module,\n        .vsr_module = options.vsr_module,\n        .vsr_options = options.vsr_options,\n        .target = options.target,\n        .mode = options.mode,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_vortex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_vortex_executable from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_vortex_executable(\n    b: *std.Build,\n    options: struct {\n        tb_client_header: std.Build.LazyPath,\n        stdx_module: *std.Build.Module,\n        vsr_module: *std.Build.Module,\n        vsr_options: *std.Build.Step.Options,\n        target: std.Build.ResolvedTarget,\n        mode: std.builtin.OptimizeMode,\n    },\n) *std.Build.Step.Compile {\n    const tb_client = b.addLibrary(.{\n        .name = \"tb_client\",\n        .linkage = .static,\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/tigerbeetle/libtb_client.zig\"),\n            .target = options.target,\n            .optimize = options.mode,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_vortex_executable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to strip_glibc_version from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn strip_glibc_version(triple: []const u8) []const u8 {\n    if (std.mem.endsWith(u8, triple, \"gnu.2.27\")) {\n        return triple[0 .. triple.len - \".2.27\".len];\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "strip_glibc_version",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_rust_client from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_rust_client(\n    b: *std.Build,\n    step_clients_rust: *std.Build.Step,\n    options: struct {\n        vsr_module: *std.Build.Module,\n        vsr_options: *std.Build.Step.Options,\n        tb_client_header: *Generated,\n        mode: std.builtin.OptimizeMode,\n    },\n) void {\n    step_clients_rust.dependOn(&options.tb_client_header.step);\n\n    inline for (platforms) |platform| {\n        const query = Query.parse(.{\n            .arch_os_abi = platform[0],\n            .cpu_features = platform[2],\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_rust_client",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_go_client from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_go_client(\n    b: *std.Build,\n    step_clients_go: *std.Build.Step,\n    options: struct {\n        vsr_module: *std.Build.Module,\n        vsr_options: *std.Build.Step.Options,\n        tb_client_header: std.Build.LazyPath,\n        mode: std.builtin.OptimizeMode,\n    },\n) void {\n    // Updates the generated header file:\n    const tb_client_header_copy = Generated.file_copy(b, .{\n        .from = options.tb_client_header,\n        .path = \"./src/clients/go/pkg/native/tb_client.h\",\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_go_client",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_java_client from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_java_client(\n    b: *std.Build,\n    step_clients_java: *std.Build.Step,\n    options: struct {\n        vsr_module: *std.Build.Module,\n        vsr_options: *std.Build.Step.Options,\n        mode: std.builtin.OptimizeMode,\n    },\n) void {\n    const java_bindings_generator = b.addExecutable(.{\n        .name = \"java_bindings\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/clients/java/java_bindings.zig\"),\n            .target = b.graph.host,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_java_client",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_dotnet_client from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_dotnet_client(\n    b: *std.Build,\n    step_clients_dotnet: *std.Build.Step,\n    options: struct {\n        vsr_module: *std.Build.Module,\n        vsr_options: *std.Build.Step.Options,\n        mode: std.builtin.OptimizeMode,\n    },\n) void {\n    const dotnet_bindings_generator = b.addExecutable(.{\n        .name = \"dotnet_bindings\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/clients/dotnet/dotnet_bindings.zig\"),\n            .target = b.graph.host,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_dotnet_client",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_node_client from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_node_client(\n    b: *std.Build,\n    step_clients_node: *std.Build.Step,\n    options: struct {\n        vsr_module: *std.Build.Module,\n        vsr_options: *std.Build.Step.Options,\n        mode: std.builtin.OptimizeMode,\n    },\n) void {\n    const node_bindings_generator = b.addExecutable(.{\n        .name = \"node_bindings\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/clients/node/node_bindings.zig\"),\n            .target = b.graph.host,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_node_client",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_python_client from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_python_client(\n    b: *std.Build,\n    step_clients_python: *std.Build.Step,\n    options: struct {\n        vsr_module: *std.Build.Module,\n        vsr_options: *std.Build.Step.Options,\n        tb_client_header: std.Build.LazyPath,\n        mode: std.builtin.OptimizeMode,\n    },\n) void {\n    const python_bindings_generator = b.addExecutable(.{\n        .name = \"python_bindings\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/clients/python/python_bindings.zig\"),\n            .target = b.graph.host,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_python_client",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_c_client from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_c_client(\n    b: *std.Build,\n    step_clients_c: *std.Build.Step,\n    options: struct {\n        vsr_module: *std.Build.Module,\n        vsr_options: *std.Build.Step.Options,\n        tb_client_header: *Generated,\n        mode: std.builtin.OptimizeMode,\n    },\n) void {\n    step_clients_c.dependOn(&options.tb_client_header.step);\n\n    inline for (platforms) |platform| {\n        const query = Query.parse(.{\n            .arch_os_abi = platform[0],\n            .cpu_features = platform[2],\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_c_client",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_clients_c_sample from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn build_clients_c_sample(\n    b: *std.Build,\n    step_clients_c_sample: *std.Build.Step,\n    options: struct {\n        vsr_module: *std.Build.Module,\n        vsr_options: *std.Build.Step.Options,\n        target: std.Build.ResolvedTarget,\n        mode: std.builtin.OptimizeMode,\n    },\n) void {\n    const static_lib = b.addLibrary(.{\n        .name = \"tb_client\",\n        .linkage = .static,\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/tigerbeetle/libtb_client.zig\"),\n            .target = options.target,\n            .optimize = options.mode,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "build_clients_c_sample",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to strip_root_module from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn strip_root_module(root_module: *std.Build.Module) void {\n    root_module.strip = true;\n    // Ensure that we get stack traces even in release builds.\n    root_module.omit_frame_pointer = false;\n    root_module.unwind_tables = .none;\n}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "strip_root_module",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to set_windows_dll from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn set_windows_dll(allocator: std.mem.Allocator, java_home: []const u8) void {\n    comptime assert(builtin.os.tag == .windows);\n\n    const java_bin_path = std.fs.path.joinZ(\n        allocator,\n        &.{ java_home, \"\\\\bin\" }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "set_windows_dll",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to SetDllDirectoryA from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn SetDllDirectoryA(path: [*:0]const u8) callconv(.c) std.os.windows.BOOL;\n\nfn print_or_install(b: *std.Build, compile: *std.Build.Step.Compile, print: bool) *std.Build.Step {\n    const PrintStep = struct {\n        step: std.Build.Step,\n        compile: *std.Build.Step.Compile,\n\n        fn make(step: *std.Build.Step, _: std.Build.Step.MakeOptions) !void {\n            const print_step: *@This() = @fieldParentPtr(\"step\", step);\n            const path = print_step.compile.getEmittedBin().getPath2(step.owner, step);\n            try std.io.getStdOut().writer().print(\"{s}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "SetDllDirectoryA",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to file from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "pub fn file(b: *std.Build, options: struct {\n        generator: *std.Build.Step.Compile,\n        path: []const u8,\n    }) *Generated {\n        return create(b, options.path, .{\n            .file = options.generator,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "file",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to file_copy from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "pub fn file_copy(b: *std.Build, options: struct {\n        from: std.Build.LazyPath,\n        path: []const u8,\n    }) *Generated {\n        return create(b, options.path, .{\n            .copy = options.from,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "file_copy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to directory from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "pub fn directory(b: *std.Build, options: struct {\n        generator: *std.Build.Step.Compile,\n        path: []const u8,\n    }) *Generated {\n        return create(b, options.path, .{\n            .directory = options.generator,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "directory",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to create from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn create(b: *std.Build, destination: []const u8, generator: union(enum) {\n        file: *std.Build.Step.Compile,\n        directory: *std.Build.Step.Compile,\n        copy: std.Build.LazyPath,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "create",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to make from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn make(step: *std.Build.Step, _: std.Build.Step.MakeOptions) !void {\n        const b = step.owner;\n        const generated: *Generated = @fieldParentPtr(\"step\", step);\n        const ci = try std.process.hasEnvVar(b.allocator, \"CI\");\n        const source_path = generated.source.getPath2(b, step);\n\n        if (ci) {\n            const fresh = switch (generated.mode) {\n                .file => file_fresh(b, source_path, generated.destination),\n                .directory => directory_fresh(b, source_path, generated.destination),\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "make",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to file_fresh from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn file_fresh(\n        b: *std.Build,\n        source_path: []const u8,\n        target_path: []const u8,\n    ) !bool {\n        const want = try b.build_root.handle.readFileAlloc(\n            b.allocator,\n            source_path,\n            std.math.maxInt(usize),\n        );\n        defer b.allocator.free(want);\n\n        const got = b.build_root.handle.readFileAlloc(\n            b.allocator,\n            target_path,\n            std.math.maxInt(usize),\n        ) catch return false;\n        defer b.allocator.free(got);\n\n        return std.mem.eql(u8, want, got);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "file_fresh",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to file_update from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn file_update(\n        b: *std.Build,\n        source_path: []const u8,\n        target_path: []const u8,\n    ) !std.fs.Dir.PrevStatus {\n        return std.fs.Dir.updateFile(\n            b.build_root.handle,\n            source_path,\n            b.build_root.handle,\n            target_path,\n            .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "file_update",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to directory_fresh from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn directory_fresh(\n        b: *std.Build,\n        source_path: []const u8,\n        target_path: []const u8,\n    ) !bool {\n        var source_dir = try b.build_root.handle.openDir(source_path, .{ .iterate = true }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "directory_fresh",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to directory_update from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn directory_update(\n        b: *std.Build,\n        source_path: []const u8,\n        target_path: []const u8,\n    ) !std.fs.Dir.PrevStatus {\n        var result: std.fs.Dir.PrevStatus = .fresh;\n        var source_dir = try b.build_root.handle.openDir(source_path, .{ .iterate = true }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "directory_update",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to download_release from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn download_release(\n    b: *std.Build,\n    version_or_latest: []const u8,\n    target: std.Build.ResolvedTarget,\n    mode: std.builtin.OptimizeMode,\n) std.Build.LazyPath {\n    const release_slug = if (std.mem.eql(u8, version_or_latest, \"latest\"))\n        \"latest/download\"\n    else\n        b.fmt(\"download/{s}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "download_release",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fetch from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "fn fetch(b: *std.Build, options: struct {\n    url: []const u8,\n    file_name: []const u8,\n    hash: ?[]const u8,\n}) std.Build.LazyPath {\n    const copy_from_cache = b.addRunArtifact(b.addExecutable(.{\n        .name = \"copy-from-cache\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.addWriteFiles().add(\"main.zig\",\n                \\\\const builtin = @import(\"builtin\");\n                \\\\const std = @import(\"std\");\n                \\\\const assert = std.debug.assert;\n                \\\\\n                \\\\pub fn main() !void {\n                \\\\    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n                \\\\    const allocator = arena.allocator();\n                \\\\    const args = try std.process.argsAlloc(allocator);\n                \\\\    assert(args.len == 5 or args.len == 6);\n                \\\\\n                \\\\    const hash_and_newline = try std.fs.cwd().readFileAlloc(allocator, args[2], 128);\n                \\\\    assert(hash_and_newline[hash_and_newline.len - 1] == '\\n');\n                \\\\    const hash = hash_and_newline[0 .. hash_and_newline.len - 1];\n                \\\\    if (args.len == 6 and !std.mem.eql(u8, args[5], hash)) {\n                \\\\        std.debug.panic(\n                \\\\            \\\\bad hash\n                \\\\            \\\\specified:  {s}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "function",
      "name": "fetch",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to override from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "const override = struct {\n        var global_map: std.AutoHashMapUnmanaged(usize, std.Build.Step.MakeFn) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "struct",
      "name": "override",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to PrintStep from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "const PrintStep = struct {\n        step: std.Build.Step,\n        compile: *std.Build.Step.Compile,\n\n        fn make(step: *std.Build.Step, _: std.Build.Step.MakeOptions) !void {\n            const print_step: *@This() = @fieldParentPtr(\"step\", step);\n            const path = print_step.compile.getEmittedBin().getPath2(step.owner, step);\n            try std.io.getStdOut().writer().print(\"{s}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "struct",
      "name": "PrintStep",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Generated from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "const Generated = struct {\n    step: std.Build.Step,\n    path: std.Build.LazyPath,\n\n    destination: []const u8,\n    generated_file: std.Build.GeneratedFile,\n    source: std.Build.LazyPath,\n    mode: enum { file, directory }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "struct",
      "name": "Generated",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to mode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "const mode: CIMode = if (b.args) |args| mode: {\n        if (args.len != 1) {\n            step_ci.dependOn(&b.addFail(\"invalid CIMode\").step);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "const",
      "name": "mode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to multiversion_file from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "const multiversion_file: ?std.Build.LazyPath = if (options.multiversion_file) |path|\n        .{ .cwd_relative = path }\n    else if (options.multiversion) |version_past|\n        download_release(b, version_past, options.target, options.mode)\n    else\n        null;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "const",
      "name": "multiversion_file",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to file_name from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "const file_name: []const u8, const extension: []const u8 = cut: {\n            assert(std.mem.count(u8, lib.out_lib_filename, \".\") == 1);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "const",
      "name": "file_name",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to print_step from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "const print_step: *@This() = @fieldParentPtr(\"step\", step);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "const",
      "name": "print_step",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to generated from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: build.zig",
    "response": "const generated: *Generated = @fieldParentPtr(\"step\", step);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "build.zig",
      "type": "const",
      "name": "generated",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to size_disk from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn size_disk(self: *AOFEntry) u64 {\n        return @sizeOf(AOFEntry) - self.message.len + self.header().size;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "size_disk",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to size_minimum from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn size_minimum(self: *AOFEntry) u64 {\n        return @sizeOf(AOFEntry) - self.message.len + @sizeOf(Header);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "size_minimum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to header from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn header(self: *AOFEntry) *Header.Prepare {\n        return @ptrCast(&self.message);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "header",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to to_message from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn to_message(self: *AOFEntry, target: *Message.Prepare) void {\n        stdx.copy_disjoint(.inexact, u8, target.buffer, self.message[0..self.header().size]);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "to_message",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to from_message from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn from_message(\n        self: *AOFEntry,\n        message: *const Message.Prepare,\n        last_checksum: *?u128,\n    ) void {\n        assert(message.header.size <= self.message.len);\n\n        // When writing, entries can backtrack / duplicate, so we don't necessarily have a valid\n        // chain. Still, log when that happens. The `aof merge` command can generate a consistent\n        // file from entries like these.\n        log.debug(\"from_message: parent {}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "from_message",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to AOFType from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn AOFType(comptime IO: type) type {\n    return struct {\n        const AOF = @This();\n\n        io: *IO,\n        file_descriptor: IO.fd_t,\n        last_checksum: ?u128 = null,\n\n        state: union(enum) {\n            /// Store the number of unflushed entries - that is, calls to write() without\n            /// checkpoint() to ensure we don't ever buffer more than the WAL can hold.\n            writing: struct { unflushed: u64 }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "AOFType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn init(\n            io: *IO,\n            options: struct {\n                dir_fd: IO.fd_t,\n                relative_path: []const u8,\n            },\n        ) !AOF {\n            assert(!std.fs.path.isAbsolute(options.relative_path));\n            assert(std.mem.endsWith(u8, options.relative_path, \".aof\"));\n            assert(IO == @import(\"io.zig\").IO);\n\n            const dir = std.fs.Dir{\n                .fd = options.dir_fd,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to close from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn close(self: *AOF) void {\n            self.io.aof_blocking_close(self.file_descriptor);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "close",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn write(self: *AOF, message: *const Message.Prepare) !void {\n            assert(self.state == .writing);\n            assert(self.state.writing.unflushed < constants.journal_slot_count);\n\n            var entry: AOFEntry align(constants.sector_size) = undefined;\n            entry.from_message(\n                message,\n                &self.last_checksum,\n            );\n\n            const size_disk = entry.size_disk();\n            const bytes = std.mem.asBytes(&entry);\n\n            try self.io.aof_blocking_write_all(self.file_descriptor, bytes[0..size_disk]);\n\n            self.size += size_disk;\n            self.state.writing.unflushed += 1;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "write",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to sync from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn sync(self: *AOF) void {\n            assert(self.state == .writing);\n            assert(self.state.writing.unflushed <= constants.journal_slot_count);\n            self.state.writing.unflushed = 0;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "sync",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to checkpoint from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn checkpoint(\n            self: *AOF,\n            replica: *anyopaque,\n            callback: *const fn (*anyopaque) void,\n        ) void {\n            assert(self.state == .writing);\n            assert(self.state.writing.unflushed <= constants.journal_slot_count);\n\n            self.state = .{\n                .checkpoint = .{\n                    .replica = replica,\n                    .fsync_completion = undefined,\n                    .replica_callback = callback,\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "checkpoint",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to on_fsync from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "fn on_fsync(self: *AOF, completion: *IO.Completion, result: IO.FsyncError!void) void {\n            _ = completion;\n            _ = result catch @panic(\"aof fsync failure\");\n\n            assert(self.state == .checkpoint);\n            const replica = self.state.checkpoint.replica;\n            const replica_callback = self.state.checkpoint.replica_callback;\n            self.state = .{ .writing = .{ .unflushed = 0 }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "on_fsync",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to validate from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn validate(self: *AOF, allocator: std.mem.Allocator, last_checksum: ?u128) !void {\n            assert(IO == @import(\"testing/io.zig\").IO);\n\n            var validation_target: AOFEntry = undefined;\n\n            var validation_checksums = std.AutoHashMap(u128, void).init(allocator);\n            defer validation_checksums.deinit();\n\n            var it = Iterator{\n                .file_descriptor = self.file_descriptor,\n                .io = self.io,\n                .size = self.size,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "validate",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to reset from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn reset(self: *AOF) void {\n            assert(IO == @import(\"testing/io.zig\").IO);\n            self.state = .{ .writing = .{ .unflushed = 0 }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "reset",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn init(\n                io: *IO,\n                allocator: std.mem.Allocator,\n                time: vsr.time.Time,\n                addresses: []std.net.Address,\n            ) !ReplayClient {\n                assert(addresses.len > 0);\n                assert(addresses.len <= constants.replicas_max);\n\n                var message_pool = try allocator.create(MessagePool);\n                errdefer allocator.destroy(message_pool);\n\n                var client = try allocator.create(Client);\n                errdefer allocator.destroy(client);\n\n                message_pool.* = try MessagePool.init(allocator, .client);\n                errdefer message_pool.deinit(allocator);\n\n                client.* = try Client.init(\n                    allocator,\n                    time,\n                    message_pool,\n                    .{\n                        .id = stdx.unique_u128(),\n                        .cluster = 0,\n                        .replica_count = @intCast(addresses.len),\n                        .message_bus_options = .{\n                            .configuration = addresses,\n                            .io = io,\n                        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn deinit(self: *ReplayClient, allocator: std.mem.Allocator) void {\n                self.client.deinit(allocator);\n                self.message_pool.deinit(allocator);\n\n                allocator.destroy(self.client);\n                allocator.destroy(self.message_pool);\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to replay from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn replay(self: *ReplayClient, iterator: *Iterator) !void {\n                var target: AOFEntry = undefined;\n\n                while (try iterator.next(&target)) |entry| {\n                    // Skip replaying reserved messages and messages not marked for playback.\n                    const header = entry.header();\n                    if (!ReplayClient.replay_message(header)) continue;\n\n                    const message = self.client.get_message().build(.request);\n                    errdefer self.client.release_message(message.base());\n\n                    assert(self.inflight_message == null);\n                    self.inflight_message = message;\n\n                    entry.to_message(message.base().build(.prepare));\n\n                    message.header.* = .{\n                        .client = self.client.id,\n                        .cluster = self.client.cluster,\n                        .command = .request,\n                        .operation = header.operation,\n                        .size = header.size,\n                        .timestamp = header.timestamp,\n                        .view = 0,\n                        .parent = 0,\n                        .session = 0,\n                        .request = 0,\n                        .release = header.release,\n                        .previous_request_latency = 0,\n                    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "replay",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to replay_message from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn replay_message(header: *Header.Prepare) bool {\n                if (header.operation.vsr_reserved()) return false;\n                const state_machine_operation = header.operation.cast(StateMachine);\n                switch (state_machine_operation) {\n                    .create_accounts, .create_transfers => return true,\n\n                    // Pulses are replayed to handle pending transfer expiry.\n                    .pulse => return true,\n\n                    else => return false,\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "replay_message",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to register_callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "fn register_callback(\n                user_data: u128,\n                result: *const vsr.RegisterResult,\n            ) void {\n                _ = user_data;\n                _ = result;\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "register_callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to replay_callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "fn replay_callback(\n                user_data: u128,\n                operation: vsr.Operation,\n                timestamp: u64,\n                result: []u8,\n            ) void {\n                _ = operation;\n                _ = timestamp;\n                _ = result;\n\n                const self: *ReplayClient = @ptrFromInt(@as(usize, @intCast(user_data)));\n                assert(self.inflight_message != null);\n                self.inflight_message = null;\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "replay_callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn init(io: *IO, path: []const u8) !Iterator {\n                assert(IO == @import(\"io.zig\").IO);\n\n                const file = try std.fs.cwd().openFile(path, .{ .mode = .read_only }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn next(it: *Iterator, target: *AOFEntry) !?*AOFEntry {\n                if (it.offset >= it.size) return null;\n\n                const buf = std.mem.asBytes(target);\n                const bytes_read = try it.io.aof_blocking_pread_all(\n                    it.file_descriptor,\n                    buf,\n                    it.offset,\n                );\n\n                // size_disk relies on information that was stored on disk, so further verify we\n                // have read at least the minimum permissible.\n                if (bytes_read < target.size_minimum() or\n                    bytes_read < target.size_disk())\n                {\n                    return error.AOFShortRead;\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reset from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn reset(it: *Iterator) !void {\n                it.offset = 0;\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "reset",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to close from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn close(it: *Iterator) void {\n                it.io.aof_blocking_close(it.file_descriptor);\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "close",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to skip from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn skip(it: *Iterator, allocator: std.mem.Allocator, count: usize) !void {\n                var skip_buffer = try allocator.alloc(u8, 1 * MiB);\n                defer allocator.free(skip_buffer);\n\n                while (it.offset < it.size) {\n                    const bytes_read = try it.io.aof_blocking_pread_all(\n                        it.file_descriptor,\n                        skip_buffer,\n                        it.offset,\n                    );\n                    const offset = std.mem.indexOfPos(\n                        u8,\n                        skip_buffer[0..bytes_read],\n                        count,\n                        std.mem.asBytes(&magic_number),\n                    );\n\n                    if (offset) |offset_bytes| {\n                        it.offset += offset_bytes;\n                        break;\n                    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "skip",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to merge from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn merge(\n            io: *IO,\n            allocator: std.mem.Allocator,\n            input_paths: []const []const u8,\n            output_path: []const u8,\n        ) !void {\n            const stdout = std.io.getStdOut().writer();\n\n            var aofs: [constants.members_max]Iterator = undefined;\n            var aof_count: usize = 0;\n            defer for (aofs[0..aof_count]) |*it| it.close();\n\n            assert(input_paths.len < aofs.len);\n\n            const EntryInfo = struct {\n                aof: *Iterator,\n                index: u64,\n                size: u64,\n                checksum: u128,\n                parent: u128,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "merge",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Iterator from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "pub const Iterator = struct {\n            io: *IO,\n            file_descriptor: IO.fd_t,\n            size: u64,\n            offset: u64 = 0,\n\n            validate_chain: bool = true,\n            last_checksum: ?u128 = null,\n\n            pub fn init(io: *IO, path: []const u8) !Iterator {\n                assert(IO == @import(\"io.zig\").IO);\n\n                const file = try std.fs.cwd().openFile(path, .{ .mode = .read_only }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "struct",
      "name": "Iterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to EntryInfo from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "const EntryInfo = struct {\n                aof: *Iterator,\n                index: u64,\n                size: u64,\n                checksum: u128,\n                parent: u128,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "struct",
      "name": "EntryInfo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to magic_number from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "const magic_number: u128 = 0xbcd8d3fee406119ed192c4f4c4fc82;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "const",
      "name": "magic_number",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/aof.zig",
    "response": "const self: *ReplayClient = @ptrFromInt(@as(usize, @intCast(user_data)));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/aof.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "pub fn init(\n        allocator: std.mem.Allocator,\n        options: struct {\n            io: *IO,\n            message_count_max: u32,\n            message_body_size_max: u32,\n            reply_timeout_ticks: u64,\n        },\n    ) !Client {\n        assert(options.message_count_max > 0);\n        assert(options.message_body_size_max > 0);\n        assert(options.reply_timeout_ticks > 0);\n\n        // The worst-case size required to write a frame containing the message body.\n        const body_frame_size = Encoder.FrameHeader.size_total +\n            options.message_body_size_max +\n            @sizeOf(protocol.FrameEnd);\n\n        const frame_size = @max(frame_min_size, body_frame_size);\n\n        // Large messages are not expected, but we must be able to receive at least\n        // the same frame size we send.\n        const receive_buffer = try allocator.alloc(u8, frame_size);\n        errdefer allocator.free(receive_buffer);\n\n        // When publishing messages, the method and header frames (including metadata)\n        // are sent in addition to the body frame.\n        // TODO: The size could be calculated more efficiently if the variable data had\n        // a known size, otherwise, it’s constrained only by the maximum frame size.\n        const send_buffer_size = 3 * frame_size * options.message_count_max;\n        const send_buffer = try allocator.alloc(u8, send_buffer_size);\n        errdefer allocator.free(send_buffer);\n\n        var publish_confirms: Confirms = try Confirms.init(allocator, options.message_count_max);\n        errdefer publish_confirms.deinit(allocator);\n\n        return .{\n            .io = options.io,\n            .receive_buffer = ReceiveBuffer.init(receive_buffer),\n            .send_buffer = SendBuffer.init(send_buffer),\n            .reply_timeout_ticks = options.reply_timeout_ticks,\n            .publish_confirms = publish_confirms,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "pub fn deinit(\n        self: *Client,\n        allocator: std.mem.Allocator,\n    ) void {\n        if (self.fd != IO.INVALID_SOCKET) {\n            self.io.close_socket(self.fd);\n            self.fd = IO.INVALID_SOCKET;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to connect from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "pub fn connect(self: *Client, callback: Callback, options: ConnectOptions) !void {\n        assert(self.fd == IO.INVALID_SOCKET);\n        assert(self.awaiter == .none);\n        assert(self.send_buffer.state == .idle);\n        assert(self.action == .none);\n        self.action = .{ .connect = .{\n            .options = options,\n            .phase = .dial,\n            .callback = callback,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "connect",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to continuation from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn continuation(\n                    context: *Client,\n                    completion: *IO.Completion,\n                    result: IO.ConnectError!void,\n                ) void {\n                    _ = completion;\n                    _ = result catch fatal(\"Connection refused.\", .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "continuation",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to connect_dispatch from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn connect_dispatch(self: *Client, reply: spec.ClientMethod) Decoder.Error!void {\n        assert(self.awaiter == .none);\n        assert(self.send_buffer.state == .idle);\n        assert(self.action == .connect);\n        const connection_options = self.action.connect.options;\n\n        switch (reply) {\n            .connection_start => |args| {\n                assert(self.action.connect.phase == .handshake);\n\n                log.info(\"Connection start received:\", .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "connect_dispatch",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to exchange_declare from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "pub fn exchange_declare(\n        self: *Client,\n        callback: Callback,\n        options: ExchangeDeclareOptions,\n    ) void {\n        assert(self.action == .none);\n        self.action = .{ .exchange_declare = callback }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "exchange_declare",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dispatch from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn dispatch(context: *Client, reply: spec.ClientMethod) Decoder.Error!void {\n                    assert(reply == .exchange_declare_ok);\n                    assert(context.action == .exchange_declare);\n                    const exchange_declare_callback = context.action.exchange_declare;\n                    context.action = .none;\n                    exchange_declare_callback(context);\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "dispatch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to queue_declare from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "pub fn queue_declare(self: *Client, callback: Callback, options: QueueDeclareOptions) void {\n        assert(self.action == .none);\n        self.action = .{ .queue_declare = callback }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "queue_declare",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dispatch from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn dispatch(context: *Client, reply: spec.ClientMethod) Decoder.Error!void {\n                    assert(reply == .queue_declare_ok);\n                    assert(context.action == .queue_declare);\n\n                    const queue_declare_callback = context.action.queue_declare;\n                    context.action = .none;\n                    queue_declare_callback(context);\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "dispatch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to publish_enqueue from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "pub fn publish_enqueue(self: *Client, options: BasicPublishOptions) void {\n        assert(self.awaiter == .none);\n        if (self.action == .none) self.action = .{ .publish_enqueue = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "publish_enqueue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to publish_send from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "pub fn publish_send(\n        self: *Client,\n        callback: Callback,\n    ) void {\n        assert(self.awaiter == .none);\n        assert(self.send_buffer.state == .writing);\n        assert(self.action == .publish_enqueue);\n        assert(self.action.publish_enqueue.count > 0);\n\n        self.publish_confirms.wait(self.action.publish_enqueue.count);\n        self.action = .{ .publish = .{ .callback = callback }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "publish_send",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dispatch from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn dispatch(context: *Client) void {\n                assert(context.action == .publish);\n                assert(context.action.publish.phase == .sending);\n                context.action.publish.phase = .awaiting_confirmation;\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "dispatch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_message from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "pub fn get_message(\n        self: *Client,\n        callback: GetMessagePropertiesCallback,\n        options: GetMessageOptions,\n    ) void {\n        assert(self.action == .none);\n        self.action = .{ .get_message = callback }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "get_message",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_message_dispatch from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn get_message_dispatch(self: *Client, reply: spec.ClientMethod) Decoder.Error!void {\n        assert(self.action == .get_message);\n        assert(self.awaiter == .none);\n        switch (reply) {\n            .basic_get_empty => {\n                const get_header_callback = self.action.get_message;\n                self.action = .none;\n                try get_header_callback(self, null);\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "get_message_dispatch",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to dispatch from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn dispatch(\n                        context: *Client,\n                        delivery_tag: u64,\n                        message_count: u32,\n                        header: Decoder.Header,\n                    ) Decoder.Error!void {\n                        assert(context.action == .get_message);\n                        assert(header.body_size <= protocol.frame_min_size);\n                        const properties = try Decoder.BasicProperties.decode(\n                            header.property_flags,\n                            header.properties,\n                        );\n                        const get_message_callback = context.action.get_message;\n                        const has_body = header.body_size > 0;\n                        context.action = if (has_body) .{\n                            .message_body_pending = .{\n                                .body_size = header.body_size,\n                            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "dispatch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_message_body from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "pub fn get_message_body(\n        self: *Client,\n        callback: GetMessageBodyCallback,\n    ) void {\n        assert(self.action == .message_body_pending);\n        assert(self.action.message_body_pending.body_size <= protocol.frame_min_size);\n        const body_size = self.action.message_body_pending.body_size;\n        self.action = .{ .get_message_body = .{\n            .body_size = body_size,\n            .callback = callback,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "get_message_body",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dispatch from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn dispatch(\n                    context: *Client,\n                    body: []const u8,\n                ) Decoder.Error!void {\n                    assert(context.action == .get_message_body);\n                    assert(context.action.get_message_body.body_size == body.len);\n                    const get_message_body_callback = context.action.get_message_body.callback;\n                    context.action = .none;\n                    try get_message_body_callback(context, body);\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "dispatch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nack from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "pub fn nack(self: *Client, callback: Callback, options: BasicNackOptions) void {\n        assert(self.awaiter == .none);\n        assert(self.action == .none);\n        self.action = .{ .nack = callback }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "nack",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dispatch from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn dispatch(context: *Client) void {\n                assert(context.action == .nack);\n                const nack_callback = context.action.nack;\n                context.action = .none;\n                nack_callback(context);\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "dispatch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_and_await_reply from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn send_and_await_reply(\n        self: *Client,\n        channel: Channel,\n        callback: *const fn (self: *Client, reply: spec.ClientMethod) Decoder.Error!void,\n    ) void {\n        assert(self.awaiter == .none);\n        assert(self.send_buffer.state == .writing);\n        self.awaiter = .{ .send_and_await_reply = .{\n            .channel = channel,\n            .state = .sending,\n            .callback = callback,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "send_and_await_reply",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_and_forget from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn send_and_forget(\n        self: *Client,\n        callback: *const fn (self: *Client) void,\n    ) void {\n        assert(self.awaiter == .none);\n        assert(self.send_buffer.state == .writing);\n        self.awaiter = .{ .send_and_forget = callback }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "send_and_forget",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to send from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn send(self: *Client) void {\n        switch (self.awaiter) {\n            .send_and_forget,\n            .send_and_await_reply,\n            => {\n                self.io.send(\n                    *Client,\n                    self,\n                    send_callback,\n                    &self.send_completion,\n                    self.fd,\n                    self.send_buffer.flush(),\n                );\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "send",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn send_callback(\n        self: *Client,\n        completion: *IO.Completion,\n        result: IO.SendError!usize,\n    ) void {\n        _ = completion;\n        assert(self.awaiter == .send_and_forget or self.awaiter == .send_and_await_reply);\n        const size = result catch |err| fatal(\n            \"Network error: {s}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "send_callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn receive(self: *Client) void {\n        assert(self.fd != IO.INVALID_SOCKET);\n        assert(self.receive_buffer.state == .idle);\n        self.io.recv(\n            *Client,\n            self,\n            receive_callback,\n            &self.receive_completion,\n            self.fd,\n            self.receive_buffer.begin_receive(),\n        );\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "receive",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive_callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn receive_callback(\n        self: *Client,\n        completion: *IO.Completion,\n        result: IO.RecvError!usize,\n    ) void {\n        _ = completion;\n        assert(self.receive_buffer.state == .receiving);\n\n        const size: usize = result catch |err| fatal(\"Network error: {}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "receive_callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to process from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn process(self: *Client, decoder: *Decoder) Decoder.Error!void {\n        const frame_header = try decoder.read_frame_header();\n        switch (frame_header.type) {\n            .method => {\n                const method_header = try decoder.read_method_header();\n                try self.process_method(frame_header, method_header, decoder);\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "process",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to process_method from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn process_method(\n        self: *Client,\n        frame_header: Decoder.FrameHeader,\n        method_header: protocol.MethodHeader,\n        decoder: *Decoder,\n    ) Decoder.Error!void {\n        assert(frame_header.type == .method);\n        const client_method = try spec.ClientMethod.decode(method_header, decoder);\n        switch (client_method) {\n            inline .connection_close, .channel_close => |close_reason, tag| {\n                const error_code: ErrorCodes = @enumFromInt(close_reason.reply_code);\n                if (std.meta.intToEnum(\n                    spec.ServerMethod.Tag,\n                    @as(u32, @bitCast(protocol.MethodHeader{\n                        .class = close_reason.class_id,\n                        .method = close_reason.method_id,\n                    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "process_method",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to process_header from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn process_header(\n        self: *Client,\n        frame_header: Decoder.FrameHeader,\n        header: Decoder.Header,\n    ) Decoder.Error!void {\n        assert(frame_header.type == .header);\n        maybe(header.body_size == 0);\n        if (self.awaiter == .await_content_header) {\n            const awaiter = self.awaiter.await_content_header;\n            if (frame_header.channel == awaiter.channel) {\n                self.awaiter = .none;\n                return try awaiter.callback(\n                    self,\n                    awaiter.delivery_tag,\n                    awaiter.message_count,\n                    header,\n                );\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "process_header",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to process_body from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn process_body(\n        self: *Client,\n        frame_header: Decoder.FrameHeader,\n        body: []const u8,\n    ) Decoder.Error!void {\n        assert(frame_header.type == .body);\n        assert(body.len > 0);\n        if (self.awaiter == .await_body) {\n            const awaiter = self.awaiter.await_body;\n            if (frame_header.channel == awaiter.channel) {\n                self.awaiter = .none;\n                return try awaiter.callback(\n                    self,\n                    body,\n                );\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "process_body",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_heartbeat from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn send_heartbeat(self: *Client) void {\n        assert(self.fd != IO.INVALID_SOCKET);\n        if (self.heartbeat == .sending) return;\n\n        log.info(\"Heartbeat\", .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "send_heartbeat",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to on_heartbeat_callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn on_heartbeat_callback(\n        self: *Client,\n        completion: *IO.Completion,\n        result: IO.SendError!usize,\n    ) void {\n        assert(self.heartbeat == .sending);\n        self.heartbeat = .idle;\n        _ = completion;\n        _ = result catch |err| fatal(\"Network error: {}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "on_heartbeat_callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tick from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "pub fn tick(self: *Client) void {\n        const duration_ticks: u64 = switch (self.awaiter) {\n            .none, .send_and_forget => return,\n            .send_and_await_reply => |*awaiter| ticks: {\n                if (awaiter.state == .sending) return;\n                assert(awaiter.state == .awaiting);\n                awaiter.state.awaiting.duration_ticks += 1;\n                break :ticks awaiter.state.awaiting.duration_ticks;\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "tick",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn init(buffer: []u8) ReceiveBuffer {\n        assert(buffer.len >= frame_min_size);\n        return .{\n            .buffer = buffer,\n            .state = .idle,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to begin_receive from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn begin_receive(self: *ReceiveBuffer) []u8 {\n        switch (self.state) {\n            .idle => {\n                self.state = .{\n                    .receiving = .{ .non_consumed = 0 }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "begin_receive",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to end_receive from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn end_receive(self: *ReceiveBuffer, size: usize) Decoder {\n        assert(size > 0);\n        switch (self.state) {\n            .idle, .decoding => unreachable,\n            .receiving => |receive_state| {\n                const total_size = size + receive_state.non_consumed;\n                assert(total_size <= self.buffer.len);\n                maybe(receive_state.non_consumed == 0);\n                self.state = .{ .decoding = .{ .size = total_size }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "end_receive",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to end_decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn end_decode(self: *ReceiveBuffer, processed_last_index: usize) []u8 {\n        maybe(processed_last_index == 0);\n        assert(self.state == .decoding);\n        const decoding_state = self.state.decoding;\n        if (processed_last_index == decoding_state.size) {\n            self.state = .{\n                .receiving = .{ .non_consumed = 0 }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "end_decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn init(buffer: []u8) SendBuffer {\n        assert(buffer.len >= frame_min_size);\n        return .{\n            .buffer = buffer,\n            .state = .idle,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encoder from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn encoder(self: *SendBuffer) *Encoder {\n        switch (self.state) {\n            .idle => {\n                self.state = .{ .writing = Encoder.init(self.buffer) }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "encoder",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to flush from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn flush(self: *SendBuffer) []const u8 {\n        switch (self.state) {\n            .idle, .sending => unreachable,\n            .writing => |*current| {\n                assert(current.index > 0);\n                const size = current.index;\n                self.state = .{ .sending = .{\n                    .size = size,\n                    .progress = 0,\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "flush",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to remaining from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn remaining(self: *SendBuffer, written_bytes: usize) ?[]const u8 {\n        switch (self.state) {\n            .idle, .writing => unreachable,\n            .sending => |*send_state| {\n                send_state.progress += written_bytes;\n                if (send_state.progress == send_state.size) {\n                    self.state = .idle;\n                    return null;\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "remaining",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to log_table from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn log_table(name: []const u8, table: Decoder.Table) Decoder.Error!void {\n    var iterator = table.iterator();\n    while (try iterator.next()) |entry| {\n        switch (entry.value) {\n            .string => |str| log.info(\"{s}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "log_table",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn init(allocator: std.mem.Allocator, capacity: u32) !Confirms {\n        assert(capacity > 0);\n        const processed = try std.DynamicBitSetUnmanaged.initEmpty(allocator, capacity);\n        return .{\n            .state = .{ .idle = .{ .sequence = 1 }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn deinit(self: *Confirms, allocator: std.mem.Allocator) void {\n        assert(self.state == .idle);\n        assert(self.processed.count() == 0);\n        self.processed.deinit(allocator);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wait from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn wait(self: *Confirms, count: u32) void {\n        assert(count > 0);\n        assert(count <= self.processed.capacity());\n        assert(self.processed.count() == 0);\n        assert(self.state == .idle);\n\n        const sequence = self.state.idle.sequence;\n        assert(sequence > 0);\n        self.state = .{ .waiting = .{\n            .count = count,\n            .sequence_initial = sequence,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "wait",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to confirm from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "fn confirm(self: *Confirms, ack: std.meta.TagPayload(spec.ClientMethod, .basic_ack)) bool {\n        assert(self.state == .waiting);\n\n        const state = self.state.waiting;\n        assert(state.count > 0);\n        assert(state.sequence_initial > 0);\n\n        // The server must not use a zero value for delivery tags.\n        // Zero is reserved for client use, meaning \"all messages so far received\".\n        // https://www.rabbitmq.com/docs/specification#rules\n        assert(ack.delivery_tag > 0);\n        assert(ack.delivery_tag >= state.sequence_initial);\n        assert(ack.delivery_tag < state.sequence_initial + state.count);\n\n        const range: std.bit_set.Range = range: {\n            const index = ack.delivery_tag - state.sequence_initial;\n            // Published messages will be confirmed only once.\n            assert(!self.processed.isSet(index));\n            const start: usize = start: {\n                if (!ack.multiple) break :start index; // Single message.\n\n                // Finds the first unconfirmed delivery tag to acknowledge\n                // all pending messages up to `ack.delivery_tag`.\n                var iterator = self.processed.iterator(.{\n                    .direction = .forward,\n                    .kind = .unset,\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "function",
      "name": "confirm",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Client from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "pub const Client = struct {\n    pub const Callback = *const fn (self: *Client) void;\n    pub const GetMessagePropertiesCallback = *const fn (\n        self: *Client,\n        result: ?GetMessagePropertiesResult,\n    ) Decoder.Error!void;\n    pub const GetMessageBodyCallback = *const fn (\n        self: *Client,\n        body: []const u8,\n    ) Decoder.Error!void;\n\n    io: *IO,\n    fd: IO.socket_t = IO.INVALID_SOCKET,\n    reply_timeout_ticks: u64,\n\n    receive_buffer: ReceiveBuffer,\n    receive_completion: IO.Completion = undefined,\n\n    send_buffer: SendBuffer,\n    send_completion: IO.Completion = undefined,\n\n    heartbeat: union(enum) {\n        idle,\n        sending: IO.Completion,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "struct",
      "name": "Client",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ReceiveBuffer from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const ReceiveBuffer = struct {\n    buffer: []u8,\n    state: union(enum) {\n        idle,\n        receiving: struct {\n            non_consumed: usize,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "struct",
      "name": "ReceiveBuffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to SendBuffer from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const SendBuffer = struct {\n    buffer: []u8,\n    state: union(enum) {\n        idle,\n        writing: Encoder,\n        sending: struct {\n            size: usize,\n            progress: usize,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "struct",
      "name": "SendBuffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Confirms from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const Confirms = struct {\n    processed: std.DynamicBitSetUnmanaged,\n    state: union(enum) {\n        idle: struct {\n            sequence: u64,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "struct",
      "name": "Confirms",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to plain_auth from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const plain_auth: types.SASLPlainAuth = .{\n                    .user_name = connection_options.user_name,\n                    .password = connection_options.password,\n                };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "plain_auth",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to method from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const method: spec.ServerMethod = .{ .connection_start_ok = .{\n                    .client_properties = connection_options.properties.table(),\n                    .mechanism = types.SASLPlainAuth.mechanism,\n                    .response = plain_auth.response(),\n                    .locale = connection_options.locale orelse first: {\n                        var iterator = std.mem.splitScalar(u8, args.locales, ' ');",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "method",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to method_open from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const method_open: spec.ServerMethod = .{ .connection_open = .{\n                    .virtual_host = connection_options.vhost,\n                } };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "method_open",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to method from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const method: spec.ServerMethod = .{ .channel_open = .{} };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "method",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to method from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const method: spec.ServerMethod = .{ .confirm_select = .{ .nowait = false } };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "method",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to method from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const method: spec.ServerMethod = .{\n            .exchange_declare = .{\n                .exchange = options.exchange,\n                .internal = options.internal,\n                .passive = options.passive,\n                .durable = options.durable,\n                .type = options.type,\n                .auto_delete = options.auto_delete,\n                .no_wait = false, // Always await the reply.\n                .arguments = null,\n            },\n        };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "method",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to method from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const method: spec.ServerMethod = .{\n            .queue_declare = .{\n                .queue = options.queue,\n                .passive = options.passive,\n                .durable = options.durable,\n                .exclusive = options.exclusive,\n                .auto_delete = options.auto_delete,\n                .no_wait = false, // Always await the reply.\n                .arguments = options.arguments.table(),\n            },\n        };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "method",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to method from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const method: spec.ServerMethod = .{ .basic_publish = .{\n            .exchange = options.exchange,\n            .routing_key = options.routing_key,\n            .mandatory = options.mandatory,\n            .immediate = options.immediate,\n        } };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "method",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to method from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const method: spec.ServerMethod = .{ .basic_get = .{\n            .queue = options.queue,\n            .no_ack = options.no_ack,\n        } };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "method",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to method from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const method: spec.ServerMethod = .{ .basic_nack = .{\n            .delivery_tag = options.delivery_tag,\n            .requeue = options.requeue,\n            .multiple = options.multiple,\n        } };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "method",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to size from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const size: usize = result catch |err| fatal(\"Network error: {}.\", .{err});",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to error_code from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const error_code: ErrorCodes = @enumFromInt(close_reason.reply_code);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "error_code",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to soft_error from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const soft_error: ErrorCodes = @enumFromInt(basic_return.reply_code);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "soft_error",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to heartbeat_message from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const heartbeat_message: [8]u8 = comptime heartbeat: {\n            var buffer: [8]u8 = undefined;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "heartbeat_message",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to duration_ticks from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const duration_ticks: u64 = switch (self.awaiter) {\n            .none, .send_and_forget => return,\n            .send_and_await_reply => |*awaiter| ticks: {\n                if (awaiter.state == .sending) return;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "duration_ticks",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to range from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const range: std.bit_set.Range = range: {\n            const index = ack.delivery_tag - state.sequence_initial;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "range",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to start from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const start: usize = start: {\n                if (!ack.multiple) break :start index;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to receive_size from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp.zig",
    "response": "const receive_size: usize = prng.range_inclusive(usize, 1, buffer.len - decoded_remain);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp.zig",
      "type": "const",
      "name": "receive_size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reset from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn reset(self: *Iterator) void {\n                self.decoder.reset();\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "reset",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn next(self: *Iterator) Decoder.Error!?struct {\n                key: []const u8,\n                value: FieldValue,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn init(value: []const u8) Table {\n            assert(value.len <= std.math.maxInt(u32));\n            return .{\n                .length = @intCast(value.len),\n                .pointer = value.ptr,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to slice from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn slice(self: Table) []const u8 {\n            return self.pointer[0..self.length];\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "slice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to iterator from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn iterator(self: Table) Iterator {\n            return .{\n                .decoder = Decoder.init(self.slice()),\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "iterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn init(buffer: []const u8) Decoder {\n        return .{\n            .buffer = buffer,\n            .index = 0,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to empty from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn empty(self: *const Decoder) bool {\n        return self.index == self.buffer.len;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "empty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read_int from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn read_int(self: *Decoder, comptime T: type) Error!T {\n        comptime assert(@typeInfo(T) == .int);\n        comptime assert(@typeInfo(T).int.signedness == .unsigned);\n        comptime assert(@sizeOf(T) == 1 or @sizeOf(T) == 2 or @sizeOf(T) == 4 or @sizeOf(T) == 8);\n        if (self.index + @sizeOf(T) > self.buffer.len) return error.BufferExhausted;\n        defer {\n            self.index += @sizeOf(T);\n            assert(self.index <= self.buffer.len);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "read_int",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to read_enum from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn read_enum(self: *Decoder, comptime Enum: type) Error!Enum {\n        comptime assert(@typeInfo(Enum) == .@\"enum\");\n        const Int = std.meta.Tag(Enum);\n        const value = try self.read_int(Int);\n        return std.meta.intToEnum(\n            Enum,\n            value,\n        ) catch |err| switch (err) {\n            error.InvalidEnumTag => return error.Unexpected,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "read_enum",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to read_bool from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn read_bool(self: *Decoder) Error!bool {\n        const value = try self.read_int(u8);\n        return value != 0;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "read_bool",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read_short_string from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn read_short_string(self: *Decoder) Error![]const u8 {\n        const length: u8 = try self.read_int(u8);\n        return try self.read_bytes(length);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "read_short_string",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read_long_string from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn read_long_string(self: *Decoder) Error![]const u8 {\n        const length: u32 = try self.read_int(u32);\n        return try self.read_bytes(length);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "read_long_string",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read_table from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn read_table(self: *Decoder) Error!Table {\n        const length: u32 = try self.read_int(u32);\n        const bytes = try self.read_bytes(length);\n        return Table.init(bytes);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "read_table",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read_bytes from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "fn read_bytes(self: *Decoder, length: u32) Error![]const u8 {\n        assert(self.index <= self.buffer.len);\n        if (self.index + length > self.buffer.len) return error.BufferExhausted;\n        defer {\n            self.index += length;\n            assert(self.index <= self.buffer.len);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "read_bytes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read_field from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn read_field(self: *Decoder) Error!FieldValue {\n        const tag = try self.read_enum(FieldValueTag);\n        const value: FieldValue = switch (tag) {\n            .boolean => .{ .boolean = try self.read_bool() }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "read_field",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read_frame_header from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn read_frame_header(self: *Decoder) Error!FrameHeader {\n        return .{\n            .type = try self.read_enum(FrameType),\n            .channel = try self.read_enum(Channel),\n            .size = try self.read_int(u32),\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "read_frame_header",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read_frame_end from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn read_frame_end(self: *Decoder) Error!void {\n        _ = try self.read_enum(FrameEnd);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "read_frame_end",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read_method_header from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn read_method_header(self: *Decoder) Error!MethodHeader {\n        return .{\n            .class = try self.read_int(u16),\n            .method = try self.read_int(u16),\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "read_method_header",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read_header from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn read_header(self: *Decoder, frame_size: usize) Error!Header {\n        const initial_index = self.index;\n\n        const class = try self.read_int(u16);\n        const weight = try self.read_int(u16);\n        const body_size = try self.read_int(u64);\n        const property_flags = try self.read_int(u16);\n\n        if (initial_index + frame_size > self.buffer.len) return error.BufferExhausted;\n        const properties = self.buffer[self.index .. initial_index + frame_size];\n        self.index += properties.len;\n\n        try self.read_frame_end();\n\n        return .{\n            .class = class,\n            .weight = weight,\n            .body_size = body_size,\n            .property_flags = @bitCast(property_flags),\n            .properties = properties,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "read_header",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read_body from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn read_body(self: *Decoder, frame_size: usize) Error![]const u8 {\n        if (self.index + frame_size > self.buffer.len) return error.BufferExhausted;\n        const body = self.buffer[self.index..][0..frame_size];\n        self.index += frame_size;\n        assert(self.index <= self.buffer.len);\n        try self.read_frame_end();\n        return body;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "read_body",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn write(self: Table, encoder: *TableEncoder) void {\n            self.vtable.write(self.context, encoder);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "write",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn write(self: Body, buffer: []u8) usize {\n            return self.vtable.write(self.context, buffer);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "write",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to put from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn put(self: *TableEncoder, key: []const u8, value: FieldValue) void {\n            self.encoder.write_short_string(key);\n            self.encoder.write_field(value);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "put",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn init(buffer: []u8) Encoder {\n        return .{\n            .buffer = buffer,\n            .index = 0,\n            .frame_reference = null,\n            .header_reference = null,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_int from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn write_int(self: *Encoder, comptime T: type, value: T) void {\n        comptime assert(@typeInfo(T) == .int);\n        comptime assert(@sizeOf(T) == 1 or @sizeOf(T) == 2 or @sizeOf(T) == 4 or @sizeOf(T) == 8);\n        assert(self.index + @sizeOf(T) <= self.buffer.len);\n        std.mem.writeInt(T, self.buffer[self.index..][0..@sizeOf(T)], value, .big);\n        self.index += @sizeOf(T);\n        assert(self.index <= self.buffer.len);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "write_int",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_bool from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn write_bool(self: *Encoder, value: bool) void {\n        self.write_int(u8, @intFromBool(value));\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "write_bool",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_short_string from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn write_short_string(self: *Encoder, value: []const u8) void {\n        assert(value.len <= std.math.maxInt(u8));\n        self.write_int(u8, @intCast(value.len));\n        assert(self.index + value.len <= self.buffer.len);\n        stdx.copy_left(.inexact, u8, self.buffer[self.index..], value);\n        self.index += value.len;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "write_short_string",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_long_string from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn write_long_string(self: *Encoder, value: []const u8) void {\n        assert(value.len <= std.math.maxInt(u32));\n        self.write_int(u32, @intCast(value.len));\n        assert(self.index + value.len <= self.buffer.len);\n        stdx.copy_left(.inexact, u8, self.buffer[self.index..], value);\n        self.index += value.len;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "write_long_string",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_long_string_body from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn write_long_string_body(self: *Encoder, body: ?Body) void {\n        if (body == null) {\n            self.write_int(u32, 0); // Zero sized string.\n            return;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "write_long_string_body",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_table from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn write_table(self: *Encoder, table: ?Table) void {\n        if (table == null) {\n            self.write_int(u32, 0); // Zero sized table.\n            return;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "write_table",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_field from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn write_field(self: *Encoder, field: FieldValue) void {\n        const tag: FieldValueTag = field;\n        self.write_int(u8, @intFromEnum(tag));\n        switch (field) {\n            .boolean => |value| self.write_bool(value),\n            .uint8 => |value| self.write_int(u8, value),\n            .int8 => |value| self.write_int(u8, @bitCast(value)),\n            .uint16 => |value| self.write_int(u16, value),\n            .int16 => |value| self.write_int(u16, @bitCast(value)),\n            .uint32 => |value| self.write_int(u32, value),\n            .int32 => |value| self.write_int(u32, @bitCast(value)),\n            .int64 => |value| self.write_int(u64, @bitCast(value)),\n            .string => |value| self.write_long_string(value),\n            .timestamp => |value| self.write_int(u64, value),\n            .field_table => |value| self.write_table(value),\n            .void => {}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "write_field",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_bytes from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn write_bytes(self: *Encoder, bytes: []const u8) void {\n        assert(bytes.len > 0);\n        assert(self.index + bytes.len <= self.buffer.len);\n        stdx.copy_disjoint(.inexact, u8, self.buffer[self.index..], bytes);\n        self.index += bytes.len;\n        assert(self.index <= self.buffer.len);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "write_bytes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to begin_frame from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn begin_frame(self: *Encoder, frame_header: FrameHeader) void {\n        assert(self.frame_reference == null);\n        assert(self.header_reference == null or frame_header.type == .body);\n        // Reserve the frame header bytes to be updated by `finish_frame()`.\n        assert(self.index + FrameHeader.size_total <= self.buffer.len);\n        const frame_header_index = self.index;\n        self.index += FrameHeader.size_total;\n        self.frame_reference = .{\n            .index = frame_header_index,\n            .frame_header = frame_header,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "begin_frame",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to finish_frame from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn finish_frame(self: *Encoder, frame_type: FrameType) void {\n        assert(self.frame_reference != null);\n        assert(self.frame_reference.?.frame_header.type == frame_type);\n        maybe(self.header_reference == null);\n\n        const reference = self.frame_reference.?;\n        self.frame_reference = null;\n        assert(reference.index + FrameHeader.size_total <= self.index);\n        const restore_index = self.index;\n        // The frame size field in the FrameHeader must be updated.\n        // It represents the payload size, excluding the FrameHeader\n        // and the frame end byte.\n        const size: u32 = @intCast(restore_index - reference.index - FrameHeader.size_total);\n        self.index = reference.index;\n        self.write_int(u8, @intFromEnum(reference.frame_header.type));\n        self.write_int(u16, @intFromEnum(reference.frame_header.channel));\n        self.write_int(u32, size);\n\n        self.index = restore_index;\n        self.write_int(u8, spec.FRAME_END);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "finish_frame",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to begin_header from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn begin_header(self: *Encoder, header: Header) void {\n        // Reserve the frame header bytes to be updated by `finish_header()`.\n        assert(self.frame_reference != null);\n        assert(self.frame_reference.?.frame_header.type == .header);\n        assert(self.header_reference == null);\n        const header_index = self.index;\n        self.index += Header.size_total;\n        self.header_reference = .{\n            .header = header,\n            .index = header_index,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "begin_header",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to finish_header from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn finish_header(self: *Encoder, body_size: u64) void {\n        assert((body_size == 0) == (self.frame_reference == null));\n        assert(body_size == 0 or self.frame_reference.?.frame_header.type == .body);\n        assert(self.header_reference != null);\n\n        const reference = self.header_reference.?;\n        self.header_reference = null;\n        assert(reference.index + Header.size_total <= self.index);\n        const restore_index = self.index;\n        self.index = reference.index;\n        self.write_int(u16, reference.header.class);\n        self.write_int(u16, reference.header.weight);\n        self.write_int(u64, body_size);\n        self.index = restore_index;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "finish_header",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_method_header from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn write_method_header(self: *Encoder, method_header: MethodHeader) void {\n        assert(self.frame_reference != null);\n        assert(self.frame_reference.?.frame_header.type == .method);\n        assert(self.header_reference == null);\n        self.write_int(u16, method_header.class);\n        self.write_int(u16, method_header.method);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "write_method_header",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to FieldValueType from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "fn FieldValueType(comptime target: enum { encode, decode }) type {\n    return union(FieldValueTag) {\n        boolean: bool,\n        uint8: u8,\n        int8: i8,\n        uint16: u16,\n        int16: i16,\n        uint32: u32,\n        int32: i32,\n        int64: i64,\n        string: []const u8,\n        timestamp: u64,\n        field_table: switch (target) {\n            .encode => Encoder.Table,\n            .decode => Decoder.Table,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "FieldValueType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to BasicPropertiesType from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "fn BasicPropertiesType(comptime target: enum { encode, decode }) type {\n    return struct {\n        const BasicProperties = @This();\n\n        /// MIME content type of the message payload.\n        content_type: ?[]const u8 = null,\n        /// MIME content encoding of the message payload.\n        content_encoding: ?[]const u8 = null,\n        /// Application-defined custom headers.\n        headers: ?switch (target) {\n            .encode => Encoder.Table,\n            .decode => Decoder.Table,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "BasicPropertiesType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to property_flags from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "fn property_flags(self: *const BasicProperties) u16 {\n            var bitset: stdx.BitSetType(16) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "property_flags",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn decode(flags: u16, content: []const u8) Decoder.Error!BasicProperties {\n            comptime assert(target == .decode);\n\n            var reader = Decoder.init(content);\n            var bitset: stdx.BitSetType(16) = .{ .bits = @bitReverse(flags) }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn encode(self: *const BasicProperties, encoder: *Encoder) void {\n            comptime assert(target == .encode);\n\n            encoder.write_int(u16, self.property_flags());\n            inline for (std.meta.fields(BasicProperties)) |field| {\n                if (@field(self, field.name)) |value| {\n                    switch (@TypeOf(value)) {\n                        []const u8 => encoder.write_short_string(value),\n                        Encoder.Table => encoder.write_table(value),\n                        DeliveryMode => encoder.write_int(u8, @intFromEnum(value)),\n                        u64 => encoder.write_int(u64, value),\n                        u8 => encoder.write_int(u8, value),\n                        else => unreachable,\n                    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fatal from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn fatal(comptime format: []const u8, args: anytype) noreturn {\n    const log = std.log.scoped(.amqp);\n    log.err(format, args);\n\n    const vsr = @import(\"../../vsr.zig\");\n    const status = vsr.FatalReason.cli.exit_status();\n    assert(status != 0);\n    std.process.exit(status);\n}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "fatal",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to set_flag from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "fn set_flag(set_field: std.meta.FieldEnum(BasicProperties)) u16 {\n            var properties: BasicProperties = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "set_flag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to table from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "fn table(self: *const TestingTable) Encoder.Table {\n        const vtable: Encoder.Table.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, encoder: *Encoder.TableEncoder) void {\n                    const object: *const TestingTable = @ptrCast(@alignCast(context));\n                    inline for (std.meta.fields(TestingTable)) |field| {\n                        if (@field(object, field.name)) |value| {\n                            encoder.put(field.name, switch (std.meta.Child(field.type)) {\n                                bool => .{ .boolean = value }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "table",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to from_table from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "fn from_table(arena: std.mem.Allocator, decoder: Decoder.Table) !*const TestingTable {\n        var object = try arena.create(TestingTable);\n        object.* = TestingTable.empty;\n\n        var iterator = decoder.iterator();\n        while (try iterator.next()) |entry| {\n            const FieldEnum = std.meta.FieldEnum(TestingTable);\n            const entry_field = std.meta.stringToEnum(FieldEnum, entry.key).?;\n            switch (entry_field) {\n                inline else => |field| {\n                    const Field = @FieldType(TestingTable, @tagName(field));\n                    @field(object, @tagName(field)) = switch (std.meta.Child(Field)) {\n                        bool => entry.value.boolean,\n                        []const u8 => entry.value.string,\n                        i64 => entry.value.int64,\n                        u32 => entry.value.uint32,\n                        i32 => entry.value.int32,\n                        u16 => entry.value.uint16,\n                        i16 => entry.value.int16,\n                        u8 => entry.value.uint8,\n                        i8 => entry.value.int8,\n                        *const TestingTable => try from_table(arena, entry.value.field_table),\n                        Timestamp => @intCast(entry.value.timestamp),\n                        else => comptime unreachable,\n                    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "from_table",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "fn eql(table1: *const TestingTable, table2: *const TestingTable) bool {\n        inline for (std.meta.fields(TestingTable)) |field| {\n            const both_null = @field(table1, field.name) == null and\n                @field(table2, field.name) == null;\n            if (!both_null) {\n                const value1 = @field(table1, field.name) orelse return false;\n                const value2 = @field(table2, field.name) orelse return false;\n\n                const equals = switch (std.meta.Child(field.type)) {\n                    bool => value1 == value2,\n                    []const u8 => std.mem.eql(u8, value1, value2),\n                    i64, u32, i32, u16, i16, u8, i8 => value1 == value2,\n                    *const TestingTable => eql(value1, value2),\n                    Timestamp => value1 == value2,\n                    else => comptime unreachable,\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to random from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "fn random(options: struct {\n        arena: std.mem.Allocator,\n        prng: *stdx.PRNG,\n        recursive: bool,\n    }) !*const TestingTable {\n        const ratio = stdx.PRNG.ratio;\n\n        const is_empty = options.prng.chance(ratio(5, 100));\n        if (is_empty) return &TestingTable.empty;\n\n        var object = try options.arena.create(TestingTable);\n        inline for (std.meta.fields(TestingTable)) |field| {\n            const is_null = options.prng.chance(ratio(5, 100));\n            if (is_null) {\n                @field(object, field.name) = null;\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "random",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to random from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn random(options: struct {\n        arena: std.mem.Allocator,\n        prng: *stdx.PRNG,\n        default: Encoder.BasicProperties = .{},\n    }) !Encoder.BasicProperties {\n        const is_null = stdx.PRNG.ratio(5, 100);\n        var properties: Encoder.BasicProperties = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "random",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub fn eql(\n        arena: std.mem.Allocator,\n        properties1: Encoder.BasicProperties,\n        properties2: Decoder.BasicProperties,\n    ) !bool {\n        inline for (std.meta.fields(Encoder.BasicProperties)) |field| {\n            const both_null = @field(properties1, field.name) == null and\n                @field(properties2, field.name) == null;\n            if (!both_null) {\n                const value1 = @field(properties1, field.name) orelse return false;\n                const value2 = @field(properties2, field.name) orelse return false;\n\n                const equals = switch (std.meta.Child(field.type)) {\n                    []const u8 => std.mem.eql(u8, value1, value2),\n                    u64, u8 => value1 == value2,\n                    DeliveryMode => value1 == value2,\n                    Encoder.Table => eql: {\n                        const encoded_object: *const TestingTable = @ptrCast(@alignCast(\n                            value1.context,\n                        ));\n                        const decoded_object: *const TestingTable = try TestingTable.from_table(\n                            arena,\n                            value2,\n                        );\n                        break :eql TestingTable.eql(encoded_object, decoded_object);\n                    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Decoder from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub const Decoder = struct {\n    pub const Error = error{\n        BufferExhausted,\n        Unexpected,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "struct",
      "name": "Decoder",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Header from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub const Header = struct {\n        class: u16,\n        weight: u16,\n        body_size: u64,\n        property_flags: u16,\n        properties: []const u8,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "struct",
      "name": "Header",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Table from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub const Table = struct {\n        pub const Iterator = struct {\n            decoder: Decoder,\n\n            pub fn reset(self: *Iterator) void {\n                self.decoder.reset();\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "struct",
      "name": "Table",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Encoder from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub const Encoder = struct {\n    pub const FrameHeader = struct {\n        /// Total size in bytes including the `size` field.\n        pub const size_total = @sizeOf(@FieldType(Decoder.FrameHeader, \"type\")) +\n            @sizeOf(@FieldType(Decoder.FrameHeader, \"channel\")) +\n            @sizeOf(@FieldType(Decoder.FrameHeader, \"size\"));\n\n        type: FrameType,\n        channel: Channel,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "struct",
      "name": "Encoder",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Header from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub const Header = struct {\n        /// Total size in bytes including the `body_size` field.\n        pub const size_total = @sizeOf(@FieldType(Decoder.Header, \"class\")) +\n            @sizeOf(@FieldType(Decoder.Header, \"weight\")) +\n            @sizeOf(@FieldType(Decoder.Header, \"body_size\"));\n\n        class: u16,\n        weight: u16,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "struct",
      "name": "Header",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Table from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub const Table = struct {\n        pub const VTable = struct {\n            write: *const fn (*const anyopaque, *TableEncoder) void,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "struct",
      "name": "Table",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Body from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub const Body = struct {\n        pub const VTable = struct {\n            write: *const fn (*const anyopaque, []u8) usize,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "struct",
      "name": "Body",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to TableEncoder from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub const TableEncoder = struct {\n        encoder: *Encoder,\n\n        pub fn put(self: *TableEncoder, key: []const u8, value: FieldValue) void {\n            self.encoder.write_short_string(key);\n            self.encoder.write_field(value);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "struct",
      "name": "TableEncoder",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to set_flag from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "const set_flag = struct {\n        fn set_flag(set_field: std.meta.FieldEnum(BasicProperties)) u16 {\n            var properties: BasicProperties = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "struct",
      "name": "set_flag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to TestingTable from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "const TestingTable = struct {\n    const Timestamp = u63;\n\n    boolean: ?bool = null,\n    string: ?[]const u8 = null,\n    int64: ?i64 = null,\n    uint32: ?u32 = null,\n    int32: ?i32 = null,\n    uint16: ?u16 = null,\n    int16: ?i16 = null,\n    uint8: ?u8 = null,\n    int8: ?i8 = null,\n    field_table: ?*const TestingTable = null,\n    timestamp: ?Timestamp = null,\n\n    const empty: TestingTable = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "struct",
      "name": "TestingTable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to TestingBasicProperties from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub const TestingBasicProperties = struct {\n    pub fn random(options: struct {\n        arena: std.mem.Allocator,\n        prng: *stdx.PRNG,\n        default: Encoder.BasicProperties = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "struct",
      "name": "TestingBasicProperties",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to protocol_header from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "pub const protocol_header: *const [8]u8 = \"AMQP\" ++ [_]u8{\n    0,\n    version.major,\n    version.minor,\n    version.revision,\n};",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "const",
      "name": "protocol_header",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to length from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "const length: u8 = try self.read_int(u8);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "const",
      "name": "length",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to length from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "const length: u32 = try self.read_int(u32);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "const",
      "name": "length",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to length from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "const length: u32 = try self.read_int(u32);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "const",
      "name": "length",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to size from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "const size: u32 = @intCast(end_index - start_index - @sizeOf(u32));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "const",
      "name": "size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to size from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "const size: u32 = @intCast(end_index - start_index - @sizeOf(u32));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "const",
      "name": "size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to tag from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "const tag: FieldValueTag = field;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "const",
      "name": "tag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to size from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "const size: u32 = @intCast(restore_index - reference.index - FrameHeader.size_total);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "const",
      "name": "size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to empty from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "const empty: BasicProperties = .{};",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "const",
      "name": "empty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to empty from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "const empty: TestingTable = .{};",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "const",
      "name": "empty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to vtable from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "const vtable: Encoder.Table.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, encoder: *Encoder.TableEncoder) void {\n                    const object: *const TestingTable = @ptrCast(@alignCast(context));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "const",
      "name": "vtable",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to encoded_object from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "const encoded_object: *const TestingTable = @ptrCast(@alignCast(\n                            value1.context,\n                        ));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "const",
      "name": "encoded_object",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to decoded_object from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/protocol.zig",
    "response": "const decoded_object: *const TestingTable = try TestingTable.from_table(\n                            arena,\n                            value2,\n                        );",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/protocol.zig",
      "type": "const",
      "name": "decoded_object",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const version_major = try decoder.read_int(u8);\n            const version_minor = try decoder.read_int(u8);\n            const server_properties = try decoder.read_table();\n            const mechanisms = try decoder.read_long_string();\n            const locales = try decoder.read_long_string();\n\n            return .{\n                .version_major = version_major,\n                .version_minor = version_minor,\n                .server_properties = server_properties,\n                .mechanisms = mechanisms,\n                .locales = locales,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const challenge = try decoder.read_long_string();\n\n            return .{\n                .challenge = challenge,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const channel_max = try decoder.read_int(u16);\n            const frame_max = try decoder.read_int(u32);\n            const heartbeat = try decoder.read_int(u16);\n\n            return .{\n                .channel_max = channel_max,\n                .frame_max = frame_max,\n                .heartbeat = heartbeat,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const reserved_1 = try decoder.read_short_string();\n\n            return .{\n                .reserved_1 = reserved_1,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const reply_code = try decoder.read_int(u16);\n            const reply_text = try decoder.read_short_string();\n            const class_id = try decoder.read_int(u16);\n            const method_id = try decoder.read_int(u16);\n\n            return .{\n                .reply_code = reply_code,\n                .reply_text = reply_text,\n                .class_id = class_id,\n                .method_id = method_id,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            _ = decoder;\n            return .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const reason = try decoder.read_short_string();\n\n            return .{\n                .reason = reason,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            _ = decoder;\n            return .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const new_secret = try decoder.read_long_string();\n            const reason = try decoder.read_short_string();\n\n            return .{\n                .new_secret = new_secret,\n                .reason = reason,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const reserved_1 = try decoder.read_long_string();\n\n            return .{\n                .reserved_1 = reserved_1,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const reply_code = try decoder.read_int(u16);\n            const reply_text = try decoder.read_short_string();\n            const class_id = try decoder.read_int(u16);\n            const method_id = try decoder.read_int(u16);\n\n            return .{\n                .reply_code = reply_code,\n                .reply_text = reply_text,\n                .class_id = class_id,\n                .method_id = method_id,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            _ = decoder;\n            return .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            _ = decoder;\n            return .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            _ = decoder;\n            return .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            _ = decoder;\n            return .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            _ = decoder;\n            return .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const queue = try decoder.read_short_string();\n            const message_count = try decoder.read_int(u32);\n            const consumer_count = try decoder.read_int(u32);\n\n            return .{\n                .queue = queue,\n                .message_count = message_count,\n                .consumer_count = consumer_count,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            _ = decoder;\n            return .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            _ = decoder;\n            return .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const message_count = try decoder.read_int(u32);\n\n            return .{\n                .message_count = message_count,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const message_count = try decoder.read_int(u32);\n\n            return .{\n                .message_count = message_count,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            _ = decoder;\n            return .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const consumer_tag = try decoder.read_short_string();\n\n            return .{\n                .consumer_tag = consumer_tag,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const consumer_tag = try decoder.read_short_string();\n            const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const consumer_tag = try decoder.read_short_string();\n\n            return .{\n                .consumer_tag = consumer_tag,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const reply_code = try decoder.read_int(u16);\n            const reply_text = try decoder.read_short_string();\n            const exchange = try decoder.read_short_string();\n            const routing_key = try decoder.read_short_string();\n\n            return .{\n                .reply_code = reply_code,\n                .reply_text = reply_text,\n                .exchange = exchange,\n                .routing_key = routing_key,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const consumer_tag = try decoder.read_short_string();\n            const delivery_tag = try decoder.read_int(u64);\n            const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const delivery_tag = try decoder.read_int(u64);\n            const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const reserved_1 = try decoder.read_short_string();\n\n            return .{\n                .reserved_1 = reserved_1,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const delivery_tag = try decoder.read_int(u64);\n            const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            _ = decoder;\n            return .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            const delivery_tag = try decoder.read_int(u64);\n            const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            _ = decoder;\n            return .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            _ = decoder;\n            return .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            _ = decoder;\n            return .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn decode(decoder: *Decoder) Decoder.Error!@This() {\n            _ = decoder;\n            return .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to method_header from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "pub fn method_header(self: ClientMethod) MethodHeader {\n        return @bitCast(@as(u32, @intFromEnum(self)));\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "method_header",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "pub fn decode(header: MethodHeader, decoder: *Decoder) Decoder.Error!ClientMethod {\n        @setEvalBranchQuota(10_000);\n        const tag: Tag = @enumFromInt(@as(u32, @bitCast(header)));\n        const value: ClientMethod = switch (tag) {\n            inline else => |tag_comptime| value: {\n                const Method = std.meta.TagPayload(ClientMethod, tag_comptime);\n                break :value @unionInit(\n                    ClientMethod,\n                    @tagName(tag_comptime),\n                    try Method.decode(decoder),\n                );\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_table(self.client_properties);\n            encoder.write_short_string(self.mechanism);\n            encoder.write_long_string_body(self.response);\n            encoder.write_short_string(self.locale);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_long_string_body(self.response);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u16, self.channel_max);\n            encoder.write_int(u32, self.frame_max);\n            encoder.write_int(u16, self.heartbeat);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_short_string(self.virtual_host);\n            encoder.write_short_string(self.reserved_1);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u16, self.reply_code);\n            encoder.write_short_string(self.reply_text);\n            encoder.write_int(u16, self.class_id);\n            encoder.write_int(u16, self.method_id);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            _ = self;\n            _ = encoder;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_short_string(self.reason);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            _ = self;\n            _ = encoder;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            _ = self;\n            _ = encoder;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_short_string(self.reserved_1);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u16, self.reply_code);\n            encoder.write_short_string(self.reply_text);\n            encoder.write_int(u16, self.class_id);\n            encoder.write_int(u16, self.method_id);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            _ = self;\n            _ = encoder;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u16, self.reserved_1);\n            encoder.write_short_string(self.exchange);\n            encoder.write_short_string(self.type);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u16, self.reserved_1);\n            encoder.write_short_string(self.exchange);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u16, self.reserved_1);\n            encoder.write_short_string(self.destination);\n            encoder.write_short_string(self.source);\n            encoder.write_short_string(self.routing_key);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u16, self.reserved_1);\n            encoder.write_short_string(self.destination);\n            encoder.write_short_string(self.source);\n            encoder.write_short_string(self.routing_key);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u16, self.reserved_1);\n            encoder.write_short_string(self.queue);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u16, self.reserved_1);\n            encoder.write_short_string(self.queue);\n            encoder.write_short_string(self.exchange);\n            encoder.write_short_string(self.routing_key);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u16, self.reserved_1);\n            encoder.write_short_string(self.queue);\n            encoder.write_short_string(self.exchange);\n            encoder.write_short_string(self.routing_key);\n            encoder.write_table(self.arguments);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u16, self.reserved_1);\n            encoder.write_short_string(self.queue);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u16, self.reserved_1);\n            encoder.write_short_string(self.queue);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u32, self.prefetch_size);\n            encoder.write_int(u16, self.prefetch_count);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u16, self.reserved_1);\n            encoder.write_short_string(self.queue);\n            encoder.write_short_string(self.consumer_tag);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_short_string(self.consumer_tag);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_short_string(self.consumer_tag);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u16, self.reserved_1);\n            encoder.write_short_string(self.exchange);\n            encoder.write_short_string(self.routing_key);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u16, self.reserved_1);\n            encoder.write_short_string(self.queue);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u64, self.delivery_tag);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u64, self.delivery_tag);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            encoder.write_int(u64, self.delivery_tag);\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            _ = self;\n            _ = encoder;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            _ = self;\n            _ = encoder;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            _ = self;\n            _ = encoder;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "fn encode(self: *const @This(), encoder: *Encoder) void {\n            var bitset_1: stdx.BitSetType(8) = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to method_header from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "pub fn method_header(self: ServerMethod) MethodHeader {\n        return @bitCast(@as(u32, @intFromEnum(self)));\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "method_header",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "pub fn encode(self: ServerMethod, channel: Channel, encoder: *Encoder) void {\n        encoder.begin_frame(.{\n            .type = .method,\n            .channel = channel,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to bitset_1 from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "const",
      "name": "bitset_1",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to bitset_1 from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "const",
      "name": "bitset_1",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to bitset_1 from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "const",
      "name": "bitset_1",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to bitset_1 from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "const",
      "name": "bitset_1",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to bitset_1 from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "const",
      "name": "bitset_1",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to bitset_1 from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "const",
      "name": "bitset_1",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to bitset_1 from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "const",
      "name": "bitset_1",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to tag from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "const tag: Tag = @enumFromInt(@as(u32, @bitCast(header)));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "const",
      "name": "tag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to value from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/spec.zig",
    "response": "const value: ClientMethod = switch (tag) {\n            inline else => |tag_comptime| value: {\n                const Method = std.meta.TagPayload(ClientMethod, tag_comptime);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/spec.zig",
      "type": "const",
      "name": "value",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to table from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "pub fn table(self: *const ConnectionProperties) Encoder.Table {\n        const vtable: Encoder.Table.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, encoder: *Encoder.TableEncoder) void {\n                    const properties: *const ConnectionProperties = @ptrCast(@alignCast(context));\n                    inline for (std.meta.fields(ConnectionProperties)) |field| {\n                        const value = @field(properties, field.name);\n                        encoder.put(field.name, switch (field.type) {\n                            []const u8 => .{ .string = value }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "function",
      "name": "table",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to table from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "pub fn table(self: *const ClientCapabilities) Encoder.Table {\n        const vtable: Encoder.Table.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, encoder: *Encoder.TableEncoder) void {\n                    const capabilities: *const ClientCapabilities = @ptrCast(@alignCast(context));\n                    encoder.put(\"publisher_confirms\", .{\n                        .boolean = capabilities.publisher_confirms,\n                    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "function",
      "name": "table",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to response from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "pub fn response(self: *const SASLPlainAuth) Encoder.Body {\n        const vtable: Encoder.Body.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, buffer: []u8) usize {\n                    const auth: *const SASLPlainAuth = @ptrCast(@alignCast(context));\n                    var fbs = std.io.fixedBufferStream(buffer);\n                    fbs.writer().print(\"\\x00{s}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "function",
      "name": "response",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to table from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "pub fn table(self: *const QueueDeclareArguments) Encoder.Table {\n        const vtable: Encoder.Table.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, encoder: *Encoder.TableEncoder) void {\n                    const arguments: *const QueueDeclareArguments = @ptrCast(@alignCast(context));\n                    inline for (std.meta.fields(QueueDeclareArguments)) |field| {\n                        if (@field(arguments, field.name)) |value| {\n                            const FieldType = @TypeOf(value);\n                            // Keys are follow the pattern \"x-max-length\":\n                            const key = comptime \"x-\" ++ kebab_case(field.name);\n                            switch (FieldType) {\n                                []const u8 => encoder.put(key, .{ .string = value }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "function",
      "name": "table",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to kebab_case from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "fn kebab_case(comptime key: []const u8) []const u8 {\n                    comptime {\n                        var buffer: [key.len]u8 = @as(*const [key.len]u8, @ptrCast(key)).*;\n                        std.mem.replaceScalar(u8, &buffer, '_', '-');\n                        return &buffer;\n                    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "function",
      "name": "kebab_case",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ConnectOptions from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "pub const ConnectOptions = struct {\n    host: std.net.Address,\n    user_name: []const u8,\n    password: []const u8,\n    vhost: []const u8,\n    locale: ?[]const u8 = null,\n    heartbeat_seconds: ?u16 = null,\n    properties: ConnectionProperties = ConnectionProperties.default,\n}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "struct",
      "name": "ConnectOptions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ConnectionProperties from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "pub const ConnectionProperties = struct {\n    product: []const u8,\n    version: []const u8,\n    platform: []const u8,\n    capabilities: *const ClientCapabilities,\n\n    pub const default: ConnectionProperties = .{\n        .product = \"TigerBeetle\",\n        .version = std.fmt.comptimePrint(\n            \"{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "struct",
      "name": "ConnectionProperties",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ClientCapabilities from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "pub const ClientCapabilities = struct {\n    publisher_confirms: bool,\n    exchange_exchange_bindings: bool,\n    basic_nack: bool,\n    consumer_cancel_notify: bool,\n    connection_blocked: bool,\n    consumer_priorities: bool,\n    authentication_failure_close: bool,\n    per_consumer_qos: bool,\n    direct_reply_to: bool,\n\n    pub const default: ClientCapabilities = .{\n        .publisher_confirms = true,\n        .exchange_exchange_bindings = false,\n        .basic_nack = true,\n        .consumer_cancel_notify = false,\n        .connection_blocked = false,\n        .consumer_priorities = false,\n        .authentication_failure_close = true,\n        .per_consumer_qos = false,\n        .direct_reply_to = false,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "struct",
      "name": "ClientCapabilities",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to SASLPlainAuth from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "pub const SASLPlainAuth = struct {\n    pub const mechanism = \"PLAIN\";\n\n    user_name: []const u8,\n    password: []const u8,\n\n    /// Response returns the SASL PLAIN mechanism encoding, delimited by null characters.\n    pub fn response(self: *const SASLPlainAuth) Encoder.Body {\n        const vtable: Encoder.Body.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, buffer: []u8) usize {\n                    const auth: *const SASLPlainAuth = @ptrCast(@alignCast(context));\n                    var fbs = std.io.fixedBufferStream(buffer);\n                    fbs.writer().print(\"\\x00{s}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "struct",
      "name": "SASLPlainAuth",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to BasicPublishOptions from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "pub const BasicPublishOptions = struct {\n    /// Specifies the name of the exchange to publish to. The exchange name can be\n    /// empty, meaning the default exchange. If the exchange name is specified, and that\n    /// exchange does not exist, the server will raise a channel exception.\n    exchange: []const u8,\n    /// Message routing key.\n    /// Specifies the routing key for the message. The routing key is used for routing\n    /// messages depending on the exchange configuration.\n    routing_key: []const u8,\n    /// Indicate mandatory routing.\n    /// This flag tells the server how to react if the message cannot be routed to a\n    /// queue. If this flag is set, the server will return an unroutable message with a\n    /// Return method. If this flag is zero, the server silently drops the message.\n    mandatory: bool,\n    /// Request immediate delivery.\n    /// This flag tells the server how to react if the message cannot be routed to a\n    /// queue consumer immediately. If this flag is set, the server will return an\n    /// undeliverable message with a Return method. If this flag is zero, the server\n    /// will queue the message, but with no guarantee that it will ever be consumed.\n    immediate: bool,\n    /// Metadata associated with the message.\n    properties: Encoder.BasicProperties,\n    /// The message payload.\n    body: ?Encoder.Body,\n}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "struct",
      "name": "BasicPublishOptions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to GetMessageOptions from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "pub const GetMessageOptions = struct {\n    /// Specifies the name of the queue to get a message from.\n    queue: []const u8,\n    /// When `true`, indicates that the message does not require an acknowledgment\n    /// and will be instantly acknowledged upon delivery.\n    no_ack: bool,\n}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "struct",
      "name": "GetMessageOptions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to GetMessagePropertiesResult from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "pub const GetMessagePropertiesResult = struct {\n    /// Delivery tag used to acknowledge or reject the message.\n    delivery_tag: u64,\n    /// The number of messages still available in the queue.\n    message_count: u32,\n    /// Basic properties including custom headers.\n    properties: Decoder.BasicProperties,\n    /// Indicates whether the message includes a body frame.\n    has_body: bool,\n}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "struct",
      "name": "GetMessagePropertiesResult",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to BasicNackOptions from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "pub const BasicNackOptions = struct {\n    delivery_tag: u64,\n    /// Requeue the message.\n    /// If requeue is true, the server will attempt to requeue the message.\n    requeue: bool,\n    /// Reject multiple messages.\n    /// If set to `true`, the delivery tag is treated as \"up to and including\",\n    /// so that multiple messages can be rejected with a single method.\n    /// If set to zero, the delivery tag refers to a single message.\n    /// If the multiple field is `true`, and the delivery tag is `false`,\n    /// this indicates rejection of all outstanding messages.\n    multiple: bool,\n}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "struct",
      "name": "BasicNackOptions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to default from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "pub const default: ConnectionProperties = .{\n        .product = \"TigerBeetle\",\n        .version = std.fmt.comptimePrint(\n            \"{}\",\n            .{vsr.constants.state_machine_config.release},\n        ),\n        // By convention, \"platform\" refers to the programming language.\n        // e.g., Erlang, Java, Go, etc.\n        .platform = \"Zig \" ++ builtin.zig_version_string,\n        .capabilities = &ClientCapabilities.default,\n    };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "const",
      "name": "default",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to vtable from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "const vtable: Encoder.Table.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, encoder: *Encoder.TableEncoder) void {\n                    const properties: *const ConnectionProperties = @ptrCast(@alignCast(context));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "const",
      "name": "vtable",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to default from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "pub const default: ClientCapabilities = .{\n        .publisher_confirms = true,\n        .exchange_exchange_bindings = false,\n        .basic_nack = true,\n        .consumer_cancel_notify = false,\n        .connection_blocked = false,\n        .consumer_priorities = false,\n        .authentication_failure_close = true,\n        .per_consumer_qos = false,\n        .direct_reply_to = false,\n    };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "const",
      "name": "default",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to vtable from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "const vtable: Encoder.Table.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, encoder: *Encoder.TableEncoder) void {\n                    const capabilities: *const ClientCapabilities = @ptrCast(@alignCast(context));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "const",
      "name": "vtable",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to vtable from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "const vtable: Encoder.Body.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, buffer: []u8) usize {\n                    const auth: *const SASLPlainAuth = @ptrCast(@alignCast(context));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "const",
      "name": "vtable",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to vtable from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/amqp/types.zig",
    "response": "const vtable: Encoder.Table.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, encoder: *Encoder.TableEncoder) void {\n                    const arguments: *const QueueDeclareArguments = @ptrCast(@alignCast(context));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/amqp/types.zig",
      "type": "const",
      "name": "vtable",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn callback(context: *amqp.Client) void {\n                    const runner: *Runner = @alignCast(@fieldParentPtr(\"amqp_client\", context));\n                    assert(!runner.connected.amqp);\n                    maybe(runner.connected.vsr);\n                    log.info(\"AMQP connected.\", .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub fn deinit(self: *Runner, allocator: std.mem.Allocator) void {\n        self.amqp_client.deinit(allocator);\n        self.vsr_client.deinit(allocator);\n        self.message_pool.deinit(allocator);\n        self.io.deinit();\n        self.buffer.deinit(allocator);\n        allocator.free(self.locker_queue);\n        allocator.free(self.progress_tracker_queue);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to recover from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn recover(self: *Runner) void {\n        assert(self.connected.amqp);\n        assert(self.state == .unknown);\n        const recovery_mode = self.state.unknown;\n        const timestamp_override: ?u64 = switch (recovery_mode) {\n            .recover => null,\n            .override => |timestamp| timestamp,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "recover",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to recover_dispatch from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn recover_dispatch(self: *Runner) void {\n        assert(self.connected.amqp);\n        assert(self.state == .recovering);\n        switch (self.state.recovering.phase) {\n            // Check whether the exchange exists.\n            // Declaring the exchange with `passive==true` only asserts if it already exists.\n            .validate_exchange => {\n                assert(self.publish_exchange.len > 0);\n                maybe(self.state.recovering.timestamp_last == null);\n\n                self.amqp_client.exchange_declare(\n                    &struct {\n                        fn callback(context: *amqp.Client) void {\n                            const runner: *Runner = @alignCast(@fieldParentPtr(\n                                \"amqp_client\",\n                                context,\n                            ));\n                            assert(runner.state == .recovering);\n                            const recovering = &runner.state.recovering;\n                            assert(recovering.phase == .validate_exchange);\n                            maybe(recovering.timestamp_last == null);\n\n                            recovering.phase = .declare_locker_queue;\n                            runner.recover_dispatch();\n                        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "recover_dispatch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn callback(context: *amqp.Client) void {\n                            const runner: *Runner = @alignCast(@fieldParentPtr(\n                                \"amqp_client\",\n                                context,\n                            ));\n                            switch (runner.state) {\n                                .recovering => |*recovering| {\n                                    assert(recovering.phase == .declare_locker_queue);\n                                    maybe(recovering.timestamp_last == null);\n\n                                    recovering.phase = .declare_progress_queue;\n                                    runner.recover_dispatch();\n                                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn callback(context: *amqp.Client) void {\n                            const runner: *Runner = @alignCast(@fieldParentPtr(\n                                \"amqp_client\",\n                                context,\n                            ));\n                            switch (runner.state) {\n                                .recovering => |*recovering| {\n                                    assert(recovering.phase == .declare_progress_queue);\n\n                                    // Overriding the progress-tracking timestamp.\n                                    if (recovering.timestamp_last) |timestamp_override| {\n                                        runner.state = .{\n                                            .last = .{\n                                                .consumer_timestamp = timestamp_override,\n                                                .producer_timestamp = timestamp_override + 1,\n                                            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn callback(\n                            context: *amqp.Client,\n                            found: ?amqp.GetMessagePropertiesResult,\n                        ) amqp.Decoder.Error!void {\n                            const runner: *Runner = @alignCast(@fieldParentPtr(\n                                \"amqp_client\",\n                                context,\n                            ));\n                            switch (runner.state) {\n                                .recovering => |*recovering| {\n                                    assert(recovering.phase == .get_progress_message);\n                                    assert(recovering.timestamp_last == null);\n\n                                    if (found) |result| {\n                                        // Since this queue is declared with `limit == 1`,\n                                        // we don't expect more than one message.\n                                        if (result.message_count > 0) fatal(\n                                            \"Unexpected message_count={}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn callback(context: *amqp.Client) void {\n                        const runner: *Runner = @alignCast(@fieldParentPtr(\n                            \"amqp_client\",\n                            context,\n                        ));\n                        switch (runner.state) {\n                            .recovering => |*recovering| {\n                                assert(recovering.phase == .nack_progress_message);\n                                assert(recovering.timestamp_last != null);\n                                assert(TimestampRange.valid(recovering.timestamp_last.?));\n\n                                const nack = recovering.phase.nack_progress_message;\n                                assert(nack.delivery_tag > 0);\n\n                                runner.state = .{ .last = .{\n                                    .consumer_timestamp = recovering.timestamp_last.?,\n                                    .producer_timestamp = recovering.timestamp_last.? + 1,\n                                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to vsr_register from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn vsr_register(self: *Runner) void {\n        assert(self.connected.amqp);\n        assert(!self.connected.vsr);\n        assert(self.producer == .idle);\n        assert(self.consumer == .idle);\n        assert(self.state == .last);\n\n        // Register the VSR client as the last step to avoid unnecessarily joining the cluster\n        // in case the CDC fails due to connectivity or configuration issues with the AMQP server.\n        self.vsr_client.register(\n            &struct {\n                fn callback(\n                    user_data: u128,\n                    result: *const vsr.RegisterResult,\n                ) void {\n                    const runner: *Runner = @ptrFromInt(@as(usize, @intCast(user_data)));\n                    assert(runner.connected.amqp);\n                    assert(!runner.connected.vsr);\n                    log.info(\"VSR client registered.\", .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "vsr_register",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to produce from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn produce(self: *Runner) void {\n        assert(self.connected.vsr);\n        assert(self.connected.amqp);\n        assert(self.state == .last);\n        assert(TimestampRange.valid(self.state.last.producer_timestamp));\n        assert(self.state.last.consumer_timestamp == 0 or\n            TimestampRange.valid(self.state.last.consumer_timestamp));\n        assert(self.state.last.producer_timestamp > self.state.last.consumer_timestamp);\n        switch (self.producer) {\n            .idle => {\n                if (!self.buffer.producer_begin()) {\n                    // No free buffers (they must be `ready` and `consuming`).\n                    // The running consumer will resume the producer once it finishes.\n                    assert(self.consumer != .idle);\n                    assert(self.buffer.find(.ready) != null);\n                    assert(self.buffer.find(.consuming) != null);\n                    return;\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "produce",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to produce_dispatch from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn produce_dispatch(self: *Runner) void {\n        assert(self.connected.vsr);\n        assert(self.connected.amqp);\n        assert(self.state == .last);\n        assert(TimestampRange.valid(self.state.last.producer_timestamp));\n        assert(self.state.last.consumer_timestamp == 0 or\n            TimestampRange.valid(self.state.last.consumer_timestamp));\n        assert(self.state.last.producer_timestamp > self.state.last.consumer_timestamp);\n        dispatch: switch (self.producer) {\n            .idle => unreachable,\n            // Check the configured rate limit.\n            .rate_limit => switch (self.rate_limit.attempt()) {\n                .ok => {\n                    self.producer = .request;\n                    continue :dispatch self.producer;\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "produce_dispatch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn callback(\n                                runner: *Runner,\n                                completion: *IO.Completion,\n                                result: IO.TimeoutError!void,\n                            ) void {\n                                result catch unreachable;\n                                _ = completion;\n                                assert(runner.producer == .rate_limit);\n                                assert(runner.buffer.find(.producing) != null);\n                                maybe(runner.consumer == .idle);\n\n                                runner.producer = .request;\n                                runner.produce_dispatch();\n                            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn callback(\n                            runner: *Runner,\n                            completion: *IO.Completion,\n                            result: IO.TimeoutError!void,\n                        ) void {\n                            result catch unreachable;\n                            _ = completion;\n                            assert(runner.buffer.all_free());\n                            assert(runner.consumer == .idle);\n                            assert(runner.producer == .waiting);\n\n                            const producer_begin = runner.buffer.producer_begin();\n                            assert(producer_begin);\n                            runner.producer = .rate_limit;\n                            runner.produce_dispatch();\n                        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to produce_request_callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn produce_request_callback(\n        context: u128,\n        operation_vsr: vsr.Operation,\n        timestamp: u64,\n        result: []u8,\n    ) void {\n        const operation = operation_vsr.cast(Client.StateMachine);\n        assert(operation == .get_change_events);\n        assert(timestamp != 0);\n        const runner: *Runner = @ptrFromInt(@as(usize, @intCast(context)));\n        assert(runner.producer == .request);\n\n        const source: []const tb.ChangeEvent = stdx.bytes_as_slice(.exact, tb.ChangeEvent, result);\n        const target: []tb.ChangeEvent = runner.buffer.get_producer_buffer();\n        assert(source.len <= target.len);\n\n        stdx.copy_disjoint(\n            .inexact,\n            tb.ChangeEvent,\n            target,\n            source,\n        );\n        runner.buffer.producer_finish(@intCast(source.len));\n\n        if (runner.buffer.all_free()) {\n            // No events to publish.\n            // Going idle and will check again for new events.\n            assert(source.len == 0);\n            assert(runner.consumer == .idle);\n            runner.producer = .waiting;\n            return runner.produce_dispatch();\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "produce_request_callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to consume from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn consume(self: *Runner) void {\n        assert(self.connected.vsr);\n        assert(self.connected.amqp);\n        assert(self.state == .last);\n        assert(TimestampRange.valid(self.state.last.producer_timestamp));\n        assert(self.state.last.consumer_timestamp == 0 or\n            TimestampRange.valid(self.state.last.consumer_timestamp));\n        assert(self.state.last.producer_timestamp > self.state.last.consumer_timestamp);\n        switch (self.consumer) {\n            .idle => {\n                if (!self.buffer.consumer_begin()) {\n                    // No buffers ready (they must be both `free` or still `producing`).\n                    // The running/waiting producer will resume the consumer once it finishes.\n                    if (self.buffer.all_free()) {\n                        assert(self.producer == .idle);\n                    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "consume",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn callback(context: *amqp.Client) void {\n                        const runner: *Runner = @alignCast(@fieldParentPtr(\n                            \"amqp_client\",\n                            context,\n                        ));\n                        assert(runner.consumer == .publish);\n                        runner.consumer = .progress_update;\n                        runner.consume_dispatch();\n                    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn callback(context: *amqp.Client) void {\n                        const runner: *Runner = @alignCast(@fieldParentPtr(\n                            \"amqp_client\",\n                            context,\n                        ));\n                        assert(runner.consumer == .progress_update);\n\n                        const event_count: usize, const timestamp_last: u64 = events: {\n                            const events = runner.buffer.get_consumer_buffer();\n                            assert(events.len > 0);\n                            break :events .{ events.len, events[events.len - 1].timestamp }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tick from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub fn tick(self: *Runner) void {\n        assert(!self.vsr_client.evicted);\n        self.vsr_client.tick();\n        self.amqp_client.tick();\n        self.io.run_for_ns(constants.tick_ms * std.time.ns_per_ms) catch unreachable;\n\n        self.metrics.tick();\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "tick",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub fn init(time: vsr.time.Time, options: Options) RateLimit {\n        assert(options.limit > 0);\n        assert(options.period.ns > 0);\n\n        return .{\n            .count = 0,\n            .timer = .init(time),\n            .options = options,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to attempt from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub fn attempt(self: *RateLimit) union(enum) {\n        ok,\n        wait: stdx.Duration,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "attempt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to record from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn record(\n            metrics: *TimingSummary,\n            event_count: u64,\n        ) void {\n            metrics.timing(\n                event_count,\n                metrics.timer.read(),\n            );\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "record",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to timing from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn timing(\n            metrics: *TimingSummary,\n            event_count: u64,\n            duration: stdx.Duration,\n        ) void {\n            maybe(duration.ns == 0);\n            maybe(event_count == 0);\n\n            metrics.count += 1;\n            metrics.event_count += event_count;\n            metrics.duration_min = if (metrics.duration_min) |min| duration.min(min) else duration;\n            metrics.duration_max = if (metrics.duration_max) |max| duration.max(max) else duration;\n            metrics.duration_sum.ns += duration.ns;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "timing",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tick from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn tick(self: *Metrics) void {\n        assert(self.flush_ticks < self.flush_timeout_ticks);\n        self.flush_ticks += 1;\n        if (self.flush_ticks == self.flush_timeout_ticks) {\n            self.flush_ticks = 0;\n            self.log_and_reset();\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "tick",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to log_and_reset from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn log_and_reset(metrics: *Metrics) void {\n        const Fields = enum { producer, consumer }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "log_and_reset",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub fn init(allocator: std.mem.Allocator, event_count: u32) !DualBuffer {\n        assert(event_count > 0);\n        assert(event_count <= Runner.constants.event_count_max);\n\n        const buffer_1 = try allocator.alloc(tb.ChangeEvent, event_count);\n        errdefer allocator.free(buffer_1);\n\n        const buffer_2 = try allocator.alloc(tb.ChangeEvent, event_count);\n        errdefer allocator.free(buffer_2);\n\n        return .{\n            .buffer_1 = .{\n                .buffer = buffer_1,\n                .state = .free,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub fn deinit(self: *DualBuffer, allocator: std.mem.Allocator) void {\n        allocator.free(self.buffer_2.buffer);\n        allocator.free(self.buffer_1.buffer);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to producer_begin from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub fn producer_begin(self: *DualBuffer) bool {\n        self.assert_state();\n        // Already producing.\n        assert(self.find(.producing) == null);\n        const buffer = self.find(.free) orelse\n            // No free buffers.\n            return false;\n        buffer.state = .producing;\n        return true;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "producer_begin",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_producer_buffer from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub fn get_producer_buffer(self: *DualBuffer) []tb.ChangeEvent {\n        self.assert_state();\n        const buffer = self.find(.producing).?;\n        return buffer.buffer;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "get_producer_buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to producer_finish from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub fn producer_finish(self: *DualBuffer, count: u32) void {\n        self.assert_state();\n        const buffer = self.find(.producing).?;\n        buffer.state = if (count == 0) .free else .{ .ready = count }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "producer_finish",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to consumer_begin from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub fn consumer_begin(self: *DualBuffer) bool {\n        self.assert_state();\n        // Already consuming.\n        assert(self.find(.consuming) == null);\n        const buffer = self.find(.ready) orelse\n            // No buffers ready.\n            return false;\n        const count = buffer.state.ready;\n        buffer.state = .{ .consuming = count }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "consumer_begin",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_consumer_buffer from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub fn get_consumer_buffer(self: *DualBuffer) []const tb.ChangeEvent {\n        self.assert_state();\n        const buffer = self.find(.consuming).?;\n        return buffer.buffer[0..buffer.state.consuming];\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "get_consumer_buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to consumer_finish from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub fn consumer_finish(self: *DualBuffer) void {\n        self.assert_state();\n        const buffer = self.find(.consuming).?;\n        buffer.state = .free;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "consumer_finish",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to all_free from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub fn all_free(self: *const DualBuffer) bool {\n        return self.buffer_1.state == .free and\n            self.buffer_2.state == .free;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "all_free",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to find from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn find(self: *DualBuffer, state: State) ?*Buffer {\n        self.assert_state();\n        if (self.buffer_1.state == state) return &self.buffer_1;\n        if (self.buffer_2.state == state) return &self.buffer_2;\n        return null;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "find",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to assert_state from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn assert_state(self: *const DualBuffer) void {\n        // Two buffers: one can be producing while the other is consuming,\n        // but never two consumers or producers.\n        assert(!(self.buffer_1.state == .producing and self.buffer_2.state == .producing));\n        assert(!(self.buffer_1.state == .consuming and self.buffer_2.state == .consuming));\n        assert(!(self.buffer_1.state == .ready and self.buffer_2.state == .ready));\n        maybe(self.buffer_1.state == .free and self.buffer_2.state == .free);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "assert_state",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to header from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn header(self: *const ProgressTrackerMessage) amqp.Encoder.Table {\n        const vtable: amqp.Encoder.Table.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, encoder: *amqp.Encoder.TableEncoder) void {\n                    const message: *const ProgressTrackerMessage = @ptrCast(@alignCast(context));\n                    var release_buffer: [\n                        std.fmt.count(\"{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "header",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parse from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn parse(table: ?amqp.Decoder.Table) amqp.Decoder.Error!ProgressTrackerMessage {\n        if (table) |headers| {\n            var timestamp: ?u64 = null;\n            var release: ?vsr.Release = null;\n\n            // Intentionally allows the presence of header fields other than `timestamp`,\n            // since some plugin may insert additional headers into messages.\n            var iterator = headers.iterator();\n            while (try iterator.next()) |entry| {\n                if (std.mem.eql(u8, entry.key, \"timestamp\")) {\n                    switch (entry.value) {\n                        .int64 => |int64| {\n                            const value: u64 = @intCast(int64);\n                            if (!TimestampRange.valid(value)) break;\n                            timestamp = value;\n                        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "parse",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub fn init(event: *const tb.ChangeEvent) Message {\n        return .{\n            .timestamp = event.timestamp,\n            .type = event.type,\n            .ledger = event.ledger,\n            .transfer = .{\n                .id = event.transfer_id,\n                .amount = event.transfer_amount,\n                .pending_id = event.transfer_pending_id,\n                .user_data_128 = event.transfer_user_data_128,\n                .user_data_64 = event.transfer_user_data_64,\n                .user_data_32 = event.transfer_user_data_32,\n                .timeout = event.transfer_timeout,\n                .code = event.transfer_code,\n                .flags = @bitCast(event.transfer_flags),\n                .timestamp = event.transfer_timestamp,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to header from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn header(self: *const Message) amqp.Encoder.Table {\n        const vtable: amqp.Encoder.Table.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, encoder: *amqp.Encoder.TableEncoder) void {\n                    const message: *const Message = @ptrCast(@alignCast(context));\n                    encoder.put(\"event_type\", .{ .string = @tagName(message.type) }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "header",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to body from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn body(self: *const Message) amqp.Encoder.Body {\n        const vtable: amqp.Encoder.Body.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, buffer: []u8) usize {\n                    const message: *const Message = @ptrCast(@alignCast(context));\n                    var fbs = std.io.fixedBufferStream(buffer);\n                    std.json.stringify(message, .{\n                        .whitespace = .minified,\n                        .emit_nonportable_numbers_as_strings = true,\n                    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "body",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to worse_case from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "fn worse_case(comptime T: type) T {\n        var value: T = undefined;\n        for (std.meta.fields(T)) |field| {\n            @field(value, field.name) = switch (@typeInfo(field.type)) {\n                .int => std.math.maxInt(field.type),\n                .@\"enum\" => max: {\n                    var name: []const u8 = \"\";\n                    for (std.enums.values(tb.ChangeEventType)) |tag| {\n                        if (@tagName(tag).len > name.len) {\n                            name = @tagName(tag);\n                        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "function",
      "name": "worse_case",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Runner from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub const Runner = struct {\n    const StateRecoveryMode = union(enum) {\n        recover,\n        override: u64,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "struct",
      "name": "Runner",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to constants from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const constants = struct {\n        const tick_ms = vsr.constants.tick_ms;\n        const idle_interval_ns: u63 = 1 * std.time.ns_per_s;\n        const reply_timeout_ticks = @divExact(\n            30 * std.time.ms_per_s,\n            constants.tick_ms,\n        );\n        const app_id = \"tigerbeetle\";\n        const progress_tracker_queue = \"tigerbeetle.internal.progress\";\n        const locker_queue = \"tigerbeetle.internal.locker\";\n        const event_count_max: u32 = Client.StateMachine.operation_result_max(\n            .get_change_events,\n            vsr.constants.message_body_size_max,\n        );\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "struct",
      "name": "constants",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to RateLimit from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub const RateLimit = struct {\n    const Options = struct {\n        /// The rate limit expressed as \"requests per second\".\n        /// Must be greater than zero. Inclusive.\n        limit: u32,\n        /// Time interval used to enforce the request limit.\n        period: stdx.Duration,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "struct",
      "name": "RateLimit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Metrics from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const Metrics = struct {\n    const TimingSummary = struct {\n        timer: vsr.time.Timer,\n\n        duration_min: ?stdx.Duration = null,\n        duration_max: ?stdx.Duration = null,\n        duration_sum: stdx.Duration = .{ .ns = 0 }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "struct",
      "name": "Metrics",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to DualBuffer from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const DualBuffer = struct {\n    const State = enum {\n        free,\n        producing,\n        ready,\n        consuming,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "struct",
      "name": "DualBuffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Buffer from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const Buffer = struct {\n        buffer: []tb.ChangeEvent,\n        state: union(State) {\n            free,\n            producing,\n            ready: u32,\n            consuming: u32,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "struct",
      "name": "Buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ProgressTrackerMessage from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const ProgressTrackerMessage = struct {\n    release: vsr.Release,\n    timestamp: u64,\n\n    fn header(self: *const ProgressTrackerMessage) amqp.Encoder.Table {\n        const vtable: amqp.Encoder.Table.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, encoder: *amqp.Encoder.TableEncoder) void {\n                    const message: *const ProgressTrackerMessage = @ptrCast(@alignCast(context));\n                    var release_buffer: [\n                        std.fmt.count(\"{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "struct",
      "name": "ProgressTrackerMessage",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Message from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "pub const Message = struct {\n    pub const content_type = \"application/json\";\n\n    pub const json_string_size_max = size: {\n        var counting_writer = std.io.countingWriter(std.io.null_writer);\n        std.json.stringify(\n            worse_case(Message),\n            stringify_options,\n            counting_writer.writer(),\n        ) catch unreachable;\n        break :size counting_writer.bytes_written;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "struct",
      "name": "Message",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to idle_interval_ns from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const idle_interval_ns: u63 = 1 * std.time.ns_per_s;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "idle_interval_ns",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to event_count_max from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const event_count_max: u32 = Client.StateMachine.operation_result_max(\n            .get_change_events,\n            vsr.constants.message_body_size_max,\n        );",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "event_count_max",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to idle_interval_ns from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const idle_interval_ns: u63 = if (options.idle_interval_ms) |value|\n            @intCast(@as(u64, value) * std.time.ns_per_ms)\n        else\n            constants.idle_interval_ns;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "idle_interval_ns",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to event_count_max from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const event_count_max: u32 = if (options.event_count_max) |event_count_max|\n            @min(event_count_max, constants.event_count_max)\n        else\n            constants.event_count_max;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "event_count_max",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to publish_exchange from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const publish_exchange: []const u8 = options.publish_exchange orelse \"\";",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "publish_exchange",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to publish_routing_key from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const publish_routing_key: []const u8 = options.publish_routing_key orelse \"\";",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "publish_routing_key",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to progress_tracker_queue_owned from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const progress_tracker_queue_owned: []const u8 = try std.fmt.allocPrint(\n            allocator,\n            \"{s}.{}\",\n            .{\n                constants.progress_tracker_queue,\n                options.cluster_id,\n            },\n        );",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "progress_tracker_queue_owned",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to locker_queue_owned from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const locker_queue_owned: []const u8 = try std.fmt.allocPrint(\n            allocator,\n            \"{s}.{}\",\n            .{\n                constants.locker_queue,\n                options.cluster_id,\n            },\n        );",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "locker_queue_owned",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to runner from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const runner: *Runner = @alignCast(@fieldParentPtr(\"amqp_client\", context));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "runner",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to timestamp_override from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const timestamp_override: ?u64 = switch (recovery_mode) {\n            .recover => null,\n            .override => |timestamp| timestamp,\n        };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "timestamp_override",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to runner from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const runner: *Runner = @alignCast(@fieldParentPtr(\n                                \"amqp_client\",\n                                context,\n                            ));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "runner",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to runner from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const runner: *Runner = @alignCast(@fieldParentPtr(\n                                \"amqp_client\",\n                                context,\n                            ));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "runner",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to runner from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const runner: *Runner = @alignCast(@fieldParentPtr(\n                                \"amqp_client\",\n                                context,\n                            ));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "runner",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to runner from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const runner: *Runner = @alignCast(@fieldParentPtr(\n                                \"amqp_client\",\n                                context,\n                            ));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "runner",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to runner from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const runner: *Runner = @alignCast(@fieldParentPtr(\n                            \"amqp_client\",\n                            context,\n                        ));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "runner",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to runner from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const runner: *Runner = @ptrFromInt(@as(usize, @intCast(user_data)));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "runner",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to filter from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const filter: tb.ChangeEventsFilter = .{\n                    .limit = self.event_count_max,\n                    .timestamp_min = self.state.last.producer_timestamp,\n                    .timestamp_max = 0,\n                };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "filter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to runner from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const runner: *Runner = @ptrFromInt(@as(usize, @intCast(context)));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "runner",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to source from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const source: []const tb.ChangeEvent = stdx.bytes_as_slice(.exact, tb.ChangeEvent, result);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "source",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to target from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const target: []tb.ChangeEvent = runner.buffer.get_producer_buffer();",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "target",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to events from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const events: []const tb.ChangeEvent = self.buffer.get_consumer_buffer();",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "events",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to runner from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const runner: *Runner = @alignCast(@fieldParentPtr(\n                            \"amqp_client\",\n                            context,\n                        ));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "runner",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to progress_tracker from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const progress_tracker: ProgressTrackerMessage = progress: {\n                    const events = self.buffer.get_consumer_buffer();",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "progress_tracker",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to runner from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const runner: *Runner = @alignCast(@fieldParentPtr(\n                            \"amqp_client\",\n                            context,\n                        ));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "runner",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to event_count from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const event_count: usize, const timestamp_last: u64 = events: {\n                            const events = runner.buffer.get_consumer_buffer();",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "event_count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to runner from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const runner: *const Runner = @alignCast(@fieldParentPtr(\"metrics\", metrics));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "runner",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to summary from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const summary: *TimingSummary = &@field(metrics, @tagName(field));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "summary",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to vtable from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const vtable: amqp.Encoder.Table.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, encoder: *amqp.Encoder.TableEncoder) void {\n                    const message: *const ProgressTrackerMessage = @ptrCast(@alignCast(context));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "vtable",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to value from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const value: u64 = @intCast(int64);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "value",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to vtable from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const vtable: amqp.Encoder.Table.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, encoder: *amqp.Encoder.TableEncoder) void {\n                    const message: *const Message = @ptrCast(@alignCast(context));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "vtable",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to vtable from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const vtable: amqp.Encoder.Body.VTable = comptime .{\n            .write = &struct {\n                fn write(context: *const anyopaque, buffer: []u8) usize {\n                    const message: *const Message = @ptrCast(@alignCast(context));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "vtable",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to resolution from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const resolution: u64 = 300 * std.time.ns_per_ms;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "resolution",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to values from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const values: []const u64 = &.{\n        TimestampRange.timestamp_min,\n        1745055501942402250,\n        TimestampRange.timestamp_max,\n    };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "values",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to message from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const message: ProgressTrackerMessage = .{\n            .release = vsr.Release.minimum,\n            .timestamp = value,\n        };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "message",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to message from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/cdc/runner.zig",
    "response": "const message: Message = std.mem.zeroInit(Message, .{});",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/cdc/runner.zig",
      "type": "const",
      "name": "message",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "pub fn init(self: *ClientInterface, context: *anyopaque, vtable: *const VTable) void {\n        self.* = .{\n            .context = .{ .ptr = context }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to submit from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "pub fn submit(client: *ClientInterface, packet: *Packet.Extern) Error!void {\n        if (client.magic_number != beetle) return Error.ClientInvalid;\n        assert(client.reserved == 0);\n\n        client.locker.lock();\n        defer client.locker.unlock();\n        const context = client.context.ptr orelse return Error.ClientInvalid;\n        client.vtable.ptr.submit_fn(context, packet);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "submit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to completion_context from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "pub fn completion_context(client: *ClientInterface) Error!usize {\n        if (client.magic_number != beetle) return Error.ClientInvalid;\n        assert(client.reserved == 0);\n\n        client.locker.lock();\n        defer client.locker.unlock();\n        const context = client.context.ptr orelse return Error.ClientInvalid;\n        return client.vtable.ptr.completion_context_fn(context);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "completion_context",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "pub fn deinit(client: *ClientInterface) Error!void {\n        if (client.magic_number != beetle) return Error.ClientInvalid;\n        assert(client.reserved == 0);\n\n        const context: *anyopaque = context: {\n            client.locker.lock();\n            defer client.locker.unlock();\n            if (client.context.ptr == null) return Error.ClientInvalid;\n\n            defer client.context.ptr = null;\n            break :context client.context.ptr.?;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init_parameters from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "pub fn init_parameters(client: *ClientInterface, out_parameters: *InitParameters) Error!void {\n        if (client.magic_number != beetle) return Error.ClientInvalid;\n        assert(client.reserved == 0);\n\n        client.locker.lock();\n        defer client.locker.unlock();\n        const context = client.context.ptr orelse return Error.ClientInvalid;\n        return client.vtable.ptr.init_parameters_fn(context, out_parameters);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "init_parameters",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ContextType from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "pub fn ContextType(\n    comptime Client: type,\n) type {\n    return struct {\n        const Context = @This();\n        const GPA = std.heap.GeneralPurposeAllocator(.{\n            .thread_safe = true,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "ContextType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "pub fn init(\n            root_allocator: std.mem.Allocator,\n            client_out: *ClientInterface,\n            cluster_id: u128,\n            addresses: []const u8,\n            completion_ctx: usize,\n            completion_callback: CompletionCallback,\n        ) InitError!void {\n            var context: *Context = context: {\n                // Wrap the root allocator - usually heap.c_allocator when built as a library - in\n                // a GPA to keep maximum compatibility while gaining the extra safety. As a library,\n                // libtbclient is running inside another process's address space.\n                var gpa = GPA{\n                    .backing_allocator = root_allocator,\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to tick from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn tick(self: *Context) void {\n            if (self.eviction_reason == null) {\n                self.client.tick();\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "tick",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to io_thread from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn io_thread(self: *Context) void {\n            while (self.signal.status() != .stopped) {\n                self.tick();\n                self.io.run_for_ns(constants.tick_ms * std.time.ns_per_ms) catch |err| {\n                    log.err(\"{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "io_thread",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to cancel_request_inflight from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn cancel_request_inflight(self: *Context) void {\n            if (self.client.request_inflight) |*inflight| {\n                if (inflight.message.header.operation != .register) {\n                    const packet: *Packet = @as(UserData, @bitCast(inflight.user_data)).packet;\n                    packet.assert_phase(.sent);\n                    self.packet_cancel(packet);\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "cancel_request_inflight",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to packet_cancel from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn packet_cancel(self: *Context, packet_list: *Packet) void {\n            assert(packet_list.link.next == null);\n            assert(packet_list.phase != .complete);\n            packet_list.assert_phase(packet_list.phase);\n\n            const result = if (self.eviction_reason) |reason| switch (reason) {\n                .reserved => unreachable,\n                .client_release_too_low => error.ClientReleaseTooLow,\n                .client_release_too_high => error.ClientReleaseTooHigh,\n                else => error.ClientEvicted,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "packet_cancel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to packet_enqueue from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn packet_enqueue(self: *Context, packet: *Packet) void {\n            assert(self.batch_size_limit != null);\n            packet.assert_phase(.submitted);\n\n            if (self.eviction_reason != null) {\n                return self.packet_cancel(packet);\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "packet_enqueue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to packet_send from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn packet_send(self: *Context, packet_list: *Packet) void {\n            assert(self.batch_size_limit != null);\n            assert(self.client.request_inflight == null);\n            packet_list.assert_phase(.pending);\n\n            // On shutdown, cancel this packet as well as any others batched onto it.\n            if (self.signal.status() != .running) {\n                return self.packet_cancel(packet_list);\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "packet_send",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to signal_notify_callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn signal_notify_callback(signal: *Signal) void {\n            const self: *Context = @alignCast(@fieldParentPtr(\"signal\", signal));\n            assert(self.signal.status() != .stopped);\n\n            // Don't send any requests until registration completes.\n            if (self.batch_size_limit == null) {\n                assert(self.client.request_inflight != null);\n                assert(self.client.request_inflight.?.message.header.operation == .register);\n                return;\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "signal_notify_callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to client_register_callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn client_register_callback(user_data: u128, result: *const vsr.RegisterResult) void {\n            const self: *Context = @ptrFromInt(@as(usize, @intCast(user_data)));\n            assert(self.client.request_inflight == null);\n            assert(self.batch_size_limit == null);\n            assert(result.batch_size_limit > 0);\n\n            // The client might have a smaller message size limit.\n            maybe(constants.message_body_size_max < result.batch_size_limit);\n            self.batch_size_limit = @min(result.batch_size_limit, constants.message_body_size_max);\n\n            // Some requests may have queued up while the client was registering.\n            signal_notify_callback(&self.signal);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "client_register_callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to client_eviction_callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn client_eviction_callback(client: *Client, eviction: *const Message.Eviction) void {\n            const self: *Context = @fieldParentPtr(\"client\", client);\n            assert(self.eviction_reason == null);\n\n            log.debug(\"{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "client_eviction_callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to client_result_callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn client_result_callback(\n            raw_user_data: u128,\n            operation_vsr: vsr.Operation,\n            timestamp: u64,\n            reply: []const u8,\n        ) void {\n            const user_data: UserData = @bitCast(raw_user_data);\n            const self: *Context = user_data.self;\n            const packet_list: *Packet = user_data.packet;\n            const operation = operation_vsr.cast(Client.StateMachine);\n            assert(packet_list.operation == @intFromEnum(operation));\n            assert(timestamp > 0);\n            packet_list.assert_phase(.sent);\n\n            const current_timestamp = self.client.time.monotonic();\n            self.previous_request_latency =\n                current_timestamp.duration_since(self.previous_request_instant.?);\n\n            // Submit the next pending packet (if any) now that VSR has completed this one.\n            assert(self.client.request_inflight == null);\n            while (self.pending.pop()) |packet_next| {\n                self.packet_send(packet_next);\n                if (self.client.request_inflight != null) break;\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "client_result_callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to notify_completion from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn notify_completion(\n            self: *Context,\n            packet: *Packet,\n            completion: PacketError!struct {\n                timestamp: u64,\n                reply: []const u8,\n            },\n        ) void {\n            const result = completion catch |err| {\n                packet.status = switch (err) {\n                    error.TooMuchData => .too_much_data,\n                    error.ClientEvicted => .client_evicted,\n                    error.ClientReleaseTooLow => .client_release_too_low,\n                    error.ClientReleaseTooHigh => .client_release_too_high,\n                    error.ClientShutdown => .client_shutdown,\n                    error.InvalidOperation => .invalid_operation,\n                    error.InvalidDataSize => .invalid_data_size,\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "notify_completion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to vtable_submit_fn from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn vtable_submit_fn(context: *anyopaque, packet_extern: *Packet.Extern) void {\n            const self: *Context = @ptrCast(@alignCast(context));\n\n            // Packet is caller-allocated to enable elastic intrusive-link-list-based\n            // memory management. However, some of Packet's fields are essentially private.\n            // Initialize them here to avoid threading default fields through FFI boundary.\n            const packet: *Packet = packet_extern.cast();\n            packet.* = .{\n                .user_data = packet_extern.user_data,\n                .operation = packet_extern.operation,\n                .data_size = packet_extern.data_size,\n                .data = packet_extern.data,\n                .user_tag = packet_extern.user_tag,\n                .status = .ok,\n                .link = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "vtable_submit_fn",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to vtable_completion_context_fn from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn vtable_completion_context_fn(context: *anyopaque) usize {\n            const self: *Context = @ptrCast(@alignCast(context));\n            return self.completion_context;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "vtable_completion_context_fn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to vtable_deinit_fn from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn vtable_deinit_fn(context: *anyopaque) void {\n            const self: *Context = @ptrCast(@alignCast(context));\n\n            self.signal.stop();\n            self.thread.join();\n\n            assert(self.submitted.pop() == null);\n            assert(self.pending.pop() == null);\n\n            self.gpa.allocator().free(self.addresses_copy);\n\n            // NB: Copy the allocator back out before trying to destroy `self` with it!\n            var gpa: GPA = self.gpa;\n            gpa.allocator().destroy(self);\n            assert(gpa.deinit() == .ok);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "vtable_deinit_fn",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to vtable_init_parameters_fn from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn vtable_init_parameters_fn(context: *anyopaque, out_parameters: *InitParameters) void {\n            const self: *Context = @ptrCast(@alignCast(context));\n            assert(self.signal.status() == .running);\n\n            out_parameters.cluster_id = self.cluster_id;\n            out_parameters.client_id = self.client_id;\n            out_parameters.addresses_ptr = self.addresses_copy.ptr;\n            out_parameters.addresses_len = self.addresses_copy.len;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "vtable_init_parameters_fn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to operation_from_int from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn operation_from_int(op: u8) ?StateMachine.Operation {\n            inline for (allowed_operations) |operation| {\n                if (op == @intFromEnum(operation)) {\n                    return operation;\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "operation_from_int",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lock from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn lock(self: *Locker) void {\n        if (!self.try_lock()) {\n            self.lock_slow();\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "lock",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to try_lock from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn try_lock(self: *Locker) bool {\n        // On x86, use `lock bts` instead of `lock cmpxchg` as:\n        // - they both seem to mark the cache-line as modified regardless: https://stackoverflow.com/a/63350048.\n        // - `lock bts` is smaller instruction-wise which makes it better for inlining.\n        if (comptime builtin.target.cpu.arch.isX86()) {\n            const locked_bit = @ctz(locked);\n            return self.state.bitSet(locked_bit, .acquire) == 0;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "try_lock",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to lock_slow from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn lock_slow(self: *Locker) void {\n        @branchHint(.cold);\n\n        // Avoid doing an atomic swap below if we already know the state is contended.\n        // An atomic swap unconditionally stores which marks the cache-line as modified\n        // unnecessarily.\n        if (self.state.load(.monotonic) == contended) {\n            Futex.wait(&self.state, contended);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "lock_slow",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to unlock from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn unlock(self: *Locker) void {\n        // Unlock the mutex and wake up a waiting thread if any.\n        //\n        // A waiting thread will acquire with `contended` instead of `locked`\n        // which ensures that it wakes up another thread on the next unlock().\n        //\n        // Release barrier ensures the critical section happens before we let go of the lock\n        // and that our critical section happens before the next lock holder grabs the lock.\n        const state = self.state.swap(unlocked, .release);\n        assert(state != unlocked);\n\n        if (state == contended) {\n            Futex.wake(&self.state, 1);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "unlock",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "fn run(self: *@This()) void {\n            while (true) {\n                self.state.locker.lock();\n                defer self.state.locker.unlock();\n                if (self.state.counter == increments) break;\n                self.state.counter += 1;\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "function",
      "name": "run",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to VTable from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "pub const VTable = struct {\n        submit_fn: *const fn (*anyopaque, *Packet.Extern) void,\n        completion_context_fn: *const fn (*anyopaque) usize,\n        deinit_fn: *const fn (*anyopaque) void,\n        init_parameters_fn: *const fn (*anyopaque, *InitParameters) void,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "struct",
      "name": "VTable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to State from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const State = struct {\n        locker: Locker = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "struct",
      "name": "State",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Runner from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const Runner = struct {\n        thread: std.Thread = undefined,\n        state: *State,\n        fn run(self: *@This()) void {\n            while (true) {\n                self.state.locker.lock();\n                defer self.state.locker.unlock();\n                if (self.state.counter == increments) break;\n                self.state.counter += 1;\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "struct",
      "name": "Runner",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to beetle from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const beetle: u64 = 0xBEE71E;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "beetle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to context from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const context: *anyopaque = context: {\n            client.locker.lock();",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "context",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to packet from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const packet: *Packet = @as(UserData, @bitCast(inflight.user_data)).packet;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "packet",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to operation from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const operation: StateMachine.Operation = operation_from_int(packet.operation) orelse {\n                return self.notify_completion(packet, error.InvalidOperation);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "operation",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to batch from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const batch: struct {\n                event_size: u32,\n                result_size: u32,\n                event_count: u32,\n                result_count_expected: u32,\n            } = batch: {\n                const event_size: u32 = StateMachine.event_size_bytes(operation);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "batch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to result_size from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const result_size: u32 = StateMachine.result_size_bytes(operation);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "result_size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const slice: []const u8 = packet.slice();",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "slice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to event_count from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const event_count: u32 = @intCast(@divExact(slice.len, event_size));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "event_count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to event_max from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const event_max: u32 = StateMachine.operation_event_max(\n                    operation,\n                    self.batch_size_limit.?,\n                );",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "event_max",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to result_max from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const result_max: u32 = StateMachine.operation_result_max(\n                    operation,\n                    self.batch_size_limit.?,\n                );",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "result_max",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to result_count_expected from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const result_count_expected: u32 = StateMachine.operation_result_count_expected(\n                    operation,\n                    slice,\n                );",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "result_count_expected",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to request_size from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const request_size: u32 = size: {\n                    const trailer_size = vsr.multi_batch.trailer_total_size(.{\n                        .element_size = batch.event_size,\n                        .batch_count = root.multi_batch_count + 1,\n                    });",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "request_size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to event_count from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const event_count: u32 = batch.event_count +\n                        root.multi_batch_event_count;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "event_count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to reply_size_expected from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const reply_size_expected: u32 = size: {\n                    const trailer_size = vsr.multi_batch.trailer_total_size(.{\n                        .element_size = batch.result_size,\n                        .batch_count = root.multi_batch_count + 1,\n                    });",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "reply_size_expected",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to event_count from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const event_count: u32 = batch.result_count_expected +\n                        root.multi_batch_result_count_expected;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "event_count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to operation from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const operation: StateMachine.Operation = operation_from_int(packet_list.operation).?;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "operation",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to event_size from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const event_size: u32 = StateMachine.event_size_bytes(operation);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "event_size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to request_size from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const request_size: u32 = request_size: {\n                if (!StateMachine.operation_is_multi_batch(operation)) {\n                    assert(packet_list.multi_batch_next == null);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "request_size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to source from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const source: []const u8 = packet_list.slice();",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "source",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to source from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const source: []const u8 = batched.slice();",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "source",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to events_count from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const events_count: u16 = @intCast(@divExact(source.len, event_size));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "events_count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to result_size from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const result_size: u32 = StateMachine.result_size_bytes(operation);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "result_size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to reply_size_max from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const reply_size_max: u32 = (result_size *\n                    packet_list.multi_batch_result_count_expected) + trailer_size;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "reply_size_max",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const self: *Context = @alignCast(@fieldParentPtr(\"signal\", signal));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to packet from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const packet: *Packet = pop: {\n                    self.interface.locker.lock();",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "packet",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to empty from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const empty: bool = empty: {\n                self.interface.locker.lock();",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "empty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const self: *Context = @ptrFromInt(@as(usize, @intCast(user_data)));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const self: *Context = @fieldParentPtr(\"client\", client);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to user_data from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const user_data: UserData = @bitCast(raw_user_data);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "user_data",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const self: *Context = user_data.self;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to packet_list from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const packet_list: *Packet = user_data.packet;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "packet_list",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to result_size from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const result_size: u32 = StateMachine.result_size_bytes(operation);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "result_size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to multi_batch_results_expected from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const multi_batch_results_expected: u16 =\n                packet_list.multi_batch_result_count_expected;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "multi_batch_results_expected",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to batched_reply from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const batched_reply: []const u8 = reply_decoder.pop().?;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "batched_reply",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const self: *Context = @ptrCast(@alignCast(context));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to packet from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const packet: *Packet = packet_extern.cast();",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "packet",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const self: *Context = @ptrCast(@alignCast(context));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const self: *Context = @ptrCast(@alignCast(context));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const self: *Context = @ptrCast(@alignCast(context));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to unlocked from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const unlocked: u32 = 0b00;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "unlocked",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to locked from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const locked: u32 = 0b01;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "locked",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to contended from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/context.zig",
    "response": "const contended: u32 = 0b11;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/context.zig",
      "type": "const",
      "name": "contended",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to EchoClientType from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/echo_client.zig",
    "response": "pub fn EchoClientType(\n    comptime StateMachine_: type,\n    comptime MessageBus: type,\n) type {\n    return struct {\n        const EchoClient = @This();\n\n        // Exposing the same types the real client does:\n        const VSRClient = vsr.ClientType(StateMachine_, MessageBus);\n        pub const StateMachine = EchoStateMachineType(VSRClient.StateMachine);\n        pub const Request = VSRClient.Request;\n\n        id: u128,\n        cluster: u128,\n        release: vsr.Release = vsr.Release.minimum,\n        request_number: u32 = 0,\n        reply_timestamp: u64 = 0, // Fake timestamp, just a counter.\n        request_inflight: ?Request = null,\n        message_pool: *MessagePool,\n        time: Time,\n\n        pub fn init(\n            allocator: mem.Allocator,\n            time: Time,\n            message_pool: *MessagePool,\n            options: struct {\n                id: u128,\n                cluster: u128,\n                replica_count: u8,\n                message_bus_options: MessageBus.Options,\n                eviction_callback: ?*const fn (\n                    client: *EchoClient,\n                    eviction: *const Message.Eviction,\n                ) void = null,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/echo_client.zig",
      "type": "function",
      "name": "EchoClientType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/echo_client.zig",
    "response": "pub fn deinit(self: *EchoClient, allocator: std.mem.Allocator) void {\n            _ = allocator;\n            if (self.request_inflight) |inflight| self.release_message(inflight.message.base());\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/echo_client.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tick from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/echo_client.zig",
    "response": "pub fn tick(self: *EchoClient) void {\n            const inflight = self.request_inflight orelse return;\n            self.request_inflight = null;\n\n            self.reply_timestamp += 1;\n            const timestamp = self.reply_timestamp;\n\n            // Allocate a reply message.\n            const reply = self.get_message().build(.request);\n            defer self.release_message(reply.base());\n\n            // Copy the request message's entire content including header into the reply.\n            const operation = inflight.message.header.operation;\n            stdx.copy_disjoint(\n                .exact,\n                u8,\n                reply.buffer,\n                inflight.message.buffer,\n            );\n\n            // Similarly to the real client, release the request message before invoking the\n            // callback. This necessitates a `copy_disjoint` above.\n            self.release_message(inflight.message.base());\n\n            switch (inflight.callback) {\n                .request => |callback| {\n                    callback(inflight.user_data, operation, timestamp, reply.body_used());\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/echo_client.zig",
      "type": "function",
      "name": "tick",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to register from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/echo_client.zig",
    "response": "pub fn register(\n            self: *EchoClient,\n            callback: Request.RegisterCallback,\n            user_data: u128,\n        ) void {\n            assert(self.request_inflight == null);\n            assert(self.request_number == 0);\n\n            const message = self.get_message().build(.request);\n            errdefer self.release_message(message.base());\n\n            // We will set parent, session, view and checksums only when sending for the first time:\n            message.header.* = .{\n                .client = self.id,\n                .request = self.request_number,\n                .cluster = self.cluster,\n                .command = .request,\n                .operation = .register,\n                .release = vsr.Release.minimum,\n                .previous_request_latency = 0,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/echo_client.zig",
      "type": "function",
      "name": "register",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to request from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/echo_client.zig",
    "response": "pub fn request(\n            self: *EchoClient,\n            callback: Request.Callback,\n            user_data: u128,\n            operation: StateMachine.Operation,\n            events: []const u8,\n        ) void {\n            const event_size: usize = switch (operation) {\n                inline else => |operation_comptime| @sizeOf(\n                    StateMachine.EventType(operation_comptime),\n                ),\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/echo_client.zig",
      "type": "function",
      "name": "request",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to raw_request from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/echo_client.zig",
    "response": "pub fn raw_request(\n            self: *EchoClient,\n            callback: Request.Callback,\n            user_data: u128,\n            message: *Message.Request,\n        ) void {\n            assert(message.header.client == self.id);\n            assert(message.header.cluster == self.cluster);\n            assert(message.header.release.value == self.release.value);\n            assert(!message.header.operation.vsr_reserved());\n            assert(message.header.size >= @sizeOf(Header));\n            assert(message.header.size <= constants.message_size_max);\n\n            message.header.request = self.request_number;\n            self.request_number += 1;\n\n            assert(self.request_inflight == null);\n            self.request_inflight = .{\n                .message = message,\n                .user_data = user_data,\n                .callback = .{ .request = callback }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/echo_client.zig",
      "type": "function",
      "name": "raw_request",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_message from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/echo_client.zig",
    "response": "pub fn get_message(self: *EchoClient) *Message {\n            return self.message_pool.get_message(null);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/echo_client.zig",
      "type": "function",
      "name": "get_message",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to release_message from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/echo_client.zig",
    "response": "pub fn release_message(self: *EchoClient, message: *Message) void {\n            self.message_pool.unref(message);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/echo_client.zig",
      "type": "function",
      "name": "release_message",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to EchoStateMachineType from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/echo_client.zig",
    "response": "fn EchoStateMachineType(comptime StateMachine: type) type {\n    return struct {\n        pub const Operation = StateMachine.Operation;\n        pub const operation_from_vsr = StateMachine.operation_from_vsr;\n\n        pub const EventType = StateMachine.EventType;\n        pub const operation_event_max = StateMachine.operation_event_max;\n        pub const operation_result_max = StateMachine.operation_result_max;\n        pub const operation_result_count_expected = StateMachine.operation_result_count_expected;\n        pub const operation_is_multi_batch = StateMachine.operation_is_multi_batch;\n\n        // Re-exporting functions where results are equal to events.\n        pub const ResultType = StateMachine.EventType;\n        pub const event_size_bytes = StateMachine.event_size_bytes;\n        pub const result_size_bytes = StateMachine.event_size_bytes;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/echo_client.zig",
      "type": "function",
      "name": "EchoStateMachineType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to event_size from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/echo_client.zig",
    "response": "const event_size: usize = switch (operation) {\n                inline else => |operation_comptime| @sizeOf(\n                    StateMachine.EventType(operation_comptime),\n                ),\n            };",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/echo_client.zig",
      "type": "const",
      "name": "event_size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to cast from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/packet.zig",
    "response": "pub fn cast(self: *Extern) *Packet {\n            return @ptrCast(self);\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/packet.zig",
      "type": "function",
      "name": "cast",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to cast from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/packet.zig",
    "response": "pub fn cast(self: *Packet) *Extern {\n        return @ptrCast(self);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/packet.zig",
      "type": "function",
      "name": "cast",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to slice from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/packet.zig",
    "response": "pub fn slice(packet: *const Packet) []const u8 {\n        if (packet.data_size == 0) {\n            // It may be an empty array (null pointer)\n            // or a buffer with no elements (valid pointer and size == 0).\n            stdx.maybe(packet.data == null);\n            return &[0]u8{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/packet.zig",
      "type": "function",
      "name": "slice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to assert_phase from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/packet.zig",
    "response": "fn assert_phase(packet: *const Packet, expected: Phase) void {\n        assert(packet.phase == expected);\n        assert(packet.data_size == 0 or packet.data != null);\n        assert(stdx.zeroed(&packet.reserved));\n        maybe(packet.user_data == null);\n        maybe(packet.user_tag == 0);\n\n        switch (expected) {\n            .submitted => {\n                assert(packet.link.next == null);\n                assert(packet.multi_batch_next == null);\n                assert(packet.multi_batch_tail == null);\n                assert(packet.multi_batch_count == 0);\n                assert(packet.multi_batch_event_count == 0);\n                assert(packet.multi_batch_result_count_expected == 0);\n                assert(packet.multi_batch_time_monotonic == 0);\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/packet.zig",
      "type": "function",
      "name": "assert_phase",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to data from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/packet.zig",
    "response": "const data: [*]const u8 = @ptrCast(packet.data.?);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/packet.zig",
      "type": "const",
      "name": "data",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal.zig",
    "response": "pub fn init(self: *Signal, io: *IO, on_signal_fn: *const fn (*Signal) void) !void {\n        const event = try io.open_event();\n        errdefer io.close_event(event);\n\n        self.* = .{\n            .io = io,\n            .completion = undefined,\n            .event = event,\n            .event_state = @TypeOf(self.event_state).init(.running),\n            .listening = Atomic(bool).init(true),\n            .on_signal_fn = on_signal_fn,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal.zig",
    "response": "pub fn deinit(self: *Signal) void {\n        assert(self.event != IO.INVALID_EVENT);\n        assert(self.status() == .stopped);\n\n        self.io.close_event(self.event);\n        self.* = undefined;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stop from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal.zig",
    "response": "pub fn stop(self: *Signal) void {\n        const listening = self.listening.swap(false, .release);\n        if (listening) {\n            self.notify();\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal.zig",
      "type": "function",
      "name": "stop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to status from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal.zig",
    "response": "pub fn status(self: *const Signal) enum {\n        /// Listening for event notifications.\n        /// Call `notify()` to trigger the callback.\n        running,\n        /// `stop()` was called, but the event listener is still waiting for the IO operation\n        /// to complete. Further calls to `notify()` have no effect.\n        stop_requested,\n        /// No pending listening events. It is safe to call `deinit()`.\n        stopped,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal.zig",
      "type": "function",
      "name": "status",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to notify from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal.zig",
    "response": "pub fn notify(self: *Signal) void {\n        // Try to transition from `waiting` to `notified`.\n        // If it fails, analyze the current state to determine if a notification is needed.\n        var state: @TypeOf(self.event_state.raw) = .waiting;\n        while (self.event_state.cmpxchgStrong(\n            state,\n            .notified,\n            .release,\n            .acquire,\n        )) |state_actual| {\n            switch (state_actual) {\n                .waiting, .running => state = state_actual, // Try again.\n                .notified => return, // Already notified.\n                .shutdown => return, // Ignore notifications after shutdown.\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal.zig",
      "type": "function",
      "name": "notify",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wait from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal.zig",
    "response": "fn wait(self: *Signal) void {\n        // It is not guaranteed to be `running` here, as another caller might have requested\n        // a stop during the callback.\n        assert(self.status() != .stopped);\n\n        const state = self.event_state.swap(.waiting, .acquire);\n        self.io.event_listen(self.event, &self.completion, on_event);\n        switch (state) {\n            // We should be the only ones who could've started waiting.\n            .waiting => unreachable,\n            // Wait for a `notify`.\n            .running => {}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal.zig",
      "type": "function",
      "name": "wait",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to on_event from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal.zig",
    "response": "fn on_event(completion: *IO.Completion) void {\n        const self: *Signal = @fieldParentPtr(\"completion\", completion);\n        const listening: bool = self.listening.load(.acquire);\n        const state = self.event_state.cmpxchgStrong(\n            .notified,\n            if (listening) .running else .shutdown,\n            .release,\n            .acquire,\n        ) orelse {\n            if (listening) {\n                (self.on_signal_fn)(self);\n                self.wait();\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal.zig",
      "type": "function",
      "name": "on_event",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run_test from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal.zig",
    "response": "fn run_test() !void {\n            var self: Context = .{\n                .io = try IO.init(32, 0),\n                .main_thread_id = std.Thread.getCurrentId(),\n                .signal = undefined,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal.zig",
      "type": "function",
      "name": "run_test",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to notify from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal.zig",
    "response": "fn notify(self: *Context) void {\n            assert(std.Thread.getCurrentId() != self.main_thread_id);\n            while (self.signal.status() != .stopped) {\n                std.time.sleep(delay + 1);\n\n                // Triggering the event:\n                self.signal.notify();\n\n                // The same signal may be triggered multiple times,\n                // but it should only fire once.\n                self.signal.notify();\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal.zig",
      "type": "function",
      "name": "notify",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to on_signal from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal.zig",
    "response": "fn on_signal(signal: *Signal) void {\n            const self: *Context = @fieldParentPtr(\"signal\", signal);\n            assert(std.Thread.getCurrentId() == self.main_thread_id);\n            switch (self.signal.status()) {\n                .running => {\n                    assert(self.count < events_count);\n                    self.count += 1;\n                }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal.zig",
      "type": "function",
      "name": "on_signal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Signal from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal.zig",
    "response": "pub const Signal = struct {\n    io: *IO,\n    completion: IO.Completion,\n    event: IO.Event,\n    event_state: Atomic(enum(u8) {\n        running,\n        waiting,\n        notified,\n        shutdown,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal.zig",
      "type": "struct",
      "name": "Signal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal.zig",
    "response": "const self: *Signal = @fieldParentPtr(\"completion\", completion);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to listening from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal.zig",
    "response": "const listening: bool = self.listening.load(.acquire);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal.zig",
      "type": "const",
      "name": "listening",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal.zig",
    "response": "const self: *Context = @fieldParentPtr(\"signal\", signal);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal_fuzz.zig",
    "response": "pub fn main(_: std.mem.Allocator, args: fuzz.FuzzArgs) !void {\n    var prng = stdx.PRNG.from_seed(args.seed);\n    const events_max = args.events_max orelse 100;\n\n    for (0..events_max) |_| {\n        var io = try IO.init(32, 0);\n        defer io.deinit();\n\n        var context: Context = .{\n            .main_thread_id = std.Thread.getCurrentId(),\n            .signal = undefined,\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal_fuzz.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to notify from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal_fuzz.zig",
    "response": "fn notify(context: *Context) void {\n    assert(std.Thread.getCurrentId() != context.main_thread_id);\n    while (context.signal.status() != .stopped) {\n        const delay_us = 1; // Shorter than `tick_us`.\n        std.time.sleep(delay_us * std.time.ns_per_us);\n\n        if (context.stop_request.load(.monotonic) == .user_thread) {\n            // Stop can be called by multiple threads.\n            context.signal.stop();\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal_fuzz.zig",
      "type": "function",
      "name": "notify",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to on_signal from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal_fuzz.zig",
    "response": "fn on_signal(signal: *Signal) void {\n    const context: *Context = @fieldParentPtr(\"signal\", signal);\n    assert(std.Thread.getCurrentId() == context.main_thread_id);\n    switch (context.signal.status()) {\n        .running => {\n            context.running_count += 1;\n            if (context.stop_request.load(.monotonic) == .io_thread) {\n                // Stop the signal while the notification is running.\n                context.signal.stop();\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal_fuzz.zig",
      "type": "function",
      "name": "on_signal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Context from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal_fuzz.zig",
    "response": "const Context = struct {\n    const Atomic = std.atomic.Value(StopRequest);\n\n    main_thread_id: std.Thread.Id,\n    signal: Signal,\n    running_count: u32 = 0,\n    stop_request: Atomic = Atomic.init(.none),\n}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal_fuzz.zig",
      "type": "struct",
      "name": "Context",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to context from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client/signal_fuzz.zig",
    "response": "const context: *Context = @fieldParentPtr(\"signal\", signal);",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client/signal_fuzz.zig",
      "type": "const",
      "name": "context",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to cast from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "fn cast(self: *tb_client_t) *tb.ClientInterface {\n        return @ptrCast(self);\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "function",
      "name": "cast",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init_error_to_status from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "pub fn init_error_to_status(err: tb.InitError) tb_init_status {\n    return switch (err) {\n        error.Unexpected => .unexpected,\n        error.OutOfMemory => .out_of_memory,\n        error.AddressInvalid => .address_invalid,\n        error.AddressLimitExceeded => .address_limit_exceeded,\n        error.SystemResources => .system_resources,\n        error.NetworkSubsystemFailed => .network_subsystem,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "function",
      "name": "init_error_to_status",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "pub fn init(\n    tb_client_out: *tb_client_t,\n    cluster_id_ptr: *const [16]u8,\n    addresses_ptr: [*:0]const u8,\n    addresses_len: u32,\n    completion_ctx: usize,\n    completion_callback: tb_completion_t,\n) callconv(.c) tb_init_status {\n    const addresses = @as([*]const u8, @ptrCast(addresses_ptr))[0..addresses_len];\n\n    // Passing u128 by value is prone to ABI issues. Pass as a [16]u8, and explicitly copy into\n    // memory we know will be aligned correctly. Don't just use bytesToValue here, as that keeps\n    // pointer alignment, and will result in a potentially unaligned access of a\n    // `*align(1) const u128`.\n    const cluster_id: u128 = blk: {\n        var cluster_id: u128 = undefined;\n        stdx.copy_disjoint(.exact, u8, std.mem.asBytes(&cluster_id), cluster_id_ptr);\n\n        break :blk cluster_id;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init_echo from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "pub fn init_echo(\n    tb_client_out: *tb_client_t,\n    cluster_id_ptr: *const [16]u8,\n    addresses_ptr: [*:0]const u8,\n    addresses_len: u32,\n    completion_ctx: usize,\n    completion_callback: tb_completion_t,\n) callconv(.c) tb_init_status {\n    const addresses = @as([*]const u8, @ptrCast(addresses_ptr))[0..addresses_len];\n\n    // See explanation in init().\n    const cluster_id: u128 = blk: {\n        var cluster_id: u128 = undefined;\n        stdx.copy_disjoint(.exact, u8, std.mem.asBytes(&cluster_id), cluster_id_ptr);\n\n        break :blk cluster_id;\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "function",
      "name": "init_echo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to submit from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "pub fn submit(tb_client: ?*tb_client_t, packet: *tb_packet_t) callconv(.c) tb_client_status {\n    const client: *tb.ClientInterface = if (tb_client) |ptr| ptr.cast() else return .invalid;\n    client.submit(packet) catch |err| switch (err) {\n        error.ClientInvalid => return .invalid,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "function",
      "name": "submit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "pub fn deinit(tb_client: ?*tb_client_t) callconv(.c) tb_client_status {\n    const client: *tb.ClientInterface = if (tb_client) |ptr| ptr.cast() else return .invalid;\n    client.deinit() catch |err| switch (err) {\n        error.ClientInvalid => return .invalid,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init_parameters from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "pub fn init_parameters(\n    tb_client: ?*tb_client_t,\n    out_parameters: *tb_init_parameters,\n) callconv(.c) tb_client_status {\n    const client: *tb.ClientInterface = if (tb_client) |ptr| ptr.cast() else return .invalid;\n    client.init_parameters(out_parameters) catch |err| switch (err) {\n        error.ClientInvalid => return .invalid,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "function",
      "name": "init_parameters",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to completion_context from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "pub fn completion_context(\n    tb_client: ?*tb_client_t,\n    completion_ctx_out: *usize,\n) callconv(.c) tb_client_status {\n    const client: *tb.ClientInterface = if (tb_client) |ptr| ptr.cast() else return .invalid;\n    completion_ctx_out.* = client.completion_context() catch |err| switch (err) {\n        error.ClientInvalid => return .invalid,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "function",
      "name": "completion_context",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to register_log_callback from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "pub fn register_log_callback(\n    callback_maybe: ?Logging.Callback,\n    debug: bool,\n) callconv(.c) tb_register_log_callback_status {\n    Logging.global.mutex.lock();\n    defer Logging.global.mutex.unlock();\n    if (Logging.global.callback == null) {\n        if (callback_maybe) |callback| {\n            Logging.global.callback = callback;\n            Logging.global.debug = debug;\n            return .success;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "function",
      "name": "register_log_callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to application_logger from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "pub fn application_logger(\n        comptime message_level: std.log.Level,\n        comptime scope: @Type(.enum_literal),\n        comptime format: []const u8,\n        args: anytype,\n    ) void {\n        // Debug logs are dropped here unless debug is set, because of the potential penalty in\n        // crossing FFI to drop them.\n        if (message_level == .debug and !Logging.global.debug) {\n            return;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "function",
      "name": "application_logger",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Logging from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "pub const Logging = struct {\n    const Callback = *const fn (\n        message_level: tb_log_level,\n        message_ptr: [*]const u8,\n        message_len: u32,\n    ) callconv(.c) void;\n\n    const log_line_max = 8192;\n\n    /// Logging is global per process; it would be nice to be able to define a different logger\n    /// for each client instance, though.\n    var global: Logging = .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "struct",
      "name": "Logging",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to level from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "const level: tb_log_level = @enumFromInt(@intFromEnum(std_level));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "const",
      "name": "level",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cluster_id from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "const cluster_id: u128 = blk: {\n        var cluster_id: u128 = undefined;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "const",
      "name": "cluster_id",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cluster_id from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "const cluster_id: u128 = blk: {\n        var cluster_id: u128 = undefined;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "const",
      "name": "cluster_id",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to client from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "const client: *tb.ClientInterface = if (tb_client) |ptr| ptr.cast() else return .invalid;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "const",
      "name": "client",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to client from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "const client: *tb.ClientInterface = if (tb_client) |ptr| ptr.cast() else return .invalid;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "const",
      "name": "client",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to client from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "const client: *tb.ClientInterface = if (tb_client) |ptr| ptr.cast() else return .invalid;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "const",
      "name": "client",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to client from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "const client: *tb.ClientInterface = if (tb_client) |ptr| ptr.cast() else return .invalid;",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "const",
      "name": "client",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to tb_message_level from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_exports.zig",
    "response": "const tb_message_level: tb_log_level = @enumFromInt(@intFromEnum(message_level));",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_exports.zig",
      "type": "const",
      "name": "tb_message_level",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolve_c_type from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_header.zig",
    "response": "fn resolve_c_type(comptime Type: type) []const u8 {\n    switch (@typeInfo(Type)) {\n        .array => |info| return resolve_c_type(info.child),\n        .@\"enum\" => |info| return resolve_c_type(info.tag_type),\n        .@\"struct\" => return resolve_c_type(std.meta.Int(.unsigned, @bitSizeOf(Type))),\n        .bool => return \"uint8_t\",\n        .int => |info| {\n            assert(info.signedness == .unsigned);\n            return switch (info.bits) {\n                8 => \"uint8_t\",\n                16 => \"uint16_t\",\n                32 => \"uint32_t\",\n                64 => \"uint64_t\",\n                128 => \"tb_uint128_t\",\n                else => @compileError(\"invalid int type\"),\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_header.zig",
      "type": "function",
      "name": "resolve_c_type",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to to_uppercase from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_header.zig",
    "response": "fn to_uppercase(comptime input: []const u8) [input.len]u8 {\n    comptime var output: [input.len]u8 = undefined;\n    inline for (&output, 0..) |*char, i| {\n        char.* = input[i];\n        char.* -= 32 * @as(u8, @intFromBool(char.* >= 'a' and char.* <= 'z'));\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_header.zig",
      "type": "function",
      "name": "to_uppercase",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to emit_enum from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_header.zig",
    "response": "fn emit_enum(\n    buffer: *std.ArrayList(u8),\n    comptime Type: type,\n    comptime type_info: anytype,\n    comptime c_name: []const u8,\n    comptime skip_fields: []const []const u8,\n) !void {\n    var suffix_pos = std.mem.lastIndexOfScalar(u8, c_name, '_').?;\n    if (std.mem.count(u8, c_name, \"_\") == 1) suffix_pos = c_name.len;\n\n    try buffer.writer().print(\"typedef enum {s}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_header.zig",
      "type": "function",
      "name": "emit_enum",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to emit_struct from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_header.zig",
    "response": "fn emit_struct(\n    buffer: *std.ArrayList(u8),\n    comptime type_info: anytype,\n    comptime c_name: []const u8,\n) !void {\n    try buffer.writer().print(\"typedef struct {s}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_header.zig",
      "type": "function",
      "name": "emit_struct",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_header.zig",
    "response": "pub fn main() !void {\n    @setEvalBranchQuota(100_000);\n\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n\n    var buffer = std.ArrayList(u8).init(allocator);\n    try buffer.writer().print(\n        \\\\ //////////////////////////////////////////////////////////\n        \\\\ // This file was auto-generated by tb_client_header.zig //\n        \\\\ //              Do not manually modify.                 //\n        \\\\ //////////////////////////////////////////////////////////\n        \\\\\n        \\\\#ifndef TB_CLIENT_H\n        \\\\#define TB_CLIENT_H\n        \\\\\n        \\\\#ifdef __cplusplus\n        \\\\extern \"C\" {{\n        \\\\#endif\n        \\\\\n        \\\\#include <stddef.h>\n        \\\\#include <stdint.h>\n        \\\\#include <stdbool.h>\n        \\\\\n        \\\\typedef __uint128_t tb_uint128_t;\n        \\\\\n        \\\\\n    , .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_header.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to comments from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/c/tb_client_header.zig",
    "response": "const comments: []const u8 = type_mapping[2];",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/c/tb_client_header.zig",
      "type": "const",
      "name": "comments",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Docs from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/docs_types.zig",
    "response": "pub const Docs = struct {\n    // Name of the directory (relative to /src/clients)\n    directory: String,\n\n    // Package name (i.e. tigerbeetle-go, tigerbeetle-node, etc.)\n    name: String,\n\n    // Name for syntax highlighting (i.e. javascript for node, go for go, etc.)\n    markdown_name: String,\n\n    // File extension without dot (i.e. js, go, etc.)\n    extension: String,\n\n    // For the title of the page on the docs site.\n    proper_name: String,\n\n    // Introduction to the client. Links to docs or build badges or\n    // whatnot.\n    description: Markdown,\n\n    // Any libraries or languages and their required versions for\n    // using, not necessarily hacking on, this client.\n    prerequisites: Markdown,\n\n    // If you need an additional project file like pom.xml or\n    // package.json. Leave blank if not needed.\n    project_file_name: String,\n    // The actual contents of the file. Leave blank if not needed.\n    project_file: Code,\n\n    // If you need to override the default name of test.${extension}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/docs_types.zig",
      "type": "struct",
      "name": "Docs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Sample from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/docs_types.zig",
    "response": "pub const Sample = struct {\n    // Capitalized name of the sample program\n    proper_name: String,\n\n    // e.g. `basic`, `two-phase`, etc.\n    directory: String,\n\n    // For use in the language primary README\n    short_description: String,\n\n    // For use as the introduction on the individual sample README\n    long_description: String,\n}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/docs_types.zig",
      "type": "struct",
      "name": "Sample",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tests from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/ci.zig",
    "response": "pub fn tests(shell: *Shell, gpa: std.mem.Allocator) !void {\n    assert(shell.file_exists(\"TigerBeetle.sln\"));\n\n    try shell.exec_zig(\"build clients:dotnet -Drelease\", .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/ci.zig",
      "type": "function",
      "name": "tests",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to validate_release from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/ci.zig",
    "response": "pub fn validate_release(shell: *Shell, gpa: std.mem.Allocator, options: struct {\n    version: []const u8,\n    tigerbeetle: []const u8,\n}) !void {\n    var tmp_beetle = try TmpTigerBeetle.init(gpa, .{\n        .development = true,\n        .prebuilt = options.tigerbeetle,\n    }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/ci.zig",
      "type": "function",
      "name": "validate_release",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to nuget_install from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/ci.zig",
    "response": "fn nuget_install(shell: *Shell, options: struct {\n    version: []const u8,\n}) !union(enum) { ok, retry: anyerror }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/ci.zig",
      "type": "function",
      "name": "nuget_install",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to release_published_latest from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/ci.zig",
    "response": "pub fn release_published_latest(shell: *Shell) ![]const u8 {\n    const DotnetSearch = struct {\n        const SearchResult = struct {\n            const Packages = struct {\n                id: []const u8,\n                latestVersion: []const u8,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/ci.zig",
      "type": "function",
      "name": "release_published_latest",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to DotnetSearch from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/ci.zig",
    "response": "const DotnetSearch = struct {\n        const SearchResult = struct {\n            const Packages = struct {\n                id: []const u8,\n                latestVersion: []const u8,\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/ci.zig",
      "type": "struct",
      "name": "DotnetSearch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to command from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/ci.zig",
    "response": "const command: []const u8 = \"dotnet add package tigerbeetle --version {version}\";",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/ci.zig",
      "type": "const",
      "name": "command",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_private from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/dotnet_bindings.zig",
    "response": "pub fn is_private(comptime self: @This(), name: []const u8) bool {\n        inline for (self.private_fields) |field| {\n            if (std.mem.eql(u8, field, name)) {\n                return true;\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/dotnet_bindings.zig",
      "type": "function",
      "name": "is_private",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_read_only from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/dotnet_bindings.zig",
    "response": "pub fn is_read_only(comptime self: @This(), name: []const u8) bool {\n        inline for (self.readonly_fields) |field| {\n            if (std.mem.eql(u8, field, name)) {\n                return true;\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/dotnet_bindings.zig",
      "type": "function",
      "name": "is_read_only",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dotnet_type from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/dotnet_bindings.zig",
    "response": "fn dotnet_type(comptime Type: type) []const u8 {\n    switch (@typeInfo(Type)) {\n        .@\"enum\", .@\"struct\" => return comptime get_mapped_type_name(Type) orelse\n            @compileError(\"Type \" ++ @typeName(Type) ++ \" not mapped.\"),\n        .bool => return \"byte\",\n        .int => |info| {\n            assert(info.signedness == .unsigned);\n            return switch (info.bits) {\n                8 => \"byte\",\n                16 => \"ushort\",\n                32 => \"uint\",\n                64 => \"ulong\",\n                128 => \"UInt128\",\n                else => @compileError(\"invalid int type\"),\n            }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/dotnet_bindings.zig",
      "type": "function",
      "name": "dotnet_type",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_mapped_type_name from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/dotnet_bindings.zig",
    "response": "fn get_mapped_type_name(comptime Type: type) ?[]const u8 {\n    inline for (type_mappings) |type_mapping| {\n        if (Type == type_mapping[0]) {\n            return type_mapping[1].name;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/dotnet_bindings.zig",
      "type": "function",
      "name": "get_mapped_type_name",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to to_case from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/dotnet_bindings.zig",
    "response": "fn to_case(comptime input: []const u8, comptime case: enum { camel, pascal }) []const u8 {\n    return comptime blk: {\n        var len: usize = 0;\n        var output: [input.len]u8 = undefined;\n        var iterator = std.mem.tokenizeScalar(u8, input, '_');\n        while (iterator.next()) |word| {\n            _ = std.ascii.lowerString(output[len..], word);\n            output[len] = std.ascii.toUpper(output[len]);\n            len += word.len;\n        }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/dotnet_bindings.zig",
      "type": "function",
      "name": "to_case",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to emit_enum from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/dotnet_bindings.zig",
    "response": "fn emit_enum(\n    buffer: *std.ArrayList(u8),\n    comptime Type: type,\n    comptime type_info: anytype,\n    comptime mapping: TypeMapping,\n    comptime int_type: []const u8,\n) !void {\n    const is_packed_struct = @TypeOf(type_info) == std.builtin.Type.Struct;\n    if (is_packed_struct) {\n        assert(type_info.layout == .@\"packed\");\n        // Packed structs represented as Enum needs a Flags attribute:\n        try buffer.writer().print(\"[Flags]\\n\", .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/dotnet_bindings.zig",
      "type": "function",
      "name": "emit_enum",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to emit_struct from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/dotnet_bindings.zig",
    "response": "fn emit_struct(\n    buffer: *std.ArrayList(u8),\n    comptime type_info: anytype,\n    comptime mapping: TypeMapping,\n    comptime size: usize,\n) !void {\n    try buffer.writer().print(\n        \\\\[StructLayout(LayoutKind.Sequential, Size = SIZE)]\n        \\\\{s}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/dotnet_bindings.zig",
      "type": "function",
      "name": "emit_struct",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to emit_docs from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/dotnet_bindings.zig",
    "response": "fn emit_docs(buffer: anytype, comptime mapping: TypeMapping, comptime field: ?[]const u8) !void {\n    if (mapping.docs_link) |docs_link| {\n        try buffer.writer().print(\n            \\\\    /// <summary>\n            \\\\    /// https://docs.tigerbeetle.com/{s}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/dotnet_bindings.zig",
      "type": "function",
      "name": "emit_docs",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generate_bindings from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/dotnet_bindings.zig",
    "response": "pub fn generate_bindings(buffer: *std.ArrayList(u8)) !void {\n    @setEvalBranchQuota(100_000);\n\n    try buffer.writer().print(\n        \\\\//////////////////////////////////////////////////////////\n        \\\\// This file was auto-generated by dotnet_bindings.zig  //\n        \\\\//              Do not manually modify.                 //\n        \\\\//////////////////////////////////////////////////////////\n        \\\\\n        \\\\using System;\n        \\\\using System.Runtime.InteropServices;\n        \\\\\n        \\\\namespace TigerBeetle;\n        \\\\\n        \\\\\n    , .{}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/dotnet_bindings.zig",
      "type": "function",
      "name": "generate_bindings",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/dotnet_bindings.zig",
    "response": "pub fn main() !void {\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n\n    var buffer = std.ArrayList(u8).init(allocator);\n    try generate_bindings(&buffer);\n\n    try std.io.getStdOut().writeAll(buffer.items);\n}",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/dotnet_bindings.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to TypeMapping from tigerbeetle/tigerbeetle",
    "context": "Repository: tigerbeetle/tigerbeetle (14142 ⭐)\nFile: src/clients/dotnet/dotnet_bindings.zig",
    "response": "const TypeMapping = struct {\n    name: []const u8,\n    visibility: enum { public, internal }",
    "metadata": {
      "repo": "tigerbeetle/tigerbeetle",
      "stars": 14142,
      "file": "src/clients/dotnet/dotnet_bindings.zig",
      "type": "struct",
      "name": "TypeMapping",
      "difficulty": "easy"
    }
  }
]