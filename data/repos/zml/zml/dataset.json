[
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn init() Condition {\n        return .{ .inner = executor.Condition.init(&AsyncThread.current.executor.exec) }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to broadcast from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn broadcast(self: *Condition) void {\n        self.inner.broadcast();\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "broadcast",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to signal from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn signal(self: *Condition) void {\n        self.inner.signal();\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "signal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wait from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn wait(self: *Condition) void {\n        self.inner.wait();\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "wait",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to Frame from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn Frame(comptime func: anytype) type {\n    const Signature = stdx.meta.FnSignature(func, null);\n    return FrameExx(func, Signature.ArgsT, Signature.ReturnT);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "Frame",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to FrameEx from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn FrameEx(comptime func: anytype, comptime argsT: type) type {\n    const Signature = stdx.meta.FnSignature(func, argsT);\n    return FrameExx(func, Signature.ArgsT, Signature.ReturnT);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "FrameEx",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to FrameExx from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "fn FrameExx(comptime func: anytype, comptime argsT: type, comptime returnT: type) type {\n    return struct {\n        const Self = @This();\n        const FrameT = coro.FrameT(func, argsT);\n\n        inner: FrameT,\n\n        pub fn await(self: *Self) returnT {\n            defer {\n                self.inner.deinit();\n                AsyncThread.current.stack_allocator.destroy(&self.inner._frame.stack);\n                self.* = undefined;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "FrameExx",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to async from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn async(comptime func: anytype, args: anytype) !FrameEx(func, @TypeOf(args)) {\n    const Signature = stdx.meta.FnSignature(func, @TypeOf(args));\n    const new_stack = try AsyncThread.current.stack_allocator.create();\n    return .{\n        .inner = try aio.xasync(func, @as(Signature.ArgsT, args), new_stack),\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "async",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to callBlocking from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn callBlocking(comptime func: anytype, args: anytype) stdx.meta.FnSignature(func, @TypeOf(args)).ReturnT {\n    const Signature = stdx.meta.FnSignature(func, @TypeOf(args));\n\n    const TaskT = struct {\n        const Self = @This();\n\n        _task: XevThreadPool.Task = .{ .callback = &Self.run }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "callBlocking",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn run(task_: *XevThreadPool.Task) void {\n            const task: *Self = @alignCast(@fieldParentPtr(\"_task\", task_));\n            task.result = @call(.auto, func, task.args);\n            task.event.set();\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "run",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sleep from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn sleep(ms: u64) !void {\n    try aio.sleep(AsyncThread.current.executor, ms);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "sleep",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isSet from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn isSet(self: *ResetEventSingle) bool {\n            return self.waiter.load(.seq_cst) == &State.set_state;\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "isSet",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reset from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn reset(self: *ResetEventSingle) void {\n            self.waiter.store(&State.unset_state, .seq_cst);\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "reset",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to set from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn set(self: *ResetEventSingle) void {\n            switch (self.waiter.swap(&State.set_state, .seq_cst).*) {\n                .waiting => |waiter| {\n                    waiter.thread.waiters_queue.push(waiter);\n                    waiter.thread.wake();\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "set",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wait from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn wait(self: *ResetEventSingle) void {\n            var waiter: Waiter = .{\n                .frame = coro.xframe(),\n                .thread = AsyncThread.current,\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "wait",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wake from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn wake(self: *const AsyncThread) void {\n        self.async_notifier.notify() catch {}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "wake",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to wakerCallback from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "fn wakerCallback(self: ?*AsyncThread, _: *xev.Loop, _: *xev.Completion, _: xev.Async.WaitError!void) xev.CallbackAction {\n        while (self.?.waiters_queue.pop()) |waiter| {\n            coro.xresume(waiter.frame);\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "wakerCallback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn main(allocator: std.mem.Allocator, comptime mainFunc: fn () anyerror!void) !void {\n        if (xev.dynamic) try xev.detect();\n        var thread_pool = XevThreadPool.init(.{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getStdIn from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn getStdIn() !File {\n    return File.initStreaming(std.fs.File.stdin()) catch @panic(\"Unable to open stdin\");\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "getStdIn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getStdOut from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn getStdOut() File {\n    return File.initStreaming(std.fs.File.stdout()) catch @panic(\"Unable to open stdout\");\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "getStdOut",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getStdErr from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn getStdErr() File {\n    return File.initStreaming(std.fs.File.stderr()) catch @panic(\"Unable to open stderr\");\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "getStdErr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stream from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "fn stream(r: *std.Io.Reader, w: *std.Io.Writer, limit: std.Io.Limit) std.Io.Reader.StreamError!usize {\n            const self: *Reader = @alignCast(@fieldParentPtr(\"interface\", r));\n            const dest = limit.slice(try w.writableSliceGreedy(1));\n            const n = switch (self.mode) {\n                .streaming => self.file.read(dest),\n                .positional => self.file.pread(dest, self.pos),\n                else => @panic(\"UNSUPPORTED\"),\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "stream",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "fn write(self: *Writer, buf: []const u8) !usize {\n            const n = switch (self.mode) {\n                .streaming => self.file.write(buf),\n                .positional => self.file.pwrite(buf, self.pos),\n                else => unreachable,\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "write",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to drain from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "fn drain(w: *std.Io.Writer, data: []const []const u8, splat: usize) std.Io.Writer.Error!usize {\n            // TODO: implement splat\n            _ = splat;\n            const self: *Writer = @alignCast(@fieldParentPtr(\"interface\", w));\n            var total: usize = 0;\n            if (w.buffered().len > 0) {\n                total += w.consume(try self.write(w.buffered()));\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "drain",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to asFile from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn asFile(self: File) std.fs.File {\n        return .{ .handle = self._handle }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "asFile",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to handle from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn handle(self: File) std.fs.File.Handle {\n        return self._handle;\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "handle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn init(file_: std.fs.File) !File {\n        return .{\n            ._handle = file_.handle,\n            .inner = aio.File.init(AsyncThread.current.executor, try xev.File.init(file_)),\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to initStreaming from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn initStreaming(file_: std.fs.File) !File {\n        return .{\n            ._handle = file_.handle,\n            .inner = aio.File.init(AsyncThread.current.executor, try xev.File.init(file_)),\n            .is_streaming = true,\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "initStreaming",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to open from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn open(path: []const u8, flags: std.fs.File.OpenFlags) !File {\n        return init(try callBlocking(std.fs.Dir.openFile, .{ std.fs.cwd(), path, flags }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "open",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to access from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn access(path: []const u8, flags: std.fs.File.OpenFlags) !void {\n        return try callBlocking(std.fs.Dir.access, .{ std.fs.cwd(), path, flags }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "access",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reader from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn reader(self: File, buffer: []u8) Reader {\n        return .{\n            .file = self,\n            .interface = .{\n                .vtable = &.{\n                    .stream = Reader.stream,\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "reader",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn read(self: File, buf: []u8) !usize {\n        // NOTE(Corentin): Early return is required to avoid error with xev on Linux with io_uring backend.\n        if (buf.len == 0) {\n            return 0;\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "read",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pread from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn pread(self: File, buf: []u8, offset: u64) !usize {\n        // NOTE(Corentin): Early return is required to avoid error with xev on Linux with io_uring backend.\n        if (buf.len == 0) {\n            return 0;\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "pread",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn write(self: File, buf: []const u8) !usize {\n        return self.inner.write(.{ .slice = buf }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "write",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writer from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn writer(self: File, buffer: []u8) Writer {\n        return .{\n            .file = self,\n            .interface = .{\n                .vtable = &.{\n                    .drain = Writer.drain,\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "writer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pwrite from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn pwrite(self: File, buf: []const u8, offset: u64) !usize {\n        return self.inner.pwrite(.{ .slice = buf }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "pwrite",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to close from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn close(self: File) !void {\n        return self.inner.close();\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "close",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stat from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn stat(self: File) !std.fs.File.Stat {\n        return try callBlocking(std.fs.File.stat, .{self.asFile()}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "stat",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to seekBy from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn seekBy(self: File, offset: i64) !void {\n        try callBlocking(std.fs.File.seekBy, .{ self.asFile(), offset }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "seekBy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to seekTo from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn seekTo(self: File, offset: u64) !void {\n        try callBlocking(std.fs.File.seekTo, .{ self.asFile(), offset }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "seekTo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getPos from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn getPos(self: File) !u64 {\n        return try callBlocking(std.fs.File.getPos, .{self.asFile()}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "getPos",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getEndPos from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn getEndPos(self: File) !u64 {\n        return try callBlocking(std.fs.File.getEndPos, .{self.asFile()}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "getEndPos",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to Listener from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn Listener(comptime T: type) type {\n        return struct {\n            const Self = @This();\n\n            inner: T.Inner,\n\n            pub fn accept(self: *Self) !T {\n                return .{ .inner = try self.inner.accept() }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "Listener",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to close from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn close(self: *Self) !void {\n                return self.inner.close();\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "close",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn deinit(self: *Self) !void {\n                self.inner.shutdown();\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stream from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "fn stream(r: *std.Io.Reader, w: *std.Io.Writer, limit: std.Io.Limit) std.Io.Reader.StreamError!usize {\n                const self: *Reader = @alignCast(@fieldParentPtr(\"interface\", r));\n                const dest = limit.slice(try w.writableSliceGreedy(1));\n                const n = self.socket.read(dest) catch {\n                    return std.Io.Reader.StreamError.ReadFailed;\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "stream",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to drain from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "fn drain(w: *std.Io.Writer, data: []const []const u8, splat: usize) std.Io.Writer.Error!usize {\n                // TODO: implement splat\n                _ = splat;\n                const self: *Writer = @alignCast(@fieldParentPtr(\"interface\", w));\n                var total: usize = 0;\n                if (w.buffered().len >= 0) {\n                    total += w.consume(self.socket.write(w.buffered()) catch {\n                        return std.Io.Writer.Error.WriteFailed;\n                    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "drain",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to listen from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn listen(addr: std.net.Address) !Listener(TCP) {\n            var self: Listener(TCP) = .{\n                .inner = aio.TCP.init(AsyncThread.current.executor, try xev.TCP.init(addr)),\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "listen",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn deinit(self: *TCP) void {\n            self.inner.shutdown();\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to accept from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn accept(self: *TCP) !TCP {\n            return .{ .inner = try self.inner.accept() }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "accept",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to connect from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn connect(addr: std.net.Address) !TCP {\n            var self: TCP = .{\n                .inner = aio.TCP.init(AsyncThread.current.executor, try xev.TCP.init(addr)),\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "connect",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn read(self: TCP, buf: []u8) !usize {\n            return self.inner.read(.{ .slice = buf }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "read",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn write(self: TCP, buf: []const u8) !usize {\n            return self.inner.write(.{ .slice = buf }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "write",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to close from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn close(self: TCP) !void {\n            // defer self.* = undefined;\n            return self.inner.close();\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "close",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reader from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn reader(self: TCP, buffer: []u8) Reader {\n            return .{\n                .socket = self,\n                .interface = .{\n                    .vtable = &.{\n                        .stream = Reader.stream,\n                    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "reader",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writer from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn writer(self: TCP, buffer: []u8) Writer {\n            return .{\n                .socket = self,\n                .interface = .{\n                    .vtable = &.{\n                        .drain = Writer.drain,\n                    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "writer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callBlocking from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "fn callBlocking(self: WriterContext, buf: []const u8) !usize {\n                return self.file.write(self.addr, buf);\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "callBlocking",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to listen from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn listen(addr: std.net.Address) !Listener(UDP) {\n            var self: Listener(UDP) = .{\n                .inner = aio.UDP.init(AsyncThread.current.executor, try xev.UDP.init(addr)),\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "listen",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn read(self: UDP, buf: []u8) !usize {\n            return self.inner.read(.{ .slice = buf }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "read",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn write(self: UDP, addr: std.net.Address, buf: []const u8) !usize {\n            return self.inner.write(addr, .{ .slice = buf }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "write",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to close from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn close(self: *UDP) !void {\n            defer self.* = undefined;\n            return self.inner.close();\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "close",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reader from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn reader(self: File) Reader {\n            return .{ .context = self }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "reader",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writer from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn writer(self: File, addr: std.net.Address) Writer {\n            return .{\n                .context = .{\n                    .file = self,\n                    .addr = addr,\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "writer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to Channel from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn Channel(comptime T: type, capacity: usize) type {\n    return struct {\n        const Self = @This();\n        const Inner = channel_mod.Channel(T, capacity);\n\n        inner: Inner,\n\n        pub fn init() Self {\n            return .{ .inner = Inner.init(&AsyncThread.current.executor.exec) }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "Channel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to initWithLen from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn initWithLen(len: usize) Self {\n            return .{ .inner = Inner.initWithLen(&AsyncThread.current.executor.exec, len) }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "initWithLen",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to close from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn close(self: *Self) void {\n            self.inner.close();\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "close",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to try_send from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn try_send(self: *Self, val: T) bool {\n            return self.inner.try_send(val);\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "try_send",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn send(self: *Self, val: T) void {\n            self.inner.send(val);\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "send",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to recv from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn recv(self: *Self) ?T {\n            return self.inner.recv();\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "recv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to try_recv from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn try_recv(self: *Self) ?T {\n            return self.inner.try_recv();\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "try_recv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to channel from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn channel(comptime T: type, len: usize, comptime capacity: usize) Channel(T, capacity) {\n    return Channel(T, capacity).initWithLen(len);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "channel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn init() Mutex {\n        return .{ .inner = VoidChannel.init() }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lock from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn lock(self: *Mutex) void {\n        self.inner.send({}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "lock",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to unlock from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn unlock(self: *Mutex) void {\n        _ = self.inner.recv();\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "unlock",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to logFn from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub fn logFn(comptime fallbackLogFn: LogFn) LogFn {\n    return struct {\n        const Self = @This();\n\n        var mu: ?Mutex = null;\n\n        pub fn call(\n            comptime message_level: std.log.Level,\n            comptime scope: @TypeOf(.enum_literal),\n            comptime format: []const u8,\n            args: anytype,\n        ) void {\n            if (coro.inCoro() == false) {\n                return fallbackLogFn(message_level, scope, format, args);\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "function",
      "name": "logFn",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Condition from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub const Condition = struct {\n    inner: executor.Condition,\n\n    pub fn init() Condition {\n        return .{ .inner = executor.Condition.init(&AsyncThread.current.executor.exec) }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "struct",
      "name": "Condition",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to TaskT from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "const TaskT = struct {\n        const Self = @This();\n\n        _task: XevThreadPool.Task = .{ .callback = &Self.run }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "struct",
      "name": "TaskT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to threading from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub const threading = struct {\n    const Waiter = struct {\n        frame: coro.Frame,\n        thread: *const AsyncThread,\n        next: ?*Waiter = null,\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "struct",
      "name": "threading",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ResetEventSingle from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub const ResetEventSingle = struct {\n        const State = union(enum) {\n            unset,\n            waiting: *Waiter,\n            set,\n\n            const unset_state: State = .unset;\n            const set_state: State = .set;\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "struct",
      "name": "ResetEventSingle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to AsyncThread from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub const AsyncThread = struct {\n    threadlocal var current: *AsyncThread = undefined;\n\n    executor: *aio.Executor,\n    stack_allocator: *stack.StackAllocator,\n    loop: *xev.Loop,\n    thread_pool: *XevThreadPool,\n    async_notifier: *xev.Async,\n    waiters_queue: *threading.WaiterQueue,\n\n    pub fn wake(self: *const AsyncThread) void {\n        self.async_notifier.notify() catch {}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "struct",
      "name": "AsyncThread",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig struct similar to File from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub const File = struct {\n    pub const Reader = struct {\n        interface: std.Io.Reader,\n        file: File,\n        mode: std.fs.File.Reader.Mode = .positional,\n        pos: u64 = 0,\n\n        fn stream(r: *std.Io.Reader, w: *std.Io.Writer, limit: std.Io.Limit) std.Io.Reader.StreamError!usize {\n            const self: *Reader = @alignCast(@fieldParentPtr(\"interface\", r));\n            const dest = limit.slice(try w.writableSliceGreedy(1));\n            const n = switch (self.mode) {\n                .streaming => self.file.read(dest),\n                .positional => self.file.pread(dest, self.pos),\n                else => @panic(\"UNSUPPORTED\"),\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "struct",
      "name": "File",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Writer from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub const Writer = struct {\n        interface: std.Io.Writer,\n        file: File,\n        mode: std.fs.File.Writer.Mode = .positional,\n        pos: u64 = 0,\n\n        fn write(self: *Writer, buf: []const u8) !usize {\n            const n = switch (self.mode) {\n                .streaming => self.file.write(buf),\n                .positional => self.file.pwrite(buf, self.pos),\n                else => unreachable,\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "struct",
      "name": "Writer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Socket from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub const Socket = struct {\n    pub fn Listener(comptime T: type) type {\n        return struct {\n            const Self = @This();\n\n            inner: T.Inner,\n\n            pub fn accept(self: *Self) !T {\n                return .{ .inner = try self.inner.accept() }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "struct",
      "name": "Socket",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to TCP from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub const TCP = struct {\n        const Inner = aio.TCP;\n\n        pub const Reader = struct {\n            interface: std.Io.Reader,\n            socket: TCP,\n\n            fn stream(r: *std.Io.Reader, w: *std.Io.Writer, limit: std.Io.Limit) std.Io.Reader.StreamError!usize {\n                const self: *Reader = @alignCast(@fieldParentPtr(\"interface\", r));\n                const dest = limit.slice(try w.writableSliceGreedy(1));\n                const n = self.socket.read(dest) catch {\n                    return std.Io.Reader.StreamError.ReadFailed;\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "struct",
      "name": "TCP",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Writer from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub const Writer = struct {\n            interface: std.Io.Writer,\n            socket: TCP,\n\n            fn drain(w: *std.Io.Writer, data: []const []const u8, splat: usize) std.Io.Writer.Error!usize {\n                // TODO: implement splat\n                _ = splat;\n                const self: *Writer = @alignCast(@fieldParentPtr(\"interface\", w));\n                var total: usize = 0;\n                if (w.buffered().len >= 0) {\n                    total += w.consume(self.socket.write(w.buffered()) catch {\n                        return std.Io.Writer.Error.WriteFailed;\n                    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "struct",
      "name": "Writer",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to UDP from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub const UDP = struct {\n        const Inner = aio.TCP;\n\n        pub const Reader = std.io.GenericReader(UDP, stdx.meta.FnSignature(UDP.read, null).ReturnErrorSet.?, UDP.read);\n        pub const WriterContext = struct {\n            file: UDP,\n            addr: std.net.Address,\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "struct",
      "name": "UDP",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Mutex from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "pub const Mutex = struct {\n    const VoidChannel = Channel(void, 1);\n\n    inner: VoidChannel,\n\n    pub fn init() Mutex {\n        return .{ .inner = VoidChannel.init() }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "struct",
      "name": "Mutex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to task from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "const task: *Self = @alignCast(@fieldParentPtr(\"_task\", task_));",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "const",
      "name": "task",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to unset_state from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "const unset_state: State = .unset;",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "const",
      "name": "unset_state",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to set_state from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "const set_state: State = .set;",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "const",
      "name": "set_state",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "const self: *Reader = @alignCast(@fieldParentPtr(\"interface\", r));",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "const self: *Writer = @alignCast(@fieldParentPtr(\"interface\", w));",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "const self: *Reader = @alignCast(@fieldParentPtr(\"interface\", r));",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/async.zig",
    "response": "const self: *Writer = @alignCast(@fieldParentPtr(\"interface\", w));",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/async.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to initEnv from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn initEnv(e: EnvArg) void {\n    env = .{ .exec = e.executor }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "initEnv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn init(loop: *xev.Loop) Executor {\n        return .{ .loop = loop }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tick from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "fn tick(self: *Executor) !void {\n        try self.loop.run(.once);\n        _ = self.exec.tick();\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "tick",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn run(\n    exec: *Executor,\n    comptime func: anytype,\n    args: anytype,\n    stack: anytype,\n) !stdx.meta.FnSignature(func, @TypeOf(args)).ReturnPayloadT {\n    stdx.debug.assert(libcoro.inCoro() == false, \"Not in a coroutine\", .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "run",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to runCoro from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "fn runCoro(exec: *Executor, frame: anytype) !void {\n    const f = frame.frame();\n    if (f.status == .Start) {\n        libcoro.xresume(f);\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "runCoro",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to sleep from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn sleep(exec: *Executor, ms: u64) !void {\n    const loop = exec.loop;\n    const Data = XCallback(SleepResult);\n\n    var data = Data.init();\n    var w = try xev.Timer.init();\n    defer w.deinit();\n    var c: xev.Completion = .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "sleep",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to waitForCompletionOutsideCoro from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn waitForCompletionOutsideCoro(exec: *Executor, c: *xev.Completion) !void {\n    @branchHint(.unlikely);\n    while (c.state() != .dead) {\n        try exec.tick();\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "waitForCompletionOutsideCoro",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to waitForCompletionInCoro from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn waitForCompletionInCoro(c: *xev.Completion) void {\n    while (c.state() != .dead) {\n        libcoro.xsuspend();\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "waitForCompletionInCoro",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to waitForCompletion from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn waitForCompletion(exec: *Executor, c: *xev.Completion) !void {\n    if (libcoro.inCoro()) {\n        waitForCompletionInCoro(c);\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "waitForCompletion",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn init(exec: *Executor, tcp: xev.TCP) Self {\n        return .{ .exec = exec, .tcp = tcp }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stream from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "fn stream(self: Self) xev.TCP {\n        return self.tcp;\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "stream",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to accept from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn accept(self: Self) !Self {\n        const AcceptResult = xev.AcceptError!xev.TCP;\n        const Data = XCallback(AcceptResult);\n\n        const loop = self.exec.loop;\n\n        var data = Data.init();\n        var c: xev.Completion = .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "accept",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to connect from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn connect(self: Self, addr: std.net.Address) !void {\n        const ResultT = ConnectResult;\n        const Data = struct {\n            result: ResultT = undefined,\n            frame: ?Frame = null,\n\n            fn callback(\n                userdata: ?*@This(),\n                l: *xev.Loop,\n                c: *xev.Completion,\n                s: xev.TCP,\n                result: ResultT,\n            ) xev.CallbackAction {\n                _ = l;\n                _ = c;\n                _ = s;\n                const data = userdata.?;\n                data.result = result;\n                if (data.frame != null) libcoro.xresume(data.frame.?);\n                return .disarm;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "connect",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to shutdown from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn shutdown(self: Self) ShutdownResult {\n        const ResultT = ShutdownResult;\n        const Data = struct {\n            result: ResultT = undefined,\n            frame: ?Frame = null,\n\n            fn callback(\n                userdata: ?*@This(),\n                l: *xev.Loop,\n                c: *xev.Completion,\n                s: xev.TCP,\n                result: ResultT,\n            ) xev.CallbackAction {\n                _ = l;\n                _ = c;\n                _ = s;\n                const data = userdata.?;\n                data.result = result;\n                if (data.frame != null) libcoro.xresume(data.frame.?);\n                return .disarm;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "shutdown",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to Closeable from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "fn Closeable(comptime T: type, comptime StreamT: type) fn (T) anyerror!void {\n    return struct {\n        const Self = T;\n        const CloseResult = xev.CloseError!void;\n        pub fn close(self: Self) anyerror!void {\n            const ResultT = CloseResult;\n            const Data = struct {\n                result: ResultT = undefined,\n                frame: ?Frame = null,\n\n                fn callback(\n                    userdata: ?*@This(),\n                    l: *xev.Loop,\n                    c: *xev.Completion,\n                    s: StreamT,\n                    result: ResultT,\n                ) xev.CallbackAction {\n                    _ = l;\n                    _ = c;\n                    _ = s;\n                    const data = userdata.?;\n                    data.result = result;\n                    if (data.frame != null) libcoro.xresume(data.frame.?);\n                    return .disarm;\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "Closeable",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to Pollable from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "fn Pollable(comptime T: type, comptime StreamT: type) fn (T) anyerror!void {\n    return struct {\n        const PollResult = xev.PollError!void;\n        pub fn poll(self: T) anyerror!void {\n            const ResultT = PollResult;\n            const Data = struct {\n                result: ResultT = undefined,\n                frame: ?Frame = null,\n\n                fn callback(\n                    userdata: ?*@This(),\n                    l: *xev.Loop,\n                    c: *xev.Completion,\n                    s: StreamT,\n                    result: ResultT,\n                ) xev.CallbackAction {\n                    _ = l;\n                    _ = c;\n                    _ = s;\n                    const data = userdata.?;\n                    data.result = result;\n                    if (data.frame != null) libcoro.xresume(data.frame.?);\n                    return .disarm;\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "Pollable",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to Readable from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "fn Readable(comptime T: type, comptime StreamT: type) fn (T, xev.ReadBuffer) anyerror!usize {\n    return struct {\n        const Self = T;\n        const ReadResult = xev.ReadError!usize;\n        pub fn read(self: Self, buf: xev.ReadBuffer) anyerror!usize {\n            const ResultT = ReadResult;\n            const Data = struct {\n                result: ResultT = undefined,\n                frame: ?Frame = null,\n\n                fn callback(\n                    userdata: ?*@This(),\n                    l: *xev.Loop,\n                    c: *xev.Completion,\n                    s: StreamT,\n                    b: xev.ReadBuffer,\n                    result: ResultT,\n                ) xev.CallbackAction {\n                    _ = l;\n                    _ = c;\n                    _ = s;\n                    _ = b;\n                    const data = userdata.?;\n                    data.result = result;\n                    if (data.frame != null) libcoro.xresume(data.frame.?);\n                    return .disarm;\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "Readable",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to Writeable from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "fn Writeable(comptime T: type, comptime StreamT: type) fn (T, xev.WriteBuffer) anyerror!usize {\n    return struct {\n        const Self = T;\n        const WriteResult = xev.WriteError!usize;\n        pub fn write(self: Self, buf: xev.WriteBuffer) !usize {\n            const ResultT = WriteResult;\n            const Data = struct {\n                result: ResultT = undefined,\n                frame: ?Frame = null,\n\n                fn callback(\n                    userdata: ?*@This(),\n                    l: *xev.Loop,\n                    c: *xev.Completion,\n                    s: StreamT,\n                    b: xev.WriteBuffer,\n                    result: ResultT,\n                ) xev.CallbackAction {\n                    _ = l;\n                    _ = c;\n                    _ = s;\n                    _ = b;\n                    const data = userdata.?;\n                    data.result = result;\n                    if (data.frame != null) libcoro.xresume(data.frame.?);\n                    return .disarm;\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "Writeable",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn init(exec: *Executor, file: xev.File) Self {\n        return .{ .exec = exec, .file = file }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stream from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "fn stream(self: Self) xev.File {\n        return self.file;\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "stream",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pread from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn pread(self: Self, buf: xev.ReadBuffer, offset: u64) !usize {\n        const ResultT = PReadResult;\n        const Data = struct {\n            result: ResultT = undefined,\n            frame: ?Frame = null,\n\n            fn callback(\n                userdata: ?*@This(),\n                l: *xev.Loop,\n                c: *xev.Completion,\n                s: xev.File,\n                b: xev.ReadBuffer,\n                result: ResultT,\n            ) xev.CallbackAction {\n                _ = l;\n                _ = c;\n                _ = s;\n                _ = b;\n                const data = userdata.?;\n                data.result = result;\n                if (data.frame != null) libcoro.xresume(data.frame.?);\n                return .disarm;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "pread",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to pwrite from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn pwrite(self: Self, buf: xev.WriteBuffer, offset: u64) !usize {\n        const ResultT = PWriteResult;\n        const Data = struct {\n            result: ResultT = undefined,\n            frame: ?Frame = null,\n\n            fn callback(\n                userdata: ?*@This(),\n                l: *xev.Loop,\n                c: *xev.Completion,\n                s: xev.File,\n                b: xev.WriteBuffer,\n                result: ResultT,\n            ) xev.CallbackAction {\n                _ = l;\n                _ = c;\n                _ = s;\n                _ = b;\n                const data = userdata.?;\n                data.result = result;\n                if (data.frame != null) libcoro.xresume(data.frame.?);\n                return .disarm;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "pwrite",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn init(exec: *Executor, p: xev.Process) Self {\n        return .{ .exec = exec, .p = p }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wait from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn wait(self: Self) !u32 {\n        const Data = XCallback(WaitResult);\n        var c: xev.Completion = .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "wait",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn init(exec: *Executor, notif: xev.Async) Self {\n        return .{ .exec = exec, .notif = notif }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wait from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn wait(self: Self) !void {\n        const Data = XCallback(WaitResult);\n\n        const loop = self.exec.loop;\n        var c: xev.Completion = .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "wait",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn init(exec: *Executor, udp: xev.UDP) Self {\n        return .{ .exec = exec, .udp = udp }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stream from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn stream(self: Self) xev.UDP {\n        return self.udp;\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "stream",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn read(self: Self, buf: xev.ReadBuffer) anyerror!usize {\n        const ResultT = ReadResult;\n        const Data = struct {\n            result: ResultT = undefined,\n            frame: ?Frame = null,\n\n            fn callback(\n                userdata: ?*@This(),\n                l: *xev.Loop,\n                c: *xev.Completion,\n                s: *xev.UDP.State,\n                addr: std.net.Address,\n                udp: xev.UDP,\n                b: xev.ReadBuffer,\n                result: ResultT,\n            ) xev.CallbackAction {\n                _ = l;\n                _ = c;\n                _ = s;\n                _ = addr;\n                _ = udp;\n                _ = b;\n                const data = userdata.?;\n                data.result = result;\n                if (data.frame != null) libcoro.xresume(data.frame.?);\n                return .disarm;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "read",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub fn write(self: Self, addr: std.net.Address, buf: xev.WriteBuffer) anyerror!usize {\n        const ResultT = WriteResult;\n        const Data = struct {\n            result: ResultT = undefined,\n            frame: ?Frame = null,\n\n            fn callback(\n                userdata: ?*@This(),\n                l: *xev.Loop,\n                c: *xev.Completion,\n                s: *xev.UDP.State,\n                udp: xev.UDP,\n                b: xev.WriteBuffer,\n                result: ResultT,\n            ) xev.CallbackAction {\n                _ = l;\n                _ = c;\n                _ = s;\n                _ = udp;\n                _ = b;\n                const data = userdata.?;\n                data.result = result;\n                if (data.frame != null) libcoro.xresume(data.frame.?);\n                return .disarm;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "write",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to RunT from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "fn RunT(comptime Func: anytype) type {\n    const T = @typeInfo(@TypeOf(Func)).Fn.return_type.?;\n    return switch (@typeInfo(T)) {\n        .ErrorUnion => |E| E.payload,\n        else => T,\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "RunT",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to XCallback from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "fn XCallback(comptime ResultT: type) type {\n    return struct {\n        frame: ?Frame = null,\n        result: ResultT = undefined,\n\n        fn init() @This() {\n            return .{ .frame = libcoro.xframe() }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "XCallback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "fn callback(\n            userdata: ?*@This(),\n            _: *xev.Loop,\n            _: *xev.Completion,\n            result: ResultT,\n        ) xev.CallbackAction {\n            const data = userdata.?;\n            data.result = result;\n            if (data.frame != null) libcoro.xresume(data.frame.?);\n            return .disarm;\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Env from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "const Env = struct {\n    exec: ?*Executor = null,\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "Env",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to EnvArg from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub const EnvArg = struct {\n    executor: ?*Executor = null,\n    stack_allocator: ?std.mem.Allocator = null,\n    default_stack_size: ?usize = null,\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "EnvArg",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Executor from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub const Executor = struct {\n    loop: *xev.Loop,\n    exec: CoroExecutor = .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "Executor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to TCP from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub const TCP = struct {\n    const Self = @This();\n\n    exec: *Executor,\n    tcp: xev.TCP,\n\n    pub const close = Closeable(Self, xev.TCP);\n    pub const poll = Pollable(Self, xev.TCP);\n    pub const read = Readable(Self, xev.TCP);\n    pub const write = Writeable(Self, xev.TCP);\n\n    pub fn init(exec: *Executor, tcp: xev.TCP) Self {\n        return .{ .exec = exec, .tcp = tcp }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "TCP",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Data from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "const Data = struct {\n            result: ResultT = undefined,\n            frame: ?Frame = null,\n\n            fn callback(\n                userdata: ?*@This(),\n                l: *xev.Loop,\n                c: *xev.Completion,\n                s: xev.TCP,\n                result: ResultT,\n            ) xev.CallbackAction {\n                _ = l;\n                _ = c;\n                _ = s;\n                const data = userdata.?;\n                data.result = result;\n                if (data.frame != null) libcoro.xresume(data.frame.?);\n                return .disarm;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "Data",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Data from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "const Data = struct {\n            result: ResultT = undefined,\n            frame: ?Frame = null,\n\n            fn callback(\n                userdata: ?*@This(),\n                l: *xev.Loop,\n                c: *xev.Completion,\n                s: xev.TCP,\n                result: ResultT,\n            ) xev.CallbackAction {\n                _ = l;\n                _ = c;\n                _ = s;\n                const data = userdata.?;\n                data.result = result;\n                if (data.frame != null) libcoro.xresume(data.frame.?);\n                return .disarm;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "Data",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Data from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "const Data = struct {\n                result: ResultT = undefined,\n                frame: ?Frame = null,\n\n                fn callback(\n                    userdata: ?*@This(),\n                    l: *xev.Loop,\n                    c: *xev.Completion,\n                    s: StreamT,\n                    result: ResultT,\n                ) xev.CallbackAction {\n                    _ = l;\n                    _ = c;\n                    _ = s;\n                    const data = userdata.?;\n                    data.result = result;\n                    if (data.frame != null) libcoro.xresume(data.frame.?);\n                    return .disarm;\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "Data",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Data from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "const Data = struct {\n                result: ResultT = undefined,\n                frame: ?Frame = null,\n\n                fn callback(\n                    userdata: ?*@This(),\n                    l: *xev.Loop,\n                    c: *xev.Completion,\n                    s: StreamT,\n                    result: ResultT,\n                ) xev.CallbackAction {\n                    _ = l;\n                    _ = c;\n                    _ = s;\n                    const data = userdata.?;\n                    data.result = result;\n                    if (data.frame != null) libcoro.xresume(data.frame.?);\n                    return .disarm;\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "Data",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Data from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "const Data = struct {\n                result: ResultT = undefined,\n                frame: ?Frame = null,\n\n                fn callback(\n                    userdata: ?*@This(),\n                    l: *xev.Loop,\n                    c: *xev.Completion,\n                    s: StreamT,\n                    b: xev.ReadBuffer,\n                    result: ResultT,\n                ) xev.CallbackAction {\n                    _ = l;\n                    _ = c;\n                    _ = s;\n                    _ = b;\n                    const data = userdata.?;\n                    data.result = result;\n                    if (data.frame != null) libcoro.xresume(data.frame.?);\n                    return .disarm;\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "Data",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Data from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "const Data = struct {\n                result: ResultT = undefined,\n                frame: ?Frame = null,\n\n                fn callback(\n                    userdata: ?*@This(),\n                    l: *xev.Loop,\n                    c: *xev.Completion,\n                    s: StreamT,\n                    b: xev.WriteBuffer,\n                    result: ResultT,\n                ) xev.CallbackAction {\n                    _ = l;\n                    _ = c;\n                    _ = s;\n                    _ = b;\n                    const data = userdata.?;\n                    data.result = result;\n                    if (data.frame != null) libcoro.xresume(data.frame.?);\n                    return .disarm;\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "Data",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to File from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub const File = struct {\n    const Self = @This();\n\n    exec: *Executor,\n    file: xev.File,\n\n    pub const close = Closeable(Self, xev.File);\n    pub const poll = Pollable(Self, xev.File);\n    pub const read = Readable(Self, xev.File);\n    pub const write = Writeable(Self, xev.File);\n\n    pub fn init(exec: *Executor, file: xev.File) Self {\n        return .{ .exec = exec, .file = file }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "File",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Data from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "const Data = struct {\n            result: ResultT = undefined,\n            frame: ?Frame = null,\n\n            fn callback(\n                userdata: ?*@This(),\n                l: *xev.Loop,\n                c: *xev.Completion,\n                s: xev.File,\n                b: xev.ReadBuffer,\n                result: ResultT,\n            ) xev.CallbackAction {\n                _ = l;\n                _ = c;\n                _ = s;\n                _ = b;\n                const data = userdata.?;\n                data.result = result;\n                if (data.frame != null) libcoro.xresume(data.frame.?);\n                return .disarm;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "Data",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Data from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "const Data = struct {\n            result: ResultT = undefined,\n            frame: ?Frame = null,\n\n            fn callback(\n                userdata: ?*@This(),\n                l: *xev.Loop,\n                c: *xev.Completion,\n                s: xev.File,\n                b: xev.WriteBuffer,\n                result: ResultT,\n            ) xev.CallbackAction {\n                _ = l;\n                _ = c;\n                _ = s;\n                _ = b;\n                const data = userdata.?;\n                data.result = result;\n                if (data.frame != null) libcoro.xresume(data.frame.?);\n                return .disarm;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "Data",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Process from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub const Process = struct {\n    const Self = @This();\n\n    exec: *Executor,\n    p: xev.Process,\n\n    pub fn init(exec: *Executor, p: xev.Process) Self {\n        return .{ .exec = exec, .p = p }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "Process",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to AsyncNotification from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub const AsyncNotification = struct {\n    const Self = @This();\n\n    exec: *Executor,\n    notif: xev.Async,\n\n    pub fn init(exec: *Executor, notif: xev.Async) Self {\n        return .{ .exec = exec, .notif = notif }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "AsyncNotification",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to UDP from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "pub const UDP = struct {\n    const Self = @This();\n\n    exec: *Executor,\n    udp: xev.UDP,\n\n    pub const close = Closeable(Self, xev.UDP);\n    pub const poll = Pollable(Self, xev.UDP);\n\n    pub fn init(exec: *Executor, udp: xev.UDP) Self {\n        return .{ .exec = exec, .udp = udp }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "UDP",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Data from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "const Data = struct {\n            result: ResultT = undefined,\n            frame: ?Frame = null,\n\n            fn callback(\n                userdata: ?*@This(),\n                l: *xev.Loop,\n                c: *xev.Completion,\n                s: *xev.UDP.State,\n                addr: std.net.Address,\n                udp: xev.UDP,\n                b: xev.ReadBuffer,\n                result: ResultT,\n            ) xev.CallbackAction {\n                _ = l;\n                _ = c;\n                _ = s;\n                _ = addr;\n                _ = udp;\n                _ = b;\n                const data = userdata.?;\n                data.result = result;\n                if (data.frame != null) libcoro.xresume(data.frame.?);\n                return .disarm;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "Data",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Data from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/asyncio.zig",
    "response": "const Data = struct {\n            result: ResultT = undefined,\n            frame: ?Frame = null,\n\n            fn callback(\n                userdata: ?*@This(),\n                l: *xev.Loop,\n                c: *xev.Completion,\n                s: *xev.UDP.State,\n                udp: xev.UDP,\n                b: xev.WriteBuffer,\n                result: ResultT,\n            ) xev.CallbackAction {\n                _ = l;\n                _ = c;\n                _ = s;\n                _ = udp;\n                _ = b;\n                const data = userdata.?;\n                data.result = result;\n                if (data.frame != null) libcoro.xresume(data.frame.?);\n                return .disarm;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/asyncio.zig",
      "type": "struct",
      "name": "Data",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to Channel from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/channel.zig",
    "response": "pub fn Channel(comptime T: type, comptime capacity: usize) type {\n    const Storage = stdx.queue.ArrayQueue(T, capacity);\n\n    return struct {\n        const Self = @This();\n\n        q: Storage = .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/channel.zig",
      "type": "function",
      "name": "Channel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/channel.zig",
    "response": "pub fn init(exec: *executor.Executor) Self {\n            return initWithLen(exec, capacity);\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/channel.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to initWithLen from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/channel.zig",
    "response": "pub fn initWithLen(exec: *executor.Executor, len: usize) Self {\n            return .{\n                .len = len,\n                .space_notif = executor.Condition.init(exec),\n                .value_notif = executor.Condition.init(exec),\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/channel.zig",
      "type": "function",
      "name": "initWithLen",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to close from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/channel.zig",
    "response": "pub fn close(self: *Self) void {\n            self.closed = true;\n            self.value_notif.signal();\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/channel.zig",
      "type": "function",
      "name": "close",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to try_send from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/channel.zig",
    "response": "pub fn try_send(self: *Self, val: T) bool {\n            stdx.debug.assert(self.closed == false, \"cannot send on closed Channel\", .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/channel.zig",
      "type": "function",
      "name": "try_send",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/channel.zig",
    "response": "pub fn send(self: *Self, val: T) void {\n            stdx.debug.assert(self.closed == false, \"cannot send on closed Channel\", .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/channel.zig",
      "type": "function",
      "name": "send",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to recv from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/channel.zig",
    "response": "pub fn recv(self: *Self) ?T {\n            while (self.closed == false or self.q.len() > 0) {\n                if (self.q.pop()) |val| {\n                    self.space_notif.signal();\n                    return val;\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/channel.zig",
      "type": "function",
      "name": "recv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to try_recv from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/channel.zig",
    "response": "pub fn try_recv(self: *Self) ?T {\n            if (self.closed == true) {\n                return null;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/channel.zig",
      "type": "function",
      "name": "try_recv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to xawait from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn xawait(frame: anytype) @TypeOf(frame).Signature.ReturnT {\n    const f = frame.frame();\n    while (f.status != .Done) xsuspend();\n    std.debug.assert(f.status == .Done);\n    return frame.xreturned();\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "xawait",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to xasync from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn xasync(func: anytype, args: anytype, stack_: stack.Stack) !FrameT(func, @TypeOf(args)) {\n    const FrameType = CoroT.fromFunc(func, @TypeOf(args));\n    const framet = try FrameType.init(args, stack_);\n    const frame = framet.frame();\n    xresume(frame);\n    return FrameType.wrap(frame);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "xasync",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to inCoro from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn inCoro() bool {\n    return thread_state.inCoro();\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "inCoro",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to xframe from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn xframe() Frame {\n    return thread_state.current();\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "xframe",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to xresume from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn xresume(frame: anytype) void {\n    const f = frame.frame();\n    thread_state.switchIn(f);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "xresume",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to xsuspend from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn xsuspend() void {\n    xsuspendSafe() catch |e| {\n        log(.err, \"{any}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "xsuspend",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to xsuspendBlock from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn xsuspendBlock(comptime func: anytype, args: anytype) void {\n    const Signature = stdx.meta.FnSignature(func, @TypeOf(args));\n    const Callback = struct {\n        func: *const Signature.FuncT,\n        args: Signature.ArgsT,\n        fn cb(ud: ?*anyopaque) void {\n            const self: *@This() = @ptrCast(@alignCast(ud));\n            @call(.auto, self.func, self.args);\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "xsuspendBlock",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to xsuspendSafe from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn xsuspendSafe() Error!void {\n    if (thread_state.current_coro == null) {\n        return Error.SuspendFromMain;\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "xsuspendSafe",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn init(func: *const fn () void, stack_: stack.Stack, storage: ?*anyopaque) !Frame {\n        return initFromStack(func, stack_, storage);\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn deinit(_: Coro) void {\n        // empty\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to initFromStack from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn initFromStack(func: *const fn () void, stack_: stack.Stack, storage: ?*anyopaque) !Frame {\n        // try StackOverflow.setMagicNumber(stack.full);\n        var stack__ = stack_;\n        const coro = try stack__.push(Coro);\n        const base_coro = try base.Coro.init(&runcoro, stack__.remaining());\n        coro.* = .{\n            .func = func,\n            .impl = base_coro,\n            .stack = stack__,\n            .storage = storage,\n            .id = thread_state.newCoroId(),\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "initFromStack",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to frame from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn frame(self: *Coro) Frame {\n        return self;\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "frame",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to runcoro from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn runcoro(from: *base.Coro, this: *base.Coro) callconv(.c) noreturn {\n        const from_coro: *Coro = @fieldParentPtr(\"impl\", from);\n        const this_coro: *Coro = @fieldParentPtr(\"impl\", this);\n        log(.debug, \"coro start {f}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "runcoro",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getStorage from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn getStorage(self: Coro, comptime T: type) *T {\n        return @ptrCast(@alignCast(self.storage));\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "getStorage",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to format from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn format(self: Coro, writer: *std.Io.Writer) !void {\n        try writer.print(\"Coro{{.id = {any}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "format",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromFunc from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn fromFunc(comptime Func: anytype, comptime ArgsT: ?type) type {\n        return fromSig(stdx.meta.FnSignature(Func, ArgsT));\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "fromFunc",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromSig from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn fromSig(comptime Sig: stdx.meta.Signature) type {\n        // Stored in the coro stack\n        const InnerStorage = struct {\n            args: Sig.ArgsT,\n            /// Values that are produced during coroutine execution\n            retval: Sig.ReturnT = undefined,\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "fromSig",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn init(args: Sig.ArgsT, stack_: StackT) !Self {\n                var coro_stack = stack_;\n                const inner = try coro_stack.push(InnerStorage);\n                inner.* = .{\n                    .args = args,\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wrap from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn wrap(_frame: Frame) Self {\n                return .{ ._frame = _frame }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "wrap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn deinit(self: Self) void {\n                self._frame.deinit();\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to status from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn status(self: Self) Coro.Status {\n                return self._frame.status;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "status",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to frame from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn frame(self: Self) Frame {\n                return self._frame;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "frame",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to xreturned from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn xreturned(self: Self) Sig.ReturnT {\n                const storage = self._frame.getStorage(InnerStorage);\n                return storage.retval;\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "xreturned",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wrapfn from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn wrapfn() void {\n                const storage = thread_state.currentStorage(InnerStorage);\n                storage.retval = @call(\n                    .auto,\n                    Sig.Func.Value,\n                    storage.args,\n                );\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "wrapfn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn run(self: SuspendBlock) void {\n            @call(.auto, self.func, .{self.data}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "run",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to switchIn from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn switchIn(self: *ThreadState, target: Frame) void {\n        log(.debug, \"coro resume {f}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "switchIn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to switchOut from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn switchOut(self: *ThreadState, target: Frame) void {\n        log(.debug, \"coro suspend {f}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "switchOut",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to switchTo from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn switchTo(self: *ThreadState, target: Frame, set_resumer: bool) void {\n        const suspender = self.current();\n        if (suspender == target) {\n            return;\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "switchTo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to newCoroId from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn newCoroId(self: *ThreadState) CoroId.InvocationId {\n        const out = CoroId.InvocationId.init(.{\n            .coro = self.next_coro_id,\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "newCoroId",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to current from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn current(self: *ThreadState) Frame {\n        return self.current_coro orelse &self.root_coro;\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "current",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to inCoro from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn inCoro(self: *ThreadState) bool {\n        return self.current() != &self.root_coro;\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "inCoro",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to currentStorage from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn currentStorage(self: *ThreadState, comptime T: type) *T {\n        return self.current_coro.?.getStorage(T);\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "currentStorage",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn init(id: CoroId) @This() {\n            _ = id;\n            return .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to incr from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn incr(self: *@This()) void {\n            _ = self;\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "incr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn init(id: CoroId) @This() {\n            return .{ .id = id }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to root from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn root() @This() {\n            return .{ .id = .{ .coro = 0 }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "root",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to incr from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn incr(self: *@This()) void {\n            self.invocation += 1;\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "incr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to format from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn format(self: @This(), writer: *std.Io.Writer) !void {\n            try writer.print(\"CoroId{{.cid={d}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "format",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to check from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn check(_: Frame) !void {\n        // const stack = coro.stack.ptr;\n        // const sp = coro.impl.stack_pointer;\n        // const magic_number_ptr: *usize = @ptrCast(stack);\n        // if (magic_number_ptr.* != magic_number or //\n        //     @intFromPtr(sp) < @intFromPtr(stack))\n        // {\n        //     return Error.StackOverflow;\n        // }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "check",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to setMagicNumber from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn setMagicNumber(_: stack.Stack) !void {\n        // if (stack.len <= @sizeOf(usize)) {\n        //     return Error.StackTooSmall;\n        // }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "setMagicNumber",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to testSetIdx from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn testSetIdx(val: usize) void {\n    test_steps[test_idx] = val;\n    test_idx += 1;\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "testSetIdx",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to testFn from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn testFn() void {\n    // Check if the stack was already overflowed\n    const current = xframe();\n    std.debug.assert(current.stack.remaining().len > 2048);\n    testSetIdx(2);\n    xsuspend();\n    testSetIdx(4);\n    xsuspend();\n    testSetIdx(6);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "testFn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to coroInner from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn coroInner(x: *usize) void {\n    //         x.* += 1;\n    //         xsuspend();\n    //         x.* += 3;\n    //     }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "coroInner",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to coroWrap from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn coroWrap() void {\n    //         const storage = xframe().getStorage(Storage);\n    //         const x = storage.x;\n    //         coroInner(x);\n    //     }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "coroWrap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to testCoroFnImpl from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "fn testCoroFnImpl(x: *usize) usize {\n    x.* += 1;\n    xsuspend();\n    x.* += 3;\n    xsuspend();\n    return x.* + 10;\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "testCoroFnImpl",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to log from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "pub fn log(comptime level: std.log.Level, comptime fmt: []const u8, args: anytype) void {\n    if (comptime !std.log.logEnabled(level, .@\"zml/async\")) return;\n\n    // Since this logs are to debug the async runtime, we want it to happen synchronously.\n    std.log.defaultLog(level, .@\"zml/async\", fmt, args);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "function",
      "name": "log",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Callback from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const Callback = struct {\n        func: *const Signature.FuncT,\n        args: Signature.ArgsT,\n        fn cb(ud: ?*anyopaque) void {\n            const self: *@This() = @ptrCast(@alignCast(ud));\n            @call(.auto, self.func, self.args);\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "struct",
      "name": "Callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Coro from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const Coro = struct {\n    /// Coroutine status\n    const Status = enum {\n        Start,\n        Suspended,\n        Active,\n        Done,\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "struct",
      "name": "Coro",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to CoroT from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const CoroT = struct {\n    fn fromFunc(comptime Func: anytype, comptime ArgsT: ?type) type {\n        return fromSig(stdx.meta.FnSignature(Func, ArgsT));\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "struct",
      "name": "CoroT",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to InnerStorage from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const InnerStorage = struct {\n            args: Sig.ArgsT,\n            /// Values that are produced during coroutine execution\n            retval: Sig.ReturnT = undefined,\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "struct",
      "name": "InnerStorage",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ThreadState from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const ThreadState = struct {\n    root_coro: Coro = .{\n        .func = undefined,\n        .stack = undefined,\n        .impl = undefined,\n        .id = CoroId.InvocationId.root(),\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "struct",
      "name": "ThreadState",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to SuspendBlock from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const SuspendBlock = struct {\n        func: *const fn (?*anyopaque) void,\n        data: ?*anyopaque,\n\n        fn run(self: SuspendBlock) void {\n            @call(.auto, self.func, .{self.data}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "struct",
      "name": "SuspendBlock",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to CoroId from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const CoroId = struct {\n    coro: usize,\n\n    pub const InvocationId = if (builtin.mode == .Debug) DebugInvocationId else DummyInvocationId;\n\n    const DummyInvocationId = struct {\n        fn init(id: CoroId) @This() {\n            _ = id;\n            return .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "struct",
      "name": "CoroId",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to DebugInvocationId from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const DebugInvocationId = struct {\n        id: CoroId,\n        invocation: i64 = -1,\n\n        fn init(id: CoroId) @This() {\n            return .{ .id = id }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "struct",
      "name": "DebugInvocationId",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to StackOverflow from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const StackOverflow = struct {\n    const magic_number: usize = 0x5E574D6D;\n\n    fn check(_: Frame) !void {\n        // const stack = coro.stack.ptr;\n        // const sp = coro.impl.stack_pointer;\n        // const magic_number_ptr: *usize = @ptrCast(stack);\n        // if (magic_number_ptr.* != magic_number or //\n        //     @intFromPtr(sp) < @intFromPtr(stack))\n        // {\n        //     return Error.StackOverflow;\n        // }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "struct",
      "name": "StackOverflow",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Test from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const Test = struct {\n    //     const Storage = struct {\n    //         x: *usize,\n    //     }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "struct",
      "name": "Test",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const self: *@This() = @ptrCast(@alignCast(ud));",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to from_coro from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const from_coro: *Coro = @fieldParentPtr(\"impl\", from);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "const",
      "name": "from_coro",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to this_coro from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const this_coro: *Coro = @fieldParentPtr(\"impl\", this);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "const",
      "name": "this_coro",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to magic_number from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const magic_number: usize = 0x5E574D6D;",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "const",
      "name": "magic_number",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to magic_number_ptr from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const magic_number_ptr: *usize = @ptrCast(stack);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "const",
      "name": "magic_number_ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to magic_number_ptr from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const magic_number_ptr: *usize = @ptrCast(stack.ptr);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "const",
      "name": "magic_number_ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to stack_size from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro.zig",
    "response": "const stack_size: usize = 1024 * 4;",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro.zig",
      "type": "const",
      "name": "stack_size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to libcoro_stack_swap from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro_base.zig",
    "response": "fn libcoro_stack_swap(current: *Coro, target: *Coro) void;\ncomptime {\n    asm (arch_info.assembly);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro_base.zig",
      "type": "function",
      "name": "libcoro_stack_swap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro_base.zig",
    "response": "pub fn init(func: Func, stack: []align(stack_alignment) u8) !Self {\n        stdx.debug.assertComptime(@sizeOf(usize) == 8, \"usize expected to take 8 bytes\", .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro_base.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resumeFrom from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro_base.zig",
    "response": "fn resumeFrom(self: *Self, from: *Self) void {\n        libcoro_stack_swap(from, self);\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro_base.zig",
      "type": "function",
      "name": "resumeFrom",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ArchInfo from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro_base.zig",
    "response": "const ArchInfo = struct {\n    num_registers: usize,\n    jump_idx: usize,\n    assembly: []const u8,\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro_base.zig",
      "type": "struct",
      "name": "ArchInfo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to jump_ptr from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/coro_base.zig",
    "response": "const jump_ptr: *Func = @ptrCast(@alignCast(&register_space[arch_info.jump_idx * 8]));",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/coro_base.zig",
      "type": "const",
      "name": "jump_ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "pub fn init(func: FuncFn, userdata: ?*anyopaque) Func {\n            return .{ .func = func, .userdata = userdata }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "fn run(self: Func) void {\n            @call(.auto, self.func, .{self.userdata}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "run",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to runSoon from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "pub fn runSoon(self: *Self, func: *Func) void {\n        self.readyq.push(func);\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "runSoon",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to runAllSoon from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "pub fn runAllSoon(self: *Self, funcs: stdx.queue.SPSC(Func)) void {\n        self.readyq.pushAll(funcs);\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "runAllSoon",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tick from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "pub fn tick(self: *Self) bool {\n        // Reset readyq so that adds run on next tick.\n        var now = self.readyq;\n        self.readyq = .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "tick",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "pub fn init(exec: *Executor) Condition {\n        return .{ .exec = exec }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to broadcast from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "pub fn broadcast(self: *Condition) void {\n        self.exec.runAllSoon(self.waiters);\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "broadcast",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to signal from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "pub fn signal(self: *Condition) void {\n        if (self.waiters.pop()) |waiter_func| {\n            self.exec.runSoon(waiter_func);\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "signal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wait from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "pub fn wait(self: *Condition) void {\n        var cr = CoroResume.init();\n        var cb = cr.func();\n        self.waiters.push(&cb);\n        libcoro.xsuspend();\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "wait",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "pub fn init() Self {\n        return .{ .coro = libcoro.xframe() }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to func from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "pub fn func(self: *Self) Executor.Func {\n        return .{ .func = Self.cb, .userdata = self }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "func",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to cb from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "fn cb(ud: ?*anyopaque) void {\n        const self: *Self = @ptrCast(@alignCast(ud));\n        libcoro.xresume(self.coro);\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "cb",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getExec from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "pub fn getExec(exec: ?*Executor) *Executor {\n    if (exec != null) return exec.?;\n    if (libcoro.getEnv().executor) |x| return x;\n    @panic(\"No explicit Executor passed and no default Executor available\");\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "getExec",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ArrayQueue from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "pub fn ArrayQueue(comptime T: type, comptime size: usize) type {\n    return struct {\n        const Self = @This();\n\n        vals: [size]T = undefined,\n        head: ?usize = null,\n        tail: ?usize = null,\n\n        fn init() Self {\n            return .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "ArrayQueue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to len from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "fn len(self: Self) usize {\n            switch (self.state()) {\n                .empty => return 0,\n                .one => return 1,\n                .many => {\n                    const head = self.head.?;\n                    const tail = self.tail.?;\n                    if (tail > head) {\n                        return tail - head + 1;\n                    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "len",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to space from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "fn space(self: Self) usize {\n            return size - self.len();\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "space",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to push from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "fn push(self: *@This(), val: T) !void {\n            if (self.space() < 1) return error.QueueFull;\n            switch (self.state()) {\n                .empty => {\n                    self.head = 0;\n                    self.tail = 0;\n                    self.vals[0] = val;\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "push",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pop from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "fn pop(self: *Self) ?T {\n            switch (self.state()) {\n                .empty => return null,\n                .one => {\n                    const out = self.vals[self.head.?];\n                    self.head = null;\n                    self.tail = null;\n                    return out;\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "pop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to state from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "fn state(self: Self) State {\n            if (self.head == null) return .empty;\n            if (self.head.? == self.tail.?) return .one;\n            return .many;\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "function",
      "name": "state",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Executor from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "pub const Executor = struct {\n    const Self = @This();\n\n    pub const Func = struct {\n        const FuncFn = *const fn (userdata: ?*anyopaque) void;\n\n        func: FuncFn,\n        userdata: ?*anyopaque = null,\n        next: ?*Func = null,\n\n        pub fn init(func: FuncFn, userdata: ?*anyopaque) Func {\n            return .{ .func = func, .userdata = userdata }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "struct",
      "name": "Executor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Condition from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "pub const Condition = struct {\n    exec: *Executor,\n    waiters: stdx.queue.SPSC(Executor.Func) = .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "struct",
      "name": "Condition",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to CoroResume from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "pub const CoroResume = struct {\n    const Self = @This();\n\n    coro: libcoro.Frame,\n\n    pub fn init() Self {\n        return .{ .coro = libcoro.xframe() }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "struct",
      "name": "CoroResume",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/executor.zig",
    "response": "const self: *Self = @ptrCast(@alignCast(ud));",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/executor.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ptr from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/stack.zig",
    "response": "pub fn ptr(self: *const Data) [*]u8 {\n            return &self.data;\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/stack.zig",
      "type": "function",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/stack.zig",
    "response": "pub fn init(full: *Data) Stack {\n        return .{\n            .full = full,\n            .used = full.data[full.data.len..],\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/stack.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to remaining from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/stack.zig",
    "response": "pub fn remaining(self: Stack) []align(coro_base.stack_alignment) u8 {\n        return self.full.data[0 .. self.full.data.len - self.used.len];\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/stack.zig",
      "type": "function",
      "name": "remaining",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to push from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/stack.zig",
    "response": "pub fn push(self: *Stack, comptime T: type) !*T {\n        const ptr_i = std.mem.alignBackward(\n            usize,\n            @intFromPtr(self.used.ptr - @sizeOf(T)),\n            coro_base.stack_alignment,\n        );\n        if (ptr_i <= @intFromPtr(&self.full.data[0])) {\n            return error.StackTooSmall;\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/stack.zig",
      "type": "function",
      "name": "push",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/stack.zig",
    "response": "pub fn init(allocator: std.mem.Allocator) PooledStackAllocator {\n        return .{ .pool = Pool.init(allocator) }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/stack.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/stack.zig",
    "response": "pub fn deinit(self: *PooledStackAllocator) void {\n        self.pool.deinit();\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/stack.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to create from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/stack.zig",
    "response": "pub fn create(self: *PooledStackAllocator) !Stack {\n        return Stack.init(try self.pool.create());\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/stack.zig",
      "type": "function",
      "name": "create",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to destroy from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/stack.zig",
    "response": "pub fn destroy(self: *PooledStackAllocator, stack: *Stack) void {\n        self.pool.destroy(stack.full);\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/stack.zig",
      "type": "function",
      "name": "destroy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/stack.zig",
    "response": "pub fn init(allocator: std.mem.Allocator) StackAllocator {\n        return .{ .allocator = allocator }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/stack.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/stack.zig",
    "response": "pub fn deinit(_: *StackAllocator) void {\n        // empty\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/stack.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to create from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/stack.zig",
    "response": "pub fn create(self: *StackAllocator) !Stack {\n        return Stack.init(try self.allocator.create(Stack.Data));\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/stack.zig",
      "type": "function",
      "name": "create",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to destroy from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/stack.zig",
    "response": "pub fn destroy(self: *StackAllocator, stack: *Stack) void {\n        self.allocator.destroy(stack.full);\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/stack.zig",
      "type": "function",
      "name": "destroy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Stack from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/stack.zig",
    "response": "pub const Stack = struct {\n    pub const Data = struct {\n        data: [stack_size]u8 align(coro_base.stack_alignment) = undefined,\n\n        pub fn ptr(self: *const Data) [*]u8 {\n            return &self.data;\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/stack.zig",
      "type": "struct",
      "name": "Stack",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to PooledStackAllocator from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/stack.zig",
    "response": "pub const PooledStackAllocator = struct {\n    const Pool = std.heap.MemoryPoolAligned(Stack.Data, coro_base.stack_alignment);\n\n    pool: Pool,\n\n    pub fn init(allocator: std.mem.Allocator) PooledStackAllocator {\n        return .{ .pool = Pool.init(allocator) }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/stack.zig",
      "type": "struct",
      "name": "PooledStackAllocator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to StackAllocator from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: async/stack.zig",
    "response": "pub const StackAllocator = struct {\n    allocator: std.mem.Allocator,\n\n    pub fn init(allocator: std.mem.Allocator) StackAllocator {\n        return .{ .allocator = allocator }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "async/stack.zig",
      "type": "struct",
      "name": "StackAllocator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to benchmark from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/benchmark/main.zig",
    "response": "pub fn benchmark(a: zml.Tensor, b: zml.Tensor) zml.Tensor {\n    return a.withSharding(.{.k}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/benchmark/main.zig",
      "type": "function",
      "name": "benchmark",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/benchmark/main.zig",
    "response": "pub fn main() !void {\n    try async.AsyncThread.main(std.heap.c_allocator, asyncMain);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/benchmark/main.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to asyncMain from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/benchmark/main.zig",
    "response": "pub fn asyncMain() !void {\n    const CliArgs = struct {\n        pub const help =\n            \\\\ benchmark --size=4096 --dtype=f16\n        ;\n        size: usize = 4096,\n        dtype: zml.DataType = .f16,\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/benchmark/main.zig",
      "type": "function",
      "name": "asyncMain",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to createRandomBuffer from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/benchmark/main.zig",
    "response": "fn createRandomBuffer(allocator: std.mem.Allocator, platform: zml.Platform, shape: zml.Shape, random: std.Random) !zml.Buffer {\n    const data = try allocator.alloc(u8, shape.byteSize());\n    defer allocator.free(data);\n\n    switch (shape.dtype()) {\n        inline else => |v| {\n            const ZigType = v.toZigType();\n            switch (comptime v.class()) {\n                .bool => unreachable,\n                .integer => {\n                    for (std.mem.bytesAsSlice(ZigType, data)) |*e| e.* = random.int(ZigType);\n                }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/benchmark/main.zig",
      "type": "function",
      "name": "createRandomBuffer",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig struct similar to CliArgs from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/benchmark/main.zig",
    "response": "const CliArgs = struct {\n        pub const help =\n            \\\\ benchmark --size=4096 --dtype=f16\n        ;\n        size: usize = 4096,\n        dtype: zml.DataType = .f16,\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/benchmark/main.zig",
      "type": "struct",
      "name": "CliArgs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to std_options from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/benchmark/main.zig",
    "response": "pub const std_options: std.Options = .{\n    .log_level = .warn,\n    .logFn = async.logFn(std.log.defaultLog),\n};",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/benchmark/main.zig",
      "type": "const",
      "name": "std_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "pub fn init(platform: zml.Platform) !GrayScale {\n        var cu_data: [2]*anyopaque = undefined;\n        if (comptime runtimes.isEnabled(.cuda)) {\n            var module: cu.CUmodule = undefined;\n            try cuda.check(cuda.moduleLoadData.?(&module, grayscale_ptx));\n            log.info(\"Loaded Grayscale cuda module\", .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "pub fn deinit(self: *GrayScale) void {\n        if (comptime runtimes.isEnabled(.cuda)) {\n            const module: cu.CUmodule = @ptrCast(self.cu_data[0]);\n            _ = cuda.moduleUnload.?(module);\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to call from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "pub fn call(self: *GrayScale, rgb_d: zml.Buffer) !void {\n        switch (self.platform.target) {\n            .cpu => grayScaleCpu(rgb_d, self.results[0]),\n            // Only try to compile `grayScaleCuda` if we have cuda symbols.\n            .cuda => if (comptime runtimes.isEnabled(.cuda))\n                try self.grayScaleCuda(rgb_d, self.results[0])\n            else\n                unreachable,\n            else => @panic(\"Platform not supported\"),\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "function",
      "name": "call",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to grayScaleCpu from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "pub fn grayScaleCpu(rgb_d: zml.Buffer, gray_d: zml.Buffer) void {\n        const rgb_h = rgb_d.asHostBuffer().items(u8);\n        const gray_h = gray_d.asHostBuffer().mutItems(u8);\n\n        for (gray_h, 0..) |*gray, i| {\n            const px = rgb_h[i * 3 .. i * 3 + 3];\n            const R: u32 = @intCast(px[0]);\n            const G: u32 = @intCast(px[1]);\n            const B: u32 = @intCast(px[2]);\n            const gray_u32: u32 = @divFloor(299 * R + 587 * G + 114 * B, 1000);\n            gray.* = @intCast(gray_u32);\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "function",
      "name": "grayScaleCpu",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to grayScaleCuda from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "pub fn grayScaleCuda(self: GrayScale, rgb_d: zml.Buffer, gray_d: zml.Buffer) !void {\n        var args: [2:null]?*anyopaque = .{ rgb_d.devicePtr(), gray_d.devicePtr() }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "function",
      "name": "grayScaleCuda",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to grayscale from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "pub fn grayscale(rgb: zml.Tensor) zml.Tensor {\n    const gray_shape = rgb.shape().setDim(0, @divExact(rgb.dim(0), 3));\n    const result = zml.callback.call(GrayScale, .{rgb.print()}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "function",
      "name": "grayscale",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "pub fn main() !void {\n    try async.AsyncThread.main(std.heap.smp_allocator, asyncMain);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to asyncMain from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "pub fn asyncMain() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "function",
      "name": "asyncMain",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to GrayScale from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "pub const GrayScale = struct {\n    // Mandatory fields to work with ZML custom call api\n    pub var type_id: zml.pjrt.ffi.TypeId = undefined;\n    pub const callback_config: zml.callback.Config = .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "struct",
      "name": "GrayScale",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to cuda from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "const cuda = struct {\n        // Here we leverage ZML sandboxing to access cuda symbols and their definitions.\n        const moduleLoadData = @extern(*const @TypeOf(cu.cuModuleLoadData), .{ .name = \"cuModuleLoadData\", .linkage = .weak }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "struct",
      "name": "cuda",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to std_options from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "pub const std_options: std.Options = .{\n    .log_level = .info,\n    .logFn = async.logFn(std.log.defaultLog),\n};",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "const",
      "name": "std_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to callback_config from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "pub const callback_config: zml.callback.Config = .{};",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "const",
      "name": "callback_config",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to module from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "const module: cu.CUmodule = @ptrCast(self.cu_data[0]);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "const",
      "name": "module",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to R from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "const R: u32 = @intCast(px[0]);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "const",
      "name": "R",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to G from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "const G: u32 = @intCast(px[1]);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "const",
      "name": "G",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to B from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "const B: u32 = @intCast(px[2]);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "const",
      "name": "B",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to gray_u32 from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "const gray_u32: u32 = @divFloor(299 * R + 587 * G + 114 * B, 1000);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "const",
      "name": "gray_u32",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to rgb_h from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/callback/main.zig",
    "response": "const rgb_h: [12][3]u8 = @splat(.{ 0xFF, 0xAA, 0x00 });",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/callback/main.zig",
      "type": "const",
      "name": "rgb_h",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn init(allocator: std.mem.Allocator, store: zml.aio.BufferStore, config: Config, options: Options) !GptOss {\n    var self: GptOss = .{\n        .config = config,\n        .options = options,\n        .model = .{\n            .max_seq_len = @intCast(options.max_seq_len),\n            .num_heads = @intCast(config.num_attention_heads),\n            .num_kv_heads = @intCast(config.num_key_value_heads),\n            .rope_opts = .{\n                .layout = if (config.hf_rope_impl) .sequential else .interleaved,\n                .freq_base = config.rope_theta,\n                .scaling = config.rope_scaling,\n            }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn forward(\n    self: GptOss,\n    tokens_: zml.Tensor,\n    mode: Mode,\n    kv_cache: KvCache,\n    rng: zml.Tensor.Rng,\n) struct { zml.Tensor, KvCache, zml.Tensor.Rng }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sampleTokens from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "fn sampleTokens(\n    self: GptOss,\n    lm_head_: ?zml.nn.Linear,\n    out_: zml.Tensor,\n    rng: zml.Tensor.Rng,\n    opts: zml.nn.SamplingStrategy,\n) struct { zml.Tensor, zml.Tensor.Rng }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "sampleTokens",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to loadBuffers from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn loadBuffers(self: GptOss, allocator: std.mem.Allocator, store: zml.aio.BufferStore, platform: zml.Platform) !zml.Bufferized(GptOss) {\n    var prefix: zml.aio.PrefixBuilder = try .initCapacity(allocator, 256);\n    defer prefix.deinit(allocator);\n\n    const noalloc = stdx.noalloc;\n    const loaded: zml.Bufferized(GptOss) = .{\n        .model = .{\n            .embed_tokens = try store.loadModelById(zml.nn.TokenEmbedding, noalloc, self.model.embed_tokens, platform),\n            .layers = try allocator.alloc(zml.Bufferized(TransformerLayer), self.model.layers.len),\n            .norm = try store.loadModelById(RmsNorm, noalloc, self.model.norm, platform),\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "loadBuffers",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn forward(self: Model, tokens: zml.Tensor, token_index: zml.Tensor, kv_cache: KvCache) struct { zml.Tensor, KvCache }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to embed from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn embed(embed_tokens_: zml.nn.TokenEmbedding, tokens_: zml.Tensor) zml.Tensor {\n        return zml.call(embed_tokens_, .forward, .{tokens_}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "embed",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn forward(\n        self: TransformerLayer,\n        x0: zml.Tensor,\n        token_index: zml.Tensor,\n        kv_cache: KvCache,\n    ) struct { zml.Tensor, KvCache }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn forward(self: RmsNorm, input: zml.Tensor) zml.Tensor {\n        const x = if (input.shape().isFullyTagged()) input else input.withPartialTags(.{.d}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn forward(self: MoE, input: zml.Tensor) zml.Tensor {\n        log.warn(\"compiling moe with {f}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rewrite from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn rewrite(on_disk: OnDisk, experts_per_token: u32, options: Options) MoE {\n            const e = on_disk.experts;\n            return .{\n                .experts = .{\n                    .gate_up_proj = .{\n                        // We need to bitcast the scale cause safetensors doesn't encode f8 types correctly\n                        .scale = e.gate_up_proj_scales.withTags(.{ .expert, .out, .d }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "rewrite",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn forward(self: Mlp, x: zml.Tensor) zml.Tensor {\n        const dt = x.dtype();\n        var gate, var up = zml.nn.splitRealImg(self.gate_up_proj.forward(x), .interleaved);\n        gate = .minimum(gate, .scalar(7, dt));\n        up = .clamp(up, .scalar(-7, dt), .scalar(7, dt));\n\n        const out = gate.quickGelu().mul(up.addConstant(1));\n        return zml.call(self.down_proj, .forward, .{out}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to format from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn format(self: Mlp, writer: *std.Io.Writer) std.Io.Writer.Error!void {\n        try writer.print(\"Mlp(gate_up_proj=.{f}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "format",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn forward(\n        self: SelfAttn,\n        x: zml.Tensor,\n        token_index: zml.Tensor,\n        kv_cache: KvCache,\n    ) struct { zml.Tensor, KvCache }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn init(kv_shape: zml.Shape) KvCache {\n        // The KV-cache is initialized with ones to detect reads of uninitialized memory.\n        return .{\n            .k = .constant(kv_shape, kv_shape.dtype().one()).withSharding(.{.h}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to initShape from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn initShape(kv_shape: zml.Shape) zml.ShapeOf(KvCache) {\n        return .{\n            .k = kv_shape,\n            .v = kv_shape,\n            .layer_index = zml.Shape.init(.{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "initShape",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to initBuffer from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn initBuffer(kv_shape: zml.Shape, platform: zml.Platform) !zml.Bufferized(KvCache) {\n        return .{\n            .k = try zml.Buffer.uninitialized(platform, kv_shape, .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "initBuffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to keys from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn keys(self: KvCache) zml.Tensor {\n        return self.k.dynamicSlice(.{ .layer = zml.Tensor.DynSlice{ .start = self.layer_index, .len = 1 }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "keys",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to values from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn values(self: KvCache) zml.Tensor {\n        return self.v.dynamicSlice(.{ .layer = zml.Tensor.DynSlice{ .start = self.layer_index, .len = 1 }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "values",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to update from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn update(self: KvCache, new_k: zml.Tensor, new_v: zml.Tensor, token_index: ?zml.Tensor) KvCache {\n        const idx = if (token_index) |idx| idx else zml.Tensor.arange(.{ .end = new_k.dim(.k) }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "update",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to atLayer from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn atLayer(self: KvCache, layer_index: usize) KvCache {\n        return .{\n            .k = self.k,\n            .v = self.v,\n            .layer_index = .scalar(layer_index, .u32),\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "atLayer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reuseBuffer from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn reuseBuffer(self: KvCache, other: KvCache) KvCache {\n        return .{\n            .k = self.k.reuseBuffer(other.k),\n            .v = self.v.reuseBuffer(other.v),\n            .layer_index = self.layer_index.reuseBuffer(other.layer_index),\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "reuseBuffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn forward(self: BlockScaledLinear, x: zml.Tensor) zml.Tensor {\n        const ctx = x.getContext();\n        const res_shape = x.shape().setDim(-1, self.blocks.dim(-3));\n\n        // Bitcast to our actual type. This allows to load weights in a packed layout.\n        const blocks_0 = self.blocks.bitCast(self.blocks_dtype);\n        const blocks = blocks_0.merge(.{ .d_block = .{ .d_block, .bitcast }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to format from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn format(self: BlockScaledLinear, writer: *std.Io.Writer) !void {\n        try writer.print(\"BlockScaledLinear(blocks={f}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "format",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to mixtureOfExperts from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn mixtureOfExperts(Expert: type, experts: Expert, input: zml.Tensor, gating: zml.Tensor, opts: MoeOpts) zml.Tensor {\n    log.warn(\"mixtureOfExperts({s}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "mixtureOfExperts",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to moePerTokenRouting from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn moePerTokenRouting(Expert: type, experts: Expert, input: zml.Tensor, gating: zml.Tensor, opts: MoeOpts) zml.Tensor {\n    const num_tokens: u32 = @intCast(input.dim(.s));\n    stdx.debug.assert(num_tokens < 32, \"Trying to unroll a lot of tokens !\", .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "moePerTokenRouting",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to cb from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn cb(expert_id_: zml.Tensor, expert_weight: zml.Tensor) zml.Tensor {\n                    return expert_weight.gather(.{ .expert = expert_id_ }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "cb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to mixtureOfExpertsAllToAll from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn mixtureOfExpertsAllToAll(Expert: type, experts: Expert, input: zml.Tensor, gating: zml.Tensor, opts: MoeOpts) zml.Tensor {\n    log.warn(\"mixtureOfExperts({s}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "mixtureOfExpertsAllToAll",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hardGating from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn hardGating(gating: zml.Tensor, opts: MoeOpts) zml.Tensor {\n    const routing = gating.topK(.{ .top_expert = .expert }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "hardGating",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dispatchTokens from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub fn dispatchTokens(\n    gating: zml.Tensor,\n    opts: struct {\n        tokens_per_expert: u32,\n        experts_per_token: u32,\n        normalization: MoeOpts.Normalization,\n    },\n) [2]zml.Tensor {\n    const num_experts = gating.dim(.expert);\n\n    const token_pref = gating.argsort(.expert, .{ .descending = true }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "function",
      "name": "dispatchTokens",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Config from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub const Config = struct {\n    bos_token_id: u32 = 199998,\n    eos_token_id: stdx.json.Union(union(enum) {\n        int: u32,\n        ints: []const u32,\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "struct",
      "name": "Config",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Options from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub const Options = struct {\n    sampling_strategy: zml.nn.SamplingStrategy,\n    max_seq_len: u32,\n    max_prompt_len: u32,\n    tokens_per_expert_ratio: f32,\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "struct",
      "name": "Options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Model from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub const Model = struct {\n    embed_tokens: zml.nn.TokenEmbedding,\n    norm: RmsNorm,\n    layers: []TransformerLayer,\n\n    max_seq_len: u32 = 0,\n    num_heads: i64 = 32,\n    num_kv_heads: i64 = 32,\n    rope_opts: zml.nn.RopeOpts = .{\n        .layout = .interleaved,\n        .freq_base = 10_000,\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "struct",
      "name": "Model",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to TransformerLayer from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub const TransformerLayer = struct {\n    input_layernorm: RmsNorm,\n    self_attn: SelfAttn,\n    post_attention_layernorm: RmsNorm,\n    mlp: MoE,\n\n    pub fn forward(\n        self: TransformerLayer,\n        x0: zml.Tensor,\n        token_index: zml.Tensor,\n        kv_cache: KvCache,\n    ) struct { zml.Tensor, KvCache }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "struct",
      "name": "TransformerLayer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to RmsNorm from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "const RmsNorm = struct {\n    weight: zml.Tensor,\n    eps: f32 = 1e-6,\n\n    /// L2 normalization of input tensor along `.d` axis.\n    pub fn forward(self: RmsNorm, input: zml.Tensor) zml.Tensor {\n        const x = if (input.shape().isFullyTagged()) input else input.withPartialTags(.{.d}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "struct",
      "name": "RmsNorm",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to MoE from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "const MoE = struct {\n    experts: Mlp,\n    router: zml.nn.Linear,\n    moe_opts: MoeOpts,\n\n    pub fn forward(self: MoE, input: zml.Tensor) zml.Tensor {\n        log.warn(\"compiling moe with {f}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "struct",
      "name": "MoE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to OnDisk from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub const OnDisk = struct {\n        router: zml.nn.Linear,\n        experts: struct {\n            down_proj_bias: zml.Tensor,\n            down_proj_blocks: zml.Tensor,\n            down_proj_scales: zml.Tensor,\n            gate_up_proj_bias: zml.Tensor,\n            gate_up_proj_blocks: zml.Tensor,\n            gate_up_proj_scales: zml.Tensor,\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "struct",
      "name": "OnDisk",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Mlp from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub const Mlp = struct {\n    gate_up_proj: BlockScaledLinear, // {.out = intermediate_size * 2, .d = hidden_size / block_size, .d_block = block_size }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "struct",
      "name": "Mlp",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to SelfAttn from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub const SelfAttn = struct {\n    q_proj: zml.nn.Linear,\n    k_proj: zml.nn.Linear,\n    v_proj: zml.nn.Linear,\n    sinks: zml.Tensor,\n\n    o_proj: zml.nn.Linear,\n\n    sliding_window: ?u32,\n    num_heads: i64,\n    num_kv_heads: i64,\n    rope_opts: zml.nn.RopeOpts,\n\n    /// Self Attention.\n    ///   - If token_index is set, x is assumed to be the representation of one new token,\n    /// and kv_cache will be read for the previous tokens.\n    ///   - If token_index is not set, x is assumed to be the representation of all tokens\n    /// since the beginning of the sequence, and kv_cache won't be read.\n    /// In both case, kv_cache will be updated with the computed key and value.\n    /// x: {.b, .s, .d }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "struct",
      "name": "SelfAttn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to KvCache from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub const KvCache = struct {\n    k: zml.Tensor,\n    v: zml.Tensor,\n    layer_index: zml.Tensor,\n\n    pub fn init(kv_shape: zml.Shape) KvCache {\n        // The KV-cache is initialized with ones to detect reads of uninitialized memory.\n        return .{\n            .k = .constant(kv_shape, kv_shape.dtype().one()).withSharding(.{.h}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "struct",
      "name": "KvCache",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to BlockScaledLinear from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "pub const BlockScaledLinear = struct {\n    blocks: zml.Tensor,\n    scale: zml.Tensor,\n    bias: ?zml.Tensor = null,\n    blocks_dtype: zml.DataType,\n\n    pub fn forward(self: BlockScaledLinear, x: zml.Tensor) zml.Tensor {\n        const ctx = x.getContext();\n        const res_shape = x.shape().setDim(-1, self.blocks.dim(-3));\n\n        // Bitcast to our actual type. This allows to load weights in a packed layout.\n        const blocks_0 = self.blocks.bitCast(self.blocks_dtype);\n        const blocks = blocks_0.merge(.{ .d_block = .{ .d_block, .bitcast }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "struct",
      "name": "BlockScaledLinear",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to MoeOpts from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "const MoeOpts = struct {\n    experts_per_token: u32,\n    tokens_per_expert_ratio: ?f32 = 0.0,\n    normalization: Normalization,\n\n    pub const Normalization = enum { linear, softmax }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "struct",
      "name": "MoeOpts",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to token_index from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "const token_index: zml.Tensor = switch (mode) {\n        .gen => |token_index| token_index,\n        .prefill => .scalar(0, .u32),\n    };",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "const",
      "name": "token_index",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to loaded from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "const loaded: zml.Bufferized(GptOss) = .{\n        .model = .{\n            .embed_tokens = try store.loadModelById(zml.nn.TokenEmbedding, noalloc, self.model.embed_tokens, platform),\n            .layers = try allocator.alloc(zml.Bufferized(TransformerLayer), self.model.layers.len),\n            .norm = try store.loadModelById(RmsNorm, noalloc, self.model.norm, platform),\n        },\n        .lm_head = try store.loadModelById(?zml.nn.Linear, noalloc, self.lm_head, platform),\n    };",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "const",
      "name": "loaded",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to num_tokens from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "const num_tokens: u32 = @intCast(input.dim(.s));",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "const",
      "name": "num_tokens",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to tokens_per_expert from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "const tokens_per_expert: u32 = if (opts.tokens_per_expert_ratio) |ratio| tpe: {\n        const compute_budget = ratio * @as(f32, @floatFromInt(num_tokens * opts.experts_per_token));",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "const",
      "name": "tokens_per_expert",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to num_tokens from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "const num_tokens: u32 = @intCast(input.dim(.s));",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "const",
      "name": "num_tokens",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to gating_v2 from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/GptOss.zig",
    "response": "const gating_v2: zml.Tensor = .scatterSlices(\n        .zeroes(gating.shape()),\n        .{ .s = expert_routing.indices },\n        scores_per_expert,\n        .{ .indices_are_unique = true, .update_fn = zml.Tensor.ScatterOpts.override },\n    );",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/GptOss.zig",
      "type": "const",
      "name": "gating_v2",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tokenizePrompt from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/main.zig",
    "response": "pub fn tokenizePrompt(tokenizer: zml.tokenizer.Tokenizer, prompt: []const u8, no_chat: bool, out: []u32) ![]u32 {\n    var encoder = try tokenizer.encoder();\n    defer encoder.deinit();\n\n    if (no_chat) {\n        const tokens = try encoder.encode(prompt);\n        if (tokens.len > out.len) return error.PromptTooLong;\n        @memcpy(out[0..tokens.len], tokens);\n        return out[0..tokens.len];\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/main.zig",
      "type": "function",
      "name": "tokenizePrompt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateText from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/main.zig",
    "response": "pub fn generateText(\n    config: GptOss.Config,\n    options: GptOss.Options,\n    mod_prefill: zml.ModuleExe(GptOss.forward),\n    mod_generate: zml.ModuleExe(GptOss.forward),\n    kv_cache_: zml.Bufferized(GptOss.KvCache),\n    tokenizer: zml.tokenizer.Tokenizer,\n    allocator: std.mem.Allocator,\n    seed: u128,\n    prompt_tok: []const u32,\n    output: *std.Io.Writer,\n) !void {\n    var tokenizer_decoder = try tokenizer.decoder();\n    defer tokenizer_decoder.deinit();\n\n    const platform = mod_generate.platform();\n\n    // init RNG and buffers\n    var rng = try zml.Tensor.Rng.init(platform, seed);\n    var generated_token_buffer = [_]u32{undefined}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/main.zig",
      "type": "function",
      "name": "generateText",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/main.zig",
    "response": "pub fn main() !void {\n    try async.AsyncThread.main(std.heap.smp_allocator, asyncMain);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/main.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to asyncMain from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/main.zig",
    "response": "pub fn asyncMain() !void {\n    log.info(\"   GptOss was compiled with {}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/main.zig",
      "type": "function",
      "name": "asyncMain",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseCli from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/main.zig",
    "response": "pub fn parseCli(allocator: std.mem.Allocator) Cli {\n        var diag: clap.Diagnostic = .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/main.zig",
      "type": "function",
      "name": "parseCli",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ClapBoilerplate from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/main.zig",
    "response": "const ClapBoilerplate = struct {\n    pub const Cli = clap.Result(clap.Help, &cli_params, parsers);\n\n    fn bool_parser(in: []const u8) error{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/main.zig",
      "type": "struct",
      "name": "ClapBoilerplate",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to std_options from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/main.zig",
    "response": "pub const std_options: std.Options = .{\n    .log_level = .info,\n    .logFn = async.logFn(std.log.defaultLog),\n};",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/main.zig",
      "type": "const",
      "name": "std_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to platform from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/main.zig",
    "response": "const platform: zml.Platform = platform: {\n        const arena: std.heap.ArenaAllocator = .init(allocator);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/main.zig",
      "type": "const",
      "name": "platform",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to options from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/main.zig",
    "response": "const options: GptOss.Options = .{\n        .max_seq_len = cli.args.@\"seq-len\" orelse 8192,\n        .max_prompt_len = cli.args.@\"prompt-len\" orelse 256,\n        .tokens_per_expert_ratio = cli.args.@\"expert-budget\" orelse 4.0,\n        .sampling_strategy = .{\n            .topk = cli.args.topk orelse 10,\n            .temperature = 1.0,\n        },\n    };",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/main.zig",
      "type": "const",
      "name": "options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to model from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/main.zig",
    "response": "const model: GptOss = try GptOss.init(compiler_arena.allocator(), store, config, options);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/main.zig",
      "type": "const",
      "name": "model",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to kv_cache_shape from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/gpt_oss/main.zig",
    "response": "const kv_cache_shape: zml.ShapeOf(GptOss.KvCache) = GptOss.KvCache.initShape(kv_shape);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/gpt_oss/main.zig",
      "type": "const",
      "name": "kv_cache_shape",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn init(allocator: std.mem.Allocator, config: Config, options: Options, store: zml.aio.BufferStore) !LlamaLM {\n        const rope_opts: zml.nn.RopeOpts = .{\n            .layout = if (config.hf_rope_impl) .sequential else .interleaved,\n            .freq_base = config.rope_theta,\n            .scaling = config.rope_scaling,\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn forward(\n        self: LlamaLM,\n        tokens_: Tensor,\n        token_index: Tensor,\n        kv_cache: KvCache,\n        rng: Tensor.Rng,\n    ) struct { Tensor, KvCache, Tensor.Rng }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sampleTokens from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn sampleTokens(\n        self: LlamaLM,\n        lm_head_: ?zml.nn.Linear,\n        out_: Tensor,\n        rng: Tensor.Rng,\n        opts: zml.nn.SamplingStrategy,\n    ) struct { Tensor, Tensor.Rng }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "sampleTokens",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to increment from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn increment(_: u8, token_index: Tensor) Tensor {\n        return token_index.addConstant(1).reuseBuffer(token_index);\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "increment",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn forward(self: Llama, tokens: Tensor, token_index: Tensor, kv_cache: KvCache) struct { Tensor, KvCache }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to embed from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn embed(embed_tokens_: zml.nn.TokenEmbedding, tokens_: Tensor) Tensor {\n        return zml.call(embed_tokens_, .forward, .{tokens_}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "embed",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn forward(\n        self: TransformerLayer,\n        x0: Tensor,\n        token_index: Tensor,\n        kv_cache: KvCache,\n    ) struct { Tensor, KvCache }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn forward(self: RmsNorm, input: Tensor) Tensor {\n        const x = if (input.shape().isFullyTagged()) input else input.withPartialTags(.{.d}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn forward(self: Mlp, x: Tensor) Tensor {\n        const proj = zml.call(self.up_proj, .forward, .{x}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn forward(\n        self: SelfAttn,\n        x: Tensor,\n        token_index: Tensor,\n        kv_cache: KvCache,\n    ) struct { Tensor, KvCache }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn init(kv_shape: zml.Shape) KvCache {\n        // The KV-cache is initialized with ones to detect reads of uninitialized memory.\n        return .{\n            .k = Tensor.constant(kv_shape, kv_shape.dtype().one()).withSharding(.{.h}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to initShape from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn initShape(kv_shape: zml.Shape) ShapeOf(KvCache) {\n        return .{\n            .k = kv_shape,\n            .v = kv_shape,\n            .layer_index = zml.Shape.init(.{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "initShape",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to initBuffer from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn initBuffer(kv_shape: zml.Shape, platform: zml.Platform) !zml.Bufferized(KvCache) {\n        return .{\n            .k = try zml.Buffer.uninitialized(platform, kv_shape, .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "initBuffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to keys from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn keys(self: KvCache) Tensor {\n        return self.k.dynamicSlice(.{ .layer = Tensor.DynSlice{ .start = self.layer_index, .len = 1 }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "keys",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to values from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn values(self: KvCache) Tensor {\n        return self.v.dynamicSlice(.{ .layer = Tensor.DynSlice{ .start = self.layer_index, .len = 1 }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "values",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to update from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn update(self: KvCache, new_k: Tensor, new_v: Tensor, token_index: ?Tensor) KvCache {\n        const k_shape = self.k.shape().drop(.layer);\n        var layer = self.layer_index;\n        layer = if (token_index) |idx| layer.broad(idx.shape()) else layer;\n\n        return if (token_index) |idx| .{\n            .k = self.k.scatterSlices(\n                .{ .layer = layer, .k = idx }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "update",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to atLayer from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn atLayer(self: KvCache, layer_index: usize) KvCache {\n        return .{\n            .k = self.k,\n            .v = self.v,\n            .layer_index = Tensor.scalar(layer_index, .u32),\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "atLayer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reuseBuffer from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub fn reuseBuffer(self: KvCache, other: KvCache) KvCache {\n        return .{\n            .k = self.k.reuseBuffer(other.k),\n            .v = self.v.reuseBuffer(other.v),\n            .layer_index = self.layer_index.reuseBuffer(other.layer_index),\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "function",
      "name": "reuseBuffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to LlamaLM from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub const LlamaLM = struct {\n    pub const Config = struct {\n        bos_token_id: u32,\n        eos_token_id: stdx.json.Union(union(enum) {\n            int: u32,\n            ints: []u32,\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "struct",
      "name": "LlamaLM",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Options from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub const Options = struct {\n        sampling_strategy: ?zml.nn.SamplingStrategy,\n        max_seq_len: u32,\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "struct",
      "name": "Options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Llama from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub const Llama = struct {\n    embed_tokens: zml.nn.TokenEmbedding,\n    norm: RmsNorm,\n    layers: []TransformerLayer,\n\n    max_seq_len: u32 = 0,\n    num_heads: u32 = 32,\n    num_kv_heads: u32 = 32,\n    rope_opts: zml.nn.RopeOpts = .{\n        .layout = .interleaved,\n        .freq_base = 10_000,\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "struct",
      "name": "Llama",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to TransformerLayer from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub const TransformerLayer = struct {\n    input_layernorm: RmsNorm,\n    self_attn: SelfAttn,\n    post_attention_layernorm: RmsNorm,\n    mlp: Mlp,\n\n    pub fn forward(\n        self: TransformerLayer,\n        x0: Tensor,\n        token_index: Tensor,\n        kv_cache: KvCache,\n    ) struct { Tensor, KvCache }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "struct",
      "name": "TransformerLayer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to RmsNorm from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "const RmsNorm = struct {\n    weight: Tensor,\n    eps: f32 = 1e-5,\n\n    /// L2 normalization of input tensor along `.d` axis.\n    pub fn forward(self: RmsNorm, input: Tensor) Tensor {\n        const x = if (input.shape().isFullyTagged()) input else input.withPartialTags(.{.d}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "struct",
      "name": "RmsNorm",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Mlp from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "const Mlp = struct {\n    up_proj: zml.nn.Linear, // (dim -> hidden_dim)\n    gate_proj: zml.nn.Linear, // (dim -> hidden_dim)\n    down_proj: zml.nn.Linear, // (hidden_dim -> dim)\n\n    pub fn forward(self: Mlp, x: Tensor) Tensor {\n        const proj = zml.call(self.up_proj, .forward, .{x}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "struct",
      "name": "Mlp",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to SelfAttn from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub const SelfAttn = struct {\n    q_proj: zml.nn.Linear,\n    k_proj: zml.nn.Linear,\n    v_proj: zml.nn.Linear,\n\n    q_norm: ?RmsNorm,\n    k_norm: ?RmsNorm,\n\n    o_proj: zml.nn.Linear,\n    num_heads: i64 = undefined,\n    num_kv_heads: i64 = 0,\n    rope_opts: zml.nn.RopeOpts = undefined,\n\n    /// Self Attention.\n    ///   - If token_index is set, x is assumed to be the representation of one new token,\n    /// and kv_cache will be read for the previous tokens.\n    ///   - If token_index is not set, x is assumed to be the representation of all tokens\n    /// since the beginning of the sequence, and kv_cache won't be read.\n    /// In both case, kv_cache will be updated with the computed key and value.\n    /// x: {.b, .s, .d }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "struct",
      "name": "SelfAttn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to KvCache from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "pub const KvCache = struct {\n    k: Tensor,\n    v: Tensor,\n    layer_index: Tensor,\n\n    pub fn init(kv_shape: zml.Shape) KvCache {\n        // The KV-cache is initialized with ones to detect reads of uninitialized memory.\n        return .{\n            .k = Tensor.constant(kv_shape, kv_shape.dtype().one()).withSharding(.{.h}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "struct",
      "name": "KvCache",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to rope_opts from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/llama.zig",
    "response": "const rope_opts: zml.nn.RopeOpts = .{\n            .layout = if (config.hf_rope_impl) .sequential else .interleaved,\n            .freq_base = config.rope_theta,\n            .scaling = config.rope_scaling,\n        };",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/llama.zig",
      "type": "const",
      "name": "rope_opts",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tokenizePrompt from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/main.zig",
    "response": "pub fn tokenizePrompt(allocator: std.mem.Allocator, tokenizer: zml.tokenizer.Tokenizer, config: LlamaLM.Config, prompt: []const u8, skip_llama3_encoding: bool) ![]u32 {\n    var encoder = try tokenizer.encoder();\n    defer encoder.deinit();\n\n    if (skip_llama3_encoding) {\n        // Copy so the ownership is the same in both branches.\n        return try allocator.dupe(u32, try encoder.encode(prompt));\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/main.zig",
      "type": "function",
      "name": "tokenizePrompt",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateText from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/main.zig",
    "response": "pub fn generateText(\n    config: LlamaLM.Config,\n    llama_: LlamaLM,\n    mod_prefill: zml.ModuleExe(LlamaLM.forward),\n    mod_generate: zml.ModuleExe(LlamaLM.forward),\n    kv_cache_: zml.Bufferized(llama.KvCache),\n    tokenizer: zml.tokenizer.Tokenizer,\n    allocator: std.mem.Allocator,\n    seed: u128,\n    prompt: []const u8,\n    skip_llama3_encoding: bool,\n    writer: *std.Io.Writer,\n) !void {\n    const prompt_tok: []const u32 = try tokenizePrompt(allocator, tokenizer, config, prompt, skip_llama3_encoding);\n    defer allocator.free(prompt_tok);\n\n    var tokenizer_decoder = try tokenizer.decoder();\n    defer tokenizer_decoder.deinit();\n\n    const platform = mod_generate.platform();\n    const max_seq_len = llama_.model.max_seq_len;\n\n    // init RNG and buffers\n    var rng = try zml.Tensor.Rng.init(platform, seed);\n    var generated_token_buffer = [_]u32{undefined}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/main.zig",
      "type": "function",
      "name": "generateText",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/main.zig",
    "response": "pub fn main() !void {\n    try async.AsyncThread.main(std.heap.c_allocator, asyncMain);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/main.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to asyncMain from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/main.zig",
    "response": "pub fn asyncMain() !void {\n    log.info(\"   LLama was compiled with {}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/main.zig",
      "type": "function",
      "name": "asyncMain",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to std_options from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/main.zig",
    "response": "pub const std_options: std.Options = .{\n    .log_level = .info,\n    .logFn = async.logFn(std.log.defaultLog),\n};",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/main.zig",
      "type": "const",
      "name": "std_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to prompt_tok from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/main.zig",
    "response": "const prompt_tok: []const u32 = try tokenizePrompt(allocator, tokenizer, config, prompt, skip_llama3_encoding);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/main.zig",
      "type": "const",
      "name": "prompt_tok",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to seq_len from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/main.zig",
    "response": "const seq_len: u32 = cli.args.@\"seq-len\" orelse 256;",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/main.zig",
      "type": "const",
      "name": "seq_len",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to llama_options from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/main.zig",
    "response": "const llama_options: llama.LlamaLM.Options = .{\n        .max_seq_len = seq_len,\n        .sampling_strategy = .{\n            .topk = 1,\n            .temperature = 1.0,\n        },\n    };",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/main.zig",
      "type": "const",
      "name": "llama_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to llama_tensors from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/main.zig",
    "response": "const llama_tensors: llama.LlamaLM = try .init(compiler_arena.allocator(), config, llama_options, store);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/main.zig",
      "type": "const",
      "name": "llama_tensors",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to kv_cache_shape from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/main.zig",
    "response": "const kv_cache_shape: zml.ShapeOf(llama.KvCache) = llama.KvCache.initShape(kv_shape);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/main.zig",
      "type": "const",
      "name": "kv_cache_shape",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to seed from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/llama/main.zig",
    "response": "const seed: u128 = cli.args.seed orelse @bitCast(std.time.nanoTimestamp());",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/llama/main.zig",
      "type": "const",
      "name": "seed",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/mnist/mnist.zig",
    "response": "pub fn forward(self: Layer, input: zml.Tensor) zml.Tensor {\n            return self.weight.matmul(input).add(self.bias).relu();\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/mnist/mnist.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/mnist/mnist.zig",
    "response": "pub fn forward(self: Mnist, input: zml.Tensor) zml.Tensor {\n        // std.log.info(\"Compiling for target: {s}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/mnist/mnist.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/mnist/mnist.zig",
    "response": "pub fn main() !void {\n    try async.AsyncThread.main(std.heap.c_allocator, asyncMain);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/mnist/mnist.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to asyncMain from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/mnist/mnist.zig",
    "response": "pub fn asyncMain() !void {\n    const allocator = std.heap.c_allocator;\n\n    // // Create ZML context\n    var context = try zml.Context.init();\n    defer context.deinit();\n\n    // log.info(\"\\n===========================\\n==   ZML MNIST Example   ==\\n===========================\\n\\n\", .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/mnist/mnist.zig",
      "type": "function",
      "name": "asyncMain",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to printDigit from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/mnist/mnist.zig",
    "response": "fn printDigit(digit: [28 * 28]u8) void {\n    var buffer: [28][30][2]u8 = undefined;\n    for (0..28) |y| {\n        buffer[y][0] = .{ '|', ' ' }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/mnist/mnist.zig",
      "type": "function",
      "name": "printDigit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Mnist from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/mnist/mnist.zig",
    "response": "const Mnist = struct {\n    fc1: Layer,\n    fc2: Layer,\n\n    const Layer = struct {\n        weight: zml.Tensor,\n        bias: zml.Tensor,\n\n        pub fn forward(self: Layer, input: zml.Tensor) zml.Tensor {\n            return self.weight.matmul(input).add(self.bias).relu();\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/mnist/mnist.zig",
      "type": "struct",
      "name": "Mnist",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to std_options from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/mnist/mnist.zig",
    "response": "pub const std_options: std.Options = .{\n    .log_level = .info,\n    .logFn = async.logFn(std.log.defaultLog),\n};",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/mnist/mnist.zig",
      "type": "const",
      "name": "std_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to layers from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/mnist/mnist.zig",
    "response": "const layers: []const Layer = &.{ self.fc1, self.fc2 };",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/mnist/mnist.zig",
      "type": "const",
      "name": "layers",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/main.zig",
    "response": "pub fn main() !void {\n    try async.AsyncThread.main(std.heap.c_allocator, asyncMain);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/main.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to asyncMain from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/main.zig",
    "response": "pub fn asyncMain() !void {\n    const allocator = std.heap.c_allocator;\n    const stderr = std.fs.File.stderr();\n\n    var diag: clap.Diagnostic = .{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/main.zig",
      "type": "function",
      "name": "asyncMain",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to unmask from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/main.zig",
    "response": "pub fn unmask(\n    allocator: std.mem.Allocator,\n    mod: zml.ModuleExe(modernbert.ModernBertForMaskedLM.forward),\n    tokenizer: zml.tokenizer.Tokenizer,\n    seq_len: i64,\n    text: []const u8,\n) !void {\n    var tokenizer_decoder = try tokenizer.decoder();\n    defer tokenizer_decoder.deinit();\n\n    const pad_token = tokenizer.tokenToId(\"[PAD]\") orelse return error.NoSuchToken;\n    const mask_token = tokenizer.tokenToId(\"[MASK]\") orelse return error.NoSuchToken;\n\n    // Tokenize input text\n    const tokens: []const u32 = try tokenize(allocator, tokenizer, text);\n    defer allocator.free(tokens);\n\n    // Find \"[MASK]\" positions\n    const mask_positions = try findMaskPositions(allocator, tokens, mask_token);\n    defer allocator.free(mask_positions);\n\n    // Prepare input tensors\n    const inputs = try prepareTensorInputs(allocator, tokens, seq_len, pad_token);\n    defer allocator.free(inputs);\n\n    // Create input tensors (on the accelerator)\n    const input_shape = zml.Shape.init(.{ .b = 1, .s = seq_len }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/main.zig",
      "type": "function",
      "name": "unmask",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to tokenize from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/main.zig",
    "response": "pub fn tokenize(allocator: std.mem.Allocator, tokenizer: zml.tokenizer.Tokenizer, prompt: []const u8) ![]const u32 {\n    var encoder = try tokenizer.encoder();\n    defer encoder.deinit();\n\n    const bos = tokenizer.tokenToId(\"[CLS]\") orelse return error.NoSuchToken;\n    const eos = tokenizer.tokenToId(\"[SEP]\") orelse return error.NoSuchToken;\n\n    var tokens: std.ArrayList(u32) = try .initCapacity(allocator, prompt.len);\n    try tokens.append(allocator, bos);\n    try tokens.appendSlice(allocator, try encoder.encode(prompt));\n    try tokens.append(allocator, eos);\n\n    return tokens.toOwnedSlice(allocator);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/main.zig",
      "type": "function",
      "name": "tokenize",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to findMaskPositions from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/main.zig",
    "response": "fn findMaskPositions(allocator: std.mem.Allocator, tokens: []const u32, mask_token: u32) ![]usize {\n    var mask_positions: std.ArrayList(usize) = .empty;\n\n    for (tokens, 0..) |token, i| {\n        if (token == mask_token) {\n            try mask_positions.append(allocator, i);\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/main.zig",
      "type": "function",
      "name": "findMaskPositions",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to prepareTensorInputs from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/main.zig",
    "response": "fn prepareTensorInputs(\n    allocator: std.mem.Allocator,\n    tokens: []const u32,\n    seq_len: i64,\n    pad_token: u32,\n) ![]u32 {\n    const input_ids = try allocator.alloc(u32, @intCast(seq_len));\n\n    @memset(input_ids, pad_token);\n    for (tokens, 0..) |token, i| {\n        input_ids[i] = @intCast(token);\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/main.zig",
      "type": "function",
      "name": "prepareTensorInputs",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to printUsageAndExit from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/main.zig",
    "response": "fn printUsageAndExit(stderr: std.fs.File) noreturn {\n    clap.usageToFile(stderr, clap.Help, &params) catch {}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/main.zig",
      "type": "function",
      "name": "printUsageAndExit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to std_options from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/main.zig",
    "response": "pub const std_options: std.Options = .{\n    .log_level = .info,\n    .log_scope_levels = &[_]std.log.ScopeLevel{\n        .{ .scope = .modernbert, .level = .info },\n    },\n    .logFn = async.logFn(std.log.defaultLog),\n};",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/main.zig",
      "type": "const",
      "name": "std_options",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to tokens from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/main.zig",
    "response": "const tokens: []const u32 = try tokenize(allocator, tokenizer, text);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/main.zig",
      "type": "const",
      "name": "tokens",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub fn init(self: *ModernBertForMaskedLM, options: ModernBertOptions) void {\n        self.model.init(options);\n        self.head.norm.eps = 1e-5;\n\n        self.head.dense.weight = self.head.dense.weight.withSharding(.{0}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub fn forward(self: ModernBertForMaskedLM, input_ids: Tensor) zml.Tensor.ArgMaxRes {\n        const outputs: Tensor = zml.call(self.model, .forward, .{input_ids}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub fn init(self: *ModernBertModel, options: ModernBertOptions) void {\n        self.options = options;\n        self.final_norm.eps = 1e-5;\n        self.embeddings.norm.eps = 1e-5;\n        for (self.layers, 0..) |*encoder_layer, layer_idx| {\n            encoder_layer.attn.Wqkv.weight = encoder_layer.attn.Wqkv.weight.withSharding(.{0}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub fn forward(self: ModernBertModel, input_ids: Tensor) Tensor {\n        var hidden_states: Tensor = zml.call(self.embeddings, .forward, .{input_ids}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to globalAttnMask from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub fn globalAttnMask(input_ids: Tensor, dt: zml.DataType, pad_token: u32) Tensor {\n        const ids = input_ids.withTags(.{ .b, .k }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "function",
      "name": "globalAttnMask",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to localAttnMask from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub fn localAttnMask(global_mask: Tensor, window_size: u32) Tensor {\n        const mask_shape = global_mask.shape();\n\n        // Calculate distance between positions\n        const rows = Tensor.iota(mask_shape, .q);\n        const cols = Tensor.iota(mask_shape, .k);\n        const distance = rows.sub(cols).abs();\n\n        // Note: we divide by two because the BERT local attention is symetric around the query token.\n        // Create sliding window mask (1 for positions within window, 0 outside)\n        const window_mask = distance.cmp(.LE, Tensor.scalar(@divExact(window_size, 2), .i32));\n        const minus_inf = Tensor.constant(mask_shape, mask_shape.dtype().minValue());\n        return window_mask.select(global_mask, minus_inf);\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "function",
      "name": "localAttnMask",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub fn forward(self: ModernBertPredictionHead, hidden_states: Tensor) Tensor {\n        const dense_output: Tensor = zml.call(self.dense, .forward, .{hidden_states}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub fn forward(self: ModernBertEmbeddings, input_ids: Tensor) Tensor {\n        // Perform tok_embeddings\n        const hidden_states = zml.call(self.tok_embeddings, .forward, .{input_ids}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub fn forward(\n        self: ModernBertEncoderLayer,\n        hidden_states: Tensor,\n        global_mask: Tensor,\n        local_mask: Tensor,\n    ) Tensor {\n        const attn_norm_output = if (self.attn_norm) |attn_norm|\n            zml.call(attn_norm, .forward, .{hidden_states}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub fn forward(\n        self: ModernBertAttention,\n        hidden_states: Tensor,\n        global_mask: Tensor,\n        local_mask: Tensor,\n    ) Tensor {\n        const batch_size = hidden_states.shape().dim(0);\n        const seq_length = hidden_states.shape().dim(1);\n        const hidden_size = hidden_states.shape().dim(2);\n        const num_heads = self.num_heads;\n        const head_dim = @divExact(hidden_size, num_heads);\n\n        // Project to query, key, value - { batch_size, seq_len, 3 * num_heads * head_dim }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub fn forward(self: ModernBertMLP, hidden_states: Tensor) Tensor {\n        // Perform Wi\n        const wi_output: Tensor = zml.call(self.Wi, .forward, .{hidden_states}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ModernBertOptions from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub const ModernBertOptions = struct {\n    num_attention_heads: i64,\n    pad_token: u32,\n    local_attention: u32,\n    tie_word_embeddings: bool = false,\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "struct",
      "name": "ModernBertOptions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ModernBertForMaskedLM from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub const ModernBertForMaskedLM = struct {\n    model: ModernBertModel,\n    head: ModernBertPredictionHead,\n    decoder: struct { weight: ?zml.Tensor, bias: zml.Tensor }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "struct",
      "name": "ModernBertForMaskedLM",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ModernBertModel from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub const ModernBertModel = struct {\n    options: ModernBertOptions,\n    embeddings: ModernBertEmbeddings,\n    layers: []ModernBertEncoderLayer,\n    final_norm: zml.nn.LayerNorm,\n\n    pub fn init(self: *ModernBertModel, options: ModernBertOptions) void {\n        self.options = options;\n        self.final_norm.eps = 1e-5;\n        self.embeddings.norm.eps = 1e-5;\n        for (self.layers, 0..) |*encoder_layer, layer_idx| {\n            encoder_layer.attn.Wqkv.weight = encoder_layer.attn.Wqkv.weight.withSharding(.{0}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "struct",
      "name": "ModernBertModel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ModernBertPredictionHead from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub const ModernBertPredictionHead = struct {\n    dense: zml.nn.Linear,\n    norm: zml.nn.LayerNorm,\n\n    pub fn forward(self: ModernBertPredictionHead, hidden_states: Tensor) Tensor {\n        const dense_output: Tensor = zml.call(self.dense, .forward, .{hidden_states}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "struct",
      "name": "ModernBertPredictionHead",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ModernBertEmbeddings from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub const ModernBertEmbeddings = struct {\n    tok_embeddings: zml.nn.TokenEmbedding,\n    norm: zml.nn.LayerNorm,\n\n    pub fn forward(self: ModernBertEmbeddings, input_ids: Tensor) Tensor {\n        // Perform tok_embeddings\n        const hidden_states = zml.call(self.tok_embeddings, .forward, .{input_ids}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "struct",
      "name": "ModernBertEmbeddings",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ModernBertEncoderLayer from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub const ModernBertEncoderLayer = struct {\n    attn_norm: ?zml.nn.LayerNorm = null,\n    attn: ModernBertAttention,\n    mlp_norm: zml.nn.LayerNorm,\n    mlp: ModernBertMLP,\n\n    pub fn forward(\n        self: ModernBertEncoderLayer,\n        hidden_states: Tensor,\n        global_mask: Tensor,\n        local_mask: Tensor,\n    ) Tensor {\n        const attn_norm_output = if (self.attn_norm) |attn_norm|\n            zml.call(attn_norm, .forward, .{hidden_states}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "struct",
      "name": "ModernBertEncoderLayer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ModernBertAttention from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub const ModernBertAttention = struct {\n    Wqkv: zml.nn.Linear,\n    Wo: zml.nn.Linear,\n    is_global_attention: bool = false,\n    num_heads: i64 = undefined,\n\n    /// sdpa_attention_forward\n    pub fn forward(\n        self: ModernBertAttention,\n        hidden_states: Tensor,\n        global_mask: Tensor,\n        local_mask: Tensor,\n    ) Tensor {\n        const batch_size = hidden_states.shape().dim(0);\n        const seq_length = hidden_states.shape().dim(1);\n        const hidden_size = hidden_states.shape().dim(2);\n        const num_heads = self.num_heads;\n        const head_dim = @divExact(hidden_size, num_heads);\n\n        // Project to query, key, value - { batch_size, seq_len, 3 * num_heads * head_dim }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "struct",
      "name": "ModernBertAttention",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ModernBertMLP from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "pub const ModernBertMLP = struct {\n    Wi: zml.nn.Linear,\n    Wo: zml.nn.Linear,\n\n    pub fn forward(self: ModernBertMLP, hidden_states: Tensor) Tensor {\n        // Perform Wi\n        const wi_output: Tensor = zml.call(self.Wi, .forward, .{hidden_states}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "struct",
      "name": "ModernBertMLP",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to outputs from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "const outputs: Tensor = zml.call(self.model, .forward, .{input_ids});",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "const",
      "name": "outputs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to head_outputs from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "const head_outputs: Tensor = zml.call(self.head, .forward, .{outputs});",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "const",
      "name": "head_outputs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to dense_output from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "const dense_output: Tensor = zml.call(self.dense, .forward, .{hidden_states});",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "const",
      "name": "dense_output",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to attn_output from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "const attn_output: Tensor = zml.call(self.attn, .forward, .{\n            attn_norm_output,\n            global_mask,\n            local_mask,\n        });",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "const",
      "name": "attn_output",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to mlp_norm_output from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "const mlp_norm_output: Tensor = zml.call(self.mlp_norm, .forward, .{output});",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "const",
      "name": "mlp_norm_output",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to wi_output from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/modernbert/modernbert.zig",
    "response": "const wi_output: Tensor = zml.call(self.Wi, .forward, .{hidden_states});",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/modernbert/modernbert.zig",
      "type": "const",
      "name": "wi_output",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forward from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/simple_layer/main.zig",
    "response": "pub fn forward(self: Layer, x: zml.Tensor) zml.Tensor {\n        var y = self.weight.mul(x);\n        if (self.bias) |bias| {\n            y = y.add(bias);\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/simple_layer/main.zig",
      "type": "function",
      "name": "forward",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/simple_layer/main.zig",
    "response": "pub fn main() !void {\n    try async.AsyncThread.main(std.heap.c_allocator, asyncMain);\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/simple_layer/main.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to asyncMain from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/simple_layer/main.zig",
    "response": "pub fn asyncMain() !void {\n    // Short lived allocations\n    var gpa = std.heap.GeneralPurposeAllocator(.{}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/simple_layer/main.zig",
      "type": "function",
      "name": "asyncMain",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Layer from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: examples/simple_layer/main.zig",
    "response": "const Layer = struct {\n    bias: ?zml.Tensor = null,\n    weight: zml.Tensor,\n\n    pub fn forward(self: Layer, x: zml.Tensor) zml.Tensor {\n        var y = self.weight.mul(x);\n        if (self.bias) |bias| {\n            y = y.add(bias);\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "examples/simple_layer/main.zig",
      "type": "struct",
      "name": "Layer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to as_path from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: ffi/ffi.zig",
    "response": "pub fn as_path(path: []const u8) [std.fs.max_path_bytes:0]u8 {\n    var result: [std.fs.max_path_bytes:0]u8 = undefined;\n    @memcpy(result[0..path.len], path);\n    result[path.len] = 0;\n    return result;\n}",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "ffi/ffi.zig",
      "type": "function",
      "name": "as_path",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to from from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: ffi/zig_allocator.zig",
    "response": "fn from(allocator: std.mem.Allocator) c.zig_allocator {\n        return .{\n            .ctx = @ptrCast(@alignCast(&allocator)),\n            .alloc = &alloc,\n            .free = &free,\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "ffi/zig_allocator.zig",
      "type": "function",
      "name": "from",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to alloc from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: ffi/zig_allocator.zig",
    "response": "pub fn alloc(ctx: ?*const anyopaque, elem: usize, nelems: usize, alignment: usize) callconv(.c) ?*anyopaque {\n        const self: *const std.mem.Allocator = @ptrCast(@alignCast(ctx));\n        const ret = self.rawAlloc(elem * nelems, std.math.log2_int(usize, alignment), @returnAddress()) orelse return null;\n        return @ptrCast(ret);\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "ffi/zig_allocator.zig",
      "type": "function",
      "name": "alloc",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to free from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: ffi/zig_allocator.zig",
    "response": "pub fn free(ctx: ?*const anyopaque, ptr: ?*anyopaque, elem: usize, nelems: usize, alignment: usize) callconv(.c) void {\n        const self: *const std.mem.Allocator = @ptrCast(@alignCast(ctx));\n        const memory: [*c]u8 = @ptrCast(ptr);\n        const size = elem * nelems;\n        self.rawFree(memory[0..size], std.math.log2_int(usize, alignment), @returnAddress());\n    }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "ffi/zig_allocator.zig",
      "type": "function",
      "name": "free",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ZigAllocator from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: ffi/zig_allocator.zig",
    "response": "pub const ZigAllocator = struct {\n    pub inline fn from(allocator: std.mem.Allocator) c.zig_allocator {\n        return .{\n            .ctx = @ptrCast(@alignCast(&allocator)),\n            .alloc = &alloc,\n            .free = &free,\n        }",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "ffi/zig_allocator.zig",
      "type": "struct",
      "name": "ZigAllocator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: ffi/zig_allocator.zig",
    "response": "const self: *const std.mem.Allocator = @ptrCast(@alignCast(ctx));",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "ffi/zig_allocator.zig",
      "type": "const",
      "name": "self",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: ffi/zig_allocator.zig",
    "response": "const self: *const std.mem.Allocator = @ptrCast(@alignCast(ctx));",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "ffi/zig_allocator.zig",
      "type": "const",
      "name": "self",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to memory from zml/zml",
    "context": "Repository: zml/zml (2827 ⭐)\nFile: ffi/zig_allocator.zig",
    "response": "const memory: [*c]u8 = @ptrCast(ptr);",
    "metadata": {
      "repo": "zml/zml",
      "stars": 2827,
      "file": "ffi/zig_allocator.zig",
      "type": "const",
      "name": "memory",
      "difficulty": "easy"
    }
  }
]