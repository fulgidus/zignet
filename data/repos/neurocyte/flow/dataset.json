[
  {
    "instruction": "Write a Zig function similar to build from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: build.zig",
    "response": "pub fn build(b: *std.Build) void {\n    const all_targets = b.option(bool, \"all_targets\", \"Build all known good targets during release builds (default: no)\") orelse false;\n    const tracy_enabled = b.option(bool, \"enable_tracy\", \"Enable tracy client library (default: no)\") orelse false;\n    const use_tree_sitter = b.option(bool, \"use_tree_sitter\", \"Enable tree-sitter (default: yes)\") orelse true;\n    const strip = b.option(bool, \"strip\", \"Disable debug information (default: no)\");\n    const use_llvm = b.option(bool, \"use_llvm\", \"Enable llvm backend (default: none)\");\n    const pie = b.option(bool, \"pie\", \"Produce an executable with position independent code (default: none)\");\n    const gui = b.option(bool, \"gui\", \"Standalone GUI mode\") orelse false;\n    const test_filters = b.option([]const []const u8, \"test-filter\", \"Skip tests that do not match any filter\") orelse &[0][]const u8{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "build.zig",
      "type": "function",
      "name": "build",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_development from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: build.zig",
    "response": "fn build_development(\n    b: *std.Build,\n    run_step: *std.Build.Step,\n    check_step: *std.Build.Step,\n    test_step: *std.Build.Step,\n    lint_step: *std.Build.Step,\n    tracy_enabled: bool,\n    use_tree_sitter: bool,\n    strip: ?bool,\n    use_llvm: ?bool,\n    pie: ?bool,\n    gui: bool,\n    version: []const u8,\n    _: bool, // all_targets\n    test_filters: []const []const u8,\n) void {\n    const target = b.standardTargetOptions(.{ .default_target = .{ .abi = if (builtin.os.tag == .linux and !tracy_enabled) .musl else null }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "build.zig",
      "type": "function",
      "name": "build_development",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_release from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: build.zig",
    "response": "fn build_release(\n    b: *std.Build,\n    run_step: *std.Build.Step,\n    check_step: *std.Build.Step,\n    test_step: *std.Build.Step,\n    lint_step: *std.Build.Step,\n    tracy_enabled: bool,\n    use_tree_sitter: bool,\n    _: ?bool, //release builds control strip\n    use_llvm: ?bool,\n    pie: ?bool,\n    _: bool, //gui\n    version: []const u8,\n    all_targets: bool,\n    test_filters: []const []const u8,\n) void {\n    const targets: []const std.Target.Query = if (all_targets) &.{\n        .{ .cpu_arch = .x86_64, .os_tag = .linux, .abi = .musl }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "build.zig",
      "type": "function",
      "name": "build_release",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build_exe from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: build.zig",
    "response": "pub fn build_exe(\n    b: *std.Build,\n    run_step: *std.Build.Step,\n    check_step: *std.Build.Step,\n    test_step: *std.Build.Step,\n    lint_step: *std.Build.Step,\n    target: std.Build.ResolvedTarget,\n    optimize: std.builtin.OptimizeMode,\n    exe_install_options: std.Build.Step.InstallArtifact.Options,\n    tracy_enabled: bool,\n    use_tree_sitter: bool,\n    strip: bool,\n    use_llvm: ?bool,\n    pie: ?bool,\n    gui: bool,\n    version: []const u8,\n    test_filters: []const []const u8,\n) void {\n    const options = b.addOptions();\n    options.addOption(bool, \"enable_tracy\", tracy_enabled);\n    options.addOption(bool, \"use_tree_sitter\", use_tree_sitter);\n    options.addOption(bool, \"strip\", strip);\n    options.addOption(bool, \"gui\", gui);\n\n    const options_mod = options.createModule();\n\n    std.fs.cwd().makeDir(\".cache\") catch |e| switch (e) {\n        error.PathAlreadyExists => {}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "build.zig",
      "type": "function",
      "name": "build_exe",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to gen_version_info from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: build.zig",
    "response": "fn gen_version_info(\n    b: *std.Build,\n    target: std.Build.ResolvedTarget,\n    writer: anytype,\n    optimize: std.builtin.OptimizeMode,\n) !void {\n    var code: u8 = 0;\n\n    const describe = try b.runAllowFail(&[_][]const u8{ \"git\", \"describe\", \"--always\", \"--tags\" }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "build.zig",
      "type": "function",
      "name": "gen_version_info",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to gen_version from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: build.zig",
    "response": "fn gen_version(b: *std.Build, writer: anytype) !void {\n    var code: u8 = 0;\n\n    const describe = try b.runAllowFail(&[_][]const u8{ \"git\", \"describe\", \"--always\", \"--tags\" }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "build.zig",
      "type": "function",
      "name": "gen_version",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to to_owned from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn to_owned(pimpl: anytype) Self {\n    const impl = @typeInfo(@TypeOf(pimpl));\n    const child: type = impl.pointer.child;\n    return .{\n        .ptr = pimpl,\n        .vtable = comptime &.{\n            .type_name = @typeName(child),\n            .deinit = struct {\n                pub fn deinit(ctx: *anyopaque) void {\n                    return child.deinit(@as(*child, @ptrCast(@alignCast(ctx))));\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "to_owned",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn receive(ctx: *anyopaque, from_: tp.pid_ref, m: tp.message) tp.result {\n                    _ = try child.receive(@as(*child, @ptrCast(@alignCast(ctx))), from_, m);\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "receive",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to static from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn static(T: type) Self {\n    return .{\n        .ptr = &none,\n        .vtable = comptime &.{\n            .type_name = @typeName(T),\n            .deinit = struct {\n                pub fn deinit(_: *anyopaque) void {}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "static",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn receive(_: *anyopaque, from_: tp.pid_ref, m: tp.message) tp.result {\n                    _ = try T.receive(from_, m);\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "receive",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to to_unowned from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn to_unowned(pimpl: anytype) Self {\n    const impl = @typeInfo(@TypeOf(pimpl));\n    const child: type = impl.pointer.child;\n    return .{\n        .ptr = pimpl,\n        .vtable = comptime &.{\n            .type_name = @typeName(child),\n            .deinit = struct {\n                pub fn deinit(_: *anyopaque) void {}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "to_unowned",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to send from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn send(ctx: *anyopaque, from_: tp.pid_ref, m: tp.message) tp.result {\n                    _ = try child.send(@as(*child, @ptrCast(@alignCast(ctx))), from_, m);\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "send",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn receive(ctx: *anyopaque, from_: tp.pid_ref, m: tp.message) tp.result {\n                    _ = try child.receive(@as(*child, @ptrCast(@alignCast(ctx))), from_, m);\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "receive",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to bind from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn bind(pimpl: anytype, comptime f: *const fn (ctx: @TypeOf(pimpl), from: tp.pid_ref, m: tp.message) tp.result) Self {\n    const impl = @typeInfo(@TypeOf(pimpl));\n    const child: type = impl.pointer.child;\n    return .{\n        .ptr = pimpl,\n        .vtable = comptime &.{\n            .type_name = @typeName(child),\n            .deinit = struct {\n                pub fn deinit(_: *anyopaque) void {}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "bind",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn receive(ctx: *anyopaque, from_: tp.pid_ref, m: tp.message) tp.result {\n                    return @call(.auto, f, .{ @as(*child, @ptrCast(@alignCast(ctx))), from_, m }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "receive",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn deinit(self: Self) void {\n    return self.vtable.deinit(self.ptr);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dynamic_cast from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn dynamic_cast(self: Self, comptime T: type) ?*T {\n    return if (std.mem.eql(u8, self.vtable.type_name, @typeName(T)))\n        @as(*T, @ptrCast(@alignCast(self.ptr)))\n    else\n        null;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "dynamic_cast",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to msg from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn msg(self: Self, m: anytype) tp.result {\n    return self.vtable.send(self.ptr, tp.self_pid(), tp.message.fmt(m));\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "msg",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn send(self: Self, from_: tp.pid_ref, m: tp.message) tp.result {\n    return self.vtable.send(self.ptr, from_, m);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "send",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to empty from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn empty(allocator: Allocator) !Self {\n    const child: type = struct {}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "empty",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn deinit(ctx: *anyopaque, allocator_: Allocator) void {\n                    return allocator_.destroy(@as(*child, @ptrCast(@alignCast(ctx))));\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn receive(_: *anyopaque, _: tp.pid_ref, _: tp.message) tp.result {\n                    return false;\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "receive",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn init(allocator: Allocator) List {\n        return .{\n            .allocator = allocator,\n            .list = .empty,\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn deinit(self: *List) void {\n        for (self.list.items) |*i|\n            i.deinit();\n        self.list.deinit(self.allocator);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to add from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn add(self: *List, h: EventHandler) !void {\n        (try self.list.addOne(self.allocator)).* = h;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "add",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to remove from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn remove(self: *List, h: EventHandler) !void {\n        return self.remove_ptr(h.ptr);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "remove",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to remove_ptr from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn remove_ptr(self: *List, p_: *anyopaque) void {\n        for (self.list.items, 0..) |*p, i|\n            if (p.ptr == p_)\n                self.list.orderedRemove(i).deinit();\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "remove_ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to msg from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn msg(self: *const List, m: anytype) tp.result {\n        return self.send(tp.self_pid(), tp.message.fmt(m));\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "msg",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to send from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub fn send(self: *const List, from: tp.pid_ref, m: tp.message) tp.result {\n        if (self.recursion_check)\n            @panic(\"recursive EventHandler call\");\n        const self_nonconst = @constCast(self);\n        self_nonconst.recursion_check = true;\n        defer self_nonconst.recursion_check = false;\n        tp.trace(tp.channel.event, m);\n        var buf: [tp.max_message_size]u8 = undefined;\n        @memcpy(buf[0..m.buf.len], m.buf);\n        const m_: tp.message = .{ .buf = buf[0..m.buf.len] }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "function",
      "name": "send",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to VTable from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub const VTable = struct {\n    deinit: *const fn (ctx: *anyopaque) void,\n    send: *const fn (ctx: *anyopaque, from: tp.pid_ref, m: tp.message) tp.result,\n    type_name: []const u8,\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "struct",
      "name": "VTable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to List from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "pub const List = struct {\n    allocator: Allocator,\n    list: ArrayList(EventHandler),\n    recursion_check: bool = false,\n\n    pub fn init(allocator: Allocator) List {\n        return .{\n            .allocator = allocator,\n            .list = .empty,\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "struct",
      "name": "List",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to child from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "const child: type = impl.pointer.child;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "const",
      "name": "child",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to child from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "const child: type = impl.pointer.child;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "const",
      "name": "child",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to child from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "const child: type = impl.pointer.child;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "const",
      "name": "child",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to child from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "const child: type = struct {};",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "const",
      "name": "child",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to m_ from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/EventHandler.zig",
    "response": "const m_: tp.message = .{ .buf = buf[0..m.buf.len] };",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/EventHandler.zig",
      "type": "const",
      "name": "m_",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to open from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "pub fn open(\n    allocator: std.mem.Allocator,\n    project: []const u8,\n    cmd: tp.message,\n) (error{ ThespianSpawnFailed, InvalidLspCommand }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "open",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "pub fn deinit(self: *const Self) void {\n    self.pid.send(.{\"close\"}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to term from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "pub fn term(self: *const Self) void {\n    self.pid.send(.{\"term\"}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "term",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_request from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "pub fn send_request(\n    self: *const Self,\n    allocator: std.mem.Allocator,\n    method: []const u8,\n    m: anytype,\n    ctx: anytype,\n) (OutOfMemoryError || SpawnError || std.Io.Writer.Error)!void {\n    var cb: std.Io.Writer.Allocating = .init(self.allocator);\n    defer cb.deinit();\n    try cbor.writeValue(&cb.writer, m);\n    return RequestContext(@TypeOf(ctx)).send(allocator, self.pid.ref(), ctx, tp.message.fmt(.{ \"REQ\", method, cb.written() }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "send_request",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_notification from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "pub fn send_notification(self: *const Self, method: []const u8, m: anytype) (OutOfMemoryError || SendError || std.Io.Writer.Error)!void {\n    var cb: std.Io.Writer.Allocating = .init(self.allocator);\n    defer cb.deinit();\n    try cbor.writeValue(&cb.writer, m);\n    return self.send_notification_raw(method, cb.written());\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "send_notification",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_notification_raw from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "pub fn send_notification_raw(self: *const Self, method: []const u8, cb: []const u8) SendError!void {\n    self.pid.send(.{ \"NTFY\", method, cb }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "send_notification_raw",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_response from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "pub fn send_response(allocator: std.mem.Allocator, to: tp.pid_ref, cbor_id: []const u8, result: anytype) (SendError || OutOfMemoryError || std.Io.Writer.Error)!void {\n    var cb: std.Io.Writer.Allocating = .init(allocator);\n    defer cb.deinit();\n    const writer = &cb.writer;\n    try cbor.writeArrayHeader(writer, 3);\n    try cbor.writeValue(writer, \"RSP\");\n    try writer.writeAll(cbor_id);\n    try cbor.writeValue(writer, result);\n    to.send_raw(.{ .buf = cb.written() }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "send_response",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_error_response from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "pub fn send_error_response(allocator: std.mem.Allocator, to: tp.pid_ref, cbor_id: []const u8, code: ErrorCode, message: []const u8) (SendError || OutOfMemoryError || std.Io.Writer.Error)!void {\n    var cb: std.Io.Writer.Allocating = .init(allocator);\n    defer cb.deinit();\n    const writer = &cb.writer;\n    try cbor.writeArrayHeader(writer, 4);\n    try cbor.writeValue(writer, \"ERR\");\n    try writer.writeAll(cbor_id);\n    try cbor.writeValue(writer, code);\n    try cbor.writeValue(writer, message);\n    to.send_raw(.{ .buf = cb.written() }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "send_error_response",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to close from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "pub fn close(self: *Self) void {\n    self.deinit();\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "close",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to RequestContext from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn RequestContext(T: type) type {\n    return struct {\n        receiver: ReceiverT,\n        ctx: T,\n        to: tp.pid,\n        request: tp.message,\n        response: ?tp.message,\n        a: std.mem.Allocator,\n\n        const Self = @This();\n        const ReceiverT = tp.Receiver(*@This());\n\n        fn send(a: std.mem.Allocator, to: tp.pid_ref, ctx: T, request: tp.message) (OutOfMemoryError || SpawnError)!void {\n            const self = try a.create(@This());\n            self.* = .{\n                .receiver = undefined,\n                .ctx = if (@hasDecl(T, \"clone\")) ctx.clone() else ctx,\n                .to = to.clone(),\n                .request = try request.clone(std.heap.c_allocator),\n                .response = null,\n                .a = a,\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "RequestContext",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn deinit(self: *@This()) void {\n            self.ctx.deinit();\n            std.heap.c_allocator.free(self.request.buf);\n            self.to.deinit();\n            self.a.destroy(self);\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to start from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn start(self: *@This()) tp.result {\n            _ = tp.set_trap(true);\n            if (@hasDecl(T, \"link\")) try self.ctx.link();\n            errdefer self.deinit();\n            try self.to.link();\n            try self.to.send_raw(self.request);\n            tp.receive(&self.receiver);\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive_ from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn receive_(self: *@This(), _: tp.pid_ref, m: tp.message) tp.result {\n            defer self.deinit();\n            self.ctx.receive(m) catch |e| return tp.exit_error(e, @errorReturnTrace());\n            return tp.exit_normal();\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "receive_",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to create from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "pub fn create(allocator: std.mem.Allocator, project: []const u8, cmd: tp.message) (error{ ThespianSpawnFailed, InvalidLspCommand }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "create",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn deinit(self: *Process) void {\n        self.free_init_queue();\n        var i = self.requests.iterator();\n        while (i.next()) |req| {\n            self.allocator.free(req.key_ptr.*);\n            req.value_ptr.deinit();\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to msg from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn msg(self: *const Process, comptime fmt: anytype, args: anytype) void {\n        send_msg(self.parent, self.tag, .msg, fmt, args);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "msg",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to err_msg from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn err_msg(self: *const Process, comptime fmt: anytype, args: anytype) void {\n        send_msg(self.parent, self.tag, .err, fmt, args);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "err_msg",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_msg from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn send_msg(proc: tp.pid, tag: []const u8, type_: enum { msg, err }, comptime fmt: anytype, args: anytype) void {\n        var buf: [@import(\"log\").max_log_message]u8 = undefined;\n        const output = std.fmt.bufPrint(&buf, fmt, args) catch \"MESSAGE TOO LARGE\";\n        proc.send(.{ \"lsp\", type_, tag, output }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "send_msg",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to start from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn start(self: *Process) tp.result {\n        const frame = tracy.initZone(@src(), .{ .name = module_name ++ \" start\" }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn receive(self: *Process, from: tp.pid_ref, m: tp.message) tp.result {\n        return self.receive_safe(from, m) catch |e| switch (e) {\n            error.ExitNormal => tp.exit_normal(),\n            error.ExitUnexpected => error.Exit,\n            else => tp.exit_error(e, @errorReturnTrace()),\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "receive",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive_safe from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn receive_safe(self: *Process, from: tp.pid_ref, m: tp.message) Error!void {\n        const frame = tracy.initZone(@src(), .{ .name = module_name }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "receive_safe",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to append_init_queue from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn append_init_queue(self: *Process, from: tp.pid_ref, method: []const u8, bytes: []const u8, type_: InitQueueType) !void {\n        const queue = if (self.init_queue) |*queue| queue else blk: {\n            self.init_queue = .empty;\n            break :blk &self.init_queue.?;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "append_init_queue",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to replay_init_queue from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn replay_init_queue(self: *Process) !void {\n        defer self.free_init_queue();\n        if (self.init_queue) |*queue| {\n            for (queue.items) |*p|\n                switch (p[3]) {\n                    .request => try self.send_request(p[0].ref(), p[1], p[2]),\n                    .notify => try self.send_notification(p[1], p[2]),\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "replay_init_queue",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to free_init_queue from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn free_init_queue(self: *Process) void {\n        if (self.init_queue) |*queue| {\n            for (queue.items) |*p| {\n                p[0].deinit();\n                self.allocator.free(p[1]);\n                self.allocator.free(p[2]);\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "free_init_queue",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive_lsp_message from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn receive_lsp_message(self: *Process, cb: []const u8) Error!void {\n        var iter = cb;\n\n        const MsgMembers = struct {\n            cbor_id: ?[]const u8 = null,\n            method: ?[]const u8 = null,\n            params: ?[]const u8 = null,\n            result: ?[]const u8 = null,\n            @\"error\": ?[]const u8 = null,\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "receive_lsp_message",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to handle_output from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn handle_output(self: *Process, bytes: []const u8) Error!void {\n        try self.recv_buf.appendSlice(self.allocator, bytes);\n        self.write_log(\"### RECV:\\n{s}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "handle_output",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to handle_not_found from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn handle_not_found(self: *Process) error{ExitNormal}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "handle_not_found",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to handle_terminated from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn handle_terminated(self: *Process, err: []const u8, code: u32) error{ExitNormal}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "handle_terminated",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_request from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn send_request(self: *Process, from: tp.pid_ref, method: []const u8, params_cb: []const u8) Error!void {\n        const sp = if (self.sp) |*sp| sp else return error.Closed;\n\n        const id = self.next_id;\n        self.next_id += 1;\n\n        var request: std.Io.Writer.Allocating = .init(self.allocator);\n        defer request.deinit();\n        const msg_writer = &request.writer;\n        try cbor.writeMapHeader(msg_writer, 4);\n        try cbor.writeValue(msg_writer, \"jsonrpc\");\n        try cbor.writeValue(msg_writer, \"2.0\");\n        try cbor.writeValue(msg_writer, \"id\");\n        try cbor.writeValue(msg_writer, id);\n        try cbor.writeValue(msg_writer, \"method\");\n        try cbor.writeValue(msg_writer, method);\n        try cbor.writeValue(msg_writer, \"params\");\n        _ = try msg_writer.write(params_cb);\n\n        const json = try cbor.toJsonAlloc(self.allocator, request.written());\n        defer self.allocator.free(json);\n        var output: std.Io.Writer.Allocating = .init(self.allocator);\n        defer output.deinit();\n        const writer = &output.writer;\n        const terminator = \"\\r\\n\";\n        const content_length = json.len + terminator.len;\n        try writer.print(\"Content-Length: {d}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "send_request",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_response from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn send_response(self: *Process, cbor_id: []const u8, result_cb: []const u8) (error{Closed}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "send_response",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_error_response from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn send_error_response(self: *Process, cbor_id: []const u8, error_code: ErrorCode, message: []const u8) (error{Closed}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "send_error_response",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_notification from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn send_notification(self: *Process, method: []const u8, params_cb: []const u8) Error!void {\n        const sp = if (self.sp) |*sp| sp else return error.Closed;\n\n        const have_params = !(cbor.match(params_cb, cbor.null_) catch false);\n\n        var notification: std.Io.Writer.Allocating = .init(self.allocator);\n        defer notification.deinit();\n        const msg_writer = &notification.writer;\n        try cbor.writeMapHeader(msg_writer, 3);\n        try cbor.writeValue(msg_writer, \"jsonrpc\");\n        try cbor.writeValue(msg_writer, \"2.0\");\n        try cbor.writeValue(msg_writer, \"method\");\n        try cbor.writeValue(msg_writer, method);\n        try cbor.writeValue(msg_writer, \"params\");\n        if (have_params) {\n            _ = try msg_writer.write(params_cb);\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "send_notification",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to frame_message_recv from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn frame_message_recv(self: *Process) Error!void {\n        const sep = \"\\r\\n\\r\\n\";\n        const headers_end = std.mem.indexOf(u8, self.recv_buf.items, sep) orelse return;\n        const headers_data = self.recv_buf.items[0..headers_end];\n        const headers = try Headers.parse(headers_data);\n        if (self.recv_buf.items.len - (headers_end + sep.len) < headers.content_length) return;\n        const buf = try self.recv_buf.toOwnedSlice(self.allocator);\n        const data = buf[headers_end + sep.len .. headers_end + sep.len + headers.content_length];\n        const rest = buf[headers_end + sep.len + headers.content_length ..];\n        defer self.allocator.free(buf);\n        if (rest.len > 0) try self.recv_buf.appendSlice(self.allocator, rest);\n        const message = .{ .body = data[0..headers.content_length] }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "frame_message_recv",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive_lsp_request from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn receive_lsp_request(self: *Process, cbor_id: []const u8, method: []const u8, params: ?[]const u8) Error!void {\n        const json_id = try cbor.toJsonPrettyAlloc(self.allocator, cbor_id);\n        defer self.allocator.free(json_id);\n        const json = if (params) |p| try cbor.toJsonPrettyAlloc(self.allocator, p) else null;\n        defer if (json) |p| self.allocator.free(p);\n        self.write_log(\"### RECV req: {s}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "receive_lsp_request",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive_lsp_response from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn receive_lsp_response(self: *Process, cbor_id: []const u8, result: ?[]const u8, err: ?[]const u8) Error!void {\n        const json_id = try cbor.toJsonPrettyAlloc(self.allocator, cbor_id);\n        defer self.allocator.free(json_id);\n        const json = if (result) |p| try cbor.toJsonPrettyAlloc(self.allocator, p) else null;\n        defer if (json) |p| self.allocator.free(p);\n        const json_err = if (err) |p| try cbor.toJsonPrettyAlloc(self.allocator, p) else null;\n        defer if (json_err) |p| self.allocator.free(p);\n        self.write_log(\"### RECV rsp: {s}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "receive_lsp_response",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive_lsp_notification from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn receive_lsp_notification(self: *Process, method: []const u8, params: ?[]const u8) Error!void {\n        const json = if (params) |p| try cbor.toJsonPrettyAlloc(self.allocator, p) else null;\n        defer if (json) |p| self.allocator.free(p);\n        self.write_log(\"### RECV notify:\\nmethod: {s}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "receive_lsp_notification",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_log from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn write_log(self: *Process, comptime format: []const u8, args: anytype) void {\n        if (!debug_lsp) return;\n        const file_writer = if (self.log_file_writer) |*writer| writer else return;\n        file_writer.interface.print(format, args) catch {}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "write_log",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to parse from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn parse(buf_: []const u8) Process.Error!Headers {\n        var buf = buf_;\n        var ret: Headers = .{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "parse",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parse_one from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "fn parse_one(self: *Headers, name: []const u8, value: []const u8) Process.Error!void {\n        if (std.mem.eql(u8, \"Content-Length\", name)) {\n            self.content_length = std.fmt.parseInt(@TypeOf(self.content_length), value, 10) catch |e| switch (e) {\n                error.Overflow => return error.InvalidContentLength,\n                error.InvalidCharacter => return error.InvalidContentLength,\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "function",
      "name": "parse_one",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Process from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "const Process = struct {\n    allocator: std.mem.Allocator,\n    cmd: tp.message,\n    receiver: Receiver,\n    sp: ?tp.subprocess = null,\n    recv_buf: std.ArrayList(u8),\n    parent: tp.pid,\n    tag: [:0]const u8,\n    project: [:0]const u8,\n    sp_tag: [:0]const u8,\n    log_file: ?std.fs.File = null,\n    log_file_path: ?[]const u8 = null,\n    log_file_writer: ?std.fs.File.Writer = null,\n    log_file_writer_buf: [1024]u8 = undefined,\n    next_id: i32 = 0,\n    requests: std.StringHashMap(tp.pid),\n    state: enum { init, running }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "struct",
      "name": "Process",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to MsgMembers from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "const MsgMembers = struct {\n            cbor_id: ?[]const u8 = null,\n            method: ?[]const u8 = null,\n            params: ?[]const u8 = null,\n            result: ?[]const u8 = null,\n            @\"error\": ?[]const u8 = null,\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "struct",
      "name": "MsgMembers",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Headers from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/LSP.zig",
    "response": "const Headers = struct {\n    content_length: usize = 0,\n    content_type: ?[]const u8 = null,\n\n    fn parse(buf_: []const u8) Process.Error!Headers {\n        var buf = buf_;\n        var ret: Headers = .{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/LSP.zig",
      "type": "struct",
      "name": "Headers",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn init(allocator: std.mem.Allocator, name: []const u8) OutOfMemoryError!Self {\n    return .{\n        .allocator = allocator,\n        .name = try allocator.dupe(u8, name),\n        .open_time = std.time.milliTimestamp(),\n        .language_servers = std.StringHashMap(*const LSP).init(allocator),\n        .file_language_server_name = std.StringHashMap([]const u8).init(allocator),\n        .tasks = .empty,\n        .logger = log.logger(\"project\"),\n        .logger_lsp = log.logger(\"lsp\"),\n        .logger_git = log.logger(\"git\"),\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn deinit(self: *Self) void {\n    if (self.walker) |pid| pid.send(.{\"stop\"}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_state from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn write_state(self: *Self, writer: anytype) !void {\n    return self.write_state_v1(writer);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "write_state",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_state_v1 from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn write_state_v1(self: *Self, writer: anytype) !void {\n    tp.trace(tp.channel.debug, .{\"write_state_v1\"}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "write_state_v1",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_state_v0 from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn write_state_v0(self: *Self, writer: anytype) !void {\n    try cbor.writeValue(writer, self.name);\n    for (self.files.items) |file| {\n        if (!file.visited) continue;\n        try cbor.writeArrayHeader(writer, 4);\n        try cbor.writeValue(writer, file.path);\n        try cbor.writeValue(writer, file.mtime);\n        try cbor.writeValue(writer, file.row);\n        try cbor.writeValue(writer, file.col);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "write_state_v0",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to restore_state from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn restore_state(self: *Self, data: []const u8) !void {\n    tp.trace(tp.channel.debug, .{\"restore_state\"}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "restore_state",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to restore_state_v1 from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn restore_state_v1(self: *Self, data: []const u8) !void {\n    tp.trace(tp.channel.debug, .{\"restore_state_v1\"}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "restore_state_v1",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to restore_state_v0 from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn restore_state_v0(self: *Self, data: []const u8) error{\n    OutOfMemory,\n    IntegerTooLarge,\n    IntegerTooSmall,\n    InvalidType,\n    TooShort,\n    InvalidFloatType,\n    InvalidArrayType,\n    InvalidPIntType,\n    JsonIncompatibleType,\n    NotAnObject,\n    BadArrayAllocExtract,\n    InvalidMapType,\n    InvalidUnion,\n    WriteFailed,\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "restore_state_v0",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_existing_language_server from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn get_existing_language_server(self: *Self, language_server: []const u8) ?*const LSP {\n    if (self.language_servers.get(language_server)) |lsp| {\n        if (!lsp.pid.expired()) return lsp;\n        if (self.language_servers.fetchRemove(language_server)) |kv| {\n            self.allocator.free(kv.key);\n            kv.value.deinit();\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "get_existing_language_server",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_language_server_instance from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn get_language_server_instance(self: *Self, language_server: []const u8) StartLspError!*const LSP {\n    if (self.get_existing_language_server(language_server)) |lsp| return lsp;\n    const lsp = try LSP.open(self.allocator, self.name, .{ .buf = language_server }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "get_language_server_instance",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_or_start_language_server from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn get_or_start_language_server(self: *Self, file_path: []const u8, language_server: []const u8) StartLspError!*const LSP {\n    if (self.file_language_server_name.get(file_path)) |lsp_name|\n        return self.get_existing_language_server(lsp_name) orelse error.LspFailed;\n    const lsp = try self.get_language_server_instance(language_server);\n    const key = try self.allocator.dupe(u8, file_path);\n    const value = try self.allocator.dupe(u8, language_server);\n    try self.file_language_server_name.put(key, value);\n    return lsp;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "get_or_start_language_server",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_language_server from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn get_language_server(self: *Self, file_path: []const u8) LspError!*const LSP {\n    const lsp_name = self.file_language_server_name.get(file_path) orelse return error.NoLsp;\n    return self.get_existing_language_server(lsp_name) orelse error.LspFailed;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "get_language_server",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to make_URI from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn make_URI(self: *Self, file_path: ?[]const u8) LspError![]const u8 {\n    var buf: std.Io.Writer.Allocating = .init(self.allocator);\n    defer buf.deinit();\n    const writer = &buf.writer;\n    if (file_path) |path| {\n        if (std.fs.path.isAbsolute(path)) {\n            try writer.print(\"file://{s}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "make_URI",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to sort_files_by_mtime from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn sort_files_by_mtime(self: *Self) void {\n    sort_by_mtime(File, self.files.items);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "sort_files_by_mtime",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sort_tasks_by_mtime from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn sort_tasks_by_mtime(self: *Self) void {\n    sort_by_mtime(Task, self.tasks.items);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "sort_tasks_by_mtime",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sort_by_mtime from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn sort_by_mtime(T: type, items: []T) void {\n    std.mem.sort(T, items, {}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "sort_by_mtime",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to cmp from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn cmp(_: void, lhs: T, rhs: T) bool {\n            return lhs.mtime > rhs.mtime;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "cmp",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to request_n_most_recent_file from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn request_n_most_recent_file(self: *Self, from: tp.pid_ref, n: usize) ClientError!void {\n    if (n >= self.files.items.len) return error.ClientFailed;\n    const file_path = if (self.files.items.len > 0) self.files.items[n].path else null;\n    from.send(.{file_path}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "request_n_most_recent_file",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to request_recent_files from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn request_recent_files(self: *Self, from: tp.pid_ref, max: usize) ClientError!void {\n    defer from.send(.{ \"PRJ\", \"recent_done\", self.longest_file_path, \"\" }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "request_recent_files",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to simple_query_recent_files from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn simple_query_recent_files(self: *Self, from: tp.pid_ref, max: usize, query: []const u8) ClientError!usize {\n    var i: usize = 0;\n    defer from.send(.{ \"PRJ\", \"recent_done\", self.longest_file_path, query }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "simple_query_recent_files",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to query_recent_files from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn query_recent_files(self: *Self, from: tp.pid_ref, max: usize, query: []const u8) ClientError!usize {\n    if (query.len < 3)\n        return self.simple_query_recent_files(from, max, query);\n    defer from.send(.{ \"PRJ\", \"recent_done\", self.longest_file_path, query }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "query_recent_files",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to less_fn from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn less_fn(_: void, lhs: Match, rhs: Match) bool {\n            return lhs.score > rhs.score;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "less_fn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walk_tree_entry_callback from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn walk_tree_entry_callback(parent: tp.pid_ref, root_path: []const u8, file_path: []const u8, mtime_high: i64, mtime_low: i64) error{Exit}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "walk_tree_entry_callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walk_tree_entry from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn walk_tree_entry(self: *Self, m: tp.message) OutOfMemoryError!void {\n    var file_path: []const u8 = undefined;\n    var mtime_high: i64 = 0;\n    var mtime_low: i64 = 0;\n    var file_type: []const u8 = undefined;\n    var file_icon: []const u8 = undefined;\n    var file_color: u32 = 0;\n    if (!(cbor.match(m.buf, .{\n        tp.string,\n        tp.string,\n        tp.extract(&file_path),\n        tp.extract(&mtime_high),\n        tp.extract(&mtime_low),\n        tp.extract(&file_type),\n        tp.extract(&file_icon),\n        tp.extract(&file_color),\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "walk_tree_entry",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walk_tree_done_callback from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn walk_tree_done_callback(parent: tp.pid_ref, root_path: []const u8) error{Exit}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "walk_tree_done_callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walk_tree_done from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn walk_tree_done(self: *Self, parent: tp.pid_ref) OutOfMemoryError!void {\n    self.state.walk_tree = .done;\n    if (self.walker) |pid| pid.deinit();\n    self.walker = null;\n    return self.loaded(parent);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "walk_tree_done",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to default_ft from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn default_ft() struct { []const u8, []const u8, u24 }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "default_ft",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to guess_path_file_type from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn guess_path_file_type(path: []const u8, file_name: []const u8) struct { []const u8, []const u8, u24 }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "guess_path_file_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to guess_file_type from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn guess_file_type(file_path: []const u8) struct { []const u8, []const u8, u24 }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "guess_file_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to merge_pending_files from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn merge_pending_files(self: *Self) OutOfMemoryError!void {\n    defer self.sort_files_by_mtime();\n    const existing = try self.files.toOwnedSlice(self.allocator);\n    defer self.allocator.free(existing);\n    self.files = self.pending;\n    self.pending = .empty;\n\n    for (existing) |*file| {\n        self.update_mru_internal(file.path, file.mtime, file.pos.row, file.pos.col) catch {}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "merge_pending_files",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to loaded from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn loaded(self: *Self, parent: tp.pid_ref) OutOfMemoryError!void {\n    inline for (@typeInfo(@TypeOf(self.state)).@\"struct\".fields) |f|\n        if (@field(self.state, f.name) == .running) return;\n\n    self.logger.print(\"project files: {d}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "loaded",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to update_mru from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn update_mru(self: *Self, file_path: []const u8, row: usize, col: usize) OutOfMemoryError!void {\n    defer self.sort_files_by_mtime();\n    try self.update_mru_internal(file_path, std.time.nanoTimestamp(), row, col);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "update_mru",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to update_mru_internal from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn update_mru_internal(self: *Self, file_path: []const u8, mtime: i128, row: usize, col: usize) OutOfMemoryError!void {\n    for (self.files.items) |*file| {\n        if (!std.mem.eql(u8, file.path, file_path)) continue;\n        file.mtime = mtime;\n        if (row != 0) {\n            file.pos.row = row;\n            file.pos.col = col;\n            file.visited = true;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "update_mru_internal",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_mru_position from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn get_mru_position(self: *Self, from: tp.pid_ref, file_path: []const u8) ClientError!void {\n    for (self.files.items) |*file| {\n        if (!std.mem.eql(u8, file.path, file_path)) continue;\n        from.send(.{ file.pos.row + 1, file.pos.col + 1 }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "get_mru_position",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to request_tasks from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn request_tasks(self: *Self, from: tp.pid_ref) ClientError!void {\n    var message: std.Io.Writer.Allocating = .init(self.allocator);\n    defer message.deinit();\n    const writer = &message.writer;\n    try cbor.writeArrayHeader(writer, self.tasks.items.len);\n    for (self.tasks.items) |task|\n        try cbor.writeValue(writer, task.command);\n    from.send_raw(.{ .buf = message.written() }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "request_tasks",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to add_task from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn add_task(self: *Self, command: []const u8) OutOfMemoryError!void {\n    defer self.sort_tasks_by_mtime();\n    const mtime = std.time.milliTimestamp();\n    for (self.tasks.items) |*task|\n        if (std.mem.eql(u8, task.command, command)) {\n            tp.trace(tp.channel.debug, .{ \"Project\", self.name, \"add_task\", command, task.mtime, \"->\", mtime }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "add_task",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to delete_task from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn delete_task(self: *Self, command: []const u8) error{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "delete_task",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to did_open from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn did_open(self: *Self, file_path: []const u8, file_type: []const u8, language_server: []const u8, version: usize, text: []const u8) StartLspError!void {\n    defer std.heap.c_allocator.free(text);\n    self.update_mru(file_path, 0, 0) catch {}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "did_open",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to did_change from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn did_change(self: *Self, file_path: []const u8, version: usize, text_dst: []const u8, text_src: []const u8, eol_mode: Buffer.EolMode) LspError!void {\n    _ = eol_mode;\n    defer std.heap.c_allocator.free(text_dst);\n    defer std.heap.c_allocator.free(text_src);\n    const lsp = try self.get_language_server(file_path);\n    const uri = try self.make_URI(file_path);\n\n    var arena_ = std.heap.ArenaAllocator.init(self.allocator);\n    const arena = arena_.allocator();\n    var scratch_alloc: ?[]u32 = null;\n    defer {\n        const frame = tracy.initZone(@src(), .{ .name = \"deinit\" }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "did_change",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to scan_char from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn scan_char(chars: []const u8, lines: *usize, char: u8, last_offset: ?*usize) void {\n    var pos = chars;\n    if (last_offset) |off| off.* += pos.len;\n    while (pos.len > 0) {\n        if (pos[0] == char) {\n            if (last_offset) |off| off.* = pos.len - 1;\n            lines.* += 1;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "scan_char",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to did_save from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn did_save(self: *Self, file_path: []const u8) LspError!void {\n    const lsp = try self.get_language_server(file_path);\n    const uri = try self.make_URI(file_path);\n    defer self.allocator.free(uri);\n    lsp.send_notification(\"textDocument/didSave\", .{\n        .textDocument = .{ .uri = uri }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "did_save",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to did_close from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn did_close(self: *Self, file_path: []const u8) LspError!void {\n    const lsp = try self.get_language_server(file_path);\n    const uri = try self.make_URI(file_path);\n    defer self.allocator.free(uri);\n    lsp.send_notification(\"textDocument/didClose\", .{\n        .textDocument = .{ .uri = uri }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "did_close",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to goto_definition from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn goto_definition(self: *Self, from: tp.pid_ref, file_path: []const u8, row: usize, col: usize) SendGotoRequestError!void {\n    return self.send_goto_request(from, file_path, row, col, \"textDocument/definition\");\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "goto_definition",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to goto_declaration from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn goto_declaration(self: *Self, from: tp.pid_ref, file_path: []const u8, row: usize, col: usize) SendGotoRequestError!void {\n    return self.send_goto_request(from, file_path, row, col, \"textDocument/declaration\");\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "goto_declaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to goto_implementation from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn goto_implementation(self: *Self, from: tp.pid_ref, file_path: []const u8, row: usize, col: usize) SendGotoRequestError!void {\n    return self.send_goto_request(from, file_path, row, col, \"textDocument/implementation\");\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "goto_implementation",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to goto_type_definition from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn goto_type_definition(self: *Self, from: tp.pid_ref, file_path: []const u8, row: usize, col: usize) SendGotoRequestError!void {\n    return self.send_goto_request(from, file_path, row, col, \"textDocument/typeDefinition\");\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "goto_type_definition",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_goto_request from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn send_goto_request(self: *Self, from: tp.pid_ref, file_path: []const u8, row: usize, col: usize, method: []const u8) SendGotoRequestError!void {\n    const lsp = try self.get_language_server(file_path);\n    const uri = try self.make_URI(file_path);\n    defer self.allocator.free(uri);\n\n    const handler: struct {\n        from: tp.pid,\n        name: []const u8,\n        project: *Self,\n\n        pub fn deinit(self_: *@This()) void {\n            std.heap.c_allocator.free(self_.name);\n            self_.from.deinit();\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "send_goto_request",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn receive(self_: @This(), response: tp.message) !void {\n            var link: []const u8 = undefined;\n            var locations: []const u8 = undefined;\n            if (try cbor.match(response.buf, .{ \"child\", tp.string, \"result\", tp.array }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "receive",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to navigate_to_location_link from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn navigate_to_location_link(from: tp.pid_ref, location_link: []const u8) (ClientError || InvalidMessageError || cbor.Error)!void {\n    var iter = location_link;\n    var targetUri: ?[]const u8 = null;\n    var targetRange: ?Range = null;\n    var targetSelectionRange: ?Range = null;\n    var len = try cbor.decodeMapHeader(&iter);\n    while (len > 0) : (len -= 1) {\n        var field_name: []const u8 = undefined;\n        if (!(try cbor.matchString(&iter, &field_name))) return error.InvalidMessage;\n        if (std.mem.eql(u8, field_name, \"targetUri\") or std.mem.eql(u8, field_name, \"uri\")) {\n            var value: []const u8 = undefined;\n            if (!(try cbor.matchValue(&iter, cbor.extract(&value)))) return error.InvalidMessageField;\n            targetUri = value;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "navigate_to_location_link",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to references from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn references(self: *Self, from: tp.pid_ref, file_path: []const u8, row: usize, col: usize) SendGotoRequestError!void {\n    const lsp = try self.get_language_server(file_path);\n    const uri = try self.make_URI(file_path);\n    defer self.allocator.free(uri);\n    self.logger_lsp.print(\"finding references...\", .{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "references",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn deinit(self_: *@This()) void {\n            std.heap.c_allocator.free(self_.name);\n            self_.from.deinit();\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn receive(self_: @This(), response: tp.message) !void {\n            var locations: []const u8 = undefined;\n            if (try cbor.match(response.buf, .{ \"child\", tp.string, \"result\", tp.null_ }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "receive",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_reference_list from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn send_reference_list(self: *Self, to: tp.pid_ref, locations: []const u8, name: []const u8) (ClientError || InvalidMessageError || GetLineOfFileError || cbor.Error)!void {\n    defer to.send(.{ \"REF\", \"done\" }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "send_reference_list",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_reference from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn send_reference(to: tp.pid_ref, location: []const u8, name: []const u8) (ClientError || InvalidMessageError || GetLineOfFileError || cbor.Error)!void {\n    const allocator = std.heap.c_allocator;\n    var iter = location;\n    var targetUri: ?[]const u8 = null;\n    var targetRange: ?Range = null;\n    var targetSelectionRange: ?Range = null;\n    var len = try cbor.decodeMapHeader(&iter);\n    while (len > 0) : (len -= 1) {\n        var field_name: []const u8 = undefined;\n        if (!(try cbor.matchString(&iter, &field_name))) return error.InvalidMessage;\n        if (std.mem.eql(u8, field_name, \"targetUri\") or std.mem.eql(u8, field_name, \"uri\")) {\n            var value: []const u8 = undefined;\n            if (!(try cbor.matchValue(&iter, cbor.extract(&value)))) return error.InvalidMessageField;\n            targetUri = value;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "send_reference",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to completion from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn completion(self: *Self, from: tp.pid_ref, file_path: []const u8, row: usize, col: usize) (LspOrClientError || InvalidMessageError || cbor.Error)!void {\n    const lsp = try self.get_language_server(file_path);\n    const uri = try self.make_URI(file_path);\n    defer self.allocator.free(uri);\n\n    const handler: struct {\n        from: tp.pid,\n        file_path: []const u8,\n        row: usize,\n        col: usize,\n\n        pub fn deinit(self_: *@This()) void {\n            std.heap.c_allocator.free(self_.file_path);\n            self_.from.deinit();\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "completion",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn receive(self_: @This(), response: tp.message) !void {\n            var result: []const u8 = undefined;\n            if (try cbor.match(response.buf, .{ \"child\", tp.string, \"result\", tp.null_ }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "receive",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_completion_list from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn send_completion_list(to: tp.pid_ref, file_path: []const u8, row: usize, col: usize, result: []const u8) (ClientError || InvalidMessageError || cbor.Error)!void {\n    var iter = result;\n    var len = cbor.decodeMapHeader(&iter) catch return;\n    var items: []const u8 = \"\";\n    var is_incomplete: bool = false;\n    while (len > 0) : (len -= 1) {\n        var field_name: []const u8 = undefined;\n        if (!(try cbor.matchString(&iter, &field_name))) return error.InvalidMessage;\n        if (std.mem.eql(u8, field_name, \"items\")) {\n            if (!(try cbor.matchValue(&iter, cbor.extract_cbor(&items)))) return error.InvalidMessageField;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "send_completion_list",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_completion_items from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn send_completion_items(to: tp.pid_ref, file_path: []const u8, row: usize, col: usize, items: []const u8, is_incomplete: bool) (ClientError || InvalidMessageError || cbor.Error)!void {\n    var iter = items;\n    var len = cbor.decodeArrayHeader(&iter) catch return;\n    var item: []const u8 = \"\";\n    while (len > 0) : (len -= 1) {\n        if (!(try cbor.matchValue(&iter, cbor.extract_cbor(&item)))) return error.InvalidMessageField;\n        try send_completion_item(to, file_path, row, col, item, if (len > 1) true else is_incomplete);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "send_completion_items",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to invalid_field from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn invalid_field(field: []const u8) error{InvalidMessage}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "invalid_field",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_completion_item from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn send_completion_item(to: tp.pid_ref, file_path: []const u8, row: usize, col: usize, item: []const u8, is_incomplete: bool) (ClientError || InvalidMessageError || cbor.Error)!void {\n    var label: []const u8 = \"\";\n    var label_detail: []const u8 = \"\";\n    var label_description: []const u8 = \"\";\n    var kind: usize = 0;\n    var detail: []const u8 = \"\";\n    var documentation: []const u8 = \"\";\n    var documentation_kind: []const u8 = \"\";\n    var sortText: []const u8 = \"\";\n    var insertTextFormat: usize = 0;\n    var textEdit: TextEdit = .{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "send_completion_item",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read_textEdit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn read_textEdit(iter: *[]const u8) !TextEdit {\n    var field_name: []const u8 = undefined;\n    var newText: []const u8 = \"\";\n    var insert: ?Range = null;\n    var replace: ?Range = null;\n    var len_ = cbor.decodeMapHeader(iter) catch return invalid_field(\"textEdit\");\n    while (len_ > 0) : (len_ -= 1) {\n        if (!(try cbor.matchString(iter, &field_name))) return invalid_field(\"textEdit\");\n        if (std.mem.eql(u8, field_name, \"newText\")) {\n            if (!(try cbor.matchValue(iter, cbor.extract(&newText)))) return invalid_field(\"textEdit.newText\");\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "read_textEdit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rename_symbol from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn rename_symbol(self: *Self, from: tp.pid_ref, file_path: []const u8, row: usize, col: usize) (LspOrClientError || GetLineOfFileError || InvalidMessageError || cbor.Error)!void {\n    const lsp = try self.get_language_server(file_path);\n    const uri = try self.make_URI(file_path);\n    defer self.allocator.free(uri);\n\n    const handler: struct {\n        from: tp.pid,\n        file_path: []const u8,\n\n        pub fn deinit(self_: *@This()) void {\n            std.heap.c_allocator.free(self_.file_path);\n            self_.from.deinit();\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "rename_symbol",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn receive(self_: @This(), response: tp.message) !void {\n            const allocator = std.heap.c_allocator;\n            var result: []const u8 = undefined;\n            // buffer the renames in order to send as a single, atomic message\n            var renames = std.array_list.Managed(Rename).init(allocator);\n            defer renames.deinit();\n\n            if (try cbor.match(response.buf, .{ \"child\", tp.string, \"result\", tp.map }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "receive",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode_rename_symbol_map from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn decode_rename_symbol_map(result: []const u8, renames: *std.array_list.Managed(Rename)) (ClientError || InvalidMessageError || cbor.Error)!void {\n    var iter = result;\n    var len = cbor.decodeMapHeader(&iter) catch return error.InvalidMessage;\n    var changes: []const u8 = \"\";\n    while (len > 0) : (len -= 1) {\n        var field_name: []const u8 = undefined;\n        if (!(try cbor.matchString(&iter, &field_name))) return error.InvalidMessage;\n        if (std.mem.eql(u8, field_name, \"changes\")) {\n            if (!(try cbor.matchValue(&iter, cbor.extract_cbor(&changes)))) return error.InvalidMessageField;\n            try decode_rename_symbol_changes(changes, renames);\n            return;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "decode_rename_symbol_map",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode_rename_symbol_changes from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn decode_rename_symbol_changes(changes: []const u8, renames: *std.array_list.Managed(Rename)) (ClientError || InvalidMessageError || cbor.Error)!void {\n    var iter = changes;\n    var files_len = cbor.decodeMapHeader(&iter) catch return error.InvalidMessage;\n    while (files_len > 0) : (files_len -= 1) {\n        var file_uri: []const u8 = undefined;\n        if (!(try cbor.matchString(&iter, &file_uri))) return error.InvalidMessage;\n        try decode_rename_symbol_item(file_uri, &iter, renames);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "decode_rename_symbol_changes",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode_rename_symbol_doc_changes from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn decode_rename_symbol_doc_changes(changes: []const u8, renames: *std.array_list.Managed(Rename)) (ClientError || InvalidMessageError || cbor.Error)!void {\n    var iter = changes;\n    var changes_len = cbor.decodeArrayHeader(&iter) catch return error.InvalidMessage;\n    while (changes_len > 0) : (changes_len -= 1) {\n        var dc_fields_len = cbor.decodeMapHeader(&iter) catch return error.InvalidMessage;\n        var file_uri: []const u8 = \"\";\n        while (dc_fields_len > 0) : (dc_fields_len -= 1) {\n            var field_name: []const u8 = undefined;\n            if (!(try cbor.matchString(&iter, &field_name))) return error.InvalidMessage;\n            if (std.mem.eql(u8, field_name, \"textDocument\")) {\n                var td_fields_len = cbor.decodeMapHeader(&iter) catch return error.InvalidMessage;\n                while (td_fields_len > 0) : (td_fields_len -= 1) {\n                    var td_field_name: []const u8 = undefined;\n                    if (!(try cbor.matchString(&iter, &td_field_name))) return error.InvalidMessage;\n                    if (std.mem.eql(u8, td_field_name, \"uri\")) {\n                        if (!(try cbor.matchString(&iter, &file_uri))) return error.InvalidMessage;\n                    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "decode_rename_symbol_doc_changes",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode_rename_symbol_item from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn decode_rename_symbol_item(file_uri: []const u8, iter: *[]const u8, renames: *std.array_list.Managed(Rename)) (ClientError || InvalidMessageError || cbor.Error)!void {\n    var text_edits_len = cbor.decodeArrayHeader(iter) catch return error.InvalidMessage;\n    while (text_edits_len > 0) : (text_edits_len -= 1) {\n        var m_range: ?Range = null;\n        var new_text: []const u8 = \"\";\n        var edits_len = cbor.decodeMapHeader(iter) catch return error.InvalidMessage;\n        while (edits_len > 0) : (edits_len -= 1) {\n            var field_name: []const u8 = undefined;\n            if (!(try cbor.matchString(iter, &field_name))) return error.InvalidMessage;\n            if (std.mem.eql(u8, field_name, \"range\")) {\n                var range: []const u8 = undefined;\n                if (!(try cbor.matchValue(iter, cbor.extract_cbor(&range)))) return error.InvalidMessageField;\n                m_range = try read_range(range);\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "decode_rename_symbol_item",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to hover from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn hover(self: *Self, from: tp.pid_ref, file_path: []const u8, row: usize, col: usize) (LspOrClientError || InvalidMessageError || cbor.Error)!void {\n    const lsp = try self.get_language_server(file_path);\n    const uri = try self.make_URI(file_path);\n    defer self.allocator.free(uri);\n    // self.logger_lsp.print(\"fetching hover information...\", .{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "hover",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn deinit(self_: *@This()) void {\n            self_.from.deinit();\n            std.heap.c_allocator.free(self_.file_path);\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn receive(self_: @This(), response: tp.message) !void {\n            var result: []const u8 = undefined;\n            if (try cbor.match(response.buf, .{ \"child\", tp.string, \"result\", tp.null_ }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "receive",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_hover from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn send_hover(to: tp.pid_ref, file_path: []const u8, row: usize, col: usize, result: []const u8) (ClientError || InvalidMessageError || cbor.Error)!void {\n    var iter = result;\n    var len = cbor.decodeMapHeader(&iter) catch return;\n    var contents: []const u8 = \"\";\n    var range: ?Range = null;\n    while (len > 0) : (len -= 1) {\n        var field_name: []const u8 = undefined;\n        if (!(try cbor.matchString(&iter, &field_name))) return error.InvalidMessage;\n        if (std.mem.eql(u8, field_name, \"contents\")) {\n            if (!(try cbor.matchValue(&iter, cbor.extract_cbor(&contents)))) return error.InvalidMessageField;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "send_hover",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_contents from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn send_contents(\n    to: tp.pid_ref,\n    tag: []const u8,\n    file_path: []const u8,\n    row: usize,\n    col: usize,\n    result: []const u8,\n    range: ?Range,\n) !void {\n    var iter = result;\n    var kind: []const u8 = \"plaintext\";\n    var value: []const u8 = \"\";\n    if (try cbor.matchValue(&iter, cbor.extract(&value)))\n        return send_content_msg(to, tag, file_path, row, col, kind, value, range);\n\n    var is_list = true;\n    var len = cbor.decodeArrayHeader(&iter) catch blk: {\n        is_list = false;\n        iter = result;\n        break :blk cbor.decodeMapHeader(&iter) catch return;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "send_contents",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_content_msg from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn send_content_msg(\n    to: tp.pid_ref,\n    tag: []const u8,\n    file_path: []const u8,\n    row: usize,\n    col: usize,\n    kind: []const u8,\n    content: []const u8,\n    range: ?Range,\n) ClientError!void {\n    const r = range orelse Range{\n        .start = .{ .line = row, .character = col }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "send_content_msg",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_content_msg_empty from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn send_content_msg_empty(to: tp.pid_ref, tag: []const u8, file_path: []const u8, row: usize, col: usize) ClientError!void {\n    return send_content_msg(to, tag, file_path, row, col, \"plaintext\", \"\", null);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "send_content_msg_empty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to publish_diagnostics from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn publish_diagnostics(self: *Self, to: tp.pid_ref, params_cb: []const u8) (ClientError || InvalidMessageError || cbor.Error)!void {\n    var uri: ?[]const u8 = null;\n    var diagnostics: []const u8 = &.{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "publish_diagnostics",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_diagnostic from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn send_diagnostic(_: *Self, to: tp.pid_ref, file_path: []const u8, diagnostic: []const u8) (ClientError || InvalidMessageError || cbor.Error)!void {\n    var source: []const u8 = \"unknown\";\n    var code: []const u8 = \"none\";\n    var message: []const u8 = \"empty\";\n    var severity: i64 = 1;\n    var range: ?Range = null;\n    var iter = diagnostic;\n    var len = try cbor.decodeMapHeader(&iter);\n    while (len > 0) : (len -= 1) {\n        var field_name: []const u8 = undefined;\n        if (!(try cbor.matchString(&iter, &field_name))) return error.InvalidMessage;\n        if (std.mem.eql(u8, field_name, \"source\") or std.mem.eql(u8, field_name, \"uri\")) {\n            if (!(try cbor.matchValue(&iter, cbor.extract(&source)))) return error.InvalidMessageField;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "send_diagnostic",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_clear_diagnostics from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn send_clear_diagnostics(_: *Self, to: tp.pid_ref, file_path: []const u8) ClientError!void {\n    to.send(.{ \"cmd\", \"clear_diagnostics\", .{file_path}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "send_clear_diagnostics",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read_range from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn read_range(range: []const u8) !Range {\n    var iter = range;\n    var start: ?Position = null;\n    var end: ?Position = null;\n    var len = try cbor.decodeMapHeader(&iter);\n    while (len > 0) : (len -= 1) {\n        var field_name: []const u8 = undefined;\n        if (!(try cbor.matchString(&iter, &field_name))) return error.InvalidMessage;\n        if (std.mem.eql(u8, field_name, \"start\")) {\n            var position: []const u8 = undefined;\n            if (!(try cbor.matchValue(&iter, cbor.extract_cbor(&position)))) return error.InvalidMessageField;\n            start = try read_position(position);\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "read_range",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read_position from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn read_position(position: []const u8) !Position {\n    var iter = position;\n    var line: ?usize = 0;\n    var character: ?usize = 0;\n    var len = try cbor.decodeMapHeader(&iter);\n    while (len > 0) : (len -= 1) {\n        var field_name: []const u8 = undefined;\n        if (!(try cbor.matchString(&iter, &field_name))) return error.InvalidMessage;\n        if (std.mem.eql(u8, field_name, \"line\")) {\n            if (!(try cbor.matchValue(&iter, cbor.extract(&line)))) return error.InvalidMessageField;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "read_position",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to show_message from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn show_message(self: *Self, params_cb: []const u8) !void {\n    return self.show_or_log_message(.show, params_cb);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "show_message",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to log_message from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn log_message(self: *Self, params_cb: []const u8) !void {\n    return self.show_or_log_message(.log, params_cb);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "log_message",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to show_or_log_message from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn show_or_log_message(self: *Self, operation: enum { show, log }, params_cb: []const u8) !void {\n    if (!tp.env.get().is(\"lsp_verbose\")) return;\n    var type_: i32 = 0;\n    var message: ?[]const u8 = null;\n    var iter = params_cb;\n    var len = try cbor.decodeMapHeader(&iter);\n    while (len > 0) : (len -= 1) {\n        var field_name: []const u8 = undefined;\n        if (!(try cbor.matchString(&iter, &field_name))) return error.InvalidMessage;\n        if (std.mem.eql(u8, field_name, \"type\")) {\n            if (!(try cbor.matchValue(&iter, cbor.extract(&type_)))) return error.InvalidMessageField;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "show_or_log_message",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to show_notification from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn show_notification(self: *Self, method: []const u8, params_cb: []const u8) !void {\n    if (!tp.env.get().is(\"lsp_verbose\")) return;\n    const params = try cbor.toJsonAlloc(self.allocator, params_cb);\n    defer self.allocator.free(params);\n    self.logger_lsp.print(\"LSP notification: {s}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "show_notification",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to register_capability from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn register_capability(self: *Self, from: tp.pid_ref, cbor_id: []const u8, params_cb: []const u8) ClientError!void {\n    _ = params_cb;\n    return LSP.send_response(self.allocator, from, cbor_id, null) catch error.ClientFailed;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "register_capability",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to workDoneProgress_create from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn workDoneProgress_create(self: *Self, from: tp.pid_ref, cbor_id: []const u8, params_cb: []const u8) ClientError!void {\n    _ = params_cb;\n    return LSP.send_response(self.allocator, from, cbor_id, null) catch error.ClientFailed;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "workDoneProgress_create",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to unsupported_lsp_request from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn unsupported_lsp_request(self: *Self, from: tp.pid_ref, cbor_id: []const u8, method: []const u8) ClientError!void {\n    return LSP.send_error_response(self.allocator, from, cbor_id, LSP.ErrorCode.MethodNotFound, method) catch error.ClientFailed;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "unsupported_lsp_request",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to send_lsp_init_request from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn send_lsp_init_request(self: *Self, lsp: *const LSP, project_path: []const u8, project_basename: []const u8, project_uri: []const u8, language_server: []const u8) !void {\n    const handler: struct {\n        language_server: []const u8,\n        lsp: LSP,\n        project: *Self,\n\n        pub fn deinit(self_: *@This()) void {\n            self_.lsp.pid.deinit();\n            std.heap.c_allocator.free(self_.language_server);\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "send_lsp_init_request",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn receive(self_: @This(), _: tp.message) !void {\n            self_.lsp.send_notification(\"initialized\", .{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "receive",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmt_lsp_name_func from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn fmt_lsp_name_func(bytes: []const u8) std.fmt.Formatter([]const u8, format_lsp_name_func) {\n    return .{ .data = bytes }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "fmt_lsp_name_func",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to format_lsp_name_func from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn format_lsp_name_func(\n    bytes: []const u8,\n    writer: *std.Io.Writer,\n) std.Io.Writer.Error!void {\n    var iter: []const u8 = bytes;\n    var len = cbor.decodeArrayHeader(&iter) catch return;\n    var first: bool = true;\n    while (len > 0) : (len -= 1) {\n        var value: []const u8 = undefined;\n        if (!(cbor.matchValue(&iter, cbor.extract(&value)) catch return))\n            return;\n        if (first) first = false else try writer.writeAll(\" \");\n        try writer.writeAll(value);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "format_lsp_name_func",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_line_of_file from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn get_line_of_file(allocator: std.mem.Allocator, file_path: []const u8, line_: usize) GetLineOfFileError![]const u8 {\n    const line = line_ + 1;\n    const file = try std.fs.cwd().openFile(file_path, .{ .mode = .read_only }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "get_line_of_file",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_line from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn get_line(allocator: std.mem.Allocator, buf: []const u8) ![]const u8 {\n    for (0..buf.len) |i| {\n        if (buf[i] == eol) return allocator.dupe(u8, buf[0..i]);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "get_line",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to query_git from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn query_git(self: *Self) void {\n    self.state.workspace_path = .running;\n    git.workspace_path(@intFromPtr(self)) catch {\n        self.state.workspace_path = .failed;\n        self.start_walker();\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "query_git",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to start_walker from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "fn start_walker(self: *Self) void {\n    self.state.walk_tree = .running;\n    self.walker = walk_tree.start(self.allocator, self.name, walk_tree_entry_callback, walk_tree_done_callback) catch blk: {\n        self.state.walk_tree = .failed;\n        break :blk null;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "start_walker",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to process_git from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub fn process_git(self: *Self, parent: tp.pid_ref, m: tp.message) (OutOfMemoryError || error{Exit}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "function",
      "name": "process_git",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to File from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const File = struct {\n    path: []const u8,\n    type: []const u8,\n    icon: []const u8,\n    color: u24,\n    mtime: i128,\n    pos: FilePos = .{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "struct",
      "name": "File",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FilePos from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "pub const FilePos = struct {\n    row: usize = 0,\n    col: usize = 0,\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "struct",
      "name": "FilePos",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Task from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const Task = struct {\n    command: []const u8,\n    mtime: i64,\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "struct",
      "name": "Task",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Match from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const Match = struct {\n        path: []const u8,\n        type: []const u8,\n        icon: []const u8,\n        color: u24,\n        score: i32,\n        matches: []const usize,\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "struct",
      "name": "Match",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to less_fn from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const less_fn = struct {\n        fn less_fn(_: void, lhs: Match, rhs: Match) bool {\n            return lhs.score > rhs.score;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "struct",
      "name": "less_fn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to TextEdit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const TextEdit = struct {\n    newText: []const u8 = &.{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "struct",
      "name": "TextEdit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Rename from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const Rename = struct {\n    uri: []const u8,\n    new_text: []const u8,\n    range: Range,\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "struct",
      "name": "Rename",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Range from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const Range = struct { start: Position, end: Position }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "struct",
      "name": "Range",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Position from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const Position = struct { line: usize, character: usize }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "struct",
      "name": "Position",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to file_type from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const file_type: []const u8, const file_icon: []const u8, const file_color: u24 = guess_file_type(file_path);",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "const",
      "name": "file_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to content from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const content: []const u8 = blk: {\n        const file = std.fs.cwd().openFile(file_path, .{ .mode = .read_only }) catch break :blk &.{};",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "const",
      "name": "content",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to file_type from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const file_type: []const u8, const file_icon: []const u8, const file_color: u24 = guess_file_type(file_path);",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "const",
      "name": "file_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to line_start_dst from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const line_start_dst: usize = lines_dst;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "const",
      "name": "line_start_dst",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to handler from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const handler: struct {\n        from: tp.pid,\n        name: []const u8,\n        project: *Self,\n\n        pub fn deinit(self_: *@This()) void {\n            std.heap.c_allocator.free(self_.name);\n            self_.from.deinit();\n        }\n\n        pub fn receive(self_: @This(), response: tp.message) !void {\n            var link: []const u8 = undefined;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "const",
      "name": "handler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to handler from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const handler: struct {\n        from: tp.pid,\n        name: []const u8,\n        project: *Self,\n\n        pub fn deinit(self_: *@This()) void {\n            std.heap.c_allocator.free(self_.name);\n            self_.from.deinit();\n        }\n\n        pub fn receive(self_: @This(), response: tp.message) !void {\n            var locations: []const u8 = undefined;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "const",
      "name": "handler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to handler from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const handler: struct {\n        from: tp.pid,\n        file_path: []const u8,\n        row: usize,\n        col: usize,\n\n        pub fn deinit(self_: *@This()) void {\n            std.heap.c_allocator.free(self_.file_path);\n            self_.from.deinit();\n        }\n\n        pub fn receive(self_: @This(), response: tp.message) !void {\n            var result: []const u8 = undefined;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "const",
      "name": "handler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to handler from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const handler: struct {\n        from: tp.pid,\n        file_path: []const u8,\n\n        pub fn deinit(self_: *@This()) void {\n            std.heap.c_allocator.free(self_.file_path);\n            self_.from.deinit();\n        }\n\n        pub fn receive(self_: @This(), response: tp.message) !void {\n            const allocator = std.heap.c_allocator;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "const",
      "name": "handler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to handler from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const handler: struct {\n        from: tp.pid,\n        file_path: []const u8,\n        row: usize,\n        col: usize,\n\n        pub fn deinit(self_: *@This()) void {\n            self_.from.deinit();\n            std.heap.c_allocator.free(self_.file_path);\n        }\n\n        pub fn receive(self_: @This(), response: tp.message) !void {\n            var result: []const u8 = undefined;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "const",
      "name": "handler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to mtime from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const mtime: i128 = blk: {\n            break :blk (std.fs.cwd().statFile(path) catch break :blk 0).mtime;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "const",
      "name": "mtime",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to file_type from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/Project.zig",
    "response": "const file_type: []const u8, const file_icon: []const u8, const file_color: u24 = guess_file_type(path);",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/Project.zig",
      "type": "const",
      "name": "file_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to find_binary_in_path_posix from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/bin_path.zig",
    "response": "fn find_binary_in_path_posix(allocator: std.mem.Allocator, binary_name: []const u8) std.mem.Allocator.Error!?[:0]const u8 {\n    const bin_paths = std.process.getEnvVarOwned(allocator, \"PATH\") catch |err| switch (err) {\n        error.OutOfMemory => return error.OutOfMemory,\n        error.EnvironmentVariableNotFound, error.InvalidWtf8 => &.{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/bin_path.zig",
      "type": "function",
      "name": "find_binary_in_path_posix",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to find_binary_in_path_windows from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/bin_path.zig",
    "response": "fn find_binary_in_path_windows(allocator: std.mem.Allocator, binary_name_: []const u8) std.mem.Allocator.Error!?[:0]const u8 {\n    const bin_paths = std.process.getEnvVarOwned(allocator, \"PATH\") catch |err| switch (err) {\n        error.OutOfMemory => return error.OutOfMemory,\n        error.EnvironmentVariableNotFound, error.InvalidWtf8 => &.{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/bin_path.zig",
      "type": "function",
      "name": "find_binary_in_path_windows",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to add from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn add(self: *Weights, other: Weights) void {\n        self.bols += other.bols;\n        self.eols += other.eols;\n        self.len += other.len;\n        self.depth = @max(self.depth, other.depth);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "add",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_balanced from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn is_balanced(self: *const Branch) bool {\n        const left: isize = @intCast(self.left.weights_sum().depth);\n        const right: isize = @intCast(self.right.weights_sum().depth);\n        return @abs(left - right) < max_imbalance;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "is_balanced",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to merge_results_const from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn merge_results_const(_: *const Branch, left: Walker, right: Walker) Walker {\n        var result = Walker{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "merge_results_const",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to merge_results from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn merge_results(self: *const Branch, allocator: Allocator, left: WalkerMut, right: WalkerMut) WalkerMut {\n        var result = WalkerMut{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "merge_results",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to new from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn new(allocator: Allocator, piece: []const u8, bol: bool, eol: bool) error{OutOfMemory}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "new",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to weights from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn weights(self: *const Leaf) Weights {\n        var len = self.buf.len;\n        if (self.eol)\n            len += 1;\n        return .{ .bols = if (self.bol) 1 else 0, .eols = if (self.eol) 1 else 0, .len = @intCast(len) }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "weights",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_empty from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn is_empty(self: *const Leaf) bool {\n        return self.buf.len == 0 and !self.bol and !self.eol;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "is_empty",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to pos_to_width from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn pos_to_width(self: *const Leaf, pos: *usize, abs_col_: usize, metrics: Metrics) usize {\n        var col: usize = 0;\n        var abs_col = abs_col_;\n        var cols: c_int = 0;\n        var buf = self.buf;\n        while (buf.len > 0 and pos.* > 0) {\n            if (buf[0] == '\\t') {\n                cols = @intCast(metrics.tab_width - (abs_col % metrics.tab_width));\n                buf = buf[1..];\n                pos.* -= 1;\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "pos_to_width",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to width from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn width(self: *const Leaf, abs_col: usize, metrics: Metrics) usize {\n        var pos: usize = std.math.maxInt(usize);\n        return self.pos_to_width(&pos, abs_col, metrics);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "width",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to width_to_pos from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn width_to_pos(self: *const Leaf, col_: usize, abs_col_: usize, metrics: Metrics) !usize {\n        var abs_col = abs_col_;\n        var col = col_;\n        var cols: c_int = 0;\n        var buf = self.buf;\n        return while (buf.len > 0) {\n            if (col == 0)\n                break @intFromPtr(buf.ptr) - @intFromPtr(self.buf.ptr);\n            const bytes = metrics.egc_length(metrics, buf, &cols, abs_col);\n            buf = buf[bytes..];\n            if (col < cols)\n                break @intFromPtr(buf.ptr) - @intFromPtr(self.buf.ptr);\n            col -= @intCast(cols);\n            abs_col += @intCast(cols);\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "width_to_pos",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to dump from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn dump(self: *const Leaf, l: *std.Io.Writer, abs_col: usize, metrics: Metrics) !void {\n        var buf: [16]u8 = undefined;\n        const wcwidth = try std.fmt.bufPrint(&buf, \"{d}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "dump",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to debug_render_chunk from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn debug_render_chunk(chunk: []const u8, l: *std.Io.Writer, metrics: Metrics) !void {\n        var cols: c_int = 0;\n        var buf = chunk;\n        while (buf.len > 0) {\n            switch (buf[0]) {\n                '\\x00'...(' ' - 1) => {\n                    const control = unicode.control_code_to_unicode(buf[0]);\n                    try l.writeAll(control);\n                    buf = buf[1..];\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "debug_render_chunk",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to new from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn new(allocator: Allocator, l: *const Node, r: *const Node) !*const Node {\n        const node = try allocator.create(Node);\n        errdefer allocator.destroy(node);\n        const l_weights_sum = l.weights_sum();\n        var weights_sum_ = Weights{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "new",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to weights_sum from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn weights_sum(self: *const Node) Weights {\n        return switch (self.*) {\n            .node => |*n| n.weights_sum,\n            .leaf => |*l| l.weights(),\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "weights_sum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to depth from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn depth(self: *const Node) usize {\n        return self.weights_sum().depth;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "depth",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lines from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn lines(self: *const Node) usize {\n        return self.weights_sum().bols;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "lines",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to length from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn length(self: *const Node) usize {\n        return self.weights_sum().len;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "length",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_balanced from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn is_balanced(self: *const Node) bool {\n        return switch (self.*) {\n            .node => |*n| n.is_balanced(),\n            .leaf => |_| true,\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "is_balanced",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rebalance from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn rebalance(self: *const Node, allocator: Allocator, tmp_allocator: Allocator) !Root {\n        return if (self.is_balanced()) self else bal: {\n            const leaves = try self.collect_leaves(tmp_allocator);\n            defer tmp_allocator.free(leaves);\n            break :bal self.merge(leaves, allocator);\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "rebalance",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to merge from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn merge(self: *const Node, leaves: []*const Node, allocator: Allocator) !Root {\n        const len = leaves.len;\n        if (len == 1) {\n            return leaves[0];\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "merge",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_empty from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn is_empty(self: *const Node) bool {\n        return switch (self.*) {\n            .node => |*n| n.left.is_empty() and n.right.is_empty(),\n            .leaf => |*l| if (self == &empty_leaf) true else l.is_empty(),\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "is_empty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to collect from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn collect(self: *const Node, allocator: Allocator, l: *ArrayList(*const Node)) !void {\n        switch (self.*) {\n            .node => |*node| {\n                try node.left.collect(allocator, l);\n                try node.right.collect(allocator, l);\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "collect",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to collect_leaves from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn collect_leaves(self: *const Node, allocator: Allocator) ![]*const Node {\n        var leaves: ArrayList(*const Node) = .empty;\n        try leaves.ensureTotalCapacity(allocator, self.lines());\n        try self.collect(allocator, &leaves);\n        return leaves.toOwnedSlice(allocator);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "collect_leaves",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to walk_const from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn walk_const(self: *const Node, f: Walker.F, ctx: *anyopaque, metrics: Metrics) Walker {\n        switch (self.*) {\n            .node => |*node| {\n                const left = node.left.walk_const(f, ctx, metrics);\n                if (!left.keep_walking_) {\n                    var result = Walker{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "walk_const",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to walk from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn walk(self: *const Node, allocator: Allocator, f: WalkerMut.F, ctx: *anyopaque, metrics: Metrics) WalkerMut {\n        switch (self.*) {\n            .node => |*node| {\n                const left = node.left.walk(allocator, f, ctx, metrics);\n                if (!left.keep_walking_) {\n                    var result = WalkerMut{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "walk",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to walk_from_line_begin_const_internal from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn walk_from_line_begin_const_internal(self: *const Node, line: usize, f: Walker.F, ctx: *anyopaque, metrics: Metrics) Walker {\n        switch (self.*) {\n            .node => |*node| {\n                const left_bols = node.weights.bols;\n                if (line >= left_bols)\n                    return node.right.walk_from_line_begin_const_internal(line - left_bols, f, ctx, metrics);\n                const left_result = node.left.walk_from_line_begin_const_internal(line, f, ctx, metrics);\n                const right_result = if (left_result.found_ and left_result.keep_walking_) node.right.walk_const(f, ctx, metrics) else Walker{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "walk_from_line_begin_const_internal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walk_from_line_begin_const from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn walk_from_line_begin_const(self: *const Node, line: usize, f: Walker.F, ctx: *anyopaque, metrics: Metrics) anyerror!bool {\n        const result = self.walk_from_line_begin_const_internal(line, f, ctx, metrics);\n        if (result.err) |e| return e;\n        return result.found_;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "walk_from_line_begin_const",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to walk_from_line_begin_internal from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn walk_from_line_begin_internal(self: *const Node, allocator: Allocator, line: usize, f: WalkerMut.F, ctx: *anyopaque, metrics: Metrics) WalkerMut {\n        switch (self.*) {\n            .node => |*node| {\n                const left_bols = node.weights.bols;\n                if (line >= left_bols) {\n                    const right_result = node.right.walk_from_line_begin_internal(allocator, line - left_bols, f, ctx, metrics);\n                    if (right_result.replace) |p| {\n                        var result = WalkerMut{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "walk_from_line_begin_internal",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to walk_from_line_begin from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn walk_from_line_begin(self: *const Node, allocator: Allocator, line: usize, f: WalkerMut.F, ctx: *anyopaque, metrics: Metrics) !struct { bool, ?Root }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "walk_from_line_begin",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to find_line_node from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn find_line_node(self: *const Node, line: usize) ?*const Node {\n        switch (self.*) {\n            .node => |*node| {\n                if (node.weights_sum.bols == 1)\n                    return self;\n                const left_bols = node.weights.bols;\n                if (line >= left_bols)\n                    return node.right.find_line_node(line - left_bols);\n                return node.left.find_line_node(line);\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "find_line_node",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to debug_render_tree from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn debug_render_tree(self: *const Node, l: *std.Io.Writer, d: usize) void {\n        switch (self.*) {\n            .node => |*node| {\n                l.writeAll(\"(\") catch {}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "debug_render_tree",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to walk_egc_forward from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn walk_egc_forward(self: *const Node, line: usize, walker_f: EgcF, walker_ctx: *anyopaque, metrics_: Metrics) anyerror!void {\n        const Ctx = struct {\n            walker_f: EgcF,\n            walker_ctx: @TypeOf(walker_ctx),\n            abs_col: usize = 0,\n            fn walker(ctx_: *anyopaque, leaf: *const Self.Leaf, metrics: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                var buf: []const u8 = leaf.buf;\n                while (buf.len > 0) {\n                    var cols: c_int = undefined;\n                    const bytes = metrics.egc_length(metrics, buf, &cols, ctx.abs_col);\n                    const ret = ctx.walker_f(ctx.walker_ctx, buf[0..bytes], @intCast(cols), metrics);\n                    if (ret.err) |e| return .{ .err = e }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "walk_egc_forward",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to egc_at from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn egc_at(self: *const Node, line: usize, col: usize, metrics: Metrics) error{NotFound}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "egc_at",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walker from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn walker(ctx_: *anyopaque, egc: []const u8, wcwidth: usize, _: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                ctx.at = egc;\n                ctx.wcwidth = wcwidth;\n                if (wcwidth > 0 and (ctx.col == 0 or egc[0] == '\\n' or ctx.col < wcwidth))\n                    return Walker.stop;\n                ctx.col -= wcwidth;\n                return Walker.keep_walking;\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "walker",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to test_at from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn test_at(self: *const Node, pred: *const fn (c: []const u8) bool, line: usize, col: usize, metrics: Metrics) bool {\n        const egc, _, _ = self.egc_at(line, col, metrics) catch return false;\n        return pred(egc);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "test_at",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_line_width_map from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn get_line_width_map(self: *const Node, line: usize, map: *ArrayList(usize), allocator: Allocator, metrics: Metrics) error{ Stop, NoSpaceLeft }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "get_line_width_map",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to walker from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn walker(ctx_: *anyopaque, egc: []const u8, wcwidth: usize, _: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                var n = egc.len;\n                while (n > 0) : (n -= 1) {\n                    const p = ctx.map.addOne(ctx.allocator) catch |e| return .{ .err = e }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "walker",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_line_width_to_pos from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn get_line_width_to_pos(self: *const Node, line: usize, col: usize, metrics: Metrics) error{Stop}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "get_line_width_to_pos",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walker from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn walker(ctx_: *anyopaque, egc: []const u8, wcwidth: usize, _: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                if (ctx.wcwidth >= ctx.col) return Walker.stop;\n                ctx.pos += egc.len;\n                ctx.wcwidth += wcwidth;\n                return if (egc[0] == '\\n') Walker.stop else Walker.keep_walking;\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "walker",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_range from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn get_range(self: *const Node, sel: Selection, copy_buf: ?[]u8, size: ?*usize, wcwidth_: ?*usize, metrics_: Metrics) error{ Stop, NoSpaceLeft }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "get_range",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walker from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn walker(ctx_: *anyopaque, egc: []const u8, wcwidth: usize, _: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                if (ctx.col < ctx.sel.begin.col) {\n                    ctx.col += wcwidth;\n                    return Walker.keep_walking;\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "walker",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_from_pos from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn get_from_pos(self: *const Node, start: Cursor, result_buf: []u8, metrics: Metrics) []const u8 {\n        var end: Cursor = .{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "get_from_pos",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to delete_range from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn delete_range(self: *const Node, sel: Selection, allocator: Allocator, size_: ?*usize, metrics: Metrics) error{Stop}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "delete_range",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to delete_bytes from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn delete_bytes(self: *const Node, line: usize, pos_: usize, bytes: usize, allocator: Allocator, metrics_: Metrics) !Root {\n        const Ctx = struct {\n            allocator: Allocator,\n            pos: usize,\n            bytes: usize,\n            delete_next_bol: bool = false,\n            fn walker(Ctx: *anyopaque, leaf: *const Leaf, _: Metrics) WalkerMut {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(Ctx)));\n                var result = WalkerMut.keep_walking;\n                if (ctx.delete_next_bol and ctx.bytes == 0) {\n                    result.replace = Leaf.new(ctx.allocator, leaf.buf, false, leaf.eol) catch |e| return .{ .err = e }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "delete_bytes",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to merge_in_place from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn merge_in_place(leaves: []const Node, allocator: Allocator) !Root {\n        const len = leaves.len;\n        if (len == 1) {\n            return &leaves[0];\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "merge_in_place",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_line from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn get_line(self: *const Node, line: usize, result: *std.Io.Writer, metrics: Metrics) !void {\n        const Ctx = struct {\n            line: *std.Io.Writer,\n            fn walker(ctx_: *anyopaque, leaf: *const Leaf, _: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                ctx.line.writeAll(leaf.buf) catch |e| return .{ .err = e }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "get_line",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to line_width from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn line_width(self: *const Node, line: usize, metrics_: Metrics) !usize {\n        const do = struct {\n            result: usize = 0,\n            fn walker(ctx: *anyopaque, leaf: *const Leaf, metrics: Metrics) Walker {\n                const do = @as(*@This(), @ptrCast(@alignCast(ctx)));\n                do.result += leaf.width(do.result, metrics);\n                return if (!leaf.eol) Walker.keep_walking else Walker.stop;\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "line_width",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to pos_to_width from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn pos_to_width(self: *const Node, line: usize, pos: usize, metrics_: Metrics) error{NotFound}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "pos_to_width",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walker from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn walker(ctx: *anyopaque, leaf: *const Leaf, metrics: Metrics) Walker {\n                const do = @as(*@This(), @ptrCast(@alignCast(ctx)));\n                do.result += leaf.pos_to_width(&do.pos, do.result, metrics);\n                return if (!(leaf.eol or do.pos == 0)) Walker.keep_walking else Walker.stop;\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "walker",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to byte_offset_to_line_and_col from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn byte_offset_to_line_and_col(self: *const Node, pos: usize, metrics: Metrics, eol_mode: EolMode) Cursor {\n        const ctx_ = struct {\n            pos: usize,\n            line: usize = 0,\n            col: usize = 0,\n            eol_mode: EolMode,\n            fn walker(ctx_: *anyopaque, egc: []const u8, wcwidth: usize, _: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                if (egc[0] == '\\n') {\n                    ctx.pos -= switch (ctx.eol_mode) {\n                        .lf => 1,\n                        .crlf => @min(2, ctx.pos),\n                    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "byte_offset_to_line_and_col",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to insert_chars from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn insert_chars(\n        self_: *const Node,\n        line_: usize,\n        col_: usize,\n        chars: []const u8,\n        allocator: Allocator,\n        metrics_: Metrics,\n    ) !struct { usize, usize, Root }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "insert_chars",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to walker from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn walker(ctx: *anyopaque, leaf: *const Leaf, metrics: Metrics) WalkerMut {\n                const Ctx = @as(*@This(), @ptrCast(@alignCast(ctx)));\n                const leaf_wcwidth = leaf.width(Ctx.abs_col, metrics);\n                const base_col = Ctx.abs_col;\n                Ctx.abs_col += leaf_wcwidth;\n\n                if (Ctx.col == 0) {\n                    const left = Leaf.new(Ctx.allocator, Ctx.s, leaf.bol, Ctx.eol) catch |e| return .{ .err = e }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "walker",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to store from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn store(self: *const Node, writer: *std.Io.Writer, eol_mode: EolMode) !void {\n        switch (self.*) {\n            .node => |*node| {\n                try node.left.store(writer, eol_mode);\n                try node.right.store(writer, eol_mode);\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "store",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to find_all_ranges from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn find_all_ranges(self: *const Node, pattern: []const u8, data: *anyopaque, callback: *const FindAllCallback, allocator: Allocator) error{ OutOfMemory, Stop }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "find_all_ranges",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to drain from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn drain(w: *std.Io.Writer, data_: []const []const u8, splat: usize) std.Io.Writer.Error!usize {\n                const ctx: *Ctx = @alignCast(@fieldParentPtr(\"writer\", w));\n                if (data_.len == 0) return 0;\n                var written: usize = 0;\n                for (data_[0 .. data_.len - 1]) |bytes| {\n                    written += try ctx.write(bytes);\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "drain",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn write(ctx: *Ctx, bytes: []const u8) std.Io.Writer.Error!usize {\n                var input = bytes;\n                while (true) {\n                    const input_consume_size = @min(ctx.buf.len - ctx.rest.len, input.len);\n                    @memcpy(ctx.buf[ctx.rest.len .. ctx.rest.len + input_consume_size], input[0..input_consume_size]);\n                    ctx.rest = ctx.buf[0 .. ctx.rest.len + input_consume_size];\n                    input = input[input_consume_size..];\n\n                    if (ctx.rest.len < ctx.pattern.len)\n                        return bytes.len - input.len;\n\n                    var i: usize = 0;\n                    const end = ctx.rest.len - ctx.pattern.len;\n\n                    while (i <= end) {\n                        if (std.mem.eql(u8, ctx.rest[i .. i + ctx.pattern.len], ctx.pattern)) {\n                            const begin_row = ctx.line + 1;\n                            const begin_pos = ctx.pos;\n                            ctx.skip(&i, ctx.pattern.len);\n                            const end_row = ctx.line + 1;\n                            const end_pos = ctx.pos;\n                            ctx.callback(ctx.data, begin_row, begin_pos, end_row, end_pos) catch return error.WriteFailed;\n                        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "write",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to skip from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn skip(ctx: *Ctx, i: *usize, n_: usize) void {\n                var n = n_;\n                while (n > 0) : (n -= 1) {\n                    if (ctx.rest[i.*] == '\\n') {\n                        ctx.line += 1;\n                        ctx.pos = 0;\n                    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "skip",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_byte_pos from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn get_byte_pos(self: *const Node, pos_: Cursor, metrics: Metrics, eol_mode: EolMode) !usize {\n        const ctx_ = struct {\n            pos: usize = 0,\n            line: usize = 0,\n            col: usize = 0,\n            target_line: usize,\n            target_col: usize,\n            eol_mode: EolMode,\n            fn walker(ctx_: *anyopaque, egc: []const u8, wcwidth: usize, _: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                if (ctx.line == ctx.target_line and ctx.col == ctx.target_col) return Walker.stop;\n                if (egc[0] == '\\n') {\n                    ctx.pos += switch (ctx.eol_mode) {\n                        .lf => 1,\n                        .crlf => 2,\n                    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "get_byte_pos",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to debug_render_chunks from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn debug_render_chunks(self: *const Node, allocator: std.mem.Allocator, line: usize, metrics_: Metrics) ![]const u8 {\n        var output: std.Io.Writer.Allocating = .init(allocator);\n        defer output.deinit();\n        const ctx_ = struct {\n            l: *std.Io.Writer,\n            wcwidth: usize = 0,\n            fn walker(ctx_: *anyopaque, leaf: *const Leaf, metrics: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                leaf.dump(ctx.l, ctx.wcwidth, metrics) catch |e| return .{ .err = e }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "debug_render_chunks",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to debug_line_render_tree from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn debug_line_render_tree(self: *const Node, allocator: std.mem.Allocator, line: usize) ![]const u8 {\n        return if (self.find_line_node(line)) |n| blk: {\n            var l: std.Io.Writer.Allocating = .init(allocator);\n            defer l.deinit();\n            n.debug_render_tree(&l.writer, 0);\n            break :blk l.toOwnedSlice();\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "debug_line_render_tree",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_range from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn write_range(\n        self: *const Node,\n        sel: Selection,\n        writer: *std.Io.Writer,\n        wcwidth_: ?*usize,\n        metrics: Metrics,\n    ) std.Io.Writer.Error!void {\n        const Ctx = struct {\n            col: usize = 0,\n            sel: Selection,\n            writer: *std.Io.Writer,\n            wcwidth: usize = 0,\n            fn walker(ctx_: *anyopaque, egc: []const u8, wcwidth: usize, _: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                if (ctx.col < ctx.sel.begin.col) {\n                    ctx.col += wcwidth;\n                    return Walker.keep_walking;\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "write_range",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to create from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn create(allocator: Allocator) error{OutOfMemory}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "create",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn deinit(self: *Self) void {\n    if (self.meta) |buf| self.external_allocator.free(buf);\n    if (self.file_buf) |buf| self.external_allocator.free(buf);\n    if (self.leaves_buf) |buf| self.external_allocator.free(buf);\n    self.file_path_buf.deinit(self.external_allocator);\n    self.arena.deinit();\n    self.external_allocator.destroy(self);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to set_meta from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn set_meta(self: *Self, meta_: []const u8) error{OutOfMemory}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "set_meta",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_meta from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn get_meta(self: *Self) ?[]const u8 {\n    return self.meta;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "get_meta",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to set_file_path from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn set_file_path(self: *Self, file_path: []const u8) void {\n    if (file_path.ptr == self.file_path_buf.items.ptr) return;\n    self.file_path_buf.clearRetainingCapacity();\n    self.file_path_buf.appendSlice(self.external_allocator, file_path) catch |e| switch (e) {\n        error.OutOfMemory => @panic(\"OOM in Buffer.set_file_path\"),\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "set_file_path",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_file_path from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn get_file_path(self: *const Self) []const u8 {\n    return self.file_path_buf.items;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "get_file_path",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to update_last_used_time from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn update_last_used_time(self: *Self) void {\n    self.utime = std.time.milliTimestamp();\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "update_last_used_time",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to new_file from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn new_file(self: *const Self, file_exists: *bool) error{OutOfMemory}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "new_file",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to load from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn load(self: *const Self, reader: *std.Io.Reader, eol_mode: *EolMode, utf8_sanitized: *bool) LoadError!Root {\n    const lf = '\\n';\n    const cr = '\\r';\n    const self_ = @constCast(self);\n    var read_buffer: ArrayList(u8) = .empty;\n    defer read_buffer.deinit(self.external_allocator);\n    try reader.appendRemainingUnlimited(self.external_allocator, &read_buffer);\n    var buf = try read_buffer.toOwnedSlice(self.external_allocator);\n\n    if (!std.unicode.utf8ValidateSlice(buf)) {\n        const converted = try unicode.utf8_sanitize(self.external_allocator, buf);\n        self.external_allocator.free(buf);\n        buf = converted;\n        utf8_sanitized.* = true;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "load",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to load_from_string from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn load_from_string(self: *const Self, s: []const u8, eol_mode: *EolMode, utf8_sanitized: *bool) LoadError!Root {\n    var reader = std.Io.Reader.fixed(s);\n    return self.load(&reader, eol_mode, utf8_sanitized);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "load_from_string",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to load_from_string_and_update from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn load_from_string_and_update(self: *Self, file_path: []const u8, s: []const u8) LoadError!void {\n    self.root = try self.load_from_string(s, &self.file_eol_mode, &self.file_utf8_sanitized);\n    self.set_file_path(file_path);\n    self.last_save = self.root;\n    self.last_save_eol_mode = self.file_eol_mode;\n    self.file_exists = false;\n    self.mtime = std.time.milliTimestamp();\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "load_from_string_and_update",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reset_from_string_and_update from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn reset_from_string_and_update(self: *Self, s: []const u8) LoadError!void {\n    self.root = try self.load_from_string(s, &self.file_eol_mode, &self.file_utf8_sanitized);\n    self.last_save = self.root;\n    self.last_save_eol_mode = self.file_eol_mode;\n    self.mtime = std.time.milliTimestamp();\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "reset_from_string_and_update",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to load_from_file from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn load_from_file(\n    self: *const Self,\n    file_path: []const u8,\n    file_exists: *bool,\n    eol_mode: *EolMode,\n    utf8_sanitized: *bool,\n) LoadFromFileError!Root {\n    const file = cwd().openFile(file_path, .{ .mode = .read_only }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "load_from_file",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to load_from_file_and_update from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn load_from_file_and_update(self: *Self, file_path: []const u8) LoadFromFileError!void {\n    var file_exists: bool = false;\n    var eol_mode: EolMode = .lf;\n    var utf8_sanitized: bool = false;\n    self.root = try self.load_from_file(file_path, &file_exists, &eol_mode, &utf8_sanitized);\n    self.set_file_path(file_path);\n    self.last_save = self.root;\n    self.file_exists = file_exists;\n    self.file_eol_mode = eol_mode;\n    self.file_utf8_sanitized = utf8_sanitized;\n    self.last_save_eol_mode = eol_mode;\n    self.mtime = std.time.milliTimestamp();\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "load_from_file_and_update",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reset_to_last_saved from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn reset_to_last_saved(self: *Self) void {\n    if (self.last_save) |last_save| {\n        self.store_undo(&[_]u8{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "reset_to_last_saved",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to refresh_from_file from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn refresh_from_file(self: *Self) LoadFromFileError!void {\n    try self.load_from_file_and_update(self.get_file_path());\n    self.update_last_used_time();\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "refresh_from_file",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to store_to_string from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn store_to_string(self: *const Self, allocator: Allocator, eol_mode: EolMode) ![]u8 {\n    var s: std.Io.Writer.Allocating = try .initCapacity(allocator, self.root.weights_sum().len);\n    try self.root.store(&s.writer, eol_mode);\n    return s.toOwnedSlice();\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "store_to_string",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to store_to_file_const from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn store_to_file_const(self: *const Self, writer: *std.Io.Writer) StoreToFileError!void {\n    try self.root.store(writer, self.file_eol_mode);\n    try writer.flush();\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "store_to_file_const",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to store_to_existing_file_const from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn store_to_existing_file_const(self: *const Self, file_path: []const u8) StoreToFileError!void {\n    var atomic = blk: {\n        var write_buffer: [4096]u8 = undefined;\n        const stat = cwd().statFile(file_path) catch\n            break :blk try cwd().atomicFile(file_path, .{ .write_buffer = &write_buffer }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "store_to_existing_file_const",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to store_to_new_file_const from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn store_to_new_file_const(self: *const Self, file_path: []const u8) StoreToFileError!void {\n    if (std.fs.path.dirname(file_path)) |dir_name|\n        try cwd().makePath(dir_name);\n    const file = try cwd().createFile(file_path, .{ .read = true, .truncate = true }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "store_to_new_file_const",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to store_to_file_and_clean from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn store_to_file_and_clean(self: *Self, file_path: []const u8) StoreToFileError!void {\n    self.store_to_existing_file_const(file_path) catch |e| switch (e) {\n        error.FileNotFound => try self.store_to_new_file_const(file_path),\n        else => return e,\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "store_to_file_and_clean",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to mark_clean from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn mark_clean(self: *Self) void {\n    self.last_save = self.root;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "mark_clean",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to mark_dirty from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn mark_dirty(self: *Self) void {\n    self.last_save = null;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "mark_dirty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_hidden from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn is_hidden(self: *const Self) bool {\n    return self.hidden;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "is_hidden",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_ephemeral from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn is_ephemeral(self: *const Self) bool {\n    return self.ephemeral;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "is_ephemeral",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to mark_not_ephemeral from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn mark_not_ephemeral(self: *Self) void {\n    self.ephemeral = false;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "mark_not_ephemeral",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_dirty from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn is_dirty(self: *const Self) bool {\n    return if (!self.file_exists)\n        self.root.length() > 0\n    else if (self.last_save) |p|\n        self.root != p or self.last_save_eol_mode != self.file_eol_mode\n    else\n        true;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "is_dirty",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to version from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn version(self: *const Self) usize {\n    return @intFromPtr(self.root);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "version",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to update from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn update(self: *Self, root: Root) void {\n    self.root = root;\n    self.mtime = std.time.milliTimestamp();\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "update",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to store_undo from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn store_undo(self: *Self, meta: []const u8) error{OutOfMemory}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "store_undo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to create_undo from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn create_undo(self: *const Self, root: Root, meta_: []const u8) error{OutOfMemory}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "create_undo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to push_undo from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn push_undo(self: *Self, h: *UndoNode) void {\n    const next = self.undo_history;\n    self.undo_history = h;\n    h.next = next;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "push_undo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to push_redo from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn push_redo(self: *Self, h: *UndoNode) void {\n    const next = self.redo_history;\n    self.redo_history = h;\n    h.next = next;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "push_redo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to push_redo_branch from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "fn push_redo_branch(self: *Self) !void {\n    const r = self.redo_history orelse return;\n    const u = self.undo_history orelse return;\n    const next = u.branches;\n    const b = try self.allocator.create(UndoBranch);\n    b.* = .{\n        .redo = r,\n        .next = next,\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "push_redo_branch",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to undo from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn undo(self: *Self, meta: []const u8) error{Stop}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "undo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_state from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn write_state(self: *const Self, writer: *std.Io.Writer) error{ Stop, OutOfMemory, WriteFailed }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "write_state",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to extract_state from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub fn extract_state(self: *Self, iter: *[]const u8) !void {\n    var file_path: []const u8 = undefined;\n    var file_type_name: []const u8 = undefined;\n    var dirty: bool = undefined;\n    var meta: ?[]const u8 = null;\n    var content: []const u8 = undefined;\n\n    if (!try cbor.matchValue(iter, .{\n        cbor.extract(&file_path),\n        cbor.extract(&self.file_exists),\n        cbor.extract(&self.file_eol_mode),\n        cbor.extract(&self.hidden),\n        cbor.extract(&self.ephemeral),\n        cbor.extract(&dirty),\n        cbor.extract(&meta),\n        cbor.extract(&file_type_name),\n        cbor.extract(&content),\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "function",
      "name": "extract_state",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Metrics from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub const Metrics = struct {\n    ctx: *const anyopaque,\n    egc_length: egc_length_func,\n    egc_chunk_width: egc_chunk_width_func,\n    egc_last: egc_last_func,\n    tab_width: usize,\n    pub const egc_length_func = *const fn (self: Metrics, egcs: []const u8, colcount: *c_int, abs_col: usize) usize;\n    pub const egc_chunk_width_func = *const fn (self: Metrics, chunk_: []const u8, abs_col_: usize) usize;\n    pub const egc_last_func = *const fn (self: Metrics, egcs: []const u8) []const u8;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "Metrics",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to UndoNode from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const UndoNode = struct {\n    root: Root,\n    next: ?*UndoNode = null,\n    branches: ?*UndoBranch = null,\n    meta: []const u8,\n    file_eol_mode: EolMode,\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "UndoNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to UndoBranch from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const UndoBranch = struct {\n    redo: *UndoNode,\n    next: ?*UndoBranch,\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "UndoBranch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to WalkerMut from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub const WalkerMut = struct {\n    keep_walking_: bool = false,\n    found_: bool = false,\n    replace: ?Root = null,\n    err: ?anyerror = null,\n\n    pub const keep_walking = WalkerMut{ .keep_walking_ = true }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "WalkerMut",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Walker from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub const Walker = struct {\n    keep_walking_: bool = false,\n    found_: bool = false,\n    err: ?anyerror = null,\n\n    pub const keep_walking = Walker{ .keep_walking_ = true }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "Walker",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Weights from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub const Weights = struct {\n    bols: u32 = 0,\n    eols: u32 = 0,\n    len: u32 = 0,\n    depth: u32 = 1,\n\n    fn add(self: *Weights, other: Weights) void {\n        self.bols += other.bols;\n        self.eols += other.eols;\n        self.len += other.len;\n        self.depth = @max(self.depth, other.depth);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "Weights",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Branch from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub const Branch = struct {\n    left: *const Node,\n    right: *const Node,\n    weights: Weights,\n    weights_sum: Weights,\n\n    const walker = *const fn (ctx: *anyopaque, branch: *const Branch) WalkerMut;\n\n    fn is_balanced(self: *const Branch) bool {\n        const left: isize = @intCast(self.left.weights_sum().depth);\n        const right: isize = @intCast(self.right.weights_sum().depth);\n        return @abs(left - right) < max_imbalance;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "Branch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Leaf from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "pub const Leaf = struct {\n    buf: []const u8,\n    bol: bool = true,\n    eol: bool = true,\n\n    fn new(allocator: Allocator, piece: []const u8, bol: bool, eol: bool) error{OutOfMemory}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "Leaf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Ctx from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const Ctx = struct {\n            walker_f: EgcF,\n            walker_ctx: @TypeOf(walker_ctx),\n            abs_col: usize = 0,\n            fn walker(ctx_: *anyopaque, leaf: *const Self.Leaf, metrics: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                var buf: []const u8 = leaf.buf;\n                while (buf.len > 0) {\n                    var cols: c_int = undefined;\n                    const bytes = metrics.egc_length(metrics, buf, &cols, ctx.abs_col);\n                    const ret = ctx.walker_f(ctx.walker_ctx, buf[0..bytes], @intCast(cols), metrics);\n                    if (ret.err) |e| return .{ .err = e }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "Ctx",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ctx_ from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const ctx_ = struct {\n            col: usize,\n            at: ?[]const u8 = null,\n            wcwidth: usize = 0,\n            fn walker(ctx_: *anyopaque, egc: []const u8, wcwidth: usize, _: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                ctx.at = egc;\n                ctx.wcwidth = wcwidth;\n                if (wcwidth > 0 and (ctx.col == 0 or egc[0] == '\\n' or ctx.col < wcwidth))\n                    return Walker.stop;\n                ctx.col -= wcwidth;\n                return Walker.keep_walking;\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "ctx_",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Ctx from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const Ctx = struct {\n            allocator: Allocator,\n            map: *ArrayList(usize),\n            wcwidth: usize = 0,\n            fn walker(ctx_: *anyopaque, egc: []const u8, wcwidth: usize, _: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                var n = egc.len;\n                while (n > 0) : (n -= 1) {\n                    const p = ctx.map.addOne(ctx.allocator) catch |e| return .{ .err = e }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "Ctx",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Ctx from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const Ctx = struct {\n            col: usize,\n            wcwidth: usize = 0,\n            pos: usize = 0,\n            fn walker(ctx_: *anyopaque, egc: []const u8, wcwidth: usize, _: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                if (ctx.wcwidth >= ctx.col) return Walker.stop;\n                ctx.pos += egc.len;\n                ctx.wcwidth += wcwidth;\n                return if (egc[0] == '\\n') Walker.stop else Walker.keep_walking;\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "Ctx",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Ctx from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const Ctx = struct {\n            col: usize = 0,\n            sel: Selection,\n            out: ?[]u8,\n            bytes: usize = 0,\n            wcwidth: usize = 0,\n            fn walker(ctx_: *anyopaque, egc: []const u8, wcwidth: usize, _: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                if (ctx.col < ctx.sel.begin.col) {\n                    ctx.col += wcwidth;\n                    return Walker.keep_walking;\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "Ctx",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Ctx from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const Ctx = struct {\n            allocator: Allocator,\n            pos: usize,\n            bytes: usize,\n            delete_next_bol: bool = false,\n            fn walker(Ctx: *anyopaque, leaf: *const Leaf, _: Metrics) WalkerMut {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(Ctx)));\n                var result = WalkerMut.keep_walking;\n                if (ctx.delete_next_bol and ctx.bytes == 0) {\n                    result.replace = Leaf.new(ctx.allocator, leaf.buf, false, leaf.eol) catch |e| return .{ .err = e }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "Ctx",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Ctx from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const Ctx = struct {\n            line: *std.Io.Writer,\n            fn walker(ctx_: *anyopaque, leaf: *const Leaf, _: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                ctx.line.writeAll(leaf.buf) catch |e| return .{ .err = e }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "Ctx",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to do from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const do = struct {\n            result: usize = 0,\n            fn walker(ctx: *anyopaque, leaf: *const Leaf, metrics: Metrics) Walker {\n                const do = @as(*@This(), @ptrCast(@alignCast(ctx)));\n                do.result += leaf.width(do.result, metrics);\n                return if (!leaf.eol) Walker.keep_walking else Walker.stop;\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "do",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to do from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const do = struct {\n            result: usize = 0,\n            pos: usize,\n            fn walker(ctx: *anyopaque, leaf: *const Leaf, metrics: Metrics) Walker {\n                const do = @as(*@This(), @ptrCast(@alignCast(ctx)));\n                do.result += leaf.pos_to_width(&do.pos, do.result, metrics);\n                return if (!(leaf.eol or do.pos == 0)) Walker.keep_walking else Walker.stop;\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "do",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ctx_ from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const ctx_ = struct {\n            pos: usize,\n            line: usize = 0,\n            col: usize = 0,\n            eol_mode: EolMode,\n            fn walker(ctx_: *anyopaque, egc: []const u8, wcwidth: usize, _: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                if (egc[0] == '\\n') {\n                    ctx.pos -= switch (ctx.eol_mode) {\n                        .lf => 1,\n                        .crlf => @min(2, ctx.pos),\n                    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "ctx_",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Ctx from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const Ctx = struct {\n            allocator: Allocator,\n            col: usize,\n            abs_col: usize = 0,\n            s: []const u8,\n            eol: bool,\n\n            fn walker(ctx: *anyopaque, leaf: *const Leaf, metrics: Metrics) WalkerMut {\n                const Ctx = @as(*@This(), @ptrCast(@alignCast(ctx)));\n                const leaf_wcwidth = leaf.width(Ctx.abs_col, metrics);\n                const base_col = Ctx.abs_col;\n                Ctx.abs_col += leaf_wcwidth;\n\n                if (Ctx.col == 0) {\n                    const left = Leaf.new(Ctx.allocator, Ctx.s, leaf.bol, Ctx.eol) catch |e| return .{ .err = e }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "Ctx",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Ctx from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const Ctx = struct {\n            pattern: []const u8,\n            data: *anyopaque,\n            callback: *const FindAllCallback,\n            line: usize = 0,\n            pos: usize = 0,\n            buf: []u8,\n            rest: []u8 = \"\",\n            writer: std.Io.Writer,\n\n            const Ctx = @This();\n            fn drain(w: *std.Io.Writer, data_: []const []const u8, splat: usize) std.Io.Writer.Error!usize {\n                const ctx: *Ctx = @alignCast(@fieldParentPtr(\"writer\", w));\n                if (data_.len == 0) return 0;\n                var written: usize = 0;\n                for (data_[0 .. data_.len - 1]) |bytes| {\n                    written += try ctx.write(bytes);\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "Ctx",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ctx_ from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const ctx_ = struct {\n            pos: usize = 0,\n            line: usize = 0,\n            col: usize = 0,\n            target_line: usize,\n            target_col: usize,\n            eol_mode: EolMode,\n            fn walker(ctx_: *anyopaque, egc: []const u8, wcwidth: usize, _: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                if (ctx.line == ctx.target_line and ctx.col == ctx.target_col) return Walker.stop;\n                if (egc[0] == '\\n') {\n                    ctx.pos += switch (ctx.eol_mode) {\n                        .lf => 1,\n                        .crlf => 2,\n                    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "ctx_",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ctx_ from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const ctx_ = struct {\n            l: *std.Io.Writer,\n            wcwidth: usize = 0,\n            fn walker(ctx_: *anyopaque, leaf: *const Leaf, metrics: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                leaf.dump(ctx.l, ctx.wcwidth, metrics) catch |e| return .{ .err = e }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "ctx_",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Ctx from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const Ctx = struct {\n            col: usize = 0,\n            sel: Selection,\n            writer: *std.Io.Writer,\n            wcwidth: usize = 0,\n            fn walker(ctx_: *anyopaque, egc: []const u8, wcwidth: usize, _: Metrics) Walker {\n                const ctx = @as(*@This(), @ptrCast(@alignCast(ctx_)));\n                if (ctx.col < ctx.sel.begin.col) {\n                    ctx.col += wcwidth;\n                    return Walker.keep_walking;\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "struct",
      "name": "Ctx",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to left from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const left: isize = @intCast(self.left.weights_sum().depth);",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "const",
      "name": "left",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to right from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const right: isize = @intCast(self.right.weights_sum().depth);",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "const",
      "name": "right",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to empty_leaf from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const empty_leaf: Node = .{ .leaf = .{ .buf = \"\", .bol = false, .eol = false } };",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "const",
      "name": "empty_leaf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to empty_bol_leaf from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const empty_bol_leaf: Node = .{ .leaf = .{ .buf = \"\", .bol = true, .eol = false } };",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "const",
      "name": "empty_bol_leaf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to empty_eol_leaf from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const empty_eol_leaf: Node = .{ .leaf = .{ .buf = \"\", .bol = false, .eol = true } };",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "const",
      "name": "empty_eol_leaf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to empty_line_leaf from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const empty_line_leaf: Node = .{ .leaf = .{ .buf = \"\", .bol = true, .eol = true } };",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "const",
      "name": "empty_line_leaf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ctx from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Buffer.zig",
    "response": "const ctx: *Ctx = @alignCast(@fieldParentPtr(\"writer\", w));",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Buffer.zig",
      "type": "const",
      "name": "ctx",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to invalid from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "fn invalid() Self {\n    return .{\n        .row = std.math.maxInt(u32),\n        .col = std.math.maxInt(u32),\n        .target = std.math.maxInt(u32),\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "invalid",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "fn eql(self: Self, other: Self) bool {\n    return self.row == other.row and self.col == other.col;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to right_of from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "fn right_of(self: Self, other: Self) bool {\n    return if (self.row > other.row) true else if (self.row == other.row and self.col > other.col) true else false;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "right_of",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to clamp_to_buffer from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn clamp_to_buffer(self: *Self, root: Buffer.Root, metrics: Metrics) void {\n    if (self.row > root.lines() - 1) {\n        self.row = root.lines() - 1;\n        self.col = root.line_width(self.row, metrics) catch 0;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "clamp_to_buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to follow_target from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "fn follow_target(self: *Self, root: Buffer.Root, metrics: Metrics) void {\n    self.col = @min(self.target, root.line_width(self.row, metrics) catch 0);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "follow_target",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_right_no_target from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "fn move_right_no_target(self: *Self, root: Buffer.Root, metrics: Metrics) !void {\n    const lines = root.lines();\n    if (lines <= self.row) return error.Stop;\n    if (self.col < root.line_width(self.row, metrics) catch 0) {\n        _, const wcwidth, const offset = root.egc_at(self.row, self.col, metrics) catch return error.Stop;\n        self.col += wcwidth - offset;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_right_no_target",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_right from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn move_right(self: *Self, root: Buffer.Root, metrics: Metrics) !void {\n    try self.move_right_no_target(root, metrics);\n    self.target = self.col;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_right",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_left_no_target from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "fn move_left_no_target(self: *Self, root: Buffer.Root, metrics: Metrics) !void {\n    if (self.col == 0) {\n        if (self.row == 0) return error.Stop;\n        self.row -= 1;\n        self.col = root.line_width(self.row, metrics) catch 0;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_left_no_target",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_left from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn move_left(self: *Self, root: Buffer.Root, metrics: Metrics) !void {\n    try self.move_left_no_target(root, metrics);\n    self.target = self.col;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_left",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_up from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn move_up(self: *Self, root: Buffer.Root, metrics: Metrics) !void {\n    if (self.row > 0) {\n        self.row -= 1;\n        self.follow_target(root, metrics);\n        self.move_left_no_target(root, metrics) catch return;\n        try self.move_right_no_target(root, metrics);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_up",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_down from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn move_down(self: *Self, root: Buffer.Root, metrics: Metrics) !void {\n    if (self.row < root.lines() - 1) {\n        self.row += 1;\n        self.follow_target(root, metrics);\n        self.move_left_no_target(root, metrics) catch return;\n        try self.move_right_no_target(root, metrics);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_down",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_page_up from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn move_page_up(self: *Self, root: Buffer.Root, view: *const View, metrics: Metrics) void {\n    self.row = if (self.row > view.rows) self.row - view.rows else 0;\n    self.follow_target(root, metrics);\n    self.move_left_no_target(root, metrics) catch return;\n    self.move_right_no_target(root, metrics) catch return;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_page_up",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_page_down from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn move_page_down(self: *Self, root: Buffer.Root, view: *const View, metrics: Metrics) void {\n    if (root.lines() > self.row + view.rows) {\n        self.row += view.rows;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_page_down",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_half_page_up from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn move_half_page_up(self: *Self, root: Buffer.Root, view: *const View, metrics: Metrics) void {\n    const half_view_rows = @divTrunc(view.rows, 2);\n    self.row = if (self.row > half_view_rows) self.row - half_view_rows else 0;\n    self.follow_target(root, metrics);\n    self.move_left_no_target(root, metrics) catch return;\n    self.move_right_no_target(root, metrics) catch return;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_half_page_up",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_half_page_down from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn move_half_page_down(self: *Self, root: Buffer.Root, view: *const View, metrics: Metrics) void {\n    const half_view_rows = @divTrunc(view.rows, 2);\n    if (root.lines() > self.row + half_view_rows) {\n        self.row += half_view_rows;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_half_page_down",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_to from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn move_to(self: *Self, root: Buffer.Root, row: usize, col: usize, metrics: Metrics) !void {\n    if (row < root.lines()) {\n        self.row = row;\n        self.col = @min(col, root.line_width(self.row, metrics) catch return error.Stop);\n        self.target = self.col;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_to",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_abs from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn move_abs(self: *Self, root: Buffer.Root, v: *View, y: usize, x: usize, metrics: Metrics) !void {\n    self.row = v.row + y;\n    self.col = v.col + x;\n    self.clamp_to_buffer(root, metrics);\n    self.target = self.col;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_abs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_begin from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn move_begin(self: *Self) void {\n    self.col = 0;\n    self.target = self.col;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_begin",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_end from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn move_end(self: *Self, root: Buffer.Root, metrics: Metrics) void {\n    if (self.row < root.lines()) self.col = root.line_width(self.row, metrics) catch 0;\n    self.target = std.math.maxInt(u32);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_end",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_buffer_begin from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn move_buffer_begin(self: *Self) void {\n    self.row = 0;\n    self.col = 0;\n    self.target = 0;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_buffer_begin",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_buffer_end from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn move_buffer_end(self: *Self, root: Buffer.Root, metrics: Metrics) void {\n    self.row = root.lines() - 1;\n    self.move_end(root, metrics);\n    if (self.col == 0) self.target = 0;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_buffer_end",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_buffer_first from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "fn move_buffer_first(self: *Self, root: Buffer.Root, metrics: Metrics) void {\n    self.row = 0;\n    self.follow_target(root, metrics);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_buffer_first",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_buffer_last from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "fn move_buffer_last(self: *Self, root: Buffer.Root, metrics: Metrics) void {\n    self.row = root.lines() - 1;\n    self.follow_target(root, metrics);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "move_buffer_last",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_at_begin from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "fn is_at_begin(self: *const Self) bool {\n    return self.col == 0;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "is_at_begin",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_at_end from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "fn is_at_end(self: *const Self, root: Buffer.Root, metrics: Metrics) bool {\n    return if (self.row < root.lines()) self.col == root.line_width(self.row, metrics) catch 0 else true;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "is_at_end",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to egc_at from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn egc_at(self: *const Self, root: Buffer.Root, metrics: Metrics) error{NotFound}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "egc_at",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to test_at from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn test_at(self: *const Self, root: Buffer.Root, pred: *const fn (c: []const u8) bool, metrics: Metrics) bool {\n    return root.test_at(pred, self.row, self.col, metrics);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "test_at",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn write(self: *const Self, writer: *std.Io.Writer) !void {\n    try cbor.writeValue(writer, .{\n        self.row,\n        self.col,\n        self.target,\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "write",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to extract from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn extract(self: *Self, iter: *[]const u8) !bool {\n    return cbor.matchValue(iter, .{\n        cbor.extract(&self.row),\n        cbor.extract(&self.col),\n        cbor.extract(&self.target),\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "extract",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nudge_insert from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn nudge_insert(self: *Self, nudge: Selection) void {\n    if (self.row < nudge.begin.row or (self.row == nudge.begin.row and self.col < nudge.begin.col)) return;\n\n    const rows = nudge.end.row - nudge.begin.row;\n    if (self.row == nudge.begin.row) {\n        if (nudge.begin.row < nudge.end.row) {\n            self.row += rows;\n            self.col = self.col - nudge.begin.col + nudge.end.col;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "nudge_insert",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nudge_delete from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Cursor.zig",
    "response": "pub fn nudge_delete(self: *Self, nudge: Selection) bool {\n    if (nudge.begin.right_of(self.*)) return true;\n    if (nudge.end.right_of(self.*)) return false;\n\n    if (self.row == nudge.begin.row) {\n        self.col -= nudge.end.col - nudge.begin.col;\n        self.target = self.col;\n        return true;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Cursor.zig",
      "type": "function",
      "name": "nudge_delete",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn init(allocator: std.mem.Allocator) Self {\n    return .{\n        .allocator = allocator,\n        .buffers = .{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn deinit(self: *Self) void {\n    var i = self.buffers.iterator();\n    while (i.next()) |p| {\n        self.allocator.free(p.key_ptr.*);\n        p.value_ptr.*.deinit();\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_buffer from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "fn get_buffer(self: *const Self, file_path: []const u8) ?*Buffer {\n    return self.buffers.get(file_path);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "get_buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to add_buffer from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "fn add_buffer(self: *Self, buffer: *Buffer) error{OutOfMemory}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "add_buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to delete_buffer from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn delete_buffer(self: *Self, buffer_: *Buffer) void {\n    const buffer = self.buffer_from_ref(self.buffer_to_ref(buffer_)) orelse return; // check buffer is valid\n    if (self.buffers.fetchRemove(buffer.get_file_path())) |kv| {\n        self.allocator.free(kv.key);\n        kv.value.deinit();\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "delete_buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to open_file from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn open_file(self: *Self, file_path: []const u8) Buffer.LoadFromFileError!*Buffer {\n    const buffer = if (self.get_buffer(file_path)) |buffer| buffer else blk: {\n        var buffer = try Buffer.create(self.allocator);\n        errdefer buffer.deinit();\n        try buffer.load_from_file_and_update(file_path);\n        try self.add_buffer(buffer);\n        break :blk buffer;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "open_file",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to open_scratch from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn open_scratch(self: *Self, file_path: []const u8, content: []const u8) Buffer.LoadError!*Buffer {\n    const buffer = if (self.buffers.get(file_path)) |buffer| buffer else blk: {\n        var buffer = try Buffer.create(self.allocator);\n        errdefer buffer.deinit();\n        try buffer.load_from_string_and_update(file_path, content);\n        buffer.file_exists = true;\n        try self.add_buffer(buffer);\n        break :blk buffer;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "open_scratch",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_state from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn write_state(self: *const Self, writer: *std.Io.Writer) error{ Stop, OutOfMemory, WriteFailed }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "write_state",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to extract_state from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn extract_state(self: *Self, iter: *[]const u8) !void {\n    var len = try cbor.decodeArrayHeader(iter);\n    tp.trace(tp.channel.debug, .{ @typeName(Self), \"extract_state\", len }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "extract_state",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_buffer_for_file from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn get_buffer_for_file(self: *const Self, file_path: []const u8) ?*Buffer {\n    return self.get_buffer(file_path);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "get_buffer_for_file",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to retire from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn retire(_: *Self, buffer: *Buffer, meta: ?[]const u8) void {\n    if (meta) |buf| buffer.set_meta(buf) catch {}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "retire",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to close_buffer from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn close_buffer(self: *Self, buffer: *Buffer) void {\n    buffer.hidden = true;\n    tp.trace(tp.channel.debug, .{ \"buffer\", \"close\", buffer.get_file_path(), \"hidden\", buffer.hidden, \"ephemeral\", buffer.ephemeral }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "close_buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to list_most_recently_used from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn list_most_recently_used(self: *Self, allocator: std.mem.Allocator) error{OutOfMemory}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "list_most_recently_used",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to less_fn from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "fn less_fn(_: void, lhs: *Buffer, rhs: *Buffer) bool {\n            return lhs.utime > rhs.utime;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "less_fn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to list_unordered from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn list_unordered(self: *const Self, allocator: std.mem.Allocator) error{OutOfMemory}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "list_unordered",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_dirty from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn is_dirty(self: *const Self) bool {\n    var i = self.buffers.iterator();\n    while (i.next()) |kv|\n        if (kv.value_ptr.*.is_dirty())\n            return true;\n    return false;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "is_dirty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to count_dirty_buffers from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn count_dirty_buffers(self: *const Self) usize {\n    var count: usize = 0;\n    var i = self.buffers.iterator();\n\n    while (i.next()) |p| {\n        const buffer = p.value_ptr.*;\n        if (!buffer.is_ephemeral() and buffer.is_dirty()) {\n            count += 1;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "count_dirty_buffers",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_buffer_dirty from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn is_buffer_dirty(self: *const Self, file_path: []const u8) bool {\n    return if (self.get_buffer(file_path)) |buffer| buffer.is_dirty() else false;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "is_buffer_dirty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to save_all from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn save_all(self: *const Self) Buffer.StoreToFileError!void {\n    var i = self.buffers.iterator();\n    while (i.next()) |kv| {\n        const buffer = kv.value_ptr.*;\n        if (buffer.is_ephemeral())\n            buffer.mark_clean()\n        else\n            try buffer.store_to_file_and_clean(buffer.get_file_path());\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "save_all",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to reload_all from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn reload_all(self: *const Self) Buffer.LoadFromFileError!void {\n    var i = self.buffers.iterator();\n    while (i.next()) |kv| {\n        const buffer = kv.value_ptr.*;\n        if (buffer.is_ephemeral())\n            buffer.mark_clean()\n        else\n            try buffer.refresh_from_file();\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "reload_all",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to delete_all from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn delete_all(self: *Self) void {\n    var i = self.buffers.iterator();\n    while (i.next()) |p| {\n        self.allocator.free(p.key_ptr.*);\n        p.value_ptr.*.deinit();\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "delete_all",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to delete_others from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn delete_others(self: *Self, protected: *Buffer) error{OutOfMemory}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "delete_others",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to close_others from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn close_others(self: *Self, protected: *Buffer) error{OutOfMemory}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "close_others",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buffer_from_ref from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn buffer_from_ref(self: *Self, buffer_ref: usize) ?*Buffer {\n    var i = self.buffers.iterator();\n    while (i.next()) |p|\n        if (@intFromPtr(p.value_ptr.*) == buffer_ref)\n            return p.value_ptr.*;\n    tp.trace(tp.channel.debug, .{ \"buffer_from_ref\", \"failed\", buffer_ref }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "buffer_from_ref",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buffer_to_ref from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Manager.zig",
    "response": "pub fn buffer_to_ref(_: *Self, buffer: *Buffer) usize {\n    return @intFromPtr(buffer);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Manager.zig",
      "type": "function",
      "name": "buffer_to_ref",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Selection.zig",
    "response": "fn eql(self: Self, other: Self) bool {\n    return self.begin.eql(other.begin) and self.end.eql(other.end);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Selection.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to from_cursor from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Selection.zig",
    "response": "pub fn from_cursor(cursor: *const Cursor) Self {\n    return .{ .begin = cursor.*, .end = cursor.* }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Selection.zig",
      "type": "function",
      "name": "from_cursor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to from_pos from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Selection.zig",
    "response": "pub fn from_pos(sel: Self, root: Buffer.Root, metrics: Buffer.Metrics) error{NotFound}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Selection.zig",
      "type": "function",
      "name": "from_pos",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to line_from_cursor from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Selection.zig",
    "response": "pub fn line_from_cursor(cursor: Cursor, root: Buffer.Root, mtrx: Buffer.Metrics) Self {\n    var begin = cursor;\n    var end = cursor;\n    begin.move_begin();\n    end.move_end(root, mtrx);\n    end.move_right(root, mtrx) catch {}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Selection.zig",
      "type": "function",
      "name": "line_from_cursor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to empty from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Selection.zig",
    "response": "pub fn empty(self: *const Self) bool {\n    return self.begin.eql(self.end);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Selection.zig",
      "type": "function",
      "name": "empty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reverse from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Selection.zig",
    "response": "pub fn reverse(self: *Self) void {\n    const tmp = self.begin;\n    self.begin = self.end;\n    self.end = tmp;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Selection.zig",
      "type": "function",
      "name": "reverse",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_reversed from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Selection.zig",
    "response": "fn is_reversed(self: *const Self) bool {\n    return self.begin.right_of(self.end);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Selection.zig",
      "type": "function",
      "name": "is_reversed",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to normalize from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Selection.zig",
    "response": "pub fn normalize(self: *Self) void {\n    if (self.is_reversed()) self.reverse();\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Selection.zig",
      "type": "function",
      "name": "normalize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Selection.zig",
    "response": "pub fn write(self: *const Self, writer: *Writer) !void {\n    try cbor.writeArrayHeader(writer, 2);\n    try self.begin.write(writer);\n    try self.end.write(writer);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Selection.zig",
      "type": "function",
      "name": "write",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to extract from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Selection.zig",
    "response": "pub fn extract(self: *Self, iter: *[]const u8) !bool {\n    var iter2 = iter.*;\n    const len = cbor.decodeArrayHeader(&iter2) catch return false;\n    if (len != 2) return false;\n    if (!try self.begin.extract(&iter2)) return false;\n    if (!try self.end.extract(&iter2)) return false;\n    iter.* = iter2;\n    return true;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Selection.zig",
      "type": "function",
      "name": "extract",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nudge_insert from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Selection.zig",
    "response": "pub fn nudge_insert(self: *Self, nudge: Self) void {\n    self.begin.nudge_insert(nudge);\n    self.end.nudge_insert(nudge);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Selection.zig",
      "type": "function",
      "name": "nudge_insert",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nudge_delete from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/Selection.zig",
    "response": "pub fn nudge_delete(self: *Self, nudge: Self) bool {\n    if (!self.begin.nudge_delete(nudge))\n        return false;\n    return self.end.nudge_delete(nudge);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/Selection.zig",
      "type": "function",
      "name": "nudge_delete",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to invalid from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "fn invalid() Self {\n    return .{\n        .row = std.math.maxInt(u32),\n        .col = std.math.maxInt(u32),\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "invalid",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "fn eql(self: Self, other: Self) bool {\n    return self.row == other.row and self.col == other.col and self.rows == other.rows and self.cols == other.cols;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_left from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "pub fn move_left(self: *Self) !void {\n    if (self.col > 0) {\n        self.col -= 1;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "move_left",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_right from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "pub fn move_right(self: *Self) !void {\n    self.col += 1;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "move_right",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_up from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "pub fn move_up(self: *Self) !void {\n    if (!self.is_at_top()) {\n        self.row -= 1;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "move_up",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_down from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "pub fn move_down(self: *Self, root: Buffer.Root) !void {\n    if (!self.is_at_bottom(root)) {\n        self.row += 1;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "move_down",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to move_to from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "pub fn move_to(self: *Self, root: Buffer.Root, row: usize) !void {\n    if (row < root.lines() - self.rows - 1) {\n        self.row = row;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "move_to",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_at_top from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "fn is_at_top(self: *const Self) bool {\n    return self.row == 0;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "is_at_top",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_at_bottom from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "fn is_at_bottom(self: *const Self, root: Buffer.Root) bool {\n    if (root.lines() < self.rows) return true;\n    return self.row >= root.lines() - scroll_cursor_min_border_distance;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "is_at_bottom",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_visible from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "fn is_visible(self: *const Self, cursor: *const Cursor) bool {\n    if (self.rows == 0) return false;\n    const row_min = self.row;\n    const row_max = row_min + self.rows - 1;\n    const col_min = self.col;\n    const col_max = col_min + self.cols;\n    return row_min <= cursor.row and cursor.row <= row_max and\n        col_min <= cursor.col and cursor.col < col_max;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "is_visible",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is_visible_selection from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "fn is_visible_selection(self: *const Self, sel: *const Selection) bool {\n    const row_min = self.row;\n    const row_max = row_min + self.rows;\n    return self.is_visible(sel.begin) or is_visible(sel.end) or\n        (sel.begin.row < row_min and sel.end.row > row_max);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "is_visible_selection",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to to_cursor_top from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "fn to_cursor_top(self: *const Self) Cursor {\n    return .{ .row = self.row, .col = 0 }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "to_cursor_top",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to to_cursor_bottom from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "fn to_cursor_bottom(self: *const Self, root: Buffer.Root) Cursor {\n    const bottom = @min(root.lines(), self.row + self.rows + 1);\n    return .{ .row = bottom, .col = 0 }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "to_cursor_bottom",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to clamp_row from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "fn clamp_row(self: *Self, cursor: *const Cursor, abs: bool) void {\n    const min_border_distance: usize = if (abs) scroll_cursor_min_border_distance_mouse else scroll_cursor_min_border_distance;\n    if (cursor.row < min_border_distance) {\n        self.row = 0;\n        return;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "clamp_row",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to clamp_col from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "fn clamp_col(self: *Self, cursor: *const Cursor, _: bool) void {\n    if (cursor.col < self.col) {\n        self.col = cursor.col;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "clamp_col",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to clamp from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "pub fn clamp(self: *Self, cursor: *const Cursor, abs: bool) void {\n    self.clamp_row(cursor, abs);\n    self.clamp_col(cursor, abs);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "clamp",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "pub fn write(self: *const Self, writer: *std.Io.Writer) !void {\n    try cbor.writeValue(writer, .{\n        self.row,\n        self.col,\n        self.rows,\n        self.cols,\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "write",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to extract from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "pub fn extract(self: *Self, iter: *[]const u8) !bool {\n    return cbor.matchValue(iter, .{\n        cbor.extract(&self.row),\n        cbor.extract(&self.col),\n        cbor.extract(&self.rows),\n        cbor.extract(&self.cols),\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "function",
      "name": "extract",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to min_border_distance from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/View.zig",
    "response": "const min_border_distance: usize = if (abs) scroll_cursor_min_border_distance_mouse else scroll_cursor_min_border_distance;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/View.zig",
      "type": "const",
      "name": "min_border_distance",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to control_code_to_unicode from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/unicode.zig",
    "response": "pub fn control_code_to_unicode(code: u8) [:0]const u8 {\n    return switch (code) {\n        '\\x00' => \"␀\",\n        '\\x01' => \"␁\",\n        '\\x02' => \"␂\",\n        '\\x03' => \"␃\",\n        '\\x04' => \"␄\",\n        '\\x05' => \"␅\",\n        '\\x06' => \"␆\",\n        '\\x07' => \"␇\",\n        '\\x08' => \"␈\",\n        '\\x09' => \"␉\",\n        '\\x0A' => \"␊\",\n        '\\x0B' => \"␋\",\n        '\\x0C' => \"␌\",\n        '\\x0D' => \"␍\",\n        '\\x0E' => \"␎\",\n        '\\x0F' => \"␏\",\n        '\\x10' => \"␐\",\n        '\\x11' => \"␑\",\n        '\\x12' => \"␒\",\n        '\\x13' => \"␓\",\n        '\\x14' => \"␔\",\n        '\\x15' => \"␕\",\n        '\\x16' => \"␖\",\n        '\\x17' => \"␗\",\n        '\\x18' => \"␘\",\n        '\\x19' => \"␙\",\n        '\\x1A' => \"␚\",\n        '\\x1B' => \"␛\",\n        '\\x1C' => \"␜\",\n        '\\x1D' => \"␝\",\n        '\\x1E' => \"␞\",\n        '\\x1F' => \"␟\",\n        '\\x20' => \"␠\",\n        '\\x7F' => \"␡\",\n        else => \"\",\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/unicode.zig",
      "type": "function",
      "name": "control_code_to_unicode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to raw_byte_to_utf8 from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/unicode.zig",
    "response": "fn raw_byte_to_utf8(cp: u8, buf: []u8) ![]const u8 {\n    var utf16le: [1]u16 = undefined;\n    const utf16le_as_bytes = std.mem.sliceAsBytes(utf16le[0..]);\n    std.mem.writeInt(u16, utf16le_as_bytes[0..2], cp, .little);\n    return buf[0..try std.unicode.utf16LeToUtf8(buf, &utf16le)];\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/unicode.zig",
      "type": "function",
      "name": "raw_byte_to_utf8",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to utf8_sanitize from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/unicode.zig",
    "response": "pub fn utf8_sanitize(allocator: std.mem.Allocator, input: []const u8) error{\n    OutOfMemory,\n    DanglingSurrogateHalf,\n    ExpectedSecondSurrogateHalf,\n    UnexpectedSecondSurrogateHalf,\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/unicode.zig",
      "type": "function",
      "name": "utf8_sanitize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_letter_casing from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/buffer/unicode.zig",
    "response": "pub fn get_letter_casing() *LetterCasing {\n    if (letter_casing) |*cd| return cd;\n    letter_casing = LetterCasing.init(letter_casing_arena.allocator()) catch @panic(\"LetterCasing.init\");\n    return &letter_casing.?;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/buffer/unicode.zig",
      "type": "function",
      "name": "get_letter_casing",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to from_u24 from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "fn from_u24(v: u24) RGB {\n        const r = @as(u8, @intCast(v >> 16 & 0xFF));\n        const g = @as(u8, @intCast(v >> 8 & 0xFF));\n        const b = @as(u8, @intCast(v & 0xFF));\n        return .{ .r = r, .g = g, .b = b }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "function",
      "name": "from_u24",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to to_u24 from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "fn to_u24(v: RGB) u24 {\n        const r = @as(u24, @intCast(v.r)) << 16;\n        const g = @as(u24, @intCast(v.g)) << 8;\n        const b = @as(u24, @intCast(v.b));\n        return r | b | g;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "function",
      "name": "to_u24",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to from_u8s from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "fn from_u8s(v: [3]u8) RGB {\n        return .{ .r = v[0], .g = v[1], .b = v[2] }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "function",
      "name": "from_u8s",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to from_string from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "pub fn from_string(s: []const u8) ?RGB {\n        const nib = struct {\n            fn f(c: u8) ?u8 {\n                return switch (c) {\n                    '0'...'9' => c - '0',\n                    'A'...'F' => c - 'A' + 10,\n                    'a'...'f' => c - 'a' + 10,\n                    else => null,\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "function",
      "name": "from_string",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to to_u8s from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "pub fn to_u8s(v: RGB) [3]u8 {\n        return [_]u8{ v.r, v.g, v.b }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "function",
      "name": "to_u8s",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to to_string from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "pub fn to_string(v: RGB, s: *[7]u8) []u8 {\n        const nib = struct {\n            fn f(n: u8) u8 {\n                return switch (n) {\n                    0...9 => '0' + n,\n                    0xA...0xF => 'A' + n - 10,\n                    else => unreachable,\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "function",
      "name": "to_string",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to contrast from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "pub fn contrast(a_: RGB, b_: RGB) f32 {\n        const a = RGBf.from_RGB(a_).luminance();\n        const b = RGBf.from_RGB(b_).luminance();\n        return (@max(a, b) + 0.05) / (@min(a, b) + 0.05);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "function",
      "name": "contrast",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to max_contrast from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "pub fn max_contrast(v: RGB, a: RGB, b: RGB) RGB {\n        return if (contrast(v, a) > contrast(v, b)) a else b;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "function",
      "name": "max_contrast",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to from_RGB from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "fn from_RGB(v: RGB) RGBf {\n        return .{ .r = tof(v.r), .g = tof(v.g), .b = tof(v.b) }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "function",
      "name": "from_RGB",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to luminance from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "pub fn luminance(v: RGBf) f32 {\n        return linear(v.r) * RED + linear(v.g) * GREEN + linear(v.b) * BLUE;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "function",
      "name": "luminance",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tof from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "fn tof(c: u8) f32 {\n        return @as(f32, @floatFromInt(c)) / 255.0;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "function",
      "name": "tof",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to linear from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "fn linear(v: f32) f32 {\n        return if (v <= 0.03928) v / 12.92 else pow(f32, (v + 0.055) / 1.055, GAMMA);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "function",
      "name": "linear",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to max_contrast from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "pub fn max_contrast(v: u24, a: u24, b: u24) u24 {\n    return RGB.max_contrast(RGB.from_u24(v), RGB.from_u24(a), RGB.from_u24(b)).to_u24();\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "function",
      "name": "max_contrast",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to apply_alpha from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "pub fn apply_alpha(base: RGB, over: RGB, alpha_u8: u8) RGB {\n    const alpha: f64 = @as(f64, @floatFromInt(alpha_u8)) / @as(f64, @floatFromInt(0xFF));\n    return .{\n        .r = component_apply_alpha(base.r, over.r, alpha),\n        .g = component_apply_alpha(base.g, over.g, alpha),\n        .b = component_apply_alpha(base.b, over.b, alpha),\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "function",
      "name": "apply_alpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to component_apply_alpha from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "fn component_apply_alpha(base_u8: u8, over_u8: u8, alpha: f64) u8 {\n    const base: f64 = @floatFromInt(base_u8);\n    const over: f64 = @floatFromInt(over_u8);\n    const result = ((1 - alpha) * base) + (alpha * over);\n    return @intFromFloat(result);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "function",
      "name": "component_apply_alpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to RGB from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "pub const RGB = struct {\n    r: u8,\n    g: u8,\n    b: u8,\n\n    pub inline fn from_u24(v: u24) RGB {\n        const r = @as(u8, @intCast(v >> 16 & 0xFF));\n        const g = @as(u8, @intCast(v >> 8 & 0xFF));\n        const b = @as(u8, @intCast(v & 0xFF));\n        return .{ .r = r, .g = g, .b = b }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "struct",
      "name": "RGB",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to nib from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "const nib = struct {\n            fn f(c: u8) ?u8 {\n                return switch (c) {\n                    '0'...'9' => c - '0',\n                    'A'...'F' => c - 'A' + 10,\n                    'a'...'f' => c - 'a' + 10,\n                    else => null,\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "struct",
      "name": "nib",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to nib from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "const nib = struct {\n            fn f(n: u8) u8 {\n                return switch (n) {\n                    0...9 => '0' + n,\n                    0xA...0xF => 'A' + n - 10,\n                    else => unreachable,\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "struct",
      "name": "nib",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to RGBf from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "pub const RGBf = struct {\n    r: f32,\n    g: f32,\n    b: f32,\n\n    pub inline fn from_RGB(v: RGB) RGBf {\n        return .{ .r = tof(v.r), .g = tof(v.g), .b = tof(v.b) }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "struct",
      "name": "RGBf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to alpha from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "const alpha: f64 = @as(f64, @floatFromInt(alpha_u8)) / @as(f64, @floatFromInt(0xFF));",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "const",
      "name": "alpha",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to base from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "const base: f64 = @floatFromInt(base_u8);",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "const",
      "name": "base",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to over from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/color.zig",
    "response": "const over: f64 = @floatFromInt(over_u8);",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/color.zig",
      "type": "const",
      "name": "over",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmt from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn fmt(value: anytype) Context {\n        context_buffer.clearRetainingCapacity();\n        cbor.writeValue(&context_buffer.writer, value) catch @panic(\"command.Context.fmt failed\");\n        return .{ .args = .{ .buf = context_buffer.written() }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "fmt",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to Closure from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn Closure(comptime T: type) type {\n    return struct {\n        vtbl: Vtable,\n        f: FunT,\n        data: T,\n\n        ///The type signature of commands\n        const FunT: type = *const fn (T, ctx: Context) Result;\n\n        const Self = @This();\n\n        pub fn init(f: FunT, data: T, name: []const u8, meta: Metadata) Self {\n            return .{\n                .vtbl = .{\n                    .run = run,\n                    .name = name,\n                    .meta = meta,\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "Closure",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to register from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn register(self: *Self) !void {\n            if (command_names.get(self.vtbl.name)) |id| {\n                self.vtbl.id = id;\n                reAddCommand(&self.vtbl) catch |e| return log.err(\"cmd\", \"reAddCommand\", e);\n                // log.print(\"cmd\", \"reAddCommand({s}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "register",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to unregister from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn unregister(self: *Self) void {\n            removeCommand(self.vtbl.id);\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "unregister",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "fn run(vtbl: *Vtable, ctx: Context) tp.result {\n            const self: *Self = fromVtable(vtbl);\n            return self.f(self.data, ctx) catch |e| tp.exit_error(e, @errorReturnTrace());\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "run",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromVtable from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "fn fromVtable(vtbl: *Vtable) *Self {\n            return @fieldParentPtr(\"vtbl\", vtbl);\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "fromVtable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addCommand from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "fn addCommand(cmd: *Vtable) !ID {\n    try commands.append(command_table_allocator, cmd);\n    return commands.items.len - 1;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "addCommand",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to reAddCommand from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "fn reAddCommand(cmd: *Vtable) !void {\n    if (commands.items[cmd.id] != null) return error.DuplicateCommand;\n    commands.items[cmd.id] = cmd;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "reAddCommand",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to removeCommand from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn removeCommand(id: ID) void {\n    commands.items[id] = null;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "removeCommand",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to execute from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn execute(id: ID, ctx: Context) tp.result {\n    if (tp.env.get().enabled(tp.channel.debug)) trace: {\n        var iter = ctx.args.buf;\n        var len = cbor.decodeArrayHeader(&iter) catch break :trace;\n        if (len < 1) {\n            tp.trace(tp.channel.debug, .{ \"command\", \"execute\", id, get_name(id) }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "execute",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_id from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn get_id(name: []const u8) ?ID {\n    var id: ?ID = null;\n    return get_id_cache(name, &id);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "get_id",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_name from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn get_name(id: ID) ?[]const u8 {\n    if (tp.env.get().enabled(tp.channel.debug)) {\n        if (id >= commands.items.len)\n            tp.trace(tp.channel.debug, .{ \"command\", \"get_name\", \"too large\", id }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "get_name",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_id_cache from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn get_id_cache(name: []const u8, id: *?ID) ?ID {\n    for (commands.items) |cmd| {\n        if (cmd) |p|\n            if (std.mem.eql(u8, p.name, name)) {\n                id.* = p.id;\n                return p.id;\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "get_id_cache",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_description from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn get_description(id: ID) ?[]const u8 {\n    if (id >= commands.items.len) return null;\n    return (commands.items[id] orelse return null).meta.description;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "get_description",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_arguments from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn get_arguments(id: ID) ?[]const ArgumentType {\n    if (id >= commands.items.len) return null;\n    return (commands.items[id] orelse return null).meta.arguments;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "get_arguments",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_icon from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn get_icon(id: ID) ?[]const u8 {\n    if (id >= commands.items.len) return null;\n    return (commands.items[id] orelse return null).meta.icon;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "get_icon",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to executeName from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn executeName(name: []const u8, ctx: Context) tp.result {\n    const id = get_id(name);\n    if (id) |id_| return execute(id_, ctx);\n    return notFoundError(name);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "executeName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to notFoundError from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn notFoundError(name: []const u8) !void {\n    if (!suppressed_errors.has(name))\n        return tp.exit_fmt(\"CommandNotFound: {s}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "notFoundError",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to CmdDef from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "fn CmdDef(comptime T: type) type {\n    return struct {\n        const Fn = fn (T, Context) anyerror!void;\n        name: [:0]const u8,\n        f: *const Fn,\n        meta: Metadata,\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "CmdDef",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getTargetType from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "fn getTargetType(comptime Namespace: type) type {\n    return @field(Namespace, \"Target\");\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "getTargetType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getCommands from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "fn getCommands(comptime Namespace: type) []const CmdDef(*getTargetType(Namespace)) {\n    @setEvalBranchQuota(10_000);\n    comptime switch (@typeInfo(Namespace)) {\n        .@\"struct\" => |info| {\n            var count = 0;\n            const Target = getTargetType(Namespace);\n            // @compileLog(Namespace, Target);\n            for (info.decls) |decl| {\n                // @compileLog(decl.name, @TypeOf(@field(Namespace, decl.name)));\n                if (@TypeOf(@field(Namespace, decl.name)) == CmdDef(*Target).Fn)\n                    count += 1;\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "getCommands",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to Collection from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn Collection(comptime Namespace: type) type {\n    const cmds = comptime getCommands(Namespace);\n    const Target = getTargetType(Namespace);\n    const Clsr = Closure(*Target);\n    var fields_var: [cmds.len]std.builtin.Type.StructField = undefined;\n    inline for (cmds, 0..) |cmd, i| {\n        @setEvalBranchQuota(10_000);\n        fields_var[i] = .{\n            .name = cmd.name,\n            .type = Clsr,\n            .default_value_ptr = null,\n            .is_comptime = false,\n            .alignment = if (@sizeOf(Clsr) > 0) @alignOf(Clsr) else 0,\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "Collection",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn init(self: *Self, targetPtr: *Target) !void {\n            if (cmds.len == 0)\n                @compileError(\"no commands found in type \" ++ @typeName(Target) ++ \" (did you mark them public?)\");\n            inline for (cmds) |cmd| {\n                @field(self.fields, cmd.name) = Closure(*Target).init(cmd.f, targetPtr, cmd.name, cmd.meta);\n                try @field(self.fields, cmd.name).register();\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub fn deinit(self: *Self) void {\n            inline for (cmds) |cmd|\n                Closure(*Target).unregister(&@field(self.fields, cmd.name));\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Context from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub const Context = struct {\n    args: tp.message = .{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "struct",
      "name": "Context",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Vtable from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "const Vtable = struct {\n    id: ID = ID_unknown,\n    name: []const u8,\n    run: *const fn (self: *Vtable, ctx: Context) tp.result,\n    meta: Metadata,\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "struct",
      "name": "Vtable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Metadata from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "pub const Metadata = struct {\n    description: []const u8 = &[_]u8{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "struct",
      "name": "Metadata",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to FunT from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "const FunT: type = *const fn (T, ctx: Context) Result;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "const",
      "name": "FunT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to self from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "const self: *Self = fromVtable(vtbl);",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "const",
      "name": "self",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to msg from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "const msg: tp.message = .{ .buf = msg_cb.written() };",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "const",
      "name": "msg",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to fields from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/command.zig",
    "response": "const fields: [cmds.len]std.builtin.Type.StructField = fields_var;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/command.zig",
      "type": "const",
      "name": "fields",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to send from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/completion.zig",
    "response": "pub fn send(\n    allocator: std.mem.Allocator,\n    to: tp.pid_ref,\n    m: anytype,\n    ctx: anytype,\n) (OutOfMemoryError || SpawnError)!void {\n    return RequestContext(@TypeOf(ctx)).send(allocator, to, ctx, tp.message.fmt(m));\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/completion.zig",
      "type": "function",
      "name": "send",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to RequestContext from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/completion.zig",
    "response": "fn RequestContext(T: type) type {\n    return struct {\n        receiver: ReceiverT,\n        ctx: T,\n        to: tp.pid,\n        request: tp.message,\n        response: ?tp.message,\n        a: std.mem.Allocator,\n\n        const Self = @This();\n        const ReceiverT = tp.Receiver(*@This());\n\n        fn send(a: std.mem.Allocator, to: tp.pid_ref, ctx: T, request: tp.message) (OutOfMemoryError || SpawnError)!void {\n            const self = try a.create(@This());\n            self.* = .{\n                .receiver = undefined,\n                .ctx = if (@hasDecl(T, \"clone\")) ctx.clone() else ctx,\n                .to = to.clone(),\n                .request = try request.clone(std.heap.c_allocator),\n                .response = null,\n                .a = a,\n            }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/completion.zig",
      "type": "function",
      "name": "RequestContext",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/completion.zig",
    "response": "fn deinit(self: *@This()) void {\n            if (@hasDecl(T, \"deinit\")) self.ctx.deinit();\n            std.heap.c_allocator.free(self.request.buf);\n            self.to.deinit();\n            self.a.destroy(self);\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/completion.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to start from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/completion.zig",
    "response": "fn start(self: *@This()) tp.result {\n            _ = tp.set_trap(true);\n            if (@hasDecl(T, \"link\")) try self.ctx.link();\n            errdefer self.deinit();\n            try self.to.link();\n            try self.to.send_raw(self.request);\n            tp.receive(&self.receiver);\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/completion.zig",
      "type": "function",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive_ from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/completion.zig",
    "response": "fn receive_(self: *@This(), _: tp.pid_ref, m: tp.message) tp.result {\n            defer self.deinit();\n            self.ctx.receive(m) catch |e| return tp.exit_error(e, @errorReturnTrace());\n            return tp.exit_normal();\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/completion.zig",
      "type": "function",
      "name": "receive_",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to create from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "pub fn create() !AsyncDiffer {\n    return .{ .pid = try Process.create() }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "function",
      "name": "create",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "pub fn deinit(self: *@This()) void {\n        if (self.pid) |pid| {\n            pid.send(.{\"shutdown\"}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to text_from_root from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "fn text_from_root(root: Buffer.Root, eol_mode: Buffer.EolMode) ![]const u8 {\n        var text: std.Io.Writer.Allocating = .init(std.heap.c_allocator);\n        defer text.deinit();\n        try root.store(&text.writer, eol_mode);\n        return text.toOwnedSlice();\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "function",
      "name": "text_from_root",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to diff from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "pub fn diff(self: @This(), cb: *const CallBack, root_dst: Buffer.Root, root_src: Buffer.Root, eol_mode: Buffer.EolMode) tp.result {\n        const text_dst = text_from_root(root_dst, eol_mode) catch |e| return tp.exit_error(e, @errorReturnTrace());\n        errdefer std.heap.c_allocator.free(text_dst);\n        const text_src = text_from_root(root_src, eol_mode) catch |e| return tp.exit_error(e, @errorReturnTrace());\n        errdefer std.heap.c_allocator.free(text_src);\n        const text_dst_ptr: usize = if (text_dst.len > 0) @intFromPtr(text_dst.ptr) else 0;\n        const text_src_ptr: usize = if (text_src.len > 0) @intFromPtr(text_src.ptr) else 0;\n        if (self.pid) |pid| try pid.send(.{ \"D\", @intFromPtr(cb), text_dst_ptr, text_dst.len, text_src_ptr, text_src.len }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "function",
      "name": "diff",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to create from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "pub fn create() !tp.pid {\n        const self = try allocator.create(Process);\n        errdefer allocator.destroy(self);\n        self.* = .{\n            .receiver = Receiver.init(Process.receive, self),\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "function",
      "name": "create",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to start from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "fn start(self: *Process) tp.result {\n        errdefer self.deinit();\n        tp.receive(&self.receiver);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "function",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "fn deinit(self: *Process) void {\n        allocator.destroy(self);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to receive from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "fn receive(self: *Process, from: tp.pid_ref, m: tp.message) tp.result {\n        errdefer self.deinit();\n\n        var cb: usize = 0;\n        var text_dst_ptr: usize = 0;\n        var text_dst_len: usize = 0;\n        var text_src_ptr: usize = 0;\n        var text_src_len: usize = 0;\n\n        return if (try m.match(.{ \"D\", tp.extract(&cb), tp.extract(&text_dst_ptr), tp.extract(&text_dst_len), tp.extract(&text_src_ptr), tp.extract(&text_src_len) }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "function",
      "name": "receive",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to do_diff_async from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "fn do_diff_async(from_: tp.pid_ref, cb_addr: usize, text_dst: []const u8, text_src: []const u8) !void {\n        defer std.heap.c_allocator.free(text_dst);\n        defer std.heap.c_allocator.free(text_src);\n        const cb_: *AsyncDiffer.CallBack = if (cb_addr == 0) return else @ptrFromInt(cb_addr);\n\n        var arena_ = std.heap.ArenaAllocator.init(allocator);\n        defer arena_.deinit();\n        const arena = arena_.allocator();\n\n        const edits = try diff(arena, text_dst, text_src);\n        cb_(from_, edits);\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "function",
      "name": "do_diff_async",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to diff from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "pub fn diff(allocator: std.mem.Allocator, dst: []const u8, src: []const u8) ![]Diff {\n    var arena_ = std.heap.ArenaAllocator.init(allocator);\n    defer arena_.deinit();\n    const arena = arena_.allocator();\n    const frame = tracy.initZone(@src(), .{ .name = \"diff\" }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "function",
      "name": "diff",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_edits from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "pub fn get_edits(allocator: std.mem.Allocator, dst: []const u8, src: []const u8) ![]Edit {\n    var arena_ = std.heap.ArenaAllocator.init(allocator);\n    defer arena_.deinit();\n    const arena = arena_.allocator();\n    const frame = tracy.initZone(@src(), .{ .name = \"diff\" }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "function",
      "name": "get_edits",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to scan_char from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "fn scan_char(chars: []const u8, lines: *usize, char: u8, last_offset: ?*usize) void {\n    var pos = chars;\n    while (pos.len > 0) {\n        if (pos[0] == char) {\n            if (last_offset) |off| off.* = pos.len - 1;\n            lines.* += 1;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "function",
      "name": "scan_char",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to assert_edits_valid from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "pub fn assert_edits_valid(allocator: std.mem.Allocator, dst: []const u8, src: []const u8, edits: []Edit) void {\n    const frame = tracy.initZone(@src(), .{ .name = \"diff validate\" }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "function",
      "name": "assert_edits_valid",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write_file from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "fn write_file(data: []const u8, file_name: []const u8) !void {\n    var file = try std.fs.cwd().createFile(file_name, .{ .truncate = true }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "function",
      "name": "write_file",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Diff from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "pub const Diff = struct {\n    kind: Kind,\n    line: usize,\n    offset: usize,\n    start: usize,\n    end: usize,\n    bytes: []const u8,\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "struct",
      "name": "Diff",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Edit from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "pub const Edit = struct {\n    kind: Kind,\n    start: usize,\n    end: usize,\n    bytes: []const u8,\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "struct",
      "name": "Edit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to AsyncDiffer from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "pub const AsyncDiffer = struct {\n    pid: ?tp.pid,\n\n    pub fn deinit(self: *@This()) void {\n        if (self.pid) |pid| {\n            pid.send(.{\"shutdown\"}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "struct",
      "name": "AsyncDiffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Process from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "const Process = struct {\n    receiver: Receiver,\n\n    const Receiver = tp.Receiver(*Process);\n    const allocator = std.heap.c_allocator;\n\n    pub fn create() !tp.pid {\n        const self = try allocator.create(Process);\n        errdefer allocator.destroy(self);\n        self.* = .{\n            .receiver = Receiver.init(Process.receive, self),\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "struct",
      "name": "Process",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to text_dst_ptr from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "const text_dst_ptr: usize = if (text_dst.len > 0) @intFromPtr(text_dst.ptr) else 0;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "const",
      "name": "text_dst_ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to text_src_ptr from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "const text_src_ptr: usize = if (text_src.len > 0) @intFromPtr(text_src.ptr) else 0;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "const",
      "name": "text_src_ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cb_ from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "const cb_: *AsyncDiffer.CallBack = if (cb_addr == 0) return else @ptrFromInt(cb_addr);",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "const",
      "name": "cb_",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to line_start_dst from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/diff.zig",
    "response": "const line_start_dst: usize = lines_dst;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/diff.zig",
      "type": "const",
      "name": "line_start_dst",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parse from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_link.zig",
    "response": "pub fn parse(link: []const u8) error{InvalidFileLink}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_link.zig",
      "type": "function",
      "name": "parse",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parse_bracket_link from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_link.zig",
    "response": "pub fn parse_bracket_link(link: []const u8) error{InvalidFileLink}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_link.zig",
      "type": "function",
      "name": "parse_bracket_link",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to navigate from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_link.zig",
    "response": "pub fn navigate(to: tp.pid_ref, link: *const Dest) anyerror!void {\n    switch (link.*) {\n        .file => |file| {\n            if (file.offset) |offset| {\n                return to.send(.{ \"cmd\", \"navigate\", .{ .file = file.path, .offset = offset }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_link.zig",
      "type": "function",
      "name": "navigate",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FileDest from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_link.zig",
    "response": "pub const FileDest = struct {\n    path: []const u8,\n    line: ?usize = null,\n    column: ?usize = null,\n    end_column: ?usize = null,\n    exists: bool = false,\n    offset: ?usize = null,\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_link.zig",
      "type": "struct",
      "name": "FileDest",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to DirDest from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_link.zig",
    "response": "pub const DirDest = struct {\n    path: []const u8,\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_link.zig",
      "type": "struct",
      "name": "DirDest",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to from_file_type from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "fn from_file_type(file_type: syntax.FileType) @This() {\n    const lsp_defaults: LspDefaults = static_file_type_lsp_defaults.get(file_type.name) orelse .{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "function",
      "name": "from_file_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_default from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "pub fn get_default(allocator: std.mem.Allocator, file_type_name: []const u8) ![]const u8 {\n    const file_type = syntax.FileType.get_by_name_static(file_type_name) orelse return error.UnknownFileType;\n    const config = from_file_type(file_type);\n    var content: std.Io.Writer.Allocating = .init(allocator);\n    defer content.deinit();\n    root.write_config_to_writer(@This(), config, &content.writer) catch {}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "function",
      "name": "get_default",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_all_names from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "pub fn get_all_names() []const []const u8 {\n    cache_mutex.lock();\n    defer cache_mutex.unlock();\n    if (cache_list.len == 0)\n        cache_list = load_all(cache_allocator) catch &.{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "function",
      "name": "get_all_names",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "pub fn get(file_type_name: []const u8) !?@This() {\n    cache_mutex.lock();\n    defer cache_mutex.unlock();\n\n    return if (cache.get(file_type_name)) |self| self else self: {\n        const file_type = file_type: {\n            const file_name = try get_config_file_path(cache_allocator, file_type_name);\n            defer cache_allocator.free(file_name);\n\n            const file: ?std.fs.File = std.fs.openFileAbsolute(file_name, .{ .mode = .read_only }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "function",
      "name": "get",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_config_file_path from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "pub fn get_config_file_path(allocator: std.mem.Allocator, file_type: []const u8) ![]u8 {\n    const config_dir_path = try get_config_dir_path(allocator);\n    var stream: std.Io.Writer.Allocating = .initOwnedSlice(allocator, config_dir_path);\n    defer stream.deinit();\n    const writer = &stream.writer;\n    writer.end = config_dir_path.len;\n    _ = try writer.writeAll(file_type);\n    _ = try writer.writeAll(\".conf\");\n    return stream.toOwnedSlice();\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "function",
      "name": "get_config_file_path",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_config_dir_path from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "fn get_config_dir_path(allocator: std.mem.Allocator) ![]u8 {\n    var stream: std.Io.Writer.Allocating = .init(allocator);\n    defer stream.deinit();\n    const writer = &stream.writer;\n    _ = try writer.writeAll(try root.get_config_dir());\n    _ = try writer.writeByte(std.fs.path.sep);\n    _ = try writer.writeAll(\"file_type\");\n    _ = try writer.writeByte(std.fs.path.sep);\n    std.fs.makeDirAbsolute(stream.written()) catch |e| switch (e) {\n        error.PathAlreadyExists => {}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "function",
      "name": "get_config_dir_path",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to load_all from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "fn load_all(allocator: std.mem.Allocator) ![]const []const u8 {\n    const dir_path = try get_config_dir_path(allocator);\n    defer allocator.free(dir_path);\n\n    var dir = try std.fs.cwd().openDir(dir_path, .{ .iterate = true }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "function",
      "name": "load_all",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to less_fn from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "fn less_fn(_: void, lhs: []const u8, rhs: []const u8) bool {\n            return std.mem.order(u8, lhs, rhs) == .lt;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "function",
      "name": "less_fn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to guess_file_type from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "pub fn guess_file_type(file_path: ?[]const u8, content: []const u8) ?@This() {\n    return guess(file_path, content);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "function",
      "name": "guess_file_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to guess from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "fn guess(file_path: ?[]const u8, content: []const u8) ?@This() {\n    if (guess_first_line(content)) |ft| return ft;\n    for (get_all_names()) |file_type_name| {\n        const file_type = get(file_type_name) catch unreachable orelse unreachable;\n        if (file_path) |fp| if (syntax.FileType.match_file_type(file_type.extensions orelse continue, fp))\n            return file_type;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "function",
      "name": "guess",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to guess_first_line from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "fn guess_first_line(content: []const u8) ?@This() {\n    const first_line = if (std.mem.indexOf(u8, content, \"\\n\")) |pos| content[0..pos] else content;\n    for (get_all_names()) |file_type_name| {\n        const file_type = get(file_type_name) catch unreachable orelse unreachable;\n        if (syntax.FileType.match_first_line(file_type.first_line_matches_prefix, file_type.first_line_matches_content, first_line))\n            return file_type;\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "function",
      "name": "guess_first_line",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to create_syntax from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "pub fn create_syntax(file_type_config: @This(), allocator: std.mem.Allocator, query_cache: *syntax.QueryCache) !?*syntax {\n    return syntax.create(\n        syntax.FileType.get_by_name_static(file_type_config.parser orelse file_type_config.name) orelse return null,\n        allocator,\n        query_cache,\n    );\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "function",
      "name": "create_syntax",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to create_syntax_guess_file_type from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "pub fn create_syntax_guess_file_type(\n    allocator: std.mem.Allocator,\n    content: []const u8,\n    file_path: ?[]const u8,\n    query_cache: *syntax.QueryCache,\n) !?*syntax {\n    const file_type = guess(file_path, content) orelse return error.NotFound;\n    return create_syntax(file_type, allocator, query_cache);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "function",
      "name": "create_syntax_guess_file_type",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to load_file_type_lsp_defaults from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "fn load_file_type_lsp_defaults(comptime Namespace: type) []const ListEntry {\n    comptime switch (@typeInfo(Namespace)) {\n        .@\"struct\" => |info| {\n            var count = 0;\n            for (info.decls) |_| count += 1;\n            var construct_types: [count]ListEntry = undefined;\n            var i = 0;\n            for (info.decls) |decl| {\n                const lang = decl.name;\n                const args = @field(Namespace, lang);\n                construct_types[i] = .{ lang, .{\n                    .formatter = if (@hasField(@TypeOf(args), \"formatter\")) vec(args.formatter) else null,\n                    .language_server = if (@hasField(@TypeOf(args), \"language_server\")) vec(args.language_server) else null,\n                }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "function",
      "name": "load_file_type_lsp_defaults",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to vec from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "fn vec(comptime args: anytype) []const []const u8 {\n    var cmd: []const []const u8 = &[_][]const u8{}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "function",
      "name": "vec",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to default from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "pub const default = struct {\n    pub const name = \"text\";\n    pub const description = \"Plain Text\";\n    pub const icon = \"🖹\";\n    pub const color = 0x000000;\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "struct",
      "name": "default",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to less_fn from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "const less_fn = struct {\n        fn less_fn(_: void, lhs: []const u8, rhs: []const u8) bool {\n            return std.mem.order(u8, lhs, rhs) == .lt;\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "struct",
      "name": "less_fn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to LspDefaults from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "const LspDefaults = struct {\n    formatter: ?[]const []const u8 = null,\n    language_server: ?[]const []const u8 = null,\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "struct",
      "name": "LspDefaults",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ListEntry from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "const ListEntry = struct { []const u8, LspDefaults }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "struct",
      "name": "ListEntry",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to lsp_defaults from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "const lsp_defaults: LspDefaults = static_file_type_lsp_defaults.get(file_type.name) orelse .{};",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "const",
      "name": "lsp_defaults",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to file from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/file_type_config.zig",
    "response": "const file: ?std.fs.File = std.fs.openFileAbsolute(file_name, .{ .mode = .read_only }) catch null;",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/file_type_config.zig",
      "type": "const",
      "name": "file",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to workspace_path from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "pub fn workspace_path(context_: usize) Error!void {\n    const fn_name = @src().fn_name;\n    try git(context_, .{ \"rev-parse\", \"--show-toplevel\" }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "workspace_path",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to result from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "fn result(context: usize, parent: tp.pid_ref, output: []const u8) void {\n            var it = std.mem.splitScalar(u8, output, '\\n');\n            while (it.next()) |value| if (value.len > 0)\n                parent.send(.{ module_name, context, fn_name, value }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "result",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to current_branch from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "pub fn current_branch(context_: usize) Error!void {\n    const fn_name = @src().fn_name;\n    try git(context_, .{ \"rev-parse\", \"--abbrev-ref\", \"HEAD\" }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "current_branch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to result from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "fn result(context: usize, parent: tp.pid_ref, output: []const u8) void {\n            var it = std.mem.splitScalar(u8, output, '\\n');\n            while (it.next()) |value| if (value.len > 0) {\n                parent.send(.{ module_name, context, fn_name, value }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "result",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to workspace_files from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "pub fn workspace_files(context: usize) Error!void {\n    return git_line_output(\n        context,\n        @src().fn_name,\n        .{ \"ls-files\", \"--cached\", \"--others\", \"--exclude-standard\" }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "workspace_files",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to workspace_ignored_files from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "pub fn workspace_ignored_files(context: usize) Error!void {\n    return git_line_output(\n        context,\n        @src().fn_name,\n        .{ \"ls-files\", \"--cached\", \"--others\", \"--exclude-standard\", \"--ignored\" }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "workspace_ignored_files",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to status from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "pub fn status(context_: usize) Error!void {\n    const tag = @src().fn_name;\n    try git_err(context_, .{\n        \"--no-optional-locks\",\n        \"status\",\n        \"--porcelain=v2\",\n        \"--branch\",\n        \"--show-stash\",\n        // \"--untracked-files=no\",\n        \"--null\",\n    }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "status",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to result from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "fn result(context: usize, parent: tp.pid_ref, output: []const u8) void {\n            var it_ = std.mem.splitScalar(u8, output, 0);\n            while (it_.next()) |line| {\n                var it = std.mem.splitScalar(u8, line, ' ');\n                const rec_type = if (it.next()) |type_tag|\n                    std.meta.stringToEnum(StatusRecordType, type_tag) orelse return\n                else\n                    return;\n                switch (rec_type) {\n                    .@\"#\" => { // header\n                        const name = it.next() orelse return;\n                        const value1 = it.next() orelse return;\n                        if (it.next()) |value2|\n                            parent.send(.{ module_name, context, tag, \"#\", name, value1, value2 }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "result",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to result from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "fn result(_: usize, _: tp.pid_ref, output: []const u8) void {\n            var it = std.mem.splitScalar(u8, output, '\\n');\n            while (it.next()) |line| if (line.len > 0)\n                std.log.err(\"{s}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "result",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to git_line_output from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "fn git_line_output(context_: usize, comptime tag: []const u8, cmd: anytype) Error!void {\n    try git_err(context_, cmd, struct {\n        fn result(context: usize, parent: tp.pid_ref, output: []const u8) void {\n            var it = std.mem.splitScalar(u8, output, '\\n');\n            while (it.next()) |value| if (value.len > 0)\n                parent.send(.{ module_name, context, tag, value }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "git_line_output",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to result from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "fn result(_: usize, _: tp.pid_ref, output: []const u8) void {\n            var it = std.mem.splitScalar(u8, output, '\\n');\n            while (it.next()) |line| if (line.len > 0)\n                std.log.err(\"{s}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "result",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to git from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "fn git(\n    context: usize,\n    cmd: anytype,\n    out: OutputHandler,\n    exit: ExitHandler,\n) Error!void {\n    return git_err(context, cmd, out, noop, exit);\n}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "git",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to git_err from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "fn git_err(\n    context: usize,\n    cmd: anytype,\n    out: OutputHandler,\n    err: OutputHandler,\n    exit: ExitHandler,\n) Error!void {\n    const cbor = @import(\"cbor\");\n    const git_binary = get_git() orelse return error.GitNotFound;\n    var buf: std.Io.Writer.Allocating = .init(allocator);\n    defer buf.deinit();\n    const writer = &buf.writer;\n    switch (@typeInfo(@TypeOf(cmd))) {\n        .@\"struct\" => |info| if (info.is_tuple) {\n            try cbor.writeArrayHeader(writer, info.fields.len + 1);\n            try cbor.writeValue(writer, git_binary);\n            inline for (info.fields) |f|\n                try cbor.writeValue(writer, @field(cmd, f.name));\n            return shell.execute(allocator, .{ .buf = buf.written() }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "git_err",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to exit_null from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "fn exit_null(comptime tag: []const u8) shell.ExitHandler {\n    return struct {\n        fn exit(context: usize, parent: tp.pid_ref, _: []const u8, _: []const u8, _: i64) void {\n            parent.send(.{ module_name, context, tag, null }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "exit_null",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to exit_null_on_error from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "fn exit_null_on_error(comptime tag: []const u8) shell.ExitHandler {\n    return struct {\n        fn exit(context: usize, parent: tp.pid_ref, _: []const u8, _: []const u8, exit_code: i64) void {\n            if (exit_code > 0)\n                parent.send(.{ module_name, context, tag, null }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "exit_null_on_error",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to to_shell_output_handler from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "fn to_shell_output_handler(handler: anytype) shell.OutputHandler {\n    return struct {\n        fn out(context: usize, parent: tp.pid_ref, _: []const u8, output: []const u8) void {\n            handler(context, parent, output);\n        }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "to_shell_output_handler",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to noop from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "fn noop(_: usize, _: tp.pid_ref, _: []const u8) void {}",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "noop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_git from neurocyte/flow",
    "context": "Repository: neurocyte/flow (1255 ⭐)\nFile: src/git.zig",
    "response": "fn get_git() ?[]const u8 {\n    if (git_path) |p| return p.path;\n    const path = bin_path.find_binary_in_path(allocator, module_name) catch null;\n    git_path = .{ .path = path }",
    "metadata": {
      "repo": "neurocyte/flow",
      "stars": 1255,
      "file": "src/git.zig",
      "type": "function",
      "name": "get_git",
      "difficulty": "medium"
    }
  }
]