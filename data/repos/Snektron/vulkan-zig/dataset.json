[
  {
    "instruction": "Write a Zig function similar to build from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: build.zig",
    "response": "pub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "build.zig",
      "type": "function",
      "name": "build",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/build.zig",
    "response": "pub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/build.zig",
      "type": "function",
      "name": "build",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to registry_path from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/build.zig",
    "response": "const registry_path: std.Build.LazyPath = if (maybe_override_registry) |override_registry|\n        .{ .cwd_relative = override_registry }\n    else\n        registry;",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/build.zig",
      "type": "const",
      "name": "registry_path",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "pub fn init(allocator: Allocator, app_name: [*:0]const u8, window: *c.GLFWwindow) !GraphicsContext {\n        var self: GraphicsContext = undefined;\n        self.allocator = allocator;\n        self.vkb = BaseWrapper.load(c.glfwGetInstanceProcAddress);\n\n        if (try checkLayerSupport(&self.vkb, self.allocator) == false) {\n            return error.MissingLayer;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "pub fn deinit(self: GraphicsContext) void {\n        self.dev.destroyDevice(null);\n        self.instance.destroySurfaceKHR(self.surface, null);\n        self.instance.destroyDebugUtilsMessengerEXT(self.debug_messenger, null);\n        self.instance.destroyInstance(null);\n\n        // Don't forget to free the tables to prevent a memory leak.\n        self.allocator.destroy(self.dev.wrapper);\n        self.allocator.destroy(self.instance.wrapper);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deviceName from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "pub fn deviceName(self: *const GraphicsContext) []const u8 {\n        return std.mem.sliceTo(&self.props.device_name, 0);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "function",
      "name": "deviceName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findMemoryTypeIndex from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "pub fn findMemoryTypeIndex(self: GraphicsContext, memory_type_bits: u32, flags: vk.MemoryPropertyFlags) !u32 {\n        for (self.mem_props.memory_types[0..self.mem_props.memory_type_count], 0..) |mem_type, i| {\n            if (memory_type_bits & (@as(u32, 1) << @truncate(i)) != 0 and mem_type.property_flags.contains(flags)) {\n                return @truncate(i);\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "function",
      "name": "findMemoryTypeIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to allocate from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "pub fn allocate(self: GraphicsContext, requirements: vk.MemoryRequirements, flags: vk.MemoryPropertyFlags) !vk.DeviceMemory {\n        return try self.dev.allocateMemory(&.{\n            .allocation_size = requirements.size,\n            .memory_type_index = try self.findMemoryTypeIndex(requirements.memory_type_bits, flags),\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "function",
      "name": "allocate",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to checkLayerSupport from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "fn checkLayerSupport(vkb: *const BaseWrapper, alloc: Allocator) !bool {\n    const available_layers = try vkb.enumerateInstanceLayerPropertiesAlloc(alloc);\n    defer alloc.free(available_layers);\n    for (required_layer_names) |required_layer| {\n        for (available_layers) |layer| {\n            if (std.mem.eql(u8, std.mem.span(required_layer), std.mem.sliceTo(&layer.layer_name, 0))) {\n                break;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "function",
      "name": "checkLayerSupport",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "fn init(device: Device, family: u32) Queue {\n        return .{\n            .handle = device.getDeviceQueue(family, 0),\n            .family = family,\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to createSurface from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "fn createSurface(instance: Instance, window: *c.GLFWwindow) !vk.SurfaceKHR {\n    var surface: vk.SurfaceKHR = undefined;\n    if (c.glfwCreateWindowSurface(instance.handle, window, null, &surface) != .success) {\n        return error.SurfaceInitFailed;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "function",
      "name": "createSurface",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to initializeCandidate from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "fn initializeCandidate(instance: Instance, candidate: DeviceCandidate) !vk.Device {\n    const priority = [_]f32{1}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "function",
      "name": "initializeCandidate",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to debugUtilsMessengerCallback from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "fn debugUtilsMessengerCallback(severity: vk.DebugUtilsMessageSeverityFlagsEXT, msg_type: vk.DebugUtilsMessageTypeFlagsEXT, callback_data: ?*const vk.DebugUtilsMessengerCallbackDataEXT, _: ?*anyopaque) callconv(.c) vk.Bool32 {\n    const severity_str = if (severity.verbose_bit_ext) \"verbose\" else if (severity.info_bit_ext) \"info\" else if (severity.warning_bit_ext) \"warning\" else if (severity.error_bit_ext) \"error\" else \"unknown\";\n\n    const type_str = if (msg_type.general_bit_ext) \"general\" else if (msg_type.validation_bit_ext) \"validation\" else if (msg_type.performance_bit_ext) \"performance\" else if (msg_type.device_address_binding_bit_ext) \"device addr\" else \"unknown\";\n\n    const message: [*c]const u8 = if (callback_data) |cb_data| cb_data.p_message else \"NO MESSAGE!\";\n    std.debug.print(\"[{s}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "function",
      "name": "debugUtilsMessengerCallback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pickPhysicalDevice from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "fn pickPhysicalDevice(\n    instance: Instance,\n    allocator: Allocator,\n    surface: vk.SurfaceKHR,\n) !DeviceCandidate {\n    const pdevs = try instance.enumeratePhysicalDevicesAlloc(allocator);\n    defer allocator.free(pdevs);\n\n    for (pdevs) |pdev| {\n        if (try checkSuitable(instance, pdev, allocator, surface)) |candidate| {\n            return candidate;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "function",
      "name": "pickPhysicalDevice",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to checkSuitable from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "fn checkSuitable(\n    instance: Instance,\n    pdev: vk.PhysicalDevice,\n    allocator: Allocator,\n    surface: vk.SurfaceKHR,\n) !?DeviceCandidate {\n    if (!try checkExtensionSupport(instance, pdev, allocator)) {\n        return null;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "function",
      "name": "checkSuitable",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to allocateQueues from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "fn allocateQueues(instance: Instance, pdev: vk.PhysicalDevice, allocator: Allocator, surface: vk.SurfaceKHR) !?QueueAllocation {\n    const families = try instance.getPhysicalDeviceQueueFamilyPropertiesAlloc(pdev, allocator);\n    defer allocator.free(families);\n\n    var graphics_family: ?u32 = null;\n    var present_family: ?u32 = null;\n\n    for (families, 0..) |properties, i| {\n        const family: u32 = @intCast(i);\n\n        if (graphics_family == null and properties.queue_flags.graphics_bit) {\n            graphics_family = family;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "function",
      "name": "allocateQueues",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to checkSurfaceSupport from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "fn checkSurfaceSupport(instance: Instance, pdev: vk.PhysicalDevice, surface: vk.SurfaceKHR) !bool {\n    var format_count: u32 = undefined;\n    _ = try instance.getPhysicalDeviceSurfaceFormatsKHR(pdev, surface, &format_count, null);\n\n    var present_mode_count: u32 = undefined;\n    _ = try instance.getPhysicalDeviceSurfacePresentModesKHR(pdev, surface, &present_mode_count, null);\n\n    return format_count > 0 and present_mode_count > 0;\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "function",
      "name": "checkSurfaceSupport",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to checkExtensionSupport from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "fn checkExtensionSupport(\n    instance: Instance,\n    pdev: vk.PhysicalDevice,\n    allocator: Allocator,\n) !bool {\n    const propsv = try instance.enumerateDeviceExtensionPropertiesAlloc(pdev, null, allocator);\n    defer allocator.free(propsv);\n\n    for (required_device_extensions) |ext| {\n        for (propsv) |props| {\n            if (std.mem.eql(u8, std.mem.span(ext), std.mem.sliceTo(&props.extension_name, 0))) {\n                break;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "function",
      "name": "checkExtensionSupport",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to GraphicsContext from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "pub const GraphicsContext = struct {\n    pub const CommandBuffer = vk.CommandBufferProxy;\n\n    allocator: Allocator,\n\n    vkb: BaseWrapper,\n\n    instance: Instance,\n    debug_messenger: vk.DebugUtilsMessengerEXT,\n    surface: vk.SurfaceKHR,\n    pdev: vk.PhysicalDevice,\n    props: vk.PhysicalDeviceProperties,\n    mem_props: vk.PhysicalDeviceMemoryProperties,\n\n    dev: Device,\n    graphics_queue: Queue,\n    present_queue: Queue,\n\n    pub fn init(allocator: Allocator, app_name: [*:0]const u8, window: *c.GLFWwindow) !GraphicsContext {\n        var self: GraphicsContext = undefined;\n        self.allocator = allocator;\n        self.vkb = BaseWrapper.load(c.glfwGetInstanceProcAddress);\n\n        if (try checkLayerSupport(&self.vkb, self.allocator) == false) {\n            return error.MissingLayer;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "struct",
      "name": "GraphicsContext",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Queue from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "pub const Queue = struct {\n    handle: vk.Queue,\n    family: u32,\n\n    fn init(device: Device, family: u32) Queue {\n        return .{\n            .handle = device.getDeviceQueue(family, 0),\n            .family = family,\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "struct",
      "name": "Queue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to DeviceCandidate from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "const DeviceCandidate = struct {\n    pdev: vk.PhysicalDevice,\n    props: vk.PhysicalDeviceProperties,\n    queues: QueueAllocation,\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "struct",
      "name": "DeviceCandidate",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to QueueAllocation from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "const QueueAllocation = struct {\n    graphics_family: u32,\n    present_family: u32,\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "struct",
      "name": "QueueAllocation",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to queue_count from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "const queue_count: u32 = if (candidate.queues.graphics_family == candidate.queues.present_family)\n        1\n    else\n        2;",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "const",
      "name": "queue_count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to message from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "const message: [*c]const u8 = if (callback_data) |cb_data| cb_data.p_message else \"NO MESSAGE!\";",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "const",
      "name": "message",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to family from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/graphics_context.zig",
    "response": "const family: u32 = @intCast(i);",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/graphics_context.zig",
      "type": "const",
      "name": "family",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/shaders/fragment.zig",
    "response": "fn main() callconv(.spirv_fragment) void {\n    gpu.location(&v_color, 0);\n    gpu.location(&f_color, 0);\n\n    f_color = .{ v_color[0], v_color[1], v_color[2], 1.0 }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/shaders/fragment.zig",
      "type": "function",
      "name": "main",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to v_color from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/shaders/fragment.zig",
    "response": "const v_color: @Vector(3, f32) addrspace(.input);\nextern var f_color: @Vector(4, f32) addrspace(.output);\n\nexport fn main() callconv(.spirv_fragment) void {\n    gpu.location(&v_color, 0);\n    gpu.location(&f_color, 0);\n\n    f_color = .{ v_color[0], v_color[1], v_color[2], 1.0 };",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/shaders/fragment.zig",
      "type": "const",
      "name": "v_color",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/shaders/vertex.zig",
    "response": "fn main() callconv(.spirv_vertex) void {\n    gpu.location(&a_pos, 0);\n    gpu.location(&a_color, 1);\n    gpu.location(&v_color, 0);\n\n    gpu.position_out.* = .{ a_pos[0], a_pos[1], 0.0, 1.0 }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/shaders/vertex.zig",
      "type": "function",
      "name": "main",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to a_pos from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/shaders/vertex.zig",
    "response": "const a_pos: @Vector(2, f32) addrspace(.input);\nextern const a_color: @Vector(3, f32) addrspace(.input);\n\nextern var v_color: @Vector(3, f32) addrspace(.output);\n\nexport fn main() callconv(.spirv_vertex) void {\n    gpu.location(&a_pos, 0);\n    gpu.location(&a_color, 1);\n    gpu.location(&v_color, 0);\n\n    gpu.position_out.* = .{ a_pos[0], a_pos[1], 0.0, 1.0 };",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/shaders/vertex.zig",
      "type": "const",
      "name": "a_pos",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "pub fn init(gc: *const GraphicsContext, allocator: Allocator, extent: vk.Extent2D) !Swapchain {\n        return try initRecycle(gc, allocator, extent, .null_handle);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to initRecycle from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "pub fn initRecycle(gc: *const GraphicsContext, allocator: Allocator, extent: vk.Extent2D, old_handle: vk.SwapchainKHR) !Swapchain {\n        const caps = try gc.instance.getPhysicalDeviceSurfaceCapabilitiesKHR(gc.pdev, gc.surface);\n        const actual_extent = findActualExtent(caps, extent);\n        if (actual_extent.width == 0 or actual_extent.height == 0) {\n            return error.InvalidSurfaceDimensions;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "function",
      "name": "initRecycle",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinitExceptSwapchain from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "fn deinitExceptSwapchain(self: Swapchain) void {\n        for (self.swap_images) |si| si.deinit(self.gc);\n        self.allocator.free(self.swap_images);\n        self.gc.dev.destroySemaphore(self.next_image_acquired, null);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "function",
      "name": "deinitExceptSwapchain",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to waitForAllFences from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "pub fn waitForAllFences(self: Swapchain) !void {\n        for (self.swap_images) |si| si.waitForFence(self.gc) catch {}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "function",
      "name": "waitForAllFences",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "pub fn deinit(self: Swapchain) void {\n        // if we have no swapchain none of these should exist and we can just return\n        if (self.handle == .null_handle) return;\n        self.deinitExceptSwapchain();\n        self.gc.dev.destroySwapchainKHR(self.handle, null);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to recreate from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "pub fn recreate(self: *Swapchain, new_extent: vk.Extent2D) !void {\n        const gc = self.gc;\n        const allocator = self.allocator;\n        const old_handle = self.handle;\n        self.deinitExceptSwapchain();\n        // set current handle to NULL_HANDLE to signal that the current swapchain does no longer need to be\n        // de-initialized if we fail to recreate it.\n        self.handle = .null_handle;\n        self.* = initRecycle(gc, allocator, new_extent, old_handle) catch |err| switch (err) {\n            error.SwapchainCreationFailed => {\n                // we failed while recreating so our current handle still exists,\n                // but we won't destroy it in the deferred deinit of this object.\n                gc.dev.destroySwapchainKHR(old_handle, null);\n                return err;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "function",
      "name": "recreate",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to currentImage from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "pub fn currentImage(self: Swapchain) vk.Image {\n        return self.swap_images[self.image_index].image;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "function",
      "name": "currentImage",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to currentSwapImage from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "pub fn currentSwapImage(self: Swapchain) *const SwapImage {\n        return &self.swap_images[self.image_index];\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "function",
      "name": "currentSwapImage",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to present from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "pub fn present(self: *Swapchain, cmdbuf: vk.CommandBuffer) !PresentState {\n        // Simple method:\n        // 1) Acquire next image\n        // 2) Wait for and reset fence of the acquired image\n        // 3) Submit command buffer with fence of acquired image,\n        //    dependendent on the semaphore signalled by the first step.\n        // 4) Present current frame, dependent on semaphore signalled by previous step\n        // Problem: This way we can't reference the current image while rendering.\n        // Better method: Shuffle the steps around such that acquire next image is the last step,\n        // leaving the swapchain in a state with the current image.\n        // 1) Wait for and reset fence of current image\n        // 2) Submit command buffer, signalling fence of current image and dependent on\n        //    the semaphore signalled by step 4.\n        // 3) Present current frame, dependent on semaphore signalled by the submit\n        // 4) Acquire next image, signalling its semaphore\n        // One problem that arises is that we can't know beforehand which semaphore to signal,\n        // so we keep an extra auxilery semaphore that is swapped around\n\n        // Step 1: Make sure the current frame has finished rendering\n        const current = self.currentSwapImage();\n        try current.waitForFence(self.gc);\n        try self.gc.dev.resetFences(1, @ptrCast(&current.frame_fence));\n\n        // Step 2: Submit the command buffer\n        const wait_stage = [_]vk.PipelineStageFlags{.{ .top_of_pipe_bit = true }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "function",
      "name": "present",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "fn init(gc: *const GraphicsContext, image: vk.Image, format: vk.Format) !SwapImage {\n        const view = try gc.dev.createImageView(&.{\n            .image = image,\n            .view_type = .@\"2d\",\n            .format = format,\n            .components = .{ .r = .identity, .g = .identity, .b = .identity, .a = .identity }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "fn deinit(self: SwapImage, gc: *const GraphicsContext) void {\n        self.waitForFence(gc) catch return;\n        gc.dev.destroyImageView(self.view, null);\n        gc.dev.destroySemaphore(self.image_acquired, null);\n        gc.dev.destroySemaphore(self.render_finished, null);\n        gc.dev.destroyFence(self.frame_fence, null);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to waitForFence from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "fn waitForFence(self: SwapImage, gc: *const GraphicsContext) !void {\n        _ = try gc.dev.waitForFences(1, @ptrCast(&self.frame_fence), .true, std.math.maxInt(u64));\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "function",
      "name": "waitForFence",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to initSwapchainImages from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "fn initSwapchainImages(gc: *const GraphicsContext, swapchain: vk.SwapchainKHR, format: vk.Format, allocator: Allocator) ![]SwapImage {\n    const images = try gc.dev.getSwapchainImagesAllocKHR(swapchain, allocator);\n    defer allocator.free(images);\n\n    const swap_images = try allocator.alloc(SwapImage, images.len);\n    errdefer allocator.free(swap_images);\n\n    var i: usize = 0;\n    errdefer for (swap_images[0..i]) |si| si.deinit(gc);\n\n    for (images) |image| {\n        swap_images[i] = try SwapImage.init(gc, image, format);\n        i += 1;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "function",
      "name": "initSwapchainImages",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to findSurfaceFormat from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "fn findSurfaceFormat(gc: *const GraphicsContext, allocator: Allocator) !vk.SurfaceFormatKHR {\n    const preferred = vk.SurfaceFormatKHR{\n        .format = .b8g8r8a8_srgb,\n        .color_space = .srgb_nonlinear_khr,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "function",
      "name": "findSurfaceFormat",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to findPresentMode from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "fn findPresentMode(gc: *const GraphicsContext, allocator: Allocator) !vk.PresentModeKHR {\n    const present_modes = try gc.instance.getPhysicalDeviceSurfacePresentModesAllocKHR(gc.pdev, gc.surface, allocator);\n    defer allocator.free(present_modes);\n\n    const preferred = [_]vk.PresentModeKHR{\n        .mailbox_khr,\n        .immediate_khr,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "function",
      "name": "findPresentMode",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to findActualExtent from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "fn findActualExtent(caps: vk.SurfaceCapabilitiesKHR, extent: vk.Extent2D) vk.Extent2D {\n    if (caps.current_extent.width != 0xFFFF_FFFF) {\n        return caps.current_extent;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "function",
      "name": "findActualExtent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Swapchain from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "pub const Swapchain = struct {\n    pub const PresentState = enum {\n        optimal,\n        suboptimal,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "struct",
      "name": "Swapchain",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to SwapImage from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "const SwapImage = struct {\n    image: vk.Image,\n    view: vk.ImageView,\n    image_acquired: vk.Semaphore,\n    render_finished: vk.Semaphore,\n    frame_fence: vk.Fence,\n\n    fn init(gc: *const GraphicsContext, image: vk.Image, format: vk.Format) !SwapImage {\n        const view = try gc.dev.createImageView(&.{\n            .image = image,\n            .view_type = .@\"2d\",\n            .format = format,\n            .components = .{ .r = .identity, .g = .identity, .b = .identity, .a = .identity }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "struct",
      "name": "SwapImage",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to sharing_mode from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/swapchain.zig",
    "response": "const sharing_mode: vk.SharingMode = if (gc.graphics_queue.family != gc.present_queue.family)\n            .concurrent\n        else\n            .exclusive;",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/swapchain.zig",
      "type": "const",
      "name": "sharing_mode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/triangle.zig",
    "response": "pub fn main() !void {\n    if (c.glfwInit() != c.GLFW_TRUE) return error.GlfwInitFailed;\n    defer c.glfwTerminate();\n\n    if (c.glfwVulkanSupported() != c.GLFW_TRUE) {\n        std.log.err(\"GLFW could not find libvulkan\", .{}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/triangle.zig",
      "type": "function",
      "name": "main",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to uploadVertices from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/triangle.zig",
    "response": "fn uploadVertices(gc: *const GraphicsContext, pool: vk.CommandPool, buffer: vk.Buffer) !void {\n    const staging_buffer = try gc.dev.createBuffer(&.{\n        .size = @sizeOf(@TypeOf(vertices)),\n        .usage = .{ .transfer_src_bit = true }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/triangle.zig",
      "type": "function",
      "name": "uploadVertices",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to copyBuffer from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/triangle.zig",
    "response": "fn copyBuffer(gc: *const GraphicsContext, pool: vk.CommandPool, dst: vk.Buffer, src: vk.Buffer, size: vk.DeviceSize) !void {\n    var cmdbuf_handle: vk.CommandBuffer = undefined;\n    try gc.dev.allocateCommandBuffers(&.{\n        .command_pool = pool,\n        .level = .primary,\n        .command_buffer_count = 1,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/triangle.zig",
      "type": "function",
      "name": "copyBuffer",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to createCommandBuffers from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/triangle.zig",
    "response": "fn createCommandBuffers(\n    gc: *const GraphicsContext,\n    pool: vk.CommandPool,\n    allocator: Allocator,\n    buffer: vk.Buffer,\n    extent: vk.Extent2D,\n    render_pass: vk.RenderPass,\n    pipeline: vk.Pipeline,\n    framebuffers: []vk.Framebuffer,\n) ![]vk.CommandBuffer {\n    const cmdbufs = try allocator.alloc(vk.CommandBuffer, framebuffers.len);\n    errdefer allocator.free(cmdbufs);\n\n    try gc.dev.allocateCommandBuffers(&.{\n        .command_pool = pool,\n        .level = .primary,\n        .command_buffer_count = @intCast(cmdbufs.len),\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/triangle.zig",
      "type": "function",
      "name": "createCommandBuffers",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to destroyCommandBuffers from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/triangle.zig",
    "response": "fn destroyCommandBuffers(gc: *const GraphicsContext, pool: vk.CommandPool, allocator: Allocator, cmdbufs: []vk.CommandBuffer) void {\n    gc.dev.freeCommandBuffers(pool, @truncate(cmdbufs.len), cmdbufs.ptr);\n    allocator.free(cmdbufs);\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/triangle.zig",
      "type": "function",
      "name": "destroyCommandBuffers",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to createFramebuffers from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/triangle.zig",
    "response": "fn createFramebuffers(gc: *const GraphicsContext, allocator: Allocator, render_pass: vk.RenderPass, swapchain: Swapchain) ![]vk.Framebuffer {\n    const framebuffers = try allocator.alloc(vk.Framebuffer, swapchain.swap_images.len);\n    errdefer allocator.free(framebuffers);\n\n    var i: usize = 0;\n    errdefer for (framebuffers[0..i]) |fb| gc.dev.destroyFramebuffer(fb, null);\n\n    for (framebuffers) |*fb| {\n        fb.* = try gc.dev.createFramebuffer(&.{\n            .render_pass = render_pass,\n            .attachment_count = 1,\n            .p_attachments = @ptrCast(&swapchain.swap_images[i].view),\n            .width = swapchain.extent.width,\n            .height = swapchain.extent.height,\n            .layers = 1,\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/triangle.zig",
      "type": "function",
      "name": "createFramebuffers",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to destroyFramebuffers from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/triangle.zig",
    "response": "fn destroyFramebuffers(gc: *const GraphicsContext, allocator: Allocator, framebuffers: []const vk.Framebuffer) void {\n    for (framebuffers) |fb| gc.dev.destroyFramebuffer(fb, null);\n    allocator.free(framebuffers);\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/triangle.zig",
      "type": "function",
      "name": "destroyFramebuffers",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to createRenderPass from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/triangle.zig",
    "response": "fn createRenderPass(gc: *const GraphicsContext, swapchain: Swapchain) !vk.RenderPass {\n    const color_attachment = vk.AttachmentDescription{\n        .format = swapchain.surface_format.format,\n        .samples = .{ .@\"1_bit\" = true }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/triangle.zig",
      "type": "function",
      "name": "createRenderPass",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to createPipeline from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/triangle.zig",
    "response": "fn createPipeline(\n    gc: *const GraphicsContext,\n    layout: vk.PipelineLayout,\n    render_pass: vk.RenderPass,\n) !vk.Pipeline {\n    const vert = try gc.dev.createShaderModule(&.{\n        .code_size = vert_spv.len,\n        .p_code = @ptrCast(&vert_spv),\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/triangle.zig",
      "type": "function",
      "name": "createPipeline",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Vertex from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/triangle.zig",
    "response": "const Vertex = struct {\n    const binding_description = vk.VertexInputBindingDescription{\n        .binding = 0,\n        .stride = @sizeOf(Vertex),\n        .input_rate = .vertex,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/triangle.zig",
      "type": "struct",
      "name": "Vertex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to gpu_vertices from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: examples/triangle.zig",
    "response": "const gpu_vertices: [*]Vertex = @ptrCast(@alignCast(data));",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "examples/triangle.zig",
      "type": "const",
      "name": "gpu_vertices",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isZigPrimitiveType from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/id_render.zig",
    "response": "pub fn isZigPrimitiveType(name: []const u8) bool {\n    if (name.len > 1 and (name[0] == 'u' or name[0] == 'i')) {\n        for (name[1..]) |c| {\n            switch (c) {\n                '0'...'9' => {}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/id_render.zig",
      "type": "function",
      "name": "isZigPrimitiveType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeIdentifier from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/id_render.zig",
    "response": "pub fn writeIdentifier(w: *std.Io.Writer, id: []const u8) !void {\n    try w.print(\"{f}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/id_render.zig",
      "type": "function",
      "name": "writeIdentifier",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/id_render.zig",
    "response": "pub fn init(text: []const u8) SegmentIterator {\n        return .{\n            .text = text,\n            .offset = 0,\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/id_render.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nextBoundary from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/id_render.zig",
    "response": "fn nextBoundary(self: SegmentIterator) usize {\n        var i = self.offset + 1;\n\n        while (true) {\n            if (i == self.text.len or self.text[i] == '_') {\n                return i;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/id_render.zig",
      "type": "function",
      "name": "nextBoundary",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/id_render.zig",
    "response": "pub fn next(self: *SegmentIterator) ?[]const u8 {\n        while (self.offset < self.text.len and self.text[self.offset] == '_') {\n            self.offset += 1;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/id_render.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rest from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/id_render.zig",
    "response": "pub fn rest(self: SegmentIterator) []const u8 {\n        if (self.offset >= self.text.len) {\n            return &[_]u8{}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/id_render.zig",
      "type": "function",
      "name": "rest",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/id_render.zig",
    "response": "pub fn init(allocator: Allocator, tags: []const []const u8) IdRenderer {\n        return .{\n            .tags = tags,\n            .text_cache = .init(allocator),\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/id_render.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/id_render.zig",
    "response": "pub fn deinit(self: IdRenderer) void {\n        self.text_cache.deinit();\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/id_render.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderSnake from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/id_render.zig",
    "response": "fn renderSnake(self: *IdRenderer, screaming: bool, id: []const u8, tag: ?[]const u8) !void {\n        var it = SegmentIterator.init(id);\n        var first = true;\n\n        while (it.next()) |segment| {\n            if (first) {\n                first = false;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/id_render.zig",
      "type": "function",
      "name": "renderSnake",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderCamel from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/id_render.zig",
    "response": "fn renderCamel(self: *IdRenderer, title: bool, id: []const u8, tag: ?[]const u8) !void {\n        var it = SegmentIterator.init(id);\n        var lower_first = !title;\n\n        while (it.next()) |segment| {\n            var i: usize = 0;\n            while (i < segment.len and std.ascii.isDigit(segment[i])) {\n                try self.text_cache.writer.writeByte(segment[i]);\n                i += 1;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/id_render.zig",
      "type": "function",
      "name": "renderCamel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderFmt from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/id_render.zig",
    "response": "pub fn renderFmt(self: *IdRenderer, out: *std.Io.Writer, comptime fmt: []const u8, args: anytype) !void {\n        _ = self.text_cache.writer.consumeAll();\n        try self.text_cache.writer.print(fmt, args);\n        try writeIdentifier(out, self.text_cache.writer.buffered());\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/id_render.zig",
      "type": "function",
      "name": "renderFmt",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderWithCase from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/id_render.zig",
    "response": "pub fn renderWithCase(self: *IdRenderer, out: *std.Io.Writer, case_style: CaseStyle, id: []const u8) !void {\n        const tag = self.getAuthorTag(id);\n        // The trailing underscore doesn't need to be removed here as its removed by the SegmentIterator.\n        const adjusted_id = if (tag) |name| id[0 .. id.len - name.len] else id;\n\n        _ = self.text_cache.writer.consumeAll();\n\n        switch (case_style) {\n            .snake => try self.renderSnake(false, adjusted_id, tag),\n            .screaming_snake => try self.renderSnake(true, adjusted_id, tag),\n            .title => try self.renderCamel(true, adjusted_id, tag),\n            .camel => try self.renderCamel(false, adjusted_id, tag),\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/id_render.zig",
      "type": "function",
      "name": "renderWithCase",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getAuthorTag from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/id_render.zig",
    "response": "pub fn getAuthorTag(self: IdRenderer, id: []const u8) ?[]const u8 {\n        for (self.tags) |tag| {\n            if (mem.endsWith(u8, id, tag)) {\n                return tag;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/id_render.zig",
      "type": "function",
      "name": "getAuthorTag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stripAuthorTag from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/id_render.zig",
    "response": "pub fn stripAuthorTag(self: IdRenderer, id: []const u8) []const u8 {\n        if (self.getAuthorTag(id)) |tag| {\n            return mem.trimRight(u8, id[0 .. id.len - tag.len], \"_\");\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/id_render.zig",
      "type": "function",
      "name": "stripAuthorTag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to SegmentIterator from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/id_render.zig",
    "response": "pub const SegmentIterator = struct {\n    text: []const u8,\n    offset: usize,\n\n    pub fn init(text: []const u8) SegmentIterator {\n        return .{\n            .text = text,\n            .offset = 0,\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/id_render.zig",
      "type": "struct",
      "name": "SegmentIterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to IdRenderer from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/id_render.zig",
    "response": "pub const IdRenderer = struct {\n    tags: []const []const u8,\n    text_cache: std.Io.Writer.Allocating,\n\n    pub fn init(allocator: Allocator, tags: []const []const u8) IdRenderer {\n        return .{\n            .tags = tags,\n            .text_cache = .init(allocator),\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/id_render.zig",
      "type": "struct",
      "name": "IdRenderer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to invalidUsage from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/main.zig",
    "response": "fn invalidUsage(prog_name: []const u8, comptime fmt: []const u8, args: anytype) noreturn {\n    std.log.err(fmt, args);\n    std.log.err(\"see {s}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/main.zig",
      "type": "function",
      "name": "invalidUsage",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to reportParseErrors from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/main.zig",
    "response": "fn reportParseErrors(tree: std.zig.Ast) !void {\n    var buf: [1024]u8 = undefined;\n    var stderr = std.fs.File.stderr().writer(&buf);\n    const w = &stderr.interface;\n    for (tree.errors) |err| {\n        const loc = tree.tokenLocation(0, err.token);\n        try w.print(\"(vulkan-zig error):{}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/main.zig",
      "type": "function",
      "name": "reportParseErrors",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to oomPanic from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/main.zig",
    "response": "fn oomPanic() noreturn {\n    @panic(\"Out of memory\");\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/main.zig",
      "type": "function",
      "name": "oomPanic",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/main.zig",
    "response": "pub fn main() !void {\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n\n    var args = std.process.argsWithAllocator(allocator) catch |err| switch (err) {\n        error.OutOfMemory => oomPanic(),\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/main.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to peek from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn peek(self: CTokenizer) ?u8 {\n        return if (self.offset < self.source.len) self.source[self.offset] else null;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "peek",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to consumeNoEof from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn consumeNoEof(self: *CTokenizer) u8 {\n        const c = self.peek().?;\n        self.offset += 1;\n        return c;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "consumeNoEof",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to consume from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn consume(self: *CTokenizer) !u8 {\n        return if (self.offset < self.source.len)\n            return self.consumeNoEof()\n        else\n            return null;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "consume",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to keyword from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn keyword(self: *CTokenizer) Token {\n        const start = self.offset;\n        _ = self.consumeNoEof();\n\n        while (true) {\n            const c = self.peek() orelse break;\n            switch (c) {\n                'A'...'Z', 'a'...'z', '_', '0'...'9' => _ = self.consumeNoEof(),\n                else => break,\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "keyword",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to int from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn int(self: *CTokenizer) Token {\n        const start = self.offset;\n        _ = self.consumeNoEof();\n\n        const hex = self.peek() == 'x';\n        if (hex) {\n            _ = self.consumeNoEof();\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "int",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to skipws from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn skipws(self: *CTokenizer) void {\n        while (true) {\n            switch (self.peek() orelse break) {\n                ' ', '\\t', '\\n', '\\r' => _ = self.consumeNoEof(),\n                else => break,\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "skipws",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "pub fn next(self: *CTokenizer) !?Token {\n        self.skipws();\n        if (mem.startsWith(u8, self.source[self.offset..], \"//\") or self.in_comment) {\n            const end = mem.indexOfScalarPos(u8, self.source, self.offset, '\\n') orelse {\n                self.offset = self.source.len;\n                self.in_comment = true;\n                return null;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "pub fn init(elem: *xml.Element) XmlCTokenizer {\n        return .{\n            .it = elem.iterator(),\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to elemToToken from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn elemToToken(elem: *xml.Element) !?Token {\n        // Sometimes we encounter empty comment tags. Filter those out\n        // by early returning here, otherwise the next check will\n        // determine that the input is not valid XML.\n        if (mem.eql(u8, elem.tag, \"comment\")) {\n            return null;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "elemToToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn next(self: *XmlCTokenizer) !?Token {\n        if (self.current) |current| {\n            const token = current;\n            self.current = null;\n            return token;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nextNoEof from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn nextNoEof(self: *XmlCTokenizer) !Token {\n        return (try self.next()) orelse return error.UnexpectedEof;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "nextNoEof",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to peek from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn peek(self: *XmlCTokenizer) !?Token {\n        if (self.current) |current| {\n            return current;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "peek",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to peekNoEof from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn peekNoEof(self: *XmlCTokenizer) !Token {\n        return (try self.peek()) orelse return error.UnexpectedEof;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "peekNoEof",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to expect from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn expect(self: *XmlCTokenizer, kind: Token.Kind) !Token {\n        const tok = (try self.next()) orelse return error.UnexpectedEof;\n        if (tok.kind != kind) {\n            return error.UnexpectedToken;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "expect",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseTypedef from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "pub fn parseTypedef(allocator: Allocator, xctok: *XmlCTokenizer, ptrs_optional: bool) !registry.Declaration {\n    _ = try xctok.expect(.kw_typedef);\n    const decl = try parseDeclaration(allocator, xctok, ptrs_optional);\n    _ = try xctok.expect(.semicolon);\n    if (try xctok.peek()) |_| {\n        return error.InvalidSyntax;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "parseTypedef",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseMember from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "pub fn parseMember(allocator: Allocator, xctok: *XmlCTokenizer, ptrs_optional: bool) !registry.Container.Field {\n    const decl = try parseDeclaration(allocator, xctok, ptrs_optional);\n    var field = registry.Container.Field{\n        .name = decl.name orelse return error.MissingTypeIdentifier,\n        .field_type = decl.decl_type,\n        .bits = null,\n        .is_buffer_len = false,\n        .is_optional = false,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "parseMember",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseParamOrProto from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "pub fn parseParamOrProto(allocator: Allocator, xctok: *XmlCTokenizer, ptrs_optional: bool) !registry.Declaration {\n    var decl = try parseDeclaration(allocator, xctok, ptrs_optional);\n    if (try xctok.peek()) |_| {\n        return error.InvalidSyntax;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "parseParamOrProto",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseDeclaration from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn parseDeclaration(allocator: Allocator, xctok: *XmlCTokenizer, ptrs_optional: bool) ParseError!Declaration {\n    // Parse declaration constness\n    var tok = try xctok.nextNoEof();\n    const inner_is_const = tok.kind == .kw_const;\n    if (inner_is_const) {\n        tok = try xctok.nextNoEof();\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "parseDeclaration",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseFnPtrSuffix from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn parseFnPtrSuffix(allocator: Allocator, xctok: *XmlCTokenizer, return_type: TypeInfo, ptrs_optional: bool) !?Declaration {\n    const lparen = try xctok.peek();\n    if (lparen == null or lparen.?.kind != .lparen) {\n        return null;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "parseFnPtrSuffix",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parsePointers from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn parsePointers(allocator: Allocator, xctok: *XmlCTokenizer, inner_const: bool, inner: TypeInfo, ptrs_optional: bool) !TypeInfo {\n    var type_info = inner;\n    var first_const = inner_const;\n\n    while (true) {\n        var tok = (try xctok.peek()) orelse return type_info;\n        var is_const = first_const;\n        first_const = false;\n\n        if (tok.kind == .kw_const) {\n            is_const = true;\n            _ = try xctok.nextNoEof();\n            tok = (try xctok.peek()) orelse return type_info;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "parsePointers",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseArrayDeclarator from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn parseArrayDeclarator(xctok: *XmlCTokenizer) !?ArraySize {\n    const lbracket = try xctok.peek();\n    if (lbracket == null or lbracket.?.kind != .lbracket) {\n        return null;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "parseArrayDeclarator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseVersion from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "pub fn parseVersion(xctok: *XmlCTokenizer) !registry.ApiConstant.Value {\n    _ = try xctok.expect(.hash);\n    const define = try xctok.expect(.id);\n    if (!mem.eql(u8, define.text, \"define\")) {\n        return error.InvalidVersion;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "parseVersion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseVersionValues from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn parseVersionValues(xctok: *XmlCTokenizer, comptime count: usize) ![count][]const u8 {\n    _ = try xctok.expect(.lparen);\n    var version: [count][]const u8 = undefined;\n    for (&version, 0..) |*part, i| {\n        if (i != 0) {\n            _ = try xctok.expect(.comma);\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "parseVersionValues",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to testTokenizer from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "fn testTokenizer(tokenizer: anytype, expected_tokens: []const Token) !void {\n    for (expected_tokens) |expected| {\n        const tok = (tokenizer.next() catch unreachable).?;\n        try testing.expectEqual(expected.kind, tok.kind);\n        try testing.expectEqualSlices(u8, expected.text, tok.text);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "function",
      "name": "testTokenizer",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Token from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "pub const Token = struct {\n    kind: Kind,\n    text: []const u8,\n\n    const Kind = enum {\n        id, // Any id thats not a keyword\n        name, // Vulkan <name>...</name>\n        type_name, // Vulkan <type>...</type>\n        enum_name, // Vulkan <enum>...</enum>\n        int,\n        star,\n        comma,\n        semicolon,\n        colon,\n        minus,\n        tilde,\n        dot,\n        hash,\n        lparen,\n        rparen,\n        lbracket,\n        rbracket,\n        kw_typedef,\n        kw_const,\n        kw_vkapi_ptr,\n        kw_struct,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "struct",
      "name": "Token",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to CTokenizer from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "pub const CTokenizer = struct {\n    source: []const u8,\n    offset: usize = 0,\n    in_comment: bool = false,\n\n    fn peek(self: CTokenizer) ?u8 {\n        return if (self.offset < self.source.len) self.source[self.offset] else null;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "struct",
      "name": "CTokenizer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to XmlCTokenizer from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "pub const XmlCTokenizer = struct {\n    it: xml.Element.ChildIterator,\n    ctok: ?CTokenizer = null,\n    current: ?Token = null,\n\n    pub fn init(elem: *xml.Element) XmlCTokenizer {\n        return .{\n            .it = elem.iterator(),\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "struct",
      "name": "XmlCTokenizer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Declaration from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/c_parse.zig",
    "response": "pub const Declaration = struct {\n    name: ?[]const u8, // Parameter names may be optional, especially in case of func(void)\n    decl_type: TypeInfo,\n    is_const: bool,\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/c_parse.zig",
      "type": "struct",
      "name": "Declaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/generator.zig",
    "response": "fn init(arena: Allocator, registry: *reg.Registry) EnumFieldMerger {\n        return .{\n            .arena = arena,\n            .registry = registry,\n            .enum_extensions = .{}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/generator.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to putEnumExtension from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/generator.zig",
    "response": "fn putEnumExtension(self: *EnumFieldMerger, enum_name: []const u8, field: reg.Enum.Field) !void {\n        const res = try self.enum_extensions.getOrPut(self.arena, enum_name);\n        if (!res.found_existing) {\n            res.value_ptr.* = .empty;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/generator.zig",
      "type": "function",
      "name": "putEnumExtension",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addRequires from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/generator.zig",
    "response": "fn addRequires(self: *EnumFieldMerger, reqs: []const reg.Require) !void {\n        for (reqs) |req| {\n            for (req.extends) |enum_ext| {\n                switch (enum_ext.value) {\n                    .field => try self.putEnumExtension(enum_ext.extends, enum_ext.value.field),\n                    .new_api_constant_expr => |expr| try self.api_constants.put(\n                        self.arena,\n                        enum_ext.extends,\n                        .{\n                            .name = enum_ext.extends,\n                            .value = .{ .expr = expr }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/generator.zig",
      "type": "function",
      "name": "addRequires",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to mergeEnumFields from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/generator.zig",
    "response": "fn mergeEnumFields(self: *EnumFieldMerger, name: []const u8, base_enum: *reg.Enum) !void {\n        // If there are no extensions for this enum, assume its valid.\n        const extensions = self.enum_extensions.get(name) orelse return;\n\n        self.field_set.clearRetainingCapacity();\n\n        const n_fields_upper_bound = base_enum.fields.len + extensions.items.len;\n        const new_fields = try self.arena.alloc(reg.Enum.Field, n_fields_upper_bound);\n        var i: usize = 0;\n\n        for (base_enum.fields) |field| {\n            const res = try self.field_set.getOrPut(self.arena, field.name);\n            if (!res.found_existing) {\n                new_fields[i] = field;\n                i += 1;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/generator.zig",
      "type": "function",
      "name": "mergeEnumFields",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to merge from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/generator.zig",
    "response": "fn merge(self: *EnumFieldMerger) !void {\n        for (self.registry.api_constants) |api_constant| {\n            try self.api_constants.put(self.arena, api_constant.name, api_constant);\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/generator.zig",
      "type": "function",
      "name": "merge",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/generator.zig",
    "response": "fn init(allocator: Allocator, spec: *xml.Element, maybe_video_spec: ?*xml.Element, api: reg.Api) !Generator {\n        const result = try parseXml(allocator, spec, maybe_video_spec, api);\n\n        const tags = try allocator.alloc([]const u8, result.registry.tags.len);\n        for (tags, result.registry.tags) |*tag, registry_tag| tag.* = registry_tag.name;\n\n        return Generator{\n            .arena = result.arena,\n            .registry = result.registry,\n            .id_renderer = IdRenderer.init(allocator, tags),\n            .have_video = maybe_video_spec != null,\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/generator.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/generator.zig",
    "response": "fn deinit(self: Generator) void {\n        self.arena.deinit();\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/generator.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stripFlagBits from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/generator.zig",
    "response": "fn stripFlagBits(self: Generator, name: []const u8) []const u8 {\n        const tagless = self.id_renderer.stripAuthorTag(name);\n        return tagless[0 .. tagless.len - \"FlagBits\".len];\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/generator.zig",
      "type": "function",
      "name": "stripFlagBits",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stripFlags from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/generator.zig",
    "response": "fn stripFlags(self: Generator, name: []const u8) []const u8 {\n        const tagless = self.id_renderer.stripAuthorTag(name);\n        return tagless[0 .. tagless.len - \"Flags\".len];\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/generator.zig",
      "type": "function",
      "name": "stripFlags",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to mergeEnumFields from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/generator.zig",
    "response": "fn mergeEnumFields(self: *Generator) !void {\n        var merger = EnumFieldMerger.init(self.arena.allocator(), &self.registry);\n        try merger.merge();\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/generator.zig",
      "type": "function",
      "name": "mergeEnumFields",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fixupBitFlags from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/generator.zig",
    "response": "fn fixupBitFlags(self: *Generator) !void {\n        var seen_bits = std.StringArrayHashMap(void).init(self.arena.allocator());\n        defer seen_bits.deinit();\n\n        for (self.registry.decls) |decl| {\n            const bitmask = switch (decl.decl_type) {\n                .bitmask => |bm| bm,\n                else => continue,\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/generator.zig",
      "type": "function",
      "name": "fixupBitFlags",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to render from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/generator.zig",
    "response": "fn render(self: *Generator, writer: *std.Io.Writer) !void {\n        try renderRegistry(writer, self.arena.allocator(), &self.registry, &self.id_renderer, self.have_video);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/generator.zig",
      "type": "function",
      "name": "render",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generate from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/generator.zig",
    "response": "pub fn generate(\n    allocator: Allocator,\n    api: Api,\n    spec_xml: []const u8,\n    maybe_video_spec_xml: ?[]const u8,\n    writer: *std.Io.Writer,\n) !void {\n    const spec = xml.parse(allocator, spec_xml) catch |err| switch (err) {\n        error.InvalidDocument,\n        error.UnexpectedEof,\n        error.UnexpectedCharacter,\n        error.IllegalCharacter,\n        error.InvalidEntity,\n        error.InvalidName,\n        error.InvalidStandaloneValue,\n        error.NonMatchingClosingTag,\n        error.UnclosedComment,\n        error.UnclosedValue,\n        => return error.InvalidXml,\n        error.OutOfMemory => return error.OutOfMemory,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/generator.zig",
      "type": "function",
      "name": "generate",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to EnumFieldMerger from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/generator.zig",
    "response": "const EnumFieldMerger = struct {\n    const EnumExtensionMap = std.StringArrayHashMapUnmanaged(std.ArrayListUnmanaged(reg.Enum.Field));\n    const ApiConstantMap = std.StringArrayHashMapUnmanaged(reg.ApiConstant);\n    const FieldSet = std.StringArrayHashMapUnmanaged(void);\n\n    arena: Allocator,\n    registry: *reg.Registry,\n    enum_extensions: EnumExtensionMap,\n    api_constants: ApiConstantMap,\n    field_set: FieldSet,\n\n    fn init(arena: Allocator, registry: *reg.Registry) EnumFieldMerger {\n        return .{\n            .arena = arena,\n            .registry = registry,\n            .enum_extensions = .{}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/generator.zig",
      "type": "struct",
      "name": "EnumFieldMerger",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Generator from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/generator.zig",
    "response": "pub const Generator = struct {\n    arena: std.heap.ArenaAllocator,\n    registry: reg.Registry,\n    id_renderer: IdRenderer,\n    have_video: bool,\n\n    fn init(allocator: Allocator, spec: *xml.Element, maybe_video_spec: ?*xml.Element, api: reg.Api) !Generator {\n        const result = try parseXml(allocator, spec, maybe_video_spec, api);\n\n        const tags = try allocator.alloc([]const u8, result.registry.tags.len);\n        for (tags, result.registry.tags) |*tag, registry_tag| tag.* = registry_tag.name;\n\n        return Generator{\n            .arena = result.arena,\n            .registry = result.registry,\n            .id_renderer = IdRenderer.init(allocator, tags),\n            .have_video = maybe_video_spec != null,\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/generator.zig",
      "type": "struct",
      "name": "Generator",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "pub fn deinit(self: ParseResult) void {\n        self.arena.deinit();\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseXml from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "pub fn parseXml(\n    backing_allocator: Allocator,\n    root: *xml.Element,\n    maybe_video_root: ?*xml.Element,\n    api: registry.Api,\n) !ParseResult {\n    var arena = ArenaAllocator.init(backing_allocator);\n    errdefer arena.deinit();\n\n    const allocator = arena.allocator();\n\n    var decls: std.ArrayList(registry.Declaration) = .empty;\n    var api_constants: std.ArrayList(registry.ApiConstant) = .empty;\n    var tags: std.ArrayList(registry.Tag) = .empty;\n    var features: std.ArrayList(registry.Feature) = .empty;\n    var extensions: std.ArrayList(registry.Extension) = .empty;\n\n    try parseDeclarations(allocator, root, api, &decls);\n    try parseApiConstants(allocator, root, api, &api_constants);\n    try parseTags(allocator, root, &tags);\n    try parseFeatures(allocator, root, api, &features);\n    try parseExtensions(allocator, root, api, &extensions);\n\n    if (maybe_video_root) |video_root| {\n        try parseDeclarations(allocator, video_root, api, &decls);\n        try parseApiConstants(allocator, video_root, api, &api_constants);\n        try parseTags(allocator, video_root, &tags);\n        try parseFeatures(allocator, video_root, api, &features);\n        try parseExtensions(allocator, video_root, api, &extensions);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseXml",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseDeclarations from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseDeclarations(\n    allocator: Allocator,\n    root: *xml.Element,\n    api: registry.Api,\n    decls: *std.ArrayList(registry.Declaration),\n) !void {\n    const types_elem = root.findChildByTag(\"types\") orelse return error.InvalidRegistry;\n    try decls.ensureUnusedCapacity(allocator, types_elem.children.len);\n\n    try parseTypes(allocator, types_elem, api, decls);\n    try parseEnums(allocator, root, api, decls);\n\n    if (root.findChildByTag(\"commands\")) |commands_elem| {\n        try decls.ensureUnusedCapacity(allocator, commands_elem.children.len);\n        try parseCommands(allocator, commands_elem, api, decls);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseDeclarations",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseTypes from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseTypes(\n    allocator: Allocator,\n    types_elem: *xml.Element,\n    api: registry.Api,\n    decls: *std.ArrayList(registry.Declaration),\n) !void {\n    var it = types_elem.findChildrenByTag(\"type\");\n    while (it.next()) |ty| {\n        try decls.append(allocator, blk: {\n            if (!requiredByApi(ty, api))\n                continue;\n\n            const category = ty.getAttribute(\"category\") orelse {\n                break :blk try parseForeigntype(ty);\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseTypes",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseForeigntype from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseForeigntype(ty: *xml.Element) !registry.Declaration {\n    const name = ty.getAttribute(\"name\") orelse return error.InvalidRegistry;\n    const depends = ty.getAttribute(\"requires\") orelse if (mem.eql(u8, name, \"int\"))\n        \"vk_platform\" // for some reason, int doesn't depend on vk_platform (but the other c types do)\n    else\n        return error.InvalidRegistry;\n\n    return registry.Declaration{\n        .name = name,\n        .decl_type = .{ .foreign = .{ .depends = depends }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseForeigntype",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseBitmaskType from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseBitmaskType(ty: *xml.Element) !registry.Declaration {\n    if (ty.getAttribute(\"name\")) |name| {\n        const alias = ty.getAttribute(\"alias\") orelse return error.InvalidRegistry;\n        return registry.Declaration{\n            .name = name,\n            .decl_type = .{ .alias = .{ .name = alias, .target = .other_type }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseBitmaskType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseHandleType from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseHandleType(ty: *xml.Element) !registry.Declaration {\n    // Parent is not handled in case of an alias\n    if (ty.getAttribute(\"name\")) |name| {\n        const alias = ty.getAttribute(\"alias\") orelse return error.InvalidRegistry;\n        return registry.Declaration{\n            .name = name,\n            .decl_type = .{\n                .alias = .{ .name = alias, .target = .other_type }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseHandleType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseBaseType from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseBaseType(allocator: Allocator, ty: *xml.Element) !registry.Declaration {\n    const name = ty.getCharData(\"name\") orelse return error.InvalidRegistry;\n    if (ty.getCharData(\"type\")) |_| {\n        var tok = cparse.XmlCTokenizer.init(ty);\n        return try cparse.parseTypedef(allocator, &tok, false);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseBaseType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseContainer from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseContainer(allocator: Allocator, ty: *xml.Element, is_union: bool, api: registry.Api) !registry.Declaration {\n    const name = ty.getAttribute(\"name\") orelse return error.InvalidRegistry;\n\n    if (ty.getAttribute(\"alias\")) |alias| {\n        return registry.Declaration{\n            .name = name,\n            .decl_type = .{\n                .alias = .{ .name = alias, .target = .other_type }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseContainer",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseFuncPointer from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseFuncPointer(allocator: Allocator, ty: *xml.Element) !registry.Declaration {\n    var xctok = cparse.XmlCTokenizer.init(ty);\n    return try cparse.parseTypedef(allocator, &xctok, true);\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseFuncPointer",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to lenToPointer from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn lenToPointer(fields: Fields, len: []const u8) std.meta.Tuple(&.{ registry.Pointer.PointerSize, bool }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "lenToPointer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parsePointerMeta from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parsePointerMeta(fields: Fields, type_info: *registry.TypeInfo, elem: *xml.Element) !void {\n    var len_attribute_depth: usize = 0;\n\n    if (elem.getAttribute(\"len\")) |lens| {\n        var it = mem.splitScalar(u8, lens, ',');\n        var current_type_info = type_info;\n\n        while (true) switch (current_type_info.*) {\n            .pointer => |*ptr| {\n                if (it.next()) |len_str| {\n                    ptr.size, ptr.is_optional = lenToPointer(fields, len_str);\n                }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parsePointerMeta",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseEnumAlias from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseEnumAlias(elem: *xml.Element) !?registry.Declaration {\n    if (elem.getAttribute(\"alias\")) |alias| {\n        const name = elem.getAttribute(\"name\") orelse return error.InvalidRegistry;\n        return registry.Declaration{\n            .name = name,\n            .decl_type = .{\n                .alias = .{ .name = alias, .target = .other_type }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseEnumAlias",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseEnums from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseEnums(\n    allocator: Allocator,\n    root: *xml.Element,\n    api: registry.Api,\n    decls: *std.ArrayList(registry.Declaration),\n) !void {\n    var it = root.findChildrenByTag(\"enums\");\n    while (it.next()) |enums| {\n        const name = enums.getAttribute(\"name\") orelse return error.InvalidRegistry;\n        if (mem.eql(u8, name, api_constants_name) or !requiredByApi(enums, api)) {\n            continue;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseEnums",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseEnumFields from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseEnumFields(allocator: Allocator, elem: *xml.Element, api: registry.Api) !registry.Enum {\n    // TODO: `type` was added recently, fall back to checking endswith FlagBits for older versions?\n    const enum_type = elem.getAttribute(\"type\") orelse return error.InvalidRegistry;\n    const is_bitmask = mem.eql(u8, enum_type, \"bitmask\");\n    if (!is_bitmask and !mem.eql(u8, enum_type, \"enum\")) {\n        return error.InvalidRegistry;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseEnumFields",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseEnumField from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseEnumField(field: *xml.Element) !registry.Enum.Field {\n    const is_compat_alias = if (field.getAttribute(\"comment\")) |comment|\n        mem.eql(u8, comment, \"Backwards-compatible alias containing a typo\") or\n            mem.eql(u8, comment, \"Deprecated name for backwards compatibility\")\n    else\n        false;\n\n    const name = field.getAttribute(\"name\") orelse return error.InvalidRegistry;\n    const value: registry.Enum.Value = blk: {\n        // An enum variant's value could be defined by any of the following attributes:\n        // - value: Straight up value of the enum variant, in either base 10 or 16 (prefixed with 0x).\n        // - bitpos: Used for bitmasks, and can also be set in extensions.\n        // - alias: The field is an alias of another variant within the same enum.\n        // - offset: Used with features and extensions, where a non-bitpos value is added to an enum.\n        //     The value is given by `1e9 + (extr_nr - 1) * 1e3 + offset`, where `ext_nr` is either\n        //     given by the `extnumber` field (in the case of a feature), or given in the parent <extension>\n        //     tag. In the latter case its passed via the `ext_nr` parameter.\n        if (field.getAttribute(\"value\")) |value| {\n            if (mem.startsWith(u8, value, \"0x\")) {\n                break :blk .{ .bit_vector = try std.fmt.parseInt(i32, value[2..], 16) }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseEnumField",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseCommands from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseCommands(\n    allocator: Allocator,\n    commands_elem: *xml.Element,\n    api: registry.Api,\n    decls: *std.ArrayList(registry.Declaration),\n) !void {\n    var it = commands_elem.findChildrenByTag(\"command\");\n    while (it.next()) |elem| {\n        if (!requiredByApi(elem, api))\n            continue;\n\n        try decls.append(allocator, try parseCommand(allocator, elem, api));\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseCommands",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to splitCommaAlloc from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn splitCommaAlloc(allocator: Allocator, text: []const u8) ![][]const u8 {\n    var n_codes: usize = 1;\n    for (text) |c| {\n        if (c == ',') n_codes += 1;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "splitCommaAlloc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseCommand from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseCommand(allocator: Allocator, elem: *xml.Element, api: registry.Api) !registry.Declaration {\n    if (elem.getAttribute(\"alias\")) |alias| {\n        const name = elem.getAttribute(\"name\") orelse return error.InvalidRegistry;\n        return registry.Declaration{\n            .name = name,\n            .decl_type = .{\n                .alias = .{ .name = alias, .target = .other_command }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseCommand",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseApiConstants from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseApiConstants(\n    allocator: Allocator,\n    root: *xml.Element,\n    api: registry.Api,\n    api_constants: *std.ArrayList(registry.ApiConstant),\n) !void {\n    const maybe_enums = blk: {\n        var it = root.findChildrenByTag(\"enums\");\n        while (it.next()) |child| {\n            const name = child.getAttribute(\"name\") orelse continue;\n            if (mem.eql(u8, name, api_constants_name)) {\n                break :blk child;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseApiConstants",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseDefines from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseDefines(\n    allocator: Allocator,\n    types: *xml.Element,\n    api: registry.Api,\n    api_constants: *std.ArrayList(registry.ApiConstant),\n) !void {\n    var it = types.findChildrenByTag(\"type\");\n    while (it.next()) |ty| {\n        if (!requiredByApi(ty, api))\n            continue;\n\n        const category = ty.getAttribute(\"category\") orelse continue;\n        if (!mem.eql(u8, category, \"define\")) {\n            continue;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseDefines",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseTags from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseTags(\n    allocator: Allocator,\n    root: *xml.Element,\n    tags: *std.ArrayList(registry.Tag),\n) !void {\n    var tags_elem = root.findChildByTag(\"tags\") orelse return;\n    try tags.ensureUnusedCapacity(allocator, tags_elem.children.len);\n\n    var it = tags_elem.findChildrenByTag(\"tag\");\n    while (it.next()) |tag| {\n        tags.appendAssumeCapacity(.{\n            .name = tag.getAttribute(\"name\") orelse return error.InvalidRegistry,\n            .author = tag.getAttribute(\"author\") orelse return error.InvalidRegistry,\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseTags",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseFeatures from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseFeatures(allocator: Allocator, root: *xml.Element, api: registry.Api, features: *std.ArrayList(registry.Feature)) !void {\n    var it = root.findChildrenByTag(\"feature\");\n    while (it.next()) |feature| {\n        if (!requiredByApi(feature, api))\n            continue;\n\n        try features.append(allocator, try parseFeature(allocator, feature, api));\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseFeatures",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseFeature from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseFeature(allocator: Allocator, feature: *xml.Element, api: registry.Api) !registry.Feature {\n    const name = feature.getAttribute(\"name\") orelse return error.InvalidRegistry;\n    const feature_level = blk: {\n        const number = feature.getAttribute(\"number\") orelse return error.InvalidRegistry;\n        break :blk try splitFeatureLevel(number, \".\");\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseFeature",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseEnumExtension from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseEnumExtension(elem: *xml.Element, parent_extnumber: ?u31) !?registry.Require.EnumExtension {\n    // check for either _SPEC_VERSION or _EXTENSION_NAME\n    const name = elem.getAttribute(\"name\") orelse return error.InvalidRegistry;\n    if (std.mem.endsWith(u8, name, \"_SPEC_VERSION\") or std.mem.endsWith(u8, name, \"_EXTENSION_NAME\")) {\n        return null;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseEnumExtension",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to enumExtOffsetToValue from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn enumExtOffsetToValue(extnumber: u31, offset: u31) u31 {\n    const extension_value_base = 1000000000;\n    const extension_block = 1000;\n    return extension_value_base + (extnumber - 1) * extension_block + offset;\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "enumExtOffsetToValue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseRequire from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseRequire(allocator: Allocator, require: *xml.Element, extnumber: ?u31, api: registry.Api) !registry.Require {\n    var n_extends: usize = 0;\n    var n_types: usize = 0;\n    var n_commands: usize = 0;\n\n    var it = require.elements();\n    while (it.next()) |elem| {\n        if (mem.eql(u8, elem.tag, \"enum\")) {\n            n_extends += 1;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseRequire",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseExtensions from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseExtensions(\n    allocator: Allocator,\n    root: *xml.Element,\n    api: registry.Api,\n    extensions: *std.ArrayList(registry.Extension),\n) !void {\n    const extensions_elem = root.findChildByTag(\"extensions\") orelse return error.InvalidRegistry;\n    try extensions.ensureUnusedCapacity(allocator, extensions_elem.children.len);\n\n    var it = extensions_elem.findChildrenByTag(\"extension\");\n    while (it.next()) |extension| {\n        if (!requiredByApi(extension, api))\n            continue;\n        // Some extensions (in particular 94) are disabled, so just skip them\n        if (extension.getAttribute(\"supported\")) |supported| {\n            if (mem.eql(u8, supported, \"disabled\")) {\n                continue;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseExtensions",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to findExtVersion from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn findExtVersion(extension: *xml.Element) !registry.Extension.Version {\n    var req_it = extension.findChildrenByTag(\"require\");\n    while (req_it.next()) |req| {\n        var enum_it = req.findChildrenByTag(\"enum\");\n        while (enum_it.next()) |e| {\n            const name = e.getAttribute(\"name\") orelse continue;\n            const value = e.getAttribute(\"value\") orelse continue;\n            if (mem.endsWith(u8, name, \"_SPEC_VERSION\")) {\n                // Vulkan Video extensions are sometimes aliases.\n                // If we fail to parse it as integer, just assume that its an alias and return that.\n                const version = std.fmt.parseInt(u32, value, 10) catch return .{ .alias = value }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "findExtVersion",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseExtension from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn parseExtension(allocator: Allocator, extension: *xml.Element, api: registry.Api) !registry.Extension {\n    const name = extension.getAttribute(\"name\") orelse return error.InvalidRegistry;\n    const platform = extension.getAttribute(\"platform\");\n\n    const is_video = std.mem.startsWith(u8, name, \"vulkan_video_\");\n\n    const version = try findExtVersion(extension);\n\n    // For some reason there are two ways for an extension to state its required\n    // feature level: both seperately in each <require> tag, or using\n    // the requiresCore attribute.\n    const requires_core = if (extension.getAttribute(\"requiresCore\")) |feature_level|\n        try splitFeatureLevel(feature_level, \".\")\n    else\n        null;\n\n    const promoted_to: registry.Extension.Promotion = blk: {\n        const promotedto = extension.getAttribute(\"promotedto\") orelse break :blk .none;\n        if (mem.startsWith(u8, promotedto, \"VK_VERSION_\")) {\n            const feature_level = try splitFeatureLevel(promotedto[\"VK_VERSION_\".len..], \"_\");\n            break :blk .{ .feature = feature_level }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "parseExtension",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to splitFeatureLevel from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn splitFeatureLevel(ver: []const u8, split: []const u8) !registry.FeatureLevel {\n    var it = mem.splitSequence(u8, ver, split);\n\n    const major = it.next() orelse return error.InvalidFeatureLevel;\n    const minor = it.next() orelse return error.InvalidFeatureLevel;\n    if (it.next() != null) {\n        return error.InvalidFeatureLevel;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "splitFeatureLevel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to requiredByApi from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "fn requiredByApi(elem: *xml.Element, api: registry.Api) bool {\n    const apis = elem.getAttribute(\"api\") orelse return true; // If the 'api' element is not present, assume required.\n\n    var it = mem.splitScalar(u8, apis, ',');\n    while (it.next()) |required_by_api| {\n        if (std.mem.eql(u8, @tagName(api), required_by_api)) return true;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "function",
      "name": "requiredByApi",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ParseResult from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "pub const ParseResult = struct {\n    arena: ArenaAllocator,\n    registry: registry.Registry,\n\n    pub fn deinit(self: ParseResult) void {\n        self.arena.deinit();\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "struct",
      "name": "ParseResult",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to bitwidth from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "const bitwidth: u8 = if (mem.eql(u8, flags_type, \"VkFlags\"))\n            32\n        else if (mem.eql(u8, flags_type, \"VkFlags64\"))\n            64\n        else\n            return error.InvalidRegistry;",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "const",
      "name": "bitwidth",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to promoted_to from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "const promoted_to: registry.Extension.Promotion = blk: {\n        const promotedto = extension.getAttribute(\"promotedto\") orelse break :blk .none;",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "const",
      "name": "promoted_to",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ext_type from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/parse.zig",
    "response": "const ext_type: ?registry.Extension.ExtensionType = blk: {\n        if (is_video) break :blk .video;",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/parse.zig",
      "type": "const",
      "name": "ext_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Registry from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const Registry = struct {\n    decls: []Declaration,\n    api_constants: []ApiConstant,\n    tags: []Tag,\n    features: []Feature,\n    extensions: []Extension,\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "Registry",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Declaration from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const Declaration = struct {\n    name: []const u8,\n    decl_type: DeclarationType,\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "Declaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Alias from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const Alias = struct {\n    pub const Target = enum {\n        other_command,\n        other_type,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "Alias",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ApiConstant from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const ApiConstant = struct {\n    pub const Value = union(enum) {\n        expr: []const u8,\n        version: [4][]const u8,\n        video_std_version: [3][]const u8,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "ApiConstant",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Tag from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const Tag = struct {\n    name: []const u8,\n    author: []const u8,\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "Tag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Container from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const Container = struct {\n    pub const Field = struct {\n        name: []const u8,\n        field_type: TypeInfo,\n        bits: ?usize,\n        is_buffer_len: bool,\n        is_optional: bool,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "Container",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Enum from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const Enum = struct {\n    pub const Value = union(enum) {\n        bitpos: u6, // 1 << bitpos\n        bit_vector: i32, // Combined flags & some vendor IDs\n        int: i32,\n        alias: struct {\n            name: []const u8,\n            is_compat_alias: bool,\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "Enum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Field from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const Field = struct {\n        name: []const u8,\n        value: Value,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "Field",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Bitmask from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const Bitmask = struct {\n    bits_enum: ?[]const u8,\n    bitwidth: u8,\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "Bitmask",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Handle from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const Handle = struct {\n    parent: ?[]const u8, // VkInstance has no parent\n    is_dispatchable: bool,\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "Handle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Command from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const Command = struct {\n    pub const Param = struct {\n        name: []const u8,\n        param_type: TypeInfo,\n        is_buffer_len: bool,\n        is_optional: bool,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "Command",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Pointer from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const Pointer = struct {\n    pub const PointerSize = union(enum) {\n        one,\n        /// The length is given by some complex expression, possibly involving another field\n        many,\n        /// The length is given by some other field or parameter\n        other_field: []const u8,\n        zero_terminated,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "Pointer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Array from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const Array = struct {\n    pub const ArraySize = union(enum) {\n        int: usize,\n        alias: []const u8, // Field size is given by an api constant\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "Array",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Foreign from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const Foreign = struct {\n    depends: []const u8, // Either a header or vk_platform\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "Foreign",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Feature from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const Feature = struct {\n    name: []const u8,\n    level: FeatureLevel, // from 'number'\n    requires: []Require,\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "Feature",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Extension from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const Extension = struct {\n    pub const ExtensionType = enum {\n        instance,\n        device,\n        video,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "Extension",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Require from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const Require = struct {\n    pub const EnumExtension = struct {\n        pub const Value = union(enum) {\n            field: Enum.Field,\n            new_api_constant_expr: []const u8,\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "Require",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FeatureLevel from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/registry.zig",
    "response": "pub const FeatureLevel = struct {\n    major: u32,\n    minor: u32,\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/registry.zig",
      "type": "struct",
      "name": "FeatureLevel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to FlagsMixin from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn FlagsMixin(comptime FlagsType: type) type {\n    \\\\    return struct {\n    \\\\        pub const IntType = @typeInfo(FlagsType).@\"struct\".backing_integer.?;\n    \\\\        pub fn toInt(self: FlagsType) IntType {\n    \\\\            return @bitCast(self);\n    \\\\        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "FlagsMixin",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromInt from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn fromInt(flags: IntType) FlagsType {\n    \\\\            return @bitCast(flags);\n    \\\\        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "fromInt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to merge from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn merge(lhs: FlagsType, rhs: FlagsType) FlagsType {\n    \\\\            return fromInt(toInt(lhs) | toInt(rhs));\n    \\\\        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "merge",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to intersect from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn intersect(lhs: FlagsType, rhs: FlagsType) FlagsType {\n    \\\\            return fromInt(toInt(lhs) & toInt(rhs));\n    \\\\        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "intersect",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to complement from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn complement(self: FlagsType) FlagsType {\n    \\\\            return fromInt(~toInt(self));\n    \\\\        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "complement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to subtract from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn subtract(lhs: FlagsType, rhs: FlagsType) FlagsType {\n    \\\\            return fromInt(toInt(lhs) & toInt(rhs.complement()));\n    \\\\        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "subtract",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to contains from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn contains(lhs: FlagsType, rhs: FlagsType) bool {\n    \\\\            return toInt(intersect(lhs, rhs)) == toInt(rhs);\n    \\\\        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "contains",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to FlagFormatMixin from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn FlagFormatMixin(comptime FlagsType: type) type {\n    \\\\    return struct {\n    \\\\        pub fn format(\n    \\\\            self: FlagsType,\n    \\\\            writer: anytype,\n    \\\\        ) !void {\n    \\\\            try writer.writeAll(@typeName(FlagsType) ++ \"{\");\n    \\\\            var first = true;\n    \\\\            @setEvalBranchQuota(100_000);\n    \\\\            inline for (comptime std.meta.fieldNames(FlagsType)) |name| {\n    \\\\                if (name[0] == '_') continue;\n    \\\\                if (@field(self, name)) {\n    \\\\                    if (first) {\n    \\\\                        try writer.writeAll(\" .\" ++ name);\n    \\\\                        first = false;\n    \\\\                    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "FlagFormatMixin",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to makeApiVersion from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn makeApiVersion(variant: u3, major: u7, minor: u10, patch: u12) Version {\n    \\\\    return .{ .variant = variant, .major = major, .minor = minor, .patch = patch }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "makeApiVersion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to CommandFlagsMixin from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn CommandFlagsMixin(comptime CommandFlags: type) type {\n    \\\\    return struct {\n    \\\\        pub fn merge(lhs: CommandFlags, rhs: CommandFlags) CommandFlags {\n    \\\\            var result: CommandFlags = .{}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "CommandFlagsMixin",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to intersect from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn intersect(lhs: CommandFlags, rhs: CommandFlags) CommandFlags {\n    \\\\            var result: CommandFlags = .{}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "intersect",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to complement from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn complement(self: CommandFlags) CommandFlags {\n    \\\\            var result: CommandFlags = .{}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "complement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to subtract from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn subtract(lhs: CommandFlags, rhs: CommandFlags) CommandFlags {\n    \\\\            var result: CommandFlags = .{}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "subtract",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to contains from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn contains(lhs: CommandFlags, rhs: CommandFlags) bool {\n    \\\\            @setEvalBranchQuota(10_000);\n    \\\\            inline for (@typeInfo(CommandFlags).@\"struct\".fields) |field| {\n    \\\\                if (!@field(lhs, field.name) and @field(rhs, field.name)) {\n    \\\\                    return false;\n    \\\\                }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "contains",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to name from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn name(self: CommandDispatchType) []const u8 {\n        return switch (self) {\n            .base => \"Base\",\n            .instance => \"Instance\",\n            .device => \"Device\",\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "name",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nameLower from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn nameLower(self: CommandDispatchType) []const u8 {\n        return switch (self) {\n            .base => \"base\",\n            .instance => \"instance\",\n            .device => \"device\",\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "nameLower",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getEnumerateFunctionDataType from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn getEnumerateFunctionDataType(command: reg.Command) !reg.TypeInfo {\n    if (command.params.len < 2) {\n        return error.InvalidRegistry;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "getEnumerateFunctionDataType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eqlIgnoreCase from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn eqlIgnoreCase(lhs: []const u8, rhs: []const u8) bool {\n    if (lhs.len != rhs.len) {\n        return false;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "eqlIgnoreCase",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to trimVkNamespace from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn trimVkNamespace(id: []const u8) []const u8 {\n    const prefixes = [_][]const u8{ \"VK_\", \"vk\", \"Vk\", \"PFN_vk\" }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "trimVkNamespace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn init(\n        writer: *std.Io.Writer,\n        allocator: Allocator,\n        registry: *const reg.Registry,\n        id_renderer: *IdRenderer,\n        have_video: bool,\n    ) !Self {\n        var decls_by_name = std.StringArrayHashMap(reg.DeclarationType).init(allocator);\n        errdefer decls_by_name.deinit();\n\n        for (registry.decls) |*decl| {\n            const result = try decls_by_name.getOrPut(decl.name);\n            if (result.found_existing) {\n                // Allow overriding 'foreign' types. These are for example the Vulkan Video types\n                // declared as foreign type in the vk.xml, then defined in video.xml. Sometimes\n                // this also includes types like uint32_t, for these we don't really care.\n                // Just make sure to keep the non-foreign variant.\n                if (result.value_ptr.* == .foreign) {\n                    result.value_ptr.* = decl.decl_type;\n                }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn deinit(self: *Self) void {\n        self.decls_by_name.deinit();\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeIdentifier from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn writeIdentifier(self: Self, id: []const u8) !void {\n        try id_render.writeIdentifier(self.writer, id);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "writeIdentifier",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeIdentifierWithCase from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn writeIdentifierWithCase(self: *Self, case: CaseStyle, id: []const u8) !void {\n        try self.id_renderer.renderWithCase(self.writer, case, id);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "writeIdentifierWithCase",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeIdentifierFmt from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn writeIdentifierFmt(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        try self.id_renderer.renderFmt(self.writer, fmt, args);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "writeIdentifierFmt",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to extractEnumFieldName from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn extractEnumFieldName(self: Self, enum_name: []const u8, field_name: []const u8) ![]const u8 {\n        const adjusted_enum_name = self.id_renderer.stripAuthorTag(enum_name);\n\n        var enum_it = id_render.SegmentIterator.init(adjusted_enum_name);\n        var field_it = id_render.SegmentIterator.init(field_name);\n\n        while (true) {\n            const rest = field_it.rest();\n            const field_segment = field_it.next() orelse return error.InvalidRegistry;\n            const enum_segment = enum_it.next() orelse return rest;\n\n            if (!eqlIgnoreCase(enum_segment, field_segment)) {\n                return rest;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "extractEnumFieldName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to extractBitflagFieldName from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn extractBitflagFieldName(bitflag_name: BitflagName, field_name: []const u8) ![]const u8 {\n        var flag_it = id_render.SegmentIterator.init(bitflag_name.base_name);\n        var field_it = id_render.SegmentIterator.init(field_name);\n\n        while (true) {\n            const rest = field_it.rest();\n            const field_segment = field_it.next() orelse return error.InvalidRegistry;\n            const flag_segment = flag_it.next() orelse {\n                if (bitflag_name.revision) |revision| {\n                    if (mem.eql(u8, revision, field_segment))\n                        return field_it.rest();\n                }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "extractBitflagFieldName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to extractBitflagName from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn extractBitflagName(self: Self, name: []const u8) !?BitflagName {\n        const tag = self.id_renderer.getAuthorTag(name);\n        const tagless_name = if (tag) |tag_name| name[0 .. name.len - tag_name.len] else name;\n\n        // Strip out the \"version\" number of a bitflag, like VkAccessFlagBits2KHR.\n        const base_name = std.mem.trimRight(u8, tagless_name, \"0123456789\");\n\n        const maybe_flag_bits_index = mem.lastIndexOf(u8, base_name, \"FlagBits\");\n        if (maybe_flag_bits_index == null) {\n            return null;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "extractBitflagName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isFlags from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn isFlags(self: Self, name: []const u8) bool {\n        const tag = self.id_renderer.getAuthorTag(name);\n        const tagless_name = if (tag) |tag_name| name[0 .. name.len - tag_name.len] else name;\n        const base_name = std.mem.trimRight(u8, tagless_name, \"0123456789\");\n        return mem.endsWith(u8, base_name, \"Flags\");\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "isFlags",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveDeclaration from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn resolveDeclaration(self: Self, name: []const u8) ?reg.DeclarationType {\n        const decl = self.decls_by_name.get(name) orelse return null;\n        return self.resolveAlias(decl) catch return null;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "resolveDeclaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveAlias from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn resolveAlias(self: Self, start_decl: reg.DeclarationType) !reg.DeclarationType {\n        var decl = start_decl;\n        while (true) {\n            const name = switch (decl) {\n                .alias => |alias| alias.name,\n                else => return decl,\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "resolveAlias",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isInOutPointer from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn isInOutPointer(self: Self, ptr: reg.Pointer) !bool {\n        if (ptr.child.* != .name) {\n            return false;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "isInOutPointer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to classifyParam from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn classifyParam(self: Self, param: reg.Command.Param) !ParamType {\n        switch (param.param_type) {\n            .pointer => |ptr| {\n                if (param.is_buffer_len) {\n                    if (ptr.is_const or ptr.is_optional) {\n                        return error.InvalidRegistry;\n                    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "classifyParam",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to classifyCommandDispatch from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn classifyCommandDispatch(name: []const u8, command: reg.Command) CommandDispatchType {\n        if (dispatch_override_functions.get(name)) |dispatch_type| {\n            return dispatch_type;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "classifyCommandDispatch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to render from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn render(self: *Self) !void {\n        try self.writer.writeAll(preamble);\n\n        try self.writer.print(\"pub const have_vulkan_video = {}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "render",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderApiConstant from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderApiConstant(self: *Self, api_constant: reg.ApiConstant) !void {\n        try self.writer.writeAll(\"pub const \");\n        try self.renderName(api_constant.name);\n        try self.writer.writeAll(\" = \");\n\n        switch (api_constant.value) {\n            .expr => |expr| try self.renderApiConstantExpr(expr),\n            inline .version, .video_std_version => |version, kind| {\n                try self.writer.writeAll(\"makeApiVersion(\");\n                // For Vulkan Video, just re-use the API version and set the variant to 0.\n                if (kind == .video_std_version) {\n                    try self.writer.writeAll(\"0, \");\n                }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderApiConstant",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderApiConstantExpr from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderApiConstantExpr(self: *Self, expr: []const u8) !void {\n        const adjusted_expr = if (expr.len > 2 and expr[0] == '(' and expr[expr.len - 1] == ')')\n            expr[1 .. expr.len - 1]\n        else\n            expr;\n\n        var tokenizer = cparse.CTokenizer{ .source = adjusted_expr }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderApiConstantExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderTypeInfo from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderTypeInfo(self: *Self, type_info: reg.TypeInfo) RenderTypeInfoError!void {\n        switch (type_info) {\n            .name => |name| try self.renderName(name),\n            .command_ptr => |command_ptr| try self.renderCommandPtr(command_ptr, true),\n            .pointer => |pointer| try self.renderPointer(pointer),\n            .array => |array| try self.renderArray(array),\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderTypeInfo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderName from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderName(self: *Self, name: []const u8) !void {\n        if (builtin_types.get(name)) |zig_name| {\n            try self.writer.writeAll(zig_name);\n            return;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderCommandPtr from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderCommandPtr(self: *Self, command_ptr: reg.Command, optional: bool) !void {\n        if (optional) {\n            try self.writer.writeByte('?');\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderCommandPtr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderPointer from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderPointer(self: *Self, pointer: reg.Pointer) !void {\n        const child_is_void = pointer.child.* == .name and mem.eql(u8, pointer.child.name, \"void\");\n\n        if (pointer.is_optional) {\n            try self.writer.writeByte('?');\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderPointer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderArray from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderArray(self: *Self, array: reg.Array) !void {\n        try self.writer.writeByte('[');\n        switch (array.size) {\n            .int => |size| try self.writer.print(\"{}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderArray",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderDecl from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderDecl(self: *Self, decl: reg.Declaration) !void {\n        if (try self.renderSpecial(decl.name)) {\n            return;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderDecl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderAssign from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderAssign(self: *Self, name: []const u8) !void {\n        try self.writer.writeAll(\"pub const \");\n        try self.renderName(name);\n        try self.writer.writeAll(\" = \");\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderAssign",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderSpecial from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderSpecial(self: *Self, name: []const u8) !bool {\n        const maybe_author = self.id_renderer.getAuthorTag(name);\n        const basename = self.id_renderer.stripAuthorTag(name);\n        if (std.mem.eql(u8, basename, \"VkBool32\")) {\n            try self.renderAssign(name);\n            try self.writer.writeAll(\n                \\\\enum(i32) {\n                \\\\    false,\n                \\\\    true,\n                \\\\    _,\n                \\\\}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderSpecial",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderSimpleBitContainer from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderSimpleBitContainer(self: *Self, container: reg.Container) !bool {\n        var total_bits: usize = 0;\n        var is_flags_container = true;\n        for (container.fields) |field| {\n            const bits = field.bits orelse {\n                // C abi type - not a packed struct.\n                return false;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderSimpleBitContainer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderContainer from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderContainer(self: *Self, name: []const u8, container: reg.Container) !void {\n        try self.writer.writeAll(\"pub const \");\n        try self.renderName(name);\n        try self.writer.writeAll(\" = \");\n\n        if (try self.renderSimpleBitContainer(container)) {\n            return;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderContainer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderContainerDefaultField from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderContainerDefaultField(self: *Self, name: []const u8, container: reg.Container, field: reg.Container.Field) !void {\n        if (mem.eql(u8, field.name, \"sType\")) {\n            if (container.stype == null) {\n                return;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderContainerDefaultField",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isFeatureStruct from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn isFeatureStruct(name: []const u8, maybe_extends: ?[]const []const u8) bool {\n        if (std.mem.eql(u8, name, \"VkPhysicalDeviceFeatures\")) return true;\n        if (maybe_extends) |extends| {\n            return for (extends) |extend| {\n                if (mem.eql(u8, extend, \"VkDeviceCreateInfo\")) break true;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "isFeatureStruct",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderEnumFieldName from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderEnumFieldName(self: *Self, name: []const u8, field_name: []const u8) !void {\n        try self.writeIdentifierWithCase(.snake, try self.extractEnumFieldName(name, field_name));\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderEnumFieldName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderEnumeration from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderEnumeration(self: *Self, name: []const u8, enumeration: reg.Enum) !void {\n        if (enumeration.is_bitmask) {\n            try self.renderBitmaskBits(name, enumeration);\n            return;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderEnumeration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to bitmaskFlagsType from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn bitmaskFlagsType(bitwidth: u8) ![]const u8 {\n        return switch (bitwidth) {\n            32 => \"Flags\",\n            64 => \"Flags64\",\n            else => return error.InvalidRegistry,\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "bitmaskFlagsType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderBitmaskBits from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderBitmaskBits(self: *Self, name: []const u8, bits: reg.Enum) !void {\n        try self.writer.writeAll(\"pub const \");\n        try self.renderName(name);\n        const flags_type = try bitmaskFlagsType(bits.bitwidth);\n        try self.writer.print(\" = packed struct({s}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderBitmaskBits",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderBitmask from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderBitmask(self: *Self, name: []const u8, bitmask: reg.Bitmask) !void {\n        if (bitmask.bits_enum == null) {\n            // The bits structure is generated by renderBitmaskBits, but that wont\n            // output flags with no associated bits type.\n\n            const flags_type = try bitmaskFlagsType(bitmask.bitwidth);\n\n            try self.writer.writeAll(\"pub const \");\n            try self.renderName(name);\n            try self.writer.print(\n                \\\\ = packed struct {{\n                \\\\_reserved_bits: {s}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderBitmask",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderFlagFunctions from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderFlagFunctions(\n        self: *Self,\n        name: []const u8,\n        mixin: []const u8,\n        functions: []const []const u8,\n        name_suffix: ?[]const u8,\n    ) !void {\n        try self.writer.writeAll(\"\\n\");\n        for (functions) |function| {\n            try self.writer.print(\"pub const {s}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderFlagFunctions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderHandle from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderHandle(self: *Self, name: []const u8, handle: reg.Handle) !void {\n        const backing_type: []const u8 = if (handle.is_dispatchable) \"usize\" else \"u64\";\n\n        try self.writer.writeAll(\"pub const \");\n        try self.renderName(name);\n        try self.writer.print(\" = enum({s}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderHandle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderAlias from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderAlias(self: *Self, name: []const u8, alias: reg.Alias) !void {\n        if (alias.target == .other_command) {\n            return;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderAlias",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderExternal from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderExternal(self: *Self, name: []const u8) !void {\n        try self.writer.writeAll(\"pub const \");\n        try self.renderName(name);\n        try self.writer.writeAll(\" = opaque {}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderExternal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderForeign from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderForeign(self: *Self, name: []const u8, foreign: reg.Foreign) !void {\n        if (mem.eql(u8, foreign.depends, \"vk_platform\") or\n            builtin_types.get(name) != null)\n        {\n            return; // Skip built-in types, they are handled differently\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderForeign",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderTypedef from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderTypedef(self: *Self, name: []const u8, type_info: reg.TypeInfo) !void {\n        try self.writer.writeAll(\"pub const \");\n        try self.renderName(name);\n        try self.writer.writeAll(\" = \");\n        try self.renderTypeInfo(type_info);\n        try self.writer.writeAll(\";\\n\");\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderTypedef",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderCommandPtrName from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderCommandPtrName(self: *Self, name: []const u8) !void {\n        try self.writeIdentifierFmt(\"Pfn{s}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderCommandPtrName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderCommandPtrs from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderCommandPtrs(self: *Self) !void {\n        for (self.decls_by_name.keys(), self.decls_by_name.values()) |name, decl_type| {\n            switch (decl_type) {\n                .command => {\n                    try self.writer.writeAll(\"pub const \");\n                    try self.renderCommandPtrName(name);\n                    try self.writer.writeAll(\" = \");\n                    try self.renderCommandPtr(decl_type.command, false);\n                    try self.writer.writeAll(\";\\n\");\n                }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderCommandPtrs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderFeatureInfo from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderFeatureInfo(self: *Self) !void {\n        try self.writer.writeAll(\n            \\\\pub const features = struct {\n            \\\\\n        );\n        for (self.registry.features) |feature| {\n            try self.writer.writeAll(\"pub const \");\n            try self.writeIdentifierWithCase(.snake, trimVkNamespace(feature.name));\n            try self.writer.writeAll(\"= ApiInfo {\\n\");\n            try self.writer.print(\".name = \\\"{s}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderFeatureInfo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderExtensionInfo from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderExtensionInfo(self: *Self) !void {\n        try self.writer.writeAll(\n            \\\\pub const extensions = struct {\n            \\\\\n        );\n        for (self.registry.extensions) |ext| {\n            try self.writer.writeAll(\"pub const \");\n            if (ext.extension_type == .video) {\n                // These are already in the right form, and the auto-casing style transformer\n                // is prone to messing up these names.\n                try self.writeIdentifier(trimVkNamespace(ext.name));\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderExtensionInfo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderDispatchTables from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderDispatchTables(self: *Self) !void {\n        try self.renderDispatchTable(.base);\n        try self.renderDispatchTable(.instance);\n        try self.renderDispatchTable(.device);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderDispatchTables",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderDispatchTable from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderDispatchTable(self: *Self, dispatch_type: CommandDispatchType) !void {\n        try self.writer.print(\n            \"pub const {s}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderDispatchTable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderWrappers from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderWrappers(self: *Self) !void {\n        try self.writer.writeAll(command_flags_mixin);\n        try self.renderWrappersOfDispatchType(.base);\n        try self.renderWrappersOfDispatchType(.instance);\n        try self.renderWrappersOfDispatchType(.device);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderWrappers",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderWrappersOfDispatchType from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderWrappersOfDispatchType(self: *Self, dispatch_type: CommandDispatchType) !void {\n        const name = dispatch_type.name();\n\n        try self.writer.print(\n            \\\\pub const {0s}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderWrappersOfDispatchType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderWrapperLoader from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderWrapperLoader(self: *Self, dispatch_type: CommandDispatchType) !void {\n        const params = switch (dispatch_type) {\n            .base => \"loader: anytype\",\n            .instance => \"instance: Instance, loader: anytype\",\n            .device => \"device: Device, loader: anytype\",\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderWrapperLoader",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to load from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn load({[params]s}) Self {{\n            \\\\    var self: Self = .{{ .dispatch = .{{}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "load",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderProxies from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderProxies(self: *Self) !void {\n        try self.renderProxy(.instance, \"VkInstance\", true);\n        try self.renderProxy(.device, \"VkDevice\", true);\n        try self.renderProxy(.device, \"VkCommandBuffer\", false);\n        try self.renderProxy(.device, \"VkQueue\", false);\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderProxies",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderProxy from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderProxy(\n        self: *Self,\n        dispatch_type: CommandDispatchType,\n        dispatch_handle: []const u8,\n        also_add_other_commands: bool,\n    ) !void {\n        const loader_name = dispatch_type.name();\n\n        try self.writer.print(\n            \\\\pub const {0s}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderProxy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn init(handle: {0s}, wrapper: *const Wrapper) Self {{\n            \\\\        return .{{\n            \\\\            .handle = handle,\n            \\\\            .wrapper = wrapper,\n            \\\\        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderProxyCommand from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderProxyCommand(self: *Self, name: []const u8, command: reg.Command, dispatch_handle: []const u8) !void {\n        const returns_vk_result = command.return_type.* == .name and mem.eql(u8, command.return_type.name, \"VkResult\");\n        const returns = try self.extractReturns(command);\n\n        if (returns_vk_result) {\n            try self.writer.writeAll(\"pub const \");\n            try self.renderErrorSetName(name);\n            try self.writer.writeAll(\" = Wrapper.\");\n            try self.renderErrorSetName(name);\n            try self.writer.writeAll(\";\\n\");\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderProxyCommand",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to makeAllocWrapperName from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn makeAllocWrapperName(self: *Self, wrapped_name: []const u8) ![]const u8 {\n        const tag = self.id_renderer.getAuthorTag(wrapped_name) orelse \"\";\n        const base_len = wrapped_name.len - tag.len;\n        return std.mem.concat(self.allocator, u8, &.{ wrapped_name[0..base_len], \"Alloc\", tag }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "makeAllocWrapperName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderProxyCommandAlloc from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderProxyCommandAlloc(self: *Self, wrapped_name: []const u8, command: reg.Command, dispatch_handle: []const u8) !void {\n        const returns_vk_result = command.return_type.* == .name and mem.eql(u8, command.return_type.name, \"VkResult\");\n\n        const name = try self.makeAllocWrapperName(wrapped_name);\n        defer self.allocator.free(name);\n\n        if (command.params.len < 2) {\n            return error.InvalidRegistry;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderProxyCommandAlloc",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to derefName from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn derefName(name: []const u8) []const u8 {\n        var it = id_render.SegmentIterator.init(name);\n        return if (mem.eql(u8, it.next().?, \"p\"))\n            name[1..]\n        else\n            name;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "derefName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderWrapperName from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderWrapperName(\n        self: *Self,\n        name: []const u8,\n        dispatch_handle: []const u8,\n        kind: WrapperKind,\n    ) !void {\n        const trimmed_name = switch (kind) {\n            .wrapper => trimVkNamespace(name),\n            .proxy => blk: {\n                // Strip additional namespaces: queue for VkQueue and cmd for VkCommandBuffer\n                const no_vk = trimVkNamespace(name);\n                const additional_namespace = additional_namespaces.get(dispatch_handle) orelse break :blk no_vk;\n                if (std.mem.startsWith(u8, no_vk, additional_namespace)) {\n                    break :blk no_vk[additional_namespace.len..];\n                }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderWrapperName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderWrapperParam from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderWrapperParam(self: *Self, param: reg.Command.Param) !void {\n        try self.writeIdentifierWithCase(.snake, param.name);\n        try self.writer.writeAll(\": \");\n        try self.renderTypeInfo(param.param_type);\n        try self.writer.writeAll(\", \");\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderWrapperParam",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderWrapperPrototype from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderWrapperPrototype(\n        self: *Self,\n        name: []const u8,\n        command: reg.Command,\n        returns: []const ReturnValue,\n        dispatch_handle: []const u8,\n        kind: WrapperKind,\n    ) !void {\n        try self.writer.writeAll(\"pub fn \");\n        try self.renderWrapperName(name, dispatch_handle, kind);\n        try self.writer.writeAll(\"(self: Self, \");\n\n        for (command.params) |param| {\n            const class = try self.classifyParam(param);\n            // Skip the dispatch type for proxying wrappers\n            if (kind == .proxy and class == .dispatch_handle and mem.eql(u8, param.param_type.name, dispatch_handle)) {\n                continue;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderWrapperPrototype",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderWrapperCall from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderWrapperCall(\n        self: *Self,\n        name: []const u8,\n        command: reg.Command,\n        returns: []const ReturnValue,\n        return_var_name: ?[]const u8,\n    ) !void {\n        try self.writer.writeAll(\"self.dispatch.\");\n        try self.writeIdentifier(name);\n        try self.writer.writeAll(\".?(\");\n\n        for (command.params) |param| {\n            switch (try self.classifyParam(param)) {\n                .out_pointer => {\n                    try self.writer.writeByte('&');\n                    try self.writeIdentifierWithCase(.snake, return_var_name.?);\n                    if (returns.len > 1) {\n                        try self.writer.writeByte('.');\n                        try self.writeIdentifierWithCase(.snake, derefName(param.name));\n                    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderWrapperCall",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to extractReturns from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn extractReturns(self: *Self, command: reg.Command) ![]const ReturnValue {\n        const allocator = self.allocator;\n        var returns: std.ArrayList(ReturnValue) = .empty;\n\n        if (command.return_type.* == .name) {\n            const return_name = command.return_type.name;\n            if (!mem.eql(u8, return_name, \"void\") and !mem.eql(u8, return_name, \"VkResult\")) {\n                try returns.append(allocator, .{\n                    .name = \"return_value\",\n                    .return_value_type = command.return_type.*,\n                    .origin = .inner_return_value,\n                }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "extractReturns",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderReturnStructName from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderReturnStructName(self: *Self, command_name: []const u8) !void {\n        try self.writeIdentifierFmt(\"{s}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderReturnStructName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderErrorSetName from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderErrorSetName(self: *Self, name: []const u8) !void {\n        try self.writeIdentifierWithCase(.title, trimVkNamespace(name));\n        try self.writer.writeAll(\"Error\");\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderErrorSetName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderReturnStruct from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderReturnStruct(self: *Self, command_name: []const u8, returns: []const ReturnValue) !void {\n        try self.writer.writeAll(\"pub const \");\n        try self.renderReturnStructName(command_name);\n        try self.writer.writeAll(\" = struct {\\n\");\n        for (returns) |ret| {\n            try self.writeIdentifierWithCase(.snake, ret.name);\n            try self.writer.writeAll(\": \");\n            try self.renderTypeInfo(ret.return_value_type);\n            try self.writer.writeAll(\", \");\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderReturnStruct",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderWrapper from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderWrapper(self: *Self, name: []const u8, command: reg.Command) !void {\n        const returns_vk_result = command.return_type.* == .name and mem.eql(u8, command.return_type.name, \"VkResult\");\n        const returns_void = command.return_type.* == .name and mem.eql(u8, command.return_type.name, \"void\");\n\n        const returns = try self.extractReturns(command);\n\n        if (returns.len > 1) {\n            try self.renderReturnStruct(name, returns);\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderWrapper",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderAllocWrapperPrototype from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderAllocWrapperPrototype(\n        self: *Self,\n        name: []const u8,\n        params: []const reg.Command.Param,\n        returns_vk_result: bool,\n        data_type: reg.TypeInfo,\n        dispatch_handle: []const u8,\n        kind: WrapperKind,\n    ) !void {\n        try self.writer.writeAll(\"pub fn \");\n        try self.renderWrapperName(name, \"\", .wrapper);\n        try self.writer.writeAll(\"(self: Self, \");\n        for (params) |param| {\n            const class = try self.classifyParam(param);\n            // Skip the dispatch type for proxying wrappers\n            if (kind == .proxy and class == .dispatch_handle and mem.eql(u8, param.param_type.name, dispatch_handle)) {\n                continue;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderAllocWrapperPrototype",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderWrapperAlloc from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderWrapperAlloc(self: *Self, wrapped_name: []const u8, command: reg.Command) !void {\n        const returns_vk_result = command.return_type.* == .name and mem.eql(u8, command.return_type.name, \"VkResult\");\n\n        const name = try self.makeAllocWrapperName(wrapped_name);\n        defer self.allocator.free(name);\n\n        if (command.params.len < 2) {\n            return error.InvalidRegistry;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderWrapperAlloc",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderErrorSwitch from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderErrorSwitch(self: *Self, result_var: []const u8, command: reg.Command) !void {\n        try self.writer.writeAll(\"switch (\");\n        try self.writeIdentifier(result_var);\n        try self.writer.writeAll(\") {\\n\");\n\n        for (command.success_codes) |success| {\n            try self.writer.writeAll(\"Result.\");\n            try self.renderEnumFieldName(\"VkResult\", success);\n            try self.writer.writeAll(\" => {}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderErrorSwitch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderErrorSet from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderErrorSet(self: *Self, errors: []const []const u8) !void {\n        try self.writer.writeAll(\"error{\");\n        for (errors) |name| {\n            if (std.mem.eql(u8, name, \"VK_ERROR_UNKNOWN\")) {\n                continue;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderErrorSet",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderResultAsErrorName from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "fn renderResultAsErrorName(self: *Self, name: []const u8) !void {\n        const error_prefix = \"VK_ERROR_\";\n        if (mem.startsWith(u8, name, error_prefix)) {\n            try self.writeIdentifierWithCase(.title, name[error_prefix.len..]);\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "renderResultAsErrorName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to render from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub fn render(\n    writer: *std.Io.Writer,\n    allocator: Allocator,\n    registry: *const reg.Registry,\n    id_renderer: *IdRenderer,\n    have_video: bool,\n) !void {\n    var renderer = try Renderer.init(writer, allocator, registry, id_renderer, have_video);\n    defer renderer.deinit();\n    try renderer.render();\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "function",
      "name": "render",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ApiInfo from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub const ApiInfo = struct {\n    \\\\    name: [:0]const u8 = \"custom\",\n    \\\\    version: Version = makeApiVersion(0, 0, 0, 0),\n    \\\\}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "struct",
      "name": "ApiInfo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Renderer from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "const Renderer = struct {\n    const Self = @This();\n    const RenderTypeInfoError = std.Io.Writer.Error || std.fmt.ParseIntError || error{ OutOfMemory, InvalidRegistry }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "struct",
      "name": "Renderer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to BitflagName from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "const BitflagName = struct {\n        /// Name without FlagBits, so VkSurfaceTransformFlagBitsKHR\n        /// becomes VkSurfaceTransform\n        base_name: []const u8,\n\n        /// Optional flag bits revision, used in places like VkAccessFlagBits2KHR\n        revision: ?[]const u8,\n\n        /// Optional tag of the flag\n        tag: ?[]const u8,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "struct",
      "name": "BitflagName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ReturnValue from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "const ReturnValue = struct {\n        name: []const u8,\n        return_value_type: reg.TypeInfo,\n        origin: enum {\n            parameter,\n            inner_return_value,\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "struct",
      "name": "ReturnValue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to features from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub const features = struct {\n            \\\\\n        );\n        for (self.registry.features) |feature| {\n            try self.writer.writeAll(\"pub const \");\n            try self.writeIdentifierWithCase(.snake, trimVkNamespace(feature.name));\n            try self.writer.writeAll(\"= ApiInfo {\\n\");\n            try self.writer.print(\".name = \\\"{s}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "struct",
      "name": "features",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to extensions from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "pub const extensions = struct {\n            \\\\\n        );\n        for (self.registry.extensions) |ext| {\n            try self.writer.writeAll(\"pub const \");\n            if (ext.extension_type == .video) {\n                // These are already in the right form, and the auto-casing style transformer\n                // is prone to messing up these names.\n                try self.writeIdentifier(trimVkNamespace(ext.name));\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "struct",
      "name": "extensions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to flag_functions from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "const flag_functions: []const []const u8 = &.{\n    \"toInt\",\n    \"fromInt\",\n    \"merge\",\n    \"intersect\",\n    \"complement\",\n    \"subtract\",\n    \"contains\",\n};",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "const",
      "name": "flag_functions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to command_flag_functions from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "const command_flag_functions: []const []const u8 = &.{\n    \"merge\",\n    \"intersect\",\n    \"complement\",\n    \"subtract\",\n    \"contains\",\n};",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "const",
      "name": "command_flag_functions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to backing_type from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "const backing_type: []const u8 = if (handle.is_dispatchable) \"usize\" else \"u64\";",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "const",
      "name": "backing_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to count_type from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/vulkan/render.zig",
    "response": "const count_type: reg.TypeInfo = blk: {\n            for (command.params) |param| {\n                if (std.mem.endsWith(u8, param.name, \"Count\")) {\n                    break :blk .{ .name = \"uint32_t\" };",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/vulkan/render.zig",
      "type": "const",
      "name": "count_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getAttribute from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub fn getAttribute(self: Element, attrib_name: []const u8) ?[]const u8 {\n        for (self.attributes) |child| {\n            if (mem.eql(u8, child.name, attrib_name)) {\n                return child.value;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "getAttribute",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getCharData from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub fn getCharData(self: Element, child_tag: []const u8) ?[]const u8 {\n        const child = self.findChildByTag(child_tag) orelse return null;\n        if (child.children.len != 1) {\n            return null;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "getCharData",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to iterator from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub fn iterator(self: Element) ChildIterator {\n        return .{\n            .items = self.children,\n            .i = 0,\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "iterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to elements from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub fn elements(self: Element) ChildElementIterator {\n        return .{\n            .inner = self.iterator(),\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "elements",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findChildByTag from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub fn findChildByTag(self: Element, tag: []const u8) ?*Element {\n        var it = self.findChildrenByTag(tag);\n        return it.next();\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "findChildByTag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findChildrenByTag from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub fn findChildrenByTag(self: Element, tag: []const u8) FindChildrenByTagIterator {\n        return .{\n            .inner = self.elements(),\n            .tag = tag,\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "findChildrenByTag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub fn next(self: *ChildIterator) ?*Content {\n            if (self.i < self.items.len) {\n                self.i += 1;\n                return &self.items[self.i - 1];\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub fn next(self: *ChildElementIterator) ?*Element {\n            while (self.inner.next()) |child| {\n                if (child.* != .element) {\n                    continue;\n                }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub fn next(self: *FindChildrenByTagIterator) ?*Element {\n            while (self.inner.next()) |child| {\n                if (!mem.eql(u8, child.tag, self.tag)) {\n                    continue;\n                }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub fn deinit(self: Document) void {\n        var arena = self.arena; // Copy to stack so self can be taken by value.\n        arena.deinit();\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn init(source: []const u8) Parser {\n        return .{\n            .source = source,\n            .offset = 0,\n            .line = 0,\n            .column = 0,\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to peek from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn peek(self: *Parser) ?u8 {\n        return if (self.offset < self.source.len) self.source[self.offset] else null;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "peek",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to consume from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn consume(self: *Parser) !u8 {\n        if (self.offset < self.source.len) {\n            return self.consumeNoEof();\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "consume",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to consumeNoEof from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn consumeNoEof(self: *Parser) u8 {\n        std.debug.assert(self.offset < self.source.len);\n        const c = self.source[self.offset];\n        self.offset += 1;\n\n        if (c == '\\n') {\n            self.line += 1;\n            self.column = 0;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "consumeNoEof",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eat from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn eat(self: *Parser, char: u8) bool {\n        self.expect(char) catch return false;\n        return true;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "eat",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to expect from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn expect(self: *Parser, expected: u8) !void {\n        if (self.peek()) |actual| {\n            if (expected != actual) {\n                return error.UnexpectedCharacter;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "expect",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eatStr from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn eatStr(self: *Parser, text: []const u8) bool {\n        self.expectStr(text) catch return false;\n        return true;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "eatStr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to expectStr from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn expectStr(self: *Parser, text: []const u8) !void {\n        if (self.source.len < self.offset + text.len) {\n            return error.UnexpectedEof;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "expectStr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eatWs from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn eatWs(self: *Parser) bool {\n        var ws = false;\n\n        while (self.peek()) |ch| {\n            switch (ch) {\n                ' ', '\\t', '\\n', '\\r' => {\n                    ws = true;\n                    _ = self.consumeNoEof();\n                }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "eatWs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to expectWs from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn expectWs(self: *Parser) !void {\n        if (!self.eatWs()) return error.UnexpectedCharacter;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "expectWs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to currentLine from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn currentLine(self: Parser) []const u8 {\n        var begin: usize = 0;\n        if (mem.lastIndexOfScalar(u8, self.source[0..self.offset], '\\n')) |prev_nl| {\n            begin = prev_nl + 1;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "currentLine",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parse from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub fn parse(backing_allocator: Allocator, source: []const u8) !Document {\n    var parser = Parser.init(source);\n    return try parseDocument(&parser, backing_allocator);\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "parse",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseDocument from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn parseDocument(parser: *Parser, backing_allocator: Allocator) !Document {\n    var doc = Document{\n        .arena = ArenaAllocator.init(backing_allocator),\n        .xml_decl = null,\n        .root = undefined,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "parseDocument",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseAttrValue from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn parseAttrValue(parser: *Parser, alloc: Allocator) ![]const u8 {\n    const quote = try parser.consume();\n    if (quote != '\"' and quote != '\\'') return error.UnexpectedCharacter;\n\n    const begin = parser.offset;\n\n    while (true) {\n        const c = parser.consume() catch return error.UnclosedValue;\n        if (c == quote) break;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "parseAttrValue",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseEqAttrValue from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn parseEqAttrValue(parser: *Parser, alloc: Allocator) ![]const u8 {\n    _ = parser.eatWs();\n    try parser.expect('=');\n    _ = parser.eatWs();\n\n    return try parseAttrValue(parser, alloc);\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "parseEqAttrValue",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseNameNoDupe from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn parseNameNoDupe(parser: *Parser) ![]const u8 {\n    // XML's spec on names is very long, so to make this easier\n    // we just take any character that is not special and not whitespace\n    const begin = parser.offset;\n\n    while (parser.peek()) |ch| {\n        switch (ch) {\n            ' ', '\\t', '\\n', '\\r' => break,\n            '&', '\"', '\\'', '<', '>', '?', '=', '/' => break,\n            else => _ = parser.consumeNoEof(),\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "parseNameNoDupe",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseCharData from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn parseCharData(parser: *Parser, alloc: Allocator) !?[]const u8 {\n    const begin = parser.offset;\n\n    while (parser.peek()) |ch| {\n        switch (ch) {\n            '<' => break,\n            else => _ = parser.consumeNoEof(),\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "parseCharData",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseContent from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn parseContent(parser: *Parser, alloc: Allocator) ParseError!Content {\n    if (try parseCharData(parser, alloc)) |cd| {\n        return Content{ .char_data = cd }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "parseContent",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseAttr from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn parseAttr(parser: *Parser, alloc: Allocator) !?Attribute {\n    const name = parseNameNoDupe(parser) catch return null;\n    _ = parser.eatWs();\n    try parser.expect('=');\n    _ = parser.eatWs();\n    const value = try parseAttrValue(parser, alloc);\n\n    const attr = Attribute{\n        .name = try alloc.dupe(u8, name),\n        .value = value,\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "parseAttr",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseElement from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn parseElement(parser: *Parser, alloc: Allocator, comptime kind: ElementKind) !?*Element {\n    const start = parser.offset;\n\n    const tag = switch (kind) {\n        .xml_decl => blk: {\n            if (!parser.eatStr(\"<?\") or !mem.eql(u8, try parseNameNoDupe(parser), \"xml\")) {\n                parser.offset = start;\n                return null;\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "parseElement",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to skipComments from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn skipComments(parser: *Parser, alloc: Allocator) !void {\n    while ((try parseComment(parser, alloc)) != null) {\n        _ = parser.eatWs();\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "skipComments",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseComment from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn parseComment(parser: *Parser, alloc: Allocator) !?[]const u8 {\n    if (!parser.eatStr(\"<!--\")) return null;\n\n    const begin = parser.offset;\n    while (!parser.eatStr(\"-->\")) {\n        _ = parser.consume() catch return error.UnclosedComment;\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "parseComment",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to unescapeEntity from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn unescapeEntity(text: []const u8) !u8 {\n    const EntitySubstition = struct { text: []const u8, replacement: u8 }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "unescapeEntity",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to unescape from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "fn unescape(arena: Allocator, text: []const u8) ![]const u8 {\n    const unescaped = try arena.alloc(u8, text.len);\n\n    var j: usize = 0;\n    var i: usize = 0;\n    while (i < text.len) : (j += 1) {\n        if (text[i] == '&') {\n            const entity_end = 1 + (mem.indexOfScalarPos(u8, text, i, ';') orelse return error.InvalidEntity);\n            unescaped[j] = try unescapeEntity(text[i..entity_end]);\n            i = entity_end;\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "function",
      "name": "unescape",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Attribute from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub const Attribute = struct {\n    name: []const u8,\n    value: []const u8,\n}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "struct",
      "name": "Attribute",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Element from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub const Element = struct {\n    tag: []const u8,\n    attributes: []Attribute = &.{}",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "struct",
      "name": "Element",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ChildIterator from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub const ChildIterator = struct {\n        items: []Content,\n        i: usize,\n\n        pub fn next(self: *ChildIterator) ?*Content {\n            if (self.i < self.items.len) {\n                self.i += 1;\n                return &self.items[self.i - 1];\n            }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "struct",
      "name": "ChildIterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ChildElementIterator from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub const ChildElementIterator = struct {\n        inner: ChildIterator,\n\n        pub fn next(self: *ChildElementIterator) ?*Element {\n            while (self.inner.next()) |child| {\n                if (child.* != .element) {\n                    continue;\n                }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "struct",
      "name": "ChildElementIterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FindChildrenByTagIterator from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub const FindChildrenByTagIterator = struct {\n        inner: ChildElementIterator,\n        tag: []const u8,\n\n        pub fn next(self: *FindChildrenByTagIterator) ?*Element {\n            while (self.inner.next()) |child| {\n                if (!mem.eql(u8, child.tag, self.tag)) {\n                    continue;\n                }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "struct",
      "name": "FindChildrenByTagIterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Document from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "pub const Document = struct {\n    arena: ArenaAllocator,\n    xml_decl: ?*Element,\n    root: *Element,\n\n    pub fn deinit(self: Document) void {\n        var arena = self.arena; // Copy to stack so self can be taken by value.\n        arena.deinit();\n    }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "struct",
      "name": "Document",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Parser from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "const Parser = struct {\n    source: []const u8,\n    offset: usize,\n    line: usize,\n    column: usize,\n\n    fn init(source: []const u8) Parser {\n        return .{\n            .source = source,\n            .offset = 0,\n            .line = 0,\n            .column = 0,\n        }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "struct",
      "name": "Parser",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to EntitySubstition from Snektron/vulkan-zig",
    "context": "Repository: Snektron/vulkan-zig (720 ⭐)\nFile: src/xml.zig",
    "response": "const EntitySubstition = struct { text: []const u8, replacement: u8 }",
    "metadata": {
      "repo": "Snektron/vulkan-zig",
      "stars": 720,
      "file": "src/xml.zig",
      "type": "struct",
      "name": "EntitySubstition",
      "difficulty": "easy"
    }
  }
]