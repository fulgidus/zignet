[
  {
    "instruction": "Write a Zig function similar to build from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: build.zig",
    "response": "pub fn build(b: *Build) void {\n    const target = b.standardTargetOptions(.{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "build.zig",
      "type": "function",
      "name": "build",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addTests from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: build.zig",
    "response": "fn addTests(b: *Build, examples_step: *std.Build.Step, bog_module: *std.Build.Module, tests: anytype) void {\n    const tests_step = b.step(\"test\", \"Run all tests\");\n    tests_step.dependOn(examples_step);\n    inline for (tests) |t| {\n        var test_step = b.addTest(.{ .root_source_file = b.path(t) }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "build.zig",
      "type": "function",
      "name": "addTests",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: examples/zig_from_bog.zig",
    "response": "pub fn main() !void {\n    var state = std.heap.GeneralPurposeAllocator(.{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "examples/zig_from_bog.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Bytecode.zig",
    "response": "pub fn deinit(b: *Bytecode, gpa: Allocator) void {\n    gpa.free(b.extra);\n    gpa.free(b.main);\n    gpa.free(b.strings);\n    b.debug_info.lines.deinit(gpa);\n    gpa.free(b.debug_info.path);\n    gpa.free(b.debug_info.source);\n    b.code.deinit(gpa);\n    b.* = undefined;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Bytecode.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to format from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Bytecode.zig",
    "response": "pub fn format(ref: Ref, _: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {\n        var buf: [8]u8 = undefined;\n        buf[0] = '%';\n        const end = std.fmt.formatIntBuf(buf[1..], @intFromEnum(ref), 10, .lower, .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Bytecode.zig",
      "type": "function",
      "name": "format",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to indexToRef from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Bytecode.zig",
    "response": "fn indexToRef(i: u64, params: u32) Ref {\n    return @enumFromInt(i + params);\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Bytecode.zig",
      "type": "function",
      "name": "indexToRef",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to refToIndex from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Bytecode.zig",
    "response": "fn refToIndex(r: Ref, params: u32) u32 {\n    return @intFromEnum(r) - params;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Bytecode.zig",
      "type": "function",
      "name": "refToIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to needsDebugInfo from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Bytecode.zig",
    "response": "pub fn needsDebugInfo(op: Op) bool {\n            return switch (op) {\n                // zig fmt: off\n                .call, .call_one, .call_zero, .this_call, .this_call_zero, .set,\n                .get, .assert_len, .unwrap_tagged, .unwrap_error, .bit_not,\n                .bool_not, .negate, .as, .in, .less_than, .less_than_equal,\n                .greater_than, .greater_than_equal, .mul, .pow, .add, .sub,\n                .l_shift, .r_shift, .bit_and, .bit_or, .bit_xor, .rem, .div,\n                .div_floor, .import, .build_range_step, .build_range,\n                .iter_init, .iter_next, .spread, .spread_dest, .get_int,\n                .@\"resume\", .@\"await\", .async_call_zero, .async_call_one,\n                .async_call, .async_this_call_zero, .async_this_call,  => true,\n                // zig fmt: on\n                else => false,\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Bytecode.zig",
      "type": "function",
      "name": "needsDebugInfo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hasResult from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Bytecode.zig",
    "response": "pub fn hasResult(op: Op) bool {\n            return switch (op) {\n                // zig fmt: off\n                .discard, .copy, .move, .append, .check_len,\n                .assert_len, .set, .push_err_handler, .pop_err_handler,\n                .jump, .jump_if_true, .jump_if_false, .jump_if_null, .ret,\n                .ret_null, .throw, .spread, .spread_dest, .get_int,\n                .@\"suspend\", .@\"resume\", .store_global => false,\n                // zig fmt: on\n                else => true,\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Bytecode.zig",
      "type": "function",
      "name": "hasResult",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dumpLineCol from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Bytecode.zig",
    "response": "fn dumpLineCol(b: *Bytecode, byte_offset: u32) void {\n    var start: u32 = 0;\n    // find the start of the line which is either a newline or a splice\n    var line_num: u32 = 1;\n    var i: u32 = 0;\n    while (i < byte_offset) : (i += 1) {\n        if (b.debug_info.source[i] == '\\n') {\n            start = i + 1;\n            line_num += 1;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Bytecode.zig",
      "type": "function",
      "name": "dumpLineCol",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dump from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Bytecode.zig",
    "response": "pub fn dump(b: *Bytecode, body: []const u32, params: u32) void {\n    const ops = b.code.items(.op);\n    const data = b.code.items(.data);\n    for (body, 0..) |i, inst| {\n        if (ops[i] == .nop) continue;\n        const ref = indexToRef(inst, params);\n        if (ops[i].needsDebugInfo()) {\n            dumpLineCol(b, b.debug_info.lines.get(@intCast(i)).?);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Bytecode.zig",
      "type": "function",
      "name": "dump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dumpList from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Bytecode.zig",
    "response": "fn dumpList(list: []const Ref) void {\n    for (list, 0..) |item, i| {\n        if (i != 0) std.debug.print(\", \", .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Bytecode.zig",
      "type": "function",
      "name": "dumpList",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to DebugInfo from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Bytecode.zig",
    "response": "pub const DebugInfo = struct {\n    path: []const u8 = \"\",\n    source: []const u8 = \"\",\n    lines: Lines,\n\n    pub const Lines = std.AutoHashMapUnmanaged(u32, u32);\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Bytecode.zig",
      "type": "struct",
      "name": "DebugInfo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to fn_body from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Bytecode.zig",
    "response": "const fn_body: []const u32 = @ptrCast(extra[2 + captures_len ..]);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Bytecode.zig",
      "type": "const",
      "name": "fn_body",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to compile from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "pub fn compile(gpa: Allocator, source: []const u8, path: []const u8, errors: *Errors) (Compiler.Error || error{ParseError}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "compile",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to compileRepl from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "pub fn compileRepl(repl: *@import(\"repl.zig\").Repl, node: Node.Index) Compiler.Error!void {\n    if (repl.compiler.instructions.len == 0) {\n        try repl.compiler.instructions.append(repl.compiler.gpa, .{ .op = .ret, .data = undefined }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "compileRepl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "pub fn deinit(c: *Compiler) void {\n    c.scopes.deinit(c.gpa);\n    c.globals.deinit(c.gpa);\n    c.unresolved_globals.deinit(c.gpa);\n    c.list_buf.deinit(c.gpa);\n    c.unwrap_jump_buf.deinit(c.gpa);\n    c.instructions.deinit(c.gpa);\n    c.extra.deinit(c.gpa);\n    c.strings.deinit(c.gpa);\n    c.string_interner.deinit(c.gpa);\n    c.* = undefined;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isRt from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn isRt(val: Value) bool {\n        return switch (val) {\n            .ref, .mut => true,\n            else => false,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "isRt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getRt from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn getRt(val: Value) Ref {\n        switch (val) {\n            .ref, .mut => |r| return r,\n            else => unreachable,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "getRt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getBool from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn getBool(val: Value, c: *Compiler, node: Node.Index) !bool {\n        if (val != .Bool) {\n            return c.reportErr(\"expected a boolean\", node);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "getBool",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getInt from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn getInt(val: Value, c: *Compiler, node: Node.Index) !i64 {\n        if (val != .int) {\n            return c.reportErr(\"expected an integer\", node);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "getInt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getNum from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn getNum(val: Value) f64 {\n        return switch (val) {\n            .int => |v| @floatFromInt(v),\n            .num => |v| v,\n            else => unreachable,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "getNum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getStr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn getStr(val: Value, c: *Compiler, node: Node.Index) ![]const u8 {\n        if (val != .str) {\n            return c.reportErr(\"expected a string\", node);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "getStr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to checkNum from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn checkNum(val: Value, c: *Compiler, node: Node.Index) !void {\n        if (val != .int and val != .num) {\n            return c.reportErr(\"expected a number\", node);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "checkNum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to checkZero from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn checkZero(val: Value, c: *Compiler, node: Node.Index) !void {\n        switch (val) {\n            .int => |v| if (v != 0) return,\n            .num => |v| if (v != 0) return,\n            else => unreachable,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "checkZero",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to checkNegative from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn checkNegative(val: Value, c: *Compiler, node: Node.Index) !void {\n        switch (val) {\n            .int => |v| if (v < 0) return,\n            .num => |v| if (v < 0) return,\n            else => unreachable,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "checkNegative",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to indexToRef from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn indexToRef(code_len: usize, params: u32) Ref {\n    return @enumFromInt(code_len + params);\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "indexToRef",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addInst from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn addInst(c: *Compiler, op: Bytecode.Inst.Op, data: Bytecode.Inst.Data, node: ?Node.Index) !Ref {\n    const new_index: u32 = @intCast(c.instructions.len);\n    const ref = indexToRef(c.code.items.len, c.params);\n    try c.instructions.append(c.gpa, .{ .op = op, .data = data }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "addInst",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addUn from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn addUn(c: *Compiler, op: Bytecode.Inst.Op, arg: Ref, node: ?Node.Index) !Ref {\n    return c.addInst(op, .{ .un = arg }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "addUn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addBin from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn addBin(c: *Compiler, op: Bytecode.Inst.Op, lhs: Ref, rhs: Ref, node: ?Node.Index) !Ref {\n    return c.addInst(op, .{ .bin = .{ .lhs = lhs, .rhs = rhs }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "addBin",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addJump from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn addJump(c: *Compiler, op: Bytecode.Inst.Op, operand: Ref) !u32 {\n    const new_index: u32 = @intCast(c.instructions.len);\n    _ = try c.addInst(op, .{\n        .jump_condition = .{\n            .operand = operand,\n            .offset = undefined, // set later\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "addJump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addExtra from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn addExtra(c: *Compiler, op: Bytecode.Inst.Op, items: []const Ref, node: ?Node.Index) !Ref {\n    const extra: u32 = @intCast(c.extra.items.len);\n    try c.extra.appendSlice(c.gpa, items);\n    return c.addInst(op, .{\n        .extra = .{\n            .extra = extra,\n            .len = @intCast(items.len),\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "addExtra",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to finishJump from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn finishJump(c: *Compiler, jump_index: u32) void {\n    const offset: u32 = @intCast(c.code.items.len);\n    const data = c.instructions.items(.data);\n    const ops = c.instructions.items(.op);\n    if (ops[jump_index] == .jump or ops[jump_index] == .pop_err_handler) {\n        data[jump_index] = .{ .jump = offset }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "finishJump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to makeRuntime from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn makeRuntime(c: *Compiler, val: Value) Error!Ref {\n    return switch (val) {\n        .empty => unreachable,\n        .mut, .ref => |ref| ref,\n        .null => try c.addInst(.primitive, .{ .primitive = .null }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "makeRuntime",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to putString from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn putString(c: *Compiler, str: []const u8) !u32 {\n    if (c.string_interner.get(str)) |some| return some;\n    const offset: u32 = @intCast(c.strings.items.len);\n    try c.strings.appendSlice(c.gpa, str);\n\n    _ = try c.string_interner.put(c.gpa, str, offset);\n    return offset;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "putString",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findSymbol from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn findSymbol(c: *Compiler, tok: TokenIndex) !FoundSymbol {\n    if (c.cur_fn != null) {\n        const name = c.tree.tokenSlice(tok);\n        for (c.globals.items) |global| {\n            if (mem.eql(u8, global.name, name)) {\n                const ref = try c.addInst(.load_global, .{ .un = global.ref }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "findSymbol",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findSymbolExtra from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn findSymbolExtra(c: *Compiler, tok: TokenIndex, start_index: usize) FindSymbolError!FoundSymbol {\n    const name = c.tree.tokenSlice(tok);\n    var i = start_index;\n\n    while (i > 0) {\n        i -= 1;\n        const item = c.scopes.items[i];\n        switch (item) {\n            .func => |f| {\n                for (f.captures.items) |capture| {\n                    if (mem.eql(u8, capture.name, name)) {\n                        return FoundSymbol{\n                            .ref = capture.local_ref,\n                            .mut = capture.mut,\n                        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "findSymbolExtra",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to checkRedeclaration from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn checkRedeclaration(c: *Compiler, tok: TokenIndex) !void {\n    const name = c.tree.tokenSlice(tok);\n    var i = c.scopes.items.len;\n    while (i > 0) {\n        i -= 1;\n        const scope = c.scopes.items[i];\n        switch (scope) {\n            .symbol => |sym| if (std.mem.eql(u8, sym.name, name)) {\n                const msg = try bog.Value.String.init(c.gpa, \"redeclaration of '{s}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "checkRedeclaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveGlobals from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn resolveGlobals(c: *Compiler) !void {\n    const data = c.instructions.items(.data);\n    for (c.unresolved_globals.items) |unresolved| {\n        const name = c.tree.tokenSlice(unresolved.tok);\n        for (c.globals.items) |global| {\n            if (mem.eql(u8, global.name, name)) {\n                data[unresolved.index] = .{ .un = global.ref }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "resolveGlobals",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getLastNode from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn getLastNode(c: *Compiler, node: Node.Index) Node.Index {\n    const data = c.tree.nodes.items(.data);\n    const ids = c.tree.nodes.items(.id);\n    var cur = node;\n    while (true)\n        switch (ids[cur]) {\n            .paren_expr => cur = data[cur].un,\n            else => return cur,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "getLastNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toVal from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn toVal(res: Result) Value {\n        return if (res == .ref) .{ .ref = res.ref }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "toVal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wrapResult from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn wrapResult(c: *Compiler, node: Node.Index, val: Value, res: Result) Error!Value {\n    if (val == .empty and res != .discard and res != .value_or_empty) {\n        return c.reportErr(\"expected a value\", node);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "wrapResult",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genNode from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genNode(c: *Compiler, node: Node.Index, res: Result) Error!Value {\n    const ids = c.tree.nodes.items(.id);\n    const tokens = c.tree.nodes.items(.token);\n    switch (ids[node]) {\n        .string_expr => {\n            const val: Value = .{ .str = try c.parseStr(tokens[node]) }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genIdent from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genIdent(c: *Compiler, node: Node.Index) Error!Value {\n    const tokens = c.tree.nodes.items(.token);\n    const sym = try c.findSymbol(tokens[node]);\n    if (sym.mut) {\n        return Value{ .mut = sym.ref }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genIdent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genDecl from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genDecl(c: *Compiler, node: Node.Index) !void {\n    const data = c.tree.nodes.items(.data);\n    const init_val = init_val: {\n        const old_make_global = c.make_ident_global;\n        defer c.make_ident_global = old_make_global;\n        c.make_ident_global = false;\n\n        break :init_val try c.genNode(data[node].bin.rhs, .value);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genDecl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genThrow from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genThrow(c: *Compiler, node: Node.Index) !void {\n    const data = c.tree.nodes.items(.data);\n    const operand = data[node].un;\n    const operand_val = try c.genNode(operand, .value);\n    const operand_ref = try c.makeRuntime(operand_val);\n    _ = try c.addUn(.throw, operand_ref, null);\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genThrow",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genReturn from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genReturn(c: *Compiler, node: Node.Index) !void {\n    const data = c.tree.nodes.items(.data);\n    if (data[node].un != 0) {\n        // handled by result location\n        _ = try c.genNode(data[node].un, .ret);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genReturn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genBreak from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genBreak(c: *Compiler, node: Node.Index) !void {\n    const loop = c.cur_loop orelse\n        return c.reportErr(\"break outside of loop\", node);\n\n    const jump = try c.addJump(.jump, undefined);\n    try loop.breaks.append(c.gpa, jump);\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genBreak",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genContinue from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genContinue(c: *Compiler, node: Node.Index) !void {\n    const loop = c.cur_loop orelse\n        return c.reportErr(\"continue outside of loop\", node);\n\n    _ = try c.addInst(.jump, .{ .jump = loop.first_inst }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genContinue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genResume from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genResume(c: *Compiler, node: Node.Index) !void {\n    const data = c.tree.nodes.items(.data);\n    const operand = try c.genNode(data[node].un, .value);\n    if (!operand.isRt()) {\n        return c.reportErr(\"expected a function frame\", data[node].un);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genResume",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to createListComprehension from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn createListComprehension(c: *Compiler, ref: ?Ref) !Result {\n    const list = try c.addExtra(.build_list, &.{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "createListComprehension",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genFor from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genFor(c: *Compiler, node: Node.Index, res: Result) Error!Value {\n    const sub_res = switch (res) {\n        .discard => res,\n        .value, .ret, .value_or_empty => try c.createListComprehension(null),\n        .ref => |ref| try c.createListComprehension(ref),\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genFor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genWhile from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genWhile(c: *Compiler, node: Node.Index, res: Result) Error!Value {\n    const sub_res = switch (res) {\n        .discard => res,\n        .value, .ret, .value_or_empty => try c.createListComprehension(null),\n        .ref => |ref| try c.createListComprehension(ref),\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genWhile",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genIf from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genIf(c: *Compiler, node: Node.Index, res: Result) Error!Value {\n    const if_expr = Tree.If.get(c.tree.*, node);\n\n    const scope_count = c.scopes.items.len;\n    defer c.scopes.items.len = scope_count;\n\n    const jump_buf_top = c.unwrap_jump_buf.items.len;\n    defer c.unwrap_jump_buf.items.len = jump_buf_top;\n\n    const cond_val = try c.genNode(if_expr.cond, .value);\n    if (if_expr.capture) |capture| {\n        const cond_ref = try c.makeRuntime(cond_val);\n        switch (c.tree.nodes.items(.id)[c.getLastNode(capture)]) {\n            .ident_expr, .mut_ident_expr, .discard_expr => {\n                const jump_null_index = try c.addJump(.jump_if_null, cond_ref);\n                try c.unwrap_jump_buf.append(c.gpa, jump_null_index);\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genIf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genMatch from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genMatch(c: *Compiler, node: Node.Index, res: Result) Error!Value {\n    const sub_res = switch (res) {\n        .ref, .discard, .ret => res,\n        .value, .value_or_empty => val: {\n            // add a dummy instruction we can store the value into\n            break :val Result{ .ref = try c.addUn(.nop, undefined, null) }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genMatch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genTry from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genTry(c: *Compiler, node: Node.Index, res: Result) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const ids = c.tree.nodes.items(.id);\n    var buf: [2]Node.Index = undefined;\n    const items = c.tree.nodeItems(node, &buf);\n    const cond = items[0];\n    const catches = items[1..];\n\n    const sub_res = switch (res) {\n        .ref, .discard, .ret => res,\n        .value, .value_or_empty => val: {\n            // add a dummy instruction we can store the value into\n            break :val Result{ .ref = try c.addUn(.nop, undefined, null) }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genTry",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genBlock from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genBlock(c: *Compiler, stmts: []const Node.Index, res: Result) Error!Value {\n    const scope_count = c.scopes.items.len;\n    defer c.scopes.items.len = scope_count;\n\n    for (stmts, 0..) |stmt, i| {\n        // return value of last instruction if it is not discarded\n        if (i + 1 == stmts.len) {\n            return c.genNode(stmt, res);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genBlock",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genAs from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genAs(c: *Compiler, node: Node.Index) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const tokens = c.tree.nodes.items(.token);\n    const lhs = try c.genNode(data[node].un, .value);\n\n    const ty_tok = tokens[node];\n\n    const type_str = c.tree.tokenSlice(ty_tok);\n    const type_id = type_id_map.get(type_str) orelse\n        return c.reportErr(\"expected a type name\", node);\n\n    switch (type_id) {\n        .null, .int, .num, .bool, .str, .tuple, .map, .list => {}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genAs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genIs from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genIs(c: *Compiler, node: Node.Index) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const tokens = c.tree.nodes.items(.token);\n    const lhs = try c.genNode(data[node].un, .value);\n\n    const ty_tok = tokens[node];\n\n    const type_str = c.tree.tokenSlice(ty_tok);\n    const type_id = type_id_map.get(type_str) orelse\n        return c.reportErr(\"expected a type name\", node);\n\n    if (lhs.isRt()) {\n        const ref = try c.addInst(.is, .{ .bin_ty = .{\n            .operand = lhs.getRt(),\n            .ty = type_id,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genIs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genBoolNot from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genBoolNot(c: *Compiler, node: Node.Index) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const operand = try c.genNode(data[node].un, .value);\n\n    if (operand.isRt()) {\n        const ref = try c.addUn(.bool_not, operand.getRt(), node);\n        return Value{ .ref = ref }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genBoolNot",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genBitNot from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genBitNot(c: *Compiler, node: Node.Index) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const operand = try c.genNode(data[node].un, .value);\n\n    if (operand.isRt()) {\n        const ref = try c.addUn(.bit_not, operand.getRt(), node);\n        return Value{ .ref = ref }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genBitNot",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genNegate from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genNegate(c: *Compiler, node: Node.Index) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const operand = try c.genNode(data[node].un, .value);\n\n    if (operand.isRt()) {\n        const ref = try c.addUn(.negate, operand.getRt(), node);\n        return Value{ .ref = ref }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genNegate",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genAwait from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genAwait(c: *Compiler, node: Node.Index) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const operand = try c.genNode(data[node].un, .value);\n\n    if (!operand.isRt()) {\n        return c.reportErr(\"expected a function frame\", data[node].un);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genAwait",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to needNum from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn needNum(a: Value, b: Value) bool {\n    return a == .num or b == .num;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "needNum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genBoolAnd from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genBoolAnd(c: *Compiler, node: Node.Index, res: Result) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const lhs = data[node].bin.lhs;\n    const rhs = data[node].bin.rhs;\n    var lhs_val = try c.genNode(lhs, .value);\n\n    if (!lhs_val.isRt()) {\n        const l_bool = try lhs_val.getBool(c, lhs);\n        if (!l_bool) return lhs_val;\n        return c.genNode(rhs, res);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genBoolAnd",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genBoolOr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genBoolOr(c: *Compiler, node: Node.Index, res: Result) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const lhs = data[node].bin.lhs;\n    const rhs = data[node].bin.rhs;\n    var lhs_val = try c.genNode(lhs, .value);\n\n    if (!lhs_val.isRt()) {\n        const l_bool = try lhs_val.getBool(c, lhs);\n        if (l_bool) return lhs_val;\n        return c.genNode(rhs, res);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genBoolOr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genComparison from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genComparison(c: *Compiler, node: Node.Index) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const lhs = data[node].bin.lhs;\n    const rhs = data[node].bin.rhs;\n    var lhs_val = try c.genNode(lhs, .value);\n    var rhs_val = try c.genNode(rhs, .value);\n\n    const op: Bytecode.Inst.Op = switch (c.tree.nodes.items(.id)[node]) {\n        .less_than_expr => .less_than,\n        .less_than_equal_expr => .less_than_equal,\n        .greater_than_expr => .greater_than,\n        .greater_than_equal_expr => .greater_than_equal,\n        .equal_expr => .equal,\n        .not_equal_expr => .not_equal,\n        .in_expr => .in,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genComparison",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genIntArithmetic from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genIntArithmetic(c: *Compiler, node: Node.Index) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const lhs = data[node].bin.lhs;\n    const rhs = data[node].bin.rhs;\n    var lhs_val = try c.genNode(lhs, .value);\n    var rhs_val = try c.genNode(rhs, .value);\n\n    const op: Bytecode.Inst.Op = switch (c.tree.nodes.items(.id)[node]) {\n        .bit_and_expr => .bit_and,\n        .bit_or_expr => .bit_or,\n        .bit_xor_expr => .bit_xor,\n        .l_shift_expr => .l_shift,\n        .r_shift_expr => .r_shift,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genIntArithmetic",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genArithmetic from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genArithmetic(c: *Compiler, node: Node.Index) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const lhs = data[node].bin.lhs;\n    const rhs = data[node].bin.rhs;\n    var lhs_val = try c.genNode(lhs, .value);\n    var rhs_val = try c.genNode(rhs, .value);\n\n    const op: Bytecode.Inst.Op = switch (c.tree.nodes.items(.id)[node]) {\n        .add_expr => .add,\n        .sub_expr => .sub,\n        .mul_expr => .mul,\n        .div_expr => .div,\n        .div_floor_expr => .div_floor,\n        .rem_expr => .rem,\n        .pow_expr => .pow,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genArithmetic",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genAssign from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genAssign(c: *Compiler, node: Node.Index, res: Result) Error!Value {\n    if (res != .discard and res != .value_or_empty) {\n        return c.reportErr(\"assignment produces no value\", node);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genAssign",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genAugAssign from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genAugAssign(c: *Compiler, node: Node.Index, res: Result) Error!Value {\n    if (res != .discard and res != .value_or_empty) {\n        return c.reportErr(\"assignment produces no value\", node);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genAugAssign",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genTupleList from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genTupleList(\n    c: *Compiler,\n    node: Node.Index,\n    res: Result,\n    op: Bytecode.Inst.Op,\n) Error!Value {\n    var buf: [2]Node.Index = undefined;\n    const items = c.tree.nodeItems(node, &buf);\n\n    const list_buf_top = c.list_buf.items.len;\n    defer c.list_buf.items.len = list_buf_top;\n\n    if (res == .discard) {\n        for (items) |val| {\n            _ = try c.genNode(val, .discard);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genTupleList",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genMap from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genMap(c: *Compiler, node: Node.Index, res: Result) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const tokens = c.tree.nodes.items(.token);\n    const tok_ids = c.tree.tokens.items(.id);\n    var buf: [2]Node.Index = undefined;\n    const items = c.tree.nodeItems(node, &buf);\n\n    const list_buf_top = c.list_buf.items.len;\n    defer c.list_buf.items.len = list_buf_top;\n\n    if (res == .discard) {\n        for (items) |item| {\n            if (data[item].bin.lhs != 0) {\n                const last_node = c.getLastNode(data[item].bin.lhs);\n                if (tok_ids[tokens[last_node]] != .identifier) {\n                    _ = try c.genNode(data[item].bin.lhs, .discard);\n                }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genMap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genEnum from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genEnum(c: *Compiler, node: Node.Index) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const tokens = c.tree.nodes.items(.token);\n    const str = c.tree.tokenSlice(tokens[node]);\n    const operand = data[node].un;\n    if (operand == 0) {\n        const res_ref = try c.addInst(.build_tagged_null, .{ .str = .{\n            .len = @intCast(str.len),\n            .offset = try c.putString(str),\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genEnum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genError from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genError(c: *Compiler, node: Node.Index) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const operand = data[node].un;\n    if (operand == 0) {\n        const ref = try c.addUn(.build_error_null, undefined, null);\n        return Value{ .ref = ref }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genError",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genRange from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genRange(c: *Compiler, node: Node.Index) Error!Value {\n    const range = Tree.Range.get(c.tree.*, node);\n\n    const start_val = try c.genNode(range.start, .value);\n    if (!start_val.isRt()) _ = try start_val.getInt(c, range.start);\n    const start_ref = try c.makeRuntime(start_val);\n\n    var end_val: Value = .{ .int = std.math.maxInt(i64) }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genRange",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genImport from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genImport(c: *Compiler, node: Node.Index) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const operand = data[node].un;\n    const str_val = try c.genNode(operand, .value);\n    if (!str_val.isRt() and str_val != .str) {\n        return c.reportErr(\"expected a string\", operand);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genImport",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genFn from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genFn(c: *Compiler, node: Node.Index) Error!Value {\n    var buf: [2]Node.Index = undefined;\n    const items = c.tree.nodeItems(node, &buf);\n    const params = items[@intFromBool(items[0] == 0) .. items.len - 1];\n    const body = items[items.len - 1];\n\n    var func: Fn = .{ .params = @intCast(params.len) }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genFn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genCall from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genCall(c: *Compiler, node: Node.Index, is_async: bool) Error!Value {\n    var buf: [2]Node.Index = undefined;\n    const items = c.tree.nodeItems(node, &buf);\n\n    const callee = items[0];\n    const args = items[1..];\n\n    const callee_val = try c.genNode(callee, .value);\n    if (!callee_val.isRt()) {\n        return c.reportErr(\"attempt to call non function value\", callee);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genCall",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to genMemberAccess from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genMemberAccess(c: *Compiler, node: Node.Index) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const tokens = c.tree.nodes.items(.token);\n    const operand = data[node].un;\n\n    var operand_val = try c.genNode(operand, .value);\n    if (operand_val != .str and !operand_val.isRt()) {\n        return c.reportErr(\"invalid operand to member access\", operand);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genMemberAccess",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genArrayAccess from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genArrayAccess(c: *Compiler, node: Node.Index) Error!Value {\n    const data = c.tree.nodes.items(.data);\n    const lhs = data[node].bin.lhs;\n    const rhs = data[node].bin.rhs;\n\n    var lhs_val = try c.genNode(lhs, .value);\n    if (lhs_val != .str and !lhs_val.isRt()) {\n        return c.reportErr(\"invalid operand to subscript\", lhs);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genArrayAccess",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genFormatString from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genFormatString(c: *Compiler, node: Node.Index) Error!Value {\n    // transform f\"foo {x=:X}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genFormatString",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genLval from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genLval(c: *Compiler, node: Node.Index, lval: Lval) Error!void {\n    const ids = c.tree.nodes.items(.id);\n    switch (ids[node]) {\n        .paren_expr => {\n            const data = c.tree.nodes.items(.data);\n            try c.genLval(data[node].un, lval);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genLval",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genLvalIdent from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genLvalIdent(c: *Compiler, node: Node.Index, lval: Lval, mutable: bool) Error!void {\n    const tokens = c.tree.nodes.items(.token);\n    if (mutable and lval != .let) {\n        return c.reportErr(\"cannot make variable mutable in assignment\", node);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genLvalIdent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genLvalEnum from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genLvalEnum(c: *Compiler, node: Node.Index, lval: Lval) Error!void {\n    const val = switch (lval) {\n        .let, .assign => |val| val,\n        .aug_assign => return c.reportErr(\"invalid left hand side to augmented assignment\", node),\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genLvalEnum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genLvalError from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genLvalError(c: *Compiler, node: Node.Index, lval: Lval) Error!void {\n    const val = switch (lval) {\n        .let, .assign => |val| val,\n        .aug_assign => return c.reportErr(\"invalid left hand side to augmented assignment\", node),\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genLvalError",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genLvalRange from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genLvalRange(c: *Compiler, node: Node.Index, lval: Lval) Error!void {\n    const val = switch (lval) {\n        .let, .assign => |val| val,\n        .aug_assign => return c.reportErr(\"invalid left hand side to augmented assignment\", node),\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genLvalRange",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genLValRangePart from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genLValRangePart(c: *Compiler, node: Node.Index, range_ref: Ref, lval: Lval, part: []const u8) Error!void {\n    const name_val: Value = .{ .str = part }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genLValRangePart",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genLvalTupleList from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genLvalTupleList(c: *Compiler, node: Node.Index, lval: Lval) Error!void {\n    const res = switch (lval) {\n        .let, .assign => |val| val,\n        .aug_assign => return c.reportErr(\"invalid left hand side to augmented assignment\", node),\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genLvalTupleList",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genLvalMap from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genLvalMap(c: *Compiler, node: Node.Index, lval: Lval) Error!void {\n    const res = switch (lval) {\n        .let, .assign => |val| val,\n        .aug_assign => return c.reportErr(\"invalid left hand side to augmented assignment\", node),\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genLvalMap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genLvalMemberAccess from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genLvalMemberAccess(c: *Compiler, node: Node.Index, lval: Lval) Error!void {\n    if (lval == .let) {\n        return c.reportErr(\"invalid left hand side to augmented assignment\", node);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genLvalMemberAccess",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genLvalArrayAccess from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genLvalArrayAccess(c: *Compiler, node: Node.Index, lval: Lval) Error!void {\n    if (lval == .let) {\n        return c.reportErr(\"cannot declare a subscript\", node);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genLvalArrayAccess",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genTryUnwrap from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genTryUnwrap(c: *Compiler, node: Node.Index, val: *const Value) Error!void {\n    const ids = c.tree.nodes.items(.id);\n    switch (ids[node]) {\n        .paren_expr => {\n            const data = c.tree.nodes.items(.data);\n            try c.genTryUnwrap(data[node].un, val);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genTryUnwrap",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to genTryUnwrapEnum from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genTryUnwrapEnum(c: *Compiler, node: Node.Index, val: *const Value) Error!void {\n    if (!val.isRt()) {\n        return c.reportErr(\"expected a tagged value\", node);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genTryUnwrapEnum",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to genTryUnwrapError from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genTryUnwrapError(c: *Compiler, node: Node.Index, val: *const Value) Error!void {\n    if (!val.isRt()) {\n        return c.reportErr(\"expected an error\", node);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genTryUnwrapError",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to genTryUnwrapRange from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genTryUnwrapRange(c: *Compiler, node: Node.Index, val: *const Value) Error!void {\n    const range = Tree.Range.get(c.tree.*, node);\n    if (!val.isRt()) {\n        return c.reportErr(\"expected a range\", node);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genTryUnwrapRange",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to genUnwrapRangePart from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genUnwrapRangePart(c: *Compiler, node: Node.Index, range_ref: Ref, part: []const u8) Error!void {\n    const name_val: Value = .{ .str = part }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genUnwrapRangePart",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genTryUnwrapTupleList from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genTryUnwrapTupleList(c: *Compiler, node: Node.Index, val: *const Value) Error!void {\n    if (!val.isRt()) {\n        return c.reportErr(\"expected a tuple/list\", node);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genTryUnwrapTupleList",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to genTryUnwrapMap from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn genTryUnwrapMap(c: *Compiler, node: Node.Index, val: *const Value) Error!void {\n    if (!val.isRt()) {\n        return c.reportErr(\"expected a map\", node);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "genTryUnwrapMap",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseStr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn parseStr(c: *Compiler, tok: TokenIndex) ![]u8 {\n    var slice = c.tree.tokenSlice(tok);\n    const start = @as(u32, 1) + @intFromBool(slice[0] == 'f');\n    slice = slice[start .. slice.len - 1];\n    var buf = try c.arena.alloc(u8, slice.len);\n    return buf[0..try c.parseStrExtra(tok, slice, buf)];\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "parseStr",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseStrExtra from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn parseStrExtra(c: *Compiler, tok: TokenIndex, slice: []const u8, buf: []u8) !usize {\n    var slice_i: u32 = 0;\n    var i: u32 = 0;\n    while (slice_i < slice.len) : (slice_i += 1) {\n        const char = slice[slice_i];\n        switch (char) {\n            '\\\\' => {\n                slice_i += 1;\n                buf[i] = switch (slice[slice_i]) {\n                    '\\\\' => '\\\\',\n                    'n' => '\\n',\n                    'r' => '\\r',\n                    't' => '\\t',\n                    '\\'' => '\\'',\n                    '\"' => '\"',\n                    'x' => {\n                        // validated by tokenizer\n                        buf[i] = std.fmt.parseInt(u8, slice[slice_i + 1 ..][0..2], 16) catch unreachable;\n                        i += 1;\n                        slice_i += 3;\n                        continue;\n                    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "parseStrExtra",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reportErr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "fn reportErr(c: *Compiler, msg: []const u8, node: Node.Index) Error {\n    @branchHint(.cold);\n    const starts = c.tree.tokens.items(.start);\n    try c.errors.add(\n        .{ .data = msg }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "function",
      "name": "reportErr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Fn from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const Fn = struct {\n    code: Code = .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "struct",
      "name": "Fn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Capture from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const Capture = struct {\n        name: []const u8,\n        local_ref: Ref,\n        parent_ref: Ref,\n        mut: bool,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "struct",
      "name": "Capture",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to UnresolvedGlobal from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const UnresolvedGlobal = struct {\n    tok: TokenIndex,\n    index: u32,\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "struct",
      "name": "UnresolvedGlobal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Symbol from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const Symbol = struct {\n    name: []const u8,\n    val: Value,\n    ref: Ref,\n    mut: bool,\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "struct",
      "name": "Symbol",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Loop from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const Loop = struct {\n    breaks: JumpList = .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "struct",
      "name": "Loop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Try from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const Try = struct {\n    jumps: JumpList = .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "struct",
      "name": "Try",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FoundSymbol from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const FoundSymbol = struct {\n    ref: Ref,\n    mut: bool,\n    global: bool = false,\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "struct",
      "name": "FoundSymbol",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to AugAssign from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const AugAssign = struct {\n        val: Ref = undefined,\n        container: ?Ref = null,\n        index: Ref = undefined,\n        global: bool = false,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "struct",
      "name": "AugAssign",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to new_index from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const new_index: u32 = @intCast(c.instructions.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "new_index",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to new_index from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const new_index: u32 = @intCast(c.instructions.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "new_index",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to extra from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const extra: u32 = @intCast(c.extra.items.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "extra",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to offset from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const offset: u32 = @intCast(c.code.items.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "offset",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to offset from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const offset: u32 = @intCast(c.strings.items.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "offset",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to new_inst from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const new_inst: u32 = @intCast(c.instructions.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "new_inst",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to new_inst from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const new_inst: u32 = @intCast(c.instructions.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "new_inst",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const val: Value = .{ .str = try c.parseStr(tokens[node]) };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const val: Value = .{\n                .int = std.fmt.parseInt(i64, slice, 0) catch\n                    return c.reportErr(\"TODO big int\", node),\n            };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const val: Value = .{\n                .num = std.fmt.parseFloat(f64, slice) catch unreachable,\n            };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const val: Value = .{ .Bool = true };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const val: Value = .{ .Bool = false };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const val: Value = .{ .null = {} };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to res_val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const res_val: Value = .{ .ref = res_ref };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "res_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to jump_index from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const jump_index: u32 = @intCast(c.instructions.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "jump_index",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to res_val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const res_val: Value = .{ .null = {} };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "res_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to res_val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const res_val: Value = .{ .null = {} };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "res_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to res_val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const res_val: Value = .{ .null = {} };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "res_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to op from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const op: Bytecode.Inst.Op = switch (c.tree.nodes.items(.id)[node]) {\n        .less_than_expr => .less_than,\n        .less_than_equal_expr => .less_than_equal,\n        .greater_than_expr => .greater_than,\n        .greater_than_equal_expr => .greater_than_equal,\n        .equal_expr => .equal,\n        .not_equal_expr => .not_equal,\n        .in_expr => .in,\n        else => unreachable,\n    };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "op",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to op from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const op: Bytecode.Inst.Op = switch (c.tree.nodes.items(.id)[node]) {\n        .bit_and_expr => .bit_and,\n        .bit_or_expr => .bit_or,\n        .bit_xor_expr => .bit_xor,\n        .l_shift_expr => .l_shift,\n        .r_shift_expr => .r_shift,\n        else => unreachable,\n    };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "op",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to op from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const op: Bytecode.Inst.Op = switch (c.tree.nodes.items(.id)[node]) {\n        .add_expr => .add,\n        .sub_expr => .sub,\n        .mul_expr => .mul,\n        .div_expr => .div,\n        .div_floor_expr => .div_floor,\n        .rem_expr => .rem,\n        .pow_expr => .pow,\n        else => unreachable,\n    };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "op",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to extra from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const extra: u32 = @intCast(c.extra.items.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "extra",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to extra from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const extra: u32 = @intCast(c.extra.items.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "extra",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to extra from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const extra: u32 = @intCast(c.extra.items.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "extra",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to sub_res from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const sub_res: Result = switch (ids[last]) {\n            // zig fmt: off\n            .block_stmt_two, .block_stmt, .assign, .add_assign, .sub_assign, .mul_assign,\n            .pow_assign, .div_assign, .div_floor_assign, .rem_assign, .l_shift_assign,\n            .r_shift_assign, .bit_and_assign, .bit_or_assign, .bit_xor_assign => .discard,\n            // zig fmt: on\n            else => .value_or_empty,\n        };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "sub_res",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to variadic_bit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const variadic_bit: u32 = @intFromBool(c.tree.tokens.items(.id)[maybe_ellipsis] == .ellipsis);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "variadic_bit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to extra from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const extra: u32 = @intCast(c.extra.items.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "extra",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to name_val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const name_val: Value = .{ .str = c.tree.tokenSlice(tokens[node]) };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "name_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to string_val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const string_val: Value = .{ .str = try c.arena.dupe(u8, buf.items) };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "string_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to format_val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const format_val: Value = .{ .str = \"format\" };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "format_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to extra from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const extra: u32 = @intCast(c.extra.items.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "extra",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to rhs_val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const rhs_val: Value = .{ .ref = unwrapped_ref };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "rhs_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to rhs_val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const rhs_val: Value = .{ .ref = unwrapped };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "rhs_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to name_val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const name_val: Value = .{ .str = part };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "name_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to res_val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const res_val: Value = .{ .ref = res_ref };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "res_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to res_val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const res_val: Value = .{ .ref = res_ref };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "res_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to res_val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const res_val: Value = .{ .ref = res_ref };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "res_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to res_val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const res_val: Value = .{ .ref = res_ref };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "res_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to name_val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const name_val: Value = .{ .str = c.tree.tokenSlice(tokens[node]) };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "name_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to extra from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const extra: u32 = @intCast(c.extra.items.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "extra",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to extra from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const extra: u32 = @intCast(c.extra.items.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "extra",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to extra from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const extra: u32 = @intCast(c.extra.items.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "extra",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to jump_index from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const jump_index: u32 = @intCast(c.instructions.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "jump_index",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to name_val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Compiler.zig",
    "response": "const name_val: Value = .{ .str = part };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Compiler.zig",
      "type": "const",
      "name": "name_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to create from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Gc.zig",
    "response": "fn create() !*Page {\n        const page = try std.heap.page_allocator.create(Page);\n        @memset(mem.bytesAsSlice(usize, mem.asBytes(page)), 0);\n        return page;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Gc.zig",
      "type": "function",
      "name": "create",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to destroy from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Gc.zig",
    "response": "fn destroy(page: *Page, gc: *Gc) void {\n        for (page.meta, 0..) |s, i| {\n            if (s == .empty) continue;\n            page.values[i].deinit(gc.gpa);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Gc.zig",
      "type": "function",
      "name": "destroy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to alloc from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Gc.zig",
    "response": "fn alloc(page: *Page) ?*Value {\n        while (page.free < page.values.len) {\n            defer page.free += 1;\n\n            if (page.meta[page.free] == .empty) {\n                page.meta[page.free] = .white;\n                return &page.values[page.free];\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Gc.zig",
      "type": "function",
      "name": "alloc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to clear from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Gc.zig",
    "response": "fn clear(page: *Page, gc: *Gc) u32 {\n        var freed: u32 = 0;\n        var i: u32 = val_count;\n        while (i > 0) {\n            i -= 1;\n            switch (page.meta[i]) {\n                .black, .gray => {\n                    // value lives to see another day\n                    page.meta[i] = .white;\n                }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Gc.zig",
      "type": "function",
      "name": "clear",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to indexOf from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Gc.zig",
    "response": "fn indexOf(page: *Page, value: *const Value) ?u32 {\n        // is the value before this page\n        if (@intFromPtr(value) < @intFromPtr(&page.values[0])) return null;\n        // is the value after this page\n        if (@intFromPtr(value) > @intFromPtr(&page.values[page.values.len - 1])) return null;\n\n        // value is in this page\n        return @intCast((@intFromPtr(value) - @intFromPtr(&page.values[0])) / @sizeOf(Value));\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Gc.zig",
      "type": "function",
      "name": "indexOf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to markVal from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Gc.zig",
    "response": "pub fn markVal(gc: *Gc, maybe_value: ?*const Value) void {\n    const value = maybe_value orelse return;\n    // These will never be allocated\n    if (value == Value.Null or\n        value == Value.True or\n        value == Value.False) return;\n\n    for (gc.simple_pages.items) |page| {\n        const index = page.indexOf(value) orelse continue;\n        if (page.meta[index] == .white) {\n            page.meta[index] = .black;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Gc.zig",
      "type": "function",
      "name": "markVal",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to markGray from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Gc.zig",
    "response": "fn markGray(gc: *Gc) void {\n    // mark all pages as dirty\n    for (gc.aggregate_pages.items) |page| {\n        page.marked = Page.val_count;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Gc.zig",
      "type": "function",
      "name": "markGray",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to collect from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Gc.zig",
    "response": "pub fn collect(gc: *Gc) usize {\n    // mark roots as reachable\n    if (gc.stack_protect_start != 0) {\n        var i: [*]*Value = @ptrFromInt(gc.stack_protect_start);\n        while (@intFromPtr(i) > @frameAddress()) : (i -= 1) {\n            gc.markVal(i[0]);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Gc.zig",
      "type": "function",
      "name": "collect",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Gc.zig",
    "response": "pub fn init(allocator: Allocator, page_limit: u32) Gc {\n    std.debug.assert(page_limit >= 1);\n    return .{\n        .gpa = allocator,\n        .page_limit = page_limit,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Gc.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Gc.zig",
    "response": "pub fn deinit(gc: *Gc) void {\n    for (gc.aggregate_pages.items) |page| page.destroy(gc);\n    gc.aggregate_pages.deinit(gc.gpa);\n    for (gc.simple_pages.items) |page| page.destroy(gc);\n    gc.simple_pages.deinit(gc.gpa);\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Gc.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to alloc from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Gc.zig",
    "response": "pub fn alloc(gc: *Gc, ty: Type) !*Value {\n    switch (ty) {\n        .null => unreachable,\n        .bool => unreachable,\n        .native,\n        .str,\n        .int,\n        .num,\n        .range,\n        => return gc.allocExtra(&gc.simple_pages),\n        .list,\n        .tuple,\n        .map,\n        .err,\n        .func,\n        .frame,\n        .iterator,\n        .tagged,\n        .spread,\n        .native_val,\n        => return gc.allocExtra(&gc.aggregate_pages),\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Gc.zig",
      "type": "function",
      "name": "alloc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to allocExtra from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Gc.zig",
    "response": "fn allocExtra(gc: *Gc, pages: *Page.List) !*Value {\n    if (pages.items.len == 0) {\n        const page = try Page.create();\n        errdefer page.destroy(gc);\n        try pages.append(gc.gpa, page);\n\n        // we just created this page so it is empty.\n        gc.allocated += 1;\n        return page.alloc() orelse unreachable;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Gc.zig",
      "type": "function",
      "name": "allocExtra",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to dupe from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Gc.zig",
    "response": "pub fn dupe(gc: *Gc, val: *const Value) !*Value {\n    // no need to copy always memoized values\n    if (val == Value.Null) return Value.Null;\n    if (val == Value.True) return Value.True;\n    if (val == Value.False) return Value.False;\n\n    const new = try gc.alloc(val.*);\n    switch (val.*) {\n        .list => |*l| {\n            new.* = .{ .list = .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Gc.zig",
      "type": "function",
      "name": "dupe",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Page from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Gc.zig",
    "response": "const Page = struct {\n    const max_size = 1_048_576;\n    comptime {\n        // 2^20, 1 MiB\n        assert(@sizeOf(Page) == max_size);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Gc.zig",
      "type": "struct",
      "name": "Page",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to PageAndIndex from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Gc.zig",
    "response": "const PageAndIndex = struct {\n    page: *Page,\n    index: usize,\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Gc.zig",
      "type": "struct",
      "name": "PageAndIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/List.zig",
    "response": "pub fn deinit(l: *List, allocator: Allocator) void {\n    l.inner.deinit(allocator);\n    l.* = undefined;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/List.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/List.zig",
    "response": "pub fn eql(a: List, b: List) bool {\n    if (a.inner.items.len != b.inner.items.len) return false;\n    for (a.inner.items, 0..) |v, i| {\n        if (!v.eql(b.inner.items[i])) return false;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/List.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/List.zig",
    "response": "pub fn get(list: *const List, ctx: Vm.Context, index: *const Value, res: *?*Value) Value.NativeError!void {\n    switch (index.*) {\n        .int => {\n            var i = index.int;\n            if (i < 0)\n                i += @intCast(list.inner.items.len);\n            if (i < 0 or i >= list.inner.items.len)\n                return ctx.throw(\"index out of bounds\");\n\n            res.* = list.inner.items[@intCast(i)];\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/List.zig",
      "type": "function",
      "name": "get",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to append from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/List.zig",
    "response": "fn append(list: Value.This(*List), ctx: Vm.Context, vals: Value.Variadic(*Value)) !void {\n        try list.t.inner.appendSlice(ctx.vm.gc.gpa, vals.t);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/List.zig",
      "type": "function",
      "name": "append",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to set from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/List.zig",
    "response": "pub fn set(list: *List, ctx: Vm.Context, index: *const Value, new_val: *Value) Value.NativeError!void {\n    switch (index.*) {\n        .int => {\n            var i = index.int;\n            if (i < 0)\n                i += @intCast(list.inner.items.len);\n            if (i < 0 or i >= list.inner.items.len)\n                return ctx.throw(\"index out of bounds\");\n\n            list.inner.items[@intCast(i)] = new_val;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/List.zig",
      "type": "function",
      "name": "set",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to as from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/List.zig",
    "response": "pub fn as(list: *List, ctx: Vm.Context, type_id: Type) Vm.Error!*Value {\n    _ = list;\n    _ = type_id;\n    return ctx.frame.fatal(ctx.vm, \"TODO cast to list\");\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/List.zig",
      "type": "function",
      "name": "as",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to from from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/List.zig",
    "response": "pub fn from(val: *Value, ctx: Vm.Context) Vm.Error!*Value {\n    _ = val;\n    return ctx.frame.fatal(ctx.vm, \"TODO cast from list\");\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/List.zig",
      "type": "function",
      "name": "from",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to in from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/List.zig",
    "response": "pub fn in(list: *const List, val: *const Value) bool {\n    for (list.inner.items) |v| {\n        if (v.eql(val)) return true;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/List.zig",
      "type": "function",
      "name": "in",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to methods from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/List.zig",
    "response": "pub const methods = struct {\n    fn append(list: Value.This(*List), ctx: Vm.Context, vals: Value.Variadic(*Value)) !void {\n        try list.t.inner.appendSlice(ctx.vm.gc.gpa, vals.t);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/List.zig",
      "type": "struct",
      "name": "methods",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn deinit(self: *Map, allocator: Allocator) void {\n    self.entries.deinit(allocator);\n    if (self.index_header) |header| {\n        header.free(allocator);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to count from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn count(self: Map) u32 {\n    return self.entries.len;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to keys from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn keys(self: Map) []*const Value {\n    return self.entries.items(.key);\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "keys",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to values from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn values(self: Map) []*Value {\n    return self.entries.items(.value);\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "values",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to iterator from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn iterator(self: Map) Iterator {\n    const slice = self.entries.slice();\n    return .{\n        .keys = slice.items(.key).ptr,\n        .values = slice.items(.value).ptr,\n        .len = @intCast(slice.len),\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "iterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn next(it: *Iterator) ?Entry {\n        if (it.index >= it.len) return null;\n        const result = Entry{\n            .key_ptr = &it.keys[it.index],\n            .value_ptr = &it.values[it.index],\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reset from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn reset(it: *Iterator) void {\n        it.index = 0;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "reset",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getOrPut from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn getOrPut(self: *Map, allocator: Allocator, key: *const Value) !GetOrPutResult {\n    const gop = try self.getOrPutContextAdapted(allocator, key);\n    if (!gop.found_existing) {\n        gop.key_ptr.* = key;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "getOrPut",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getOrPutContextAdapted from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn getOrPutContextAdapted(self: *Map, allocator: Allocator, key: *const Value) !GetOrPutResult {\n    self.ensureTotalCapacity(allocator, self.entries.len + 1) catch |err| {\n        // \"If key exists this function cannot fail.\"\n        const index = self.getIndex(key) orelse return err;\n        const slice = self.entries.slice();\n        return GetOrPutResult{\n            .key_ptr = &slice.items(.key)[index],\n            .value_ptr = &slice.items(.value)[index],\n            .found_existing = true,\n            .index = index,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "getOrPutContextAdapted",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getOrPutAssumeCapacity from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn getOrPutAssumeCapacity(self: *Map, key: *const Value) GetOrPutResult {\n    const gop = self.getOrPutAssumeCapacityAdapted(key);\n    if (!gop.found_existing) {\n        gop.key_ptr.* = key;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "getOrPutAssumeCapacity",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getOrPutAssumeCapacityAdapted from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn getOrPutAssumeCapacityAdapted(self: *Map, key: *const Value) GetOrPutResult {\n    const header = self.index_header orelse {\n        // Linear scan.\n        const h = key.hash();\n        const slice = self.entries.slice();\n        const hashes_array = slice.items(.hash);\n        const keys_array = slice.items(.key);\n        for (keys_array, 0..) |*item_key, i| {\n            if (hashes_array[i] == h and key.eql(item_key.*)) {\n                return GetOrPutResult{\n                    .key_ptr = item_key,\n                    .value_ptr = &slice.items(.value)[i],\n                    .found_existing = true,\n                    .index = @intCast(i),\n                }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "getOrPutAssumeCapacityAdapted",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ensureTotalCapacity from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn ensureTotalCapacity(self: *Map, allocator: Allocator, new_capacity: u32) !void {\n    if (new_capacity <= linear_scan_max) {\n        try self.entries.ensureTotalCapacity(allocator, new_capacity);\n        return;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "ensureTotalCapacity",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to ensureUnusedCapacity from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn ensureUnusedCapacity(\n    self: *Map,\n    allocator: Allocator,\n    additional_capacity: u32,\n) !void {\n    return self.ensureTotalCapacity(allocator, self.count() + additional_capacity);\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "ensureUnusedCapacity",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to put from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn put(self: *Map, allocator: Allocator, key: *const Value, value: *Value) !void {\n    const result = try self.getOrPut(allocator, key);\n    result.value_ptr.* = value;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "put",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to putNoClobber from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn putNoClobber(self: *Map, allocator: Allocator, key: *const Value, value: *Value) !void {\n    const result = try self.getOrPut(allocator, key);\n    assert(!result.found_existing);\n    result.value_ptr.* = value;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "putNoClobber",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to putAssumeCapacity from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn putAssumeCapacity(self: *Map, key: *const Value, value: *Value) void {\n    const result = self.getOrPutAssumeCapacity(key);\n    result.value_ptr.* = value;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "putAssumeCapacity",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to putAssumeCapacityNoClobber from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn putAssumeCapacityNoClobber(self: *Map, key: *const Value, value: *Value) void {\n    const result = self.getOrPutAssumeCapacity(key);\n    assert(!result.found_existing);\n    result.value_ptr.* = value;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "putAssumeCapacityNoClobber",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getIndex from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn getIndex(self: Map, key: *const Value) ?u32 {\n    const header = self.index_header orelse {\n        // Linear scan.\n        const h = key.hash();\n        const slice = self.entries.slice();\n        const hashes_array = slice.items(.hash);\n        const keys_array = slice.items(.key);\n        for (keys_array, 0..) |*item_key, i| {\n            if (hashes_array[i] == h and key.eql(item_key.*)) {\n                return @intCast(i);\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "getIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getIndexWithHeaderGeneric from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn getIndexWithHeaderGeneric(self: Map, key: anytype, header: *IndexHeader, comptime I: type) ?u32 {\n    const indexes = header.indexes(I);\n    const slot = self.getSlotByKey(key, header, I, indexes) orelse return null;\n    return indexes[slot].entry_index;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "getIndexWithHeaderGeneric",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn get(self: Map, key: *const Value) ?*Value {\n    const index = self.getIndex(key) orelse return null;\n    return self.values()[index];\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "get",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to contains from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn contains(self: Map, key: *const Value) bool {\n    return self.getIndex(key) != null;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "contains",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to clone from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub fn clone(self: Map, allocator: Allocator) !Map {\n    var other: Map = .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "clone",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getOrPutInternal from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn getOrPutInternal(self: *Map, key: *const Value, header: *IndexHeader, comptime I: type) GetOrPutResult {\n    const slice = self.entries.slice();\n    const hashes_array = slice.items(.hash);\n    const keys_array = slice.items(.key);\n    const values_array = slice.items(.value);\n    const indexes = header.indexes(I);\n\n    const h = key.hash();\n    const start_index = h;\n    const end_index = start_index +% indexes.len;\n\n    var index = start_index;\n    var distance_from_start_index: I = 0;\n    while (index != end_index) : ({\n        index +%= 1;\n        distance_from_start_index += 1;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "getOrPutInternal",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getSlotByKey from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn getSlotByKey(self: Map, key: anytype, header: *IndexHeader, comptime I: type, indexes: []Index(I)) ?u32 {\n    const slice = self.entries.slice();\n    const hashes_array = slice.items(.hash);\n    const keys_array = slice.items(.key);\n    const h = key.hash();\n\n    const start_index = h;\n    const end_index = start_index +% indexes.len;\n\n    var index = start_index;\n    var distance_from_start_index: I = 0;\n    while (index != end_index) : ({\n        index +%= 1;\n        distance_from_start_index += 1;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "getSlotByKey",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to insertAllEntriesIntoNewHeader from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn insertAllEntriesIntoNewHeader(self: *Map, header: *IndexHeader) void {\n    switch (header.capacityIndexType()) {\n        .u8 => return self.insertAllEntriesIntoNewHeaderGeneric(header, u8),\n        .u16 => return self.insertAllEntriesIntoNewHeaderGeneric(header, u16),\n        .u32 => return self.insertAllEntriesIntoNewHeaderGeneric(header, u32),\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "insertAllEntriesIntoNewHeader",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to insertAllEntriesIntoNewHeaderGeneric from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn insertAllEntriesIntoNewHeaderGeneric(self: *Map, header: *IndexHeader, comptime I: type) void {\n    const slice = self.entries.slice();\n    const items = slice.items(.hash);\n    const indexes = header.indexes(I);\n\n    entry_loop: for (items, 0..) |key, i| {\n        const start_index = key;\n        const end_index = start_index +% indexes.len;\n        var index = start_index;\n        var entry_index: I = @intCast(i);\n        var distance_from_start_index: I = 0;\n        while (index != end_index) : ({\n            index +%= 1;\n            distance_from_start_index += 1;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "insertAllEntriesIntoNewHeaderGeneric",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to capacityIndexType from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn capacityIndexType(bit_index: u8) CapacityIndexType {\n    if (bit_index <= 8)\n        return .u8;\n    if (bit_index <= 16)\n        return .u16;\n    assert(bit_index <= 32);\n    return .u32;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "capacityIndexType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to capacityIndexSize from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn capacityIndexSize(bit_index: u8) u32 {\n    switch (capacityIndexType(bit_index)) {\n        .u8 => return @sizeOf(Index(u8)),\n        .u16 => return @sizeOf(Index(u16)),\n        .u32 => return @sizeOf(Index(u32)),\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "capacityIndexSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to Index from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn Index(comptime I: type) type {\n    return extern struct {\n        const Self = @This();\n\n        /// The index of this entry in the backing store.  If the index is\n        /// empty, this is empty_sentinel.\n        entry_index: I,\n\n        /// The distance between this slot and its ideal placement.  This is\n        /// used to keep maximum scan length small.  This value is undefined\n        /// if the index is empty.\n        distance_from_start_index: I,\n\n        /// The special entry_index value marking an empty slot.\n        const empty_sentinel = ~@as(I, 0);\n\n        /// A constant empty index\n        const empty = Self{\n            .entry_index = empty_sentinel,\n            .distance_from_start_index = undefined,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "Index",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to isEmpty from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn isEmpty(idx: Self) bool {\n            return idx.entry_index == empty_sentinel;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "isEmpty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to setEmpty from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn setEmpty(idx: *Self) void {\n            idx.entry_index = empty_sentinel;\n            idx.distance_from_start_index = undefined;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "setEmpty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to constrainIndex from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn constrainIndex(header: IndexHeader, i: u32) u32 {\n        // This is an optimization for modulo of power of two integers;\n        // it requires `indexes_len` to always be a power of two.\n        return @intCast(i & header.mask());\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "constrainIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to indexes from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn indexes(header: *IndexHeader, comptime I: type) []Index(I) {\n        const start_ptr: [*]Index(I) = @ptrCast(@alignCast(@as([*]u8, @ptrCast(header)) + @sizeOf(IndexHeader)));\n        return start_ptr[0..header.length()];\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "indexes",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to capacityIndexType from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn capacityIndexType(header: IndexHeader) CapacityIndexType {\n        return Map.capacityIndexType(header.bit_index);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "capacityIndexType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to capacity from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn capacity(self: IndexHeader) u32 {\n        return index_capacities[self.bit_index];\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "capacity",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to length from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn length(self: IndexHeader) u32 {\n        return @as(u32, 1) << @intCast(self.bit_index);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "length",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to mask from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn mask(self: IndexHeader) u32 {\n        return @intCast(self.length() - 1);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "mask",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findBitIndex from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn findBitIndex(desired_capacity: u32) !u8 {\n        if (desired_capacity > max_capacity) return error.OutOfMemory;\n        var new_bit_index: u8 = @intCast(std.math.log2_int_ceil(u32, desired_capacity));\n        if (desired_capacity > index_capacities[new_bit_index]) new_bit_index += 1;\n        if (new_bit_index < min_bit_index) new_bit_index = min_bit_index;\n        assert(desired_capacity <= index_capacities[new_bit_index]);\n        return new_bit_index;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "findBitIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to alloc from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn alloc(allocator: Allocator, new_bit_index: u8) !*IndexHeader {\n        const len = @as(usize, 1) << @intCast(new_bit_index);\n        const index_size = Map.capacityIndexSize(new_bit_index);\n        const nbytes = @sizeOf(IndexHeader) + index_size * len;\n        const bytes = try allocator.alignedAlloc(u8, @alignOf(IndexHeader), nbytes);\n        @memset(bytes[@sizeOf(IndexHeader)..], 0xff);\n        const result: *IndexHeader = @ptrCast(bytes.ptr);\n        result.* = .{\n            .bit_index = new_bit_index,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "alloc",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to free from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "fn free(header: *IndexHeader, allocator: Allocator) void {\n        const index_size = Map.capacityIndexSize(header.bit_index);\n        const ptr: [*]align(@alignOf(IndexHeader)) u8 = @ptrCast(header);\n        const slice = ptr[0 .. @sizeOf(IndexHeader) + header.length() * index_size];\n        allocator.free(slice);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "function",
      "name": "free",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Entry from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub const Entry = struct {\n    key_ptr: **const Value,\n    value_ptr: **Value,\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "struct",
      "name": "Entry",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to KV from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub const KV = struct {\n    key: *const Value,\n    value: *Value,\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "struct",
      "name": "KV",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Data from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub const Data = struct {\n    hash: Hash,\n    key: *const Value,\n    value: *Value,\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "struct",
      "name": "Data",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to GetOrPutResult from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub const GetOrPutResult = struct {\n    key_ptr: **const Value,\n    value_ptr: **Value,\n    found_existing: bool,\n    index: u32,\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "struct",
      "name": "GetOrPutResult",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Iterator from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "pub const Iterator = struct {\n    keys: [*]*const Value,\n    values: [*]*Value,\n    len: u32,\n    index: u32 = 0,\n\n    pub fn next(it: *Iterator) ?Entry {\n        if (it.index >= it.len) return null;\n        const result = Entry{\n            .key_ptr = &it.keys[it.index],\n            .value_ptr = &it.values[it.index],\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "struct",
      "name": "Iterator",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to IndexHeader from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "const IndexHeader = struct {\n    /// This field tracks the total number of items in the arrays following\n    /// this header.  It is the bit index of the power of two number of indices.\n    /// This value is between min_bit_index and max_bit_index, inclusive.\n    bit_index: u8 align(@alignOf(u32)),\n\n    /// Map from an incrementing index to an index slot in the attached arrays.\n    fn constrainIndex(header: IndexHeader, i: u32) u32 {\n        // This is an optimization for modulo of power of two integers;\n        // it requires `indexes_len` to always be a power of two.\n        return @intCast(i & header.mask());\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "struct",
      "name": "IndexHeader",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to start_ptr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "const start_ptr: [*]Index(I) = @ptrCast(@alignCast(@as([*]u8, @ptrCast(header)) + @sizeOf(IndexHeader)));",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "const",
      "name": "start_ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to result from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "const result: *IndexHeader = @ptrCast(bytes.ptr);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "const",
      "name": "result",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Map.zig",
    "response": "const ptr: [*]align(@alignOf(IndexHeader)) u8 = @ptrCast(header);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Map.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to finish from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn finish(b: Builder) String {\n        return .{\n            .data = b.inner.items,\n            .capacity = b.inner.capacity,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "finish",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to cancel from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn cancel(b: *Builder) void {\n        b.inner.deinit();\n        b.* = undefined;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "cancel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to append from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn append(b: *Builder, data: []const u8) !void {\n        try b.inner.appendSlice(data);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "append",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writer from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn writer(self: *Builder) Writer {\n        return .{ .context = self }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "writer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to appendWrite from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "fn appendWrite(self: *Builder, data: []const u8) !usize {\n        try self.append(data);\n        return data.len;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "appendWrite",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to builder from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn builder(allocator: Allocator) Builder {\n    return Builder{\n        .inner = std.ArrayList(u8).init(allocator),\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "builder",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn init(allocator: Allocator, comptime fmt: []const u8, args: anytype) !String {\n    var b = builder(allocator);\n    errdefer b.cancel();\n\n    try b.writer().print(fmt, args);\n    return b.finish();\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "init",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn deinit(str: *String, allocator: Allocator) void {\n    if (str.capacity != 0) {\n        allocator.free(str.data);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn eql(a: String, b: String) bool {\n    return mem.eql(u8, a.data, b.data);\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dump from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn dump(str: String, writer: anytype) !void {\n    try writer.print(\"\\\"{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "dump",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn get(str: *const String, ctx: Vm.Context, index: *const Value, res: *?*Value) Value.NativeError!void {\n    switch (index.*) {\n        .int => return ctx.frame.fatal(ctx.vm, \"TODO str get int\"),\n        .range => return ctx.frame.fatal(ctx.vm, \"TODO str get with ranges\"),\n        .str => |*s| {\n            if (res.* == null) {\n                res.* = try ctx.vm.gc.alloc(.int);\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "get",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to append from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn append(str: Value.This(*String), ctx: Vm.Context, strs: Value.Variadic([]const u8)) !void {\n        var b = builder(ctx.vm.gc.gpa);\n        errdefer b.cancel();\n\n        var len = str.t.data.len;\n        for (strs.t) |new| len += new.len;\n        try b.inner.ensureUnusedCapacity(len);\n\n        b.inner.appendSliceAssumeCapacity(str.t.data);\n        for (strs.t) |new| b.inner.appendSliceAssumeCapacity(new);\n\n        str.t.deinit(ctx.vm.gc.gpa);\n        str.t.* = b.finish();\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "append",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to format from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn format(str: Value.This([]const u8), ctx: Vm.Context, args: Value.Variadic(*Value)) !*Value {\n        var b = builder(ctx.vm.gc.gpa);\n        errdefer b.cancel();\n\n        try b.inner.ensureTotalCapacity(str.t.len);\n\n        const w = b.writer();\n        var state: enum {\n            start,\n            brace,\n            format,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "format",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to join from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn join(str: Value.This([]const u8), ctx: Vm.Context, strs: Value.Variadic([]const u8)) !*Value {\n        if (strs.t.len == 0) {\n            const ret = try ctx.vm.gc.alloc(.str);\n            ret.* = Value.string(\"\");\n            return ret;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "join",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to set from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn set(str: *String, ctx: Vm.Context, index: *const Value, new_val: *const Value) Value.NativeError!void {\n    _ = str;\n    _ = index;\n    _ = new_val;\n    return ctx.frame.fatal(ctx.vm, \"TODO set string\");\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "set",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to as from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn as(str: *String, ctx: Vm.Context, type_id: Type) Value.NativeError!*Value {\n    if (type_id == .null) {\n        return Value.Null;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "as",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to from from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn from(val: *Value, vm: *Vm) Vm.Error!*Value {\n    const str = try vm.gc.alloc(.str);\n\n    if (val == Value.Null) {\n        str.* = Value.string(\"null\");\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "from",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to in from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub fn in(str: *const String, val: *const Value) bool {\n    if (val.* != .str) return false;\n    return mem.indexOf(u8, str.data, val.str.data) != null;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "function",
      "name": "in",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Builder from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub const Builder = struct {\n    inner: std.ArrayList(u8),\n\n    pub fn finish(b: Builder) String {\n        return .{\n            .data = b.inner.items,\n            .capacity = b.inner.capacity,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "struct",
      "name": "Builder",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to methods from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/String.zig",
    "response": "pub const methods = struct {\n    pub fn append(str: Value.This(*String), ctx: Vm.Context, strs: Value.Variadic([]const u8)) !void {\n        var b = builder(ctx.vm.gc.gpa);\n        errdefer b.cancel();\n\n        var len = str.t.data.len;\n        for (strs.t) |new| len += new.len;\n        try b.inner.ensureUnusedCapacity(len);\n\n        b.inner.appendSliceAssumeCapacity(str.t.data);\n        for (strs.t) |new| b.inner.appendSliceAssumeCapacity(new);\n\n        str.t.deinit(ctx.vm.gc.gpa);\n        str.t.* = b.finish();\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/String.zig",
      "type": "struct",
      "name": "methods",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub fn deinit(tree: *Tree, gpa: Allocator) void {\n    tree.tokens.deinit(gpa);\n    tree.nodes.deinit(gpa);\n    gpa.free(tree.extra);\n    gpa.free(tree.root_nodes);\n    tree.* = undefined;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tokenSlice from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub fn tokenSlice(tree: Tree, tok: Token.Index) []const u8 {\n    const starts = tree.tokens.items(.start);\n    const ends = tree.tokens.items(.end);\n    return tree.source[starts[tok]..ends[tok]];\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "function",
      "name": "tokenSlice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to firstToken from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub fn firstToken(tree: Tree, node: Node.Index) Token.Index {\n    const toks = tree.nodes.items(.token);\n    const ids = tree.nodes.items(.id);\n    const data = tree.nodes.items(.data);\n    var cur = node;\n    while (true) switch (ids[cur]) {\n        .bool_not_expr,\n        .bit_not_expr,\n        .negate_expr,\n        .spread_expr,\n        .await_expr,\n        .decl,\n        .ident_expr,\n        .discard_expr,\n        .return_expr,\n        .break_expr,\n        .continue_expr,\n        .throw_expr,\n        .suspend_expr,\n        .resume_expr,\n        .fn_expr,\n        .fn_expr_one,\n        .paren_expr,\n        .tuple_expr,\n        .tuple_expr_two,\n        .list_expr,\n        .list_expr_two,\n        .map_expr,\n        .map_expr_two,\n        .error_expr,\n        .string_expr,\n        .int_expr,\n        .num_expr,\n        .true_expr,\n        .false_expr,\n        .this_expr,\n        .null_expr,\n        .if_expr,\n        .if_else_expr,\n        .if_let_expr,\n        .if_let_else_expr,\n        .while_expr,\n        .while_let_expr,\n        .for_expr,\n        .for_let_expr,\n        .match_expr,\n        .match_expr_one,\n        .try_expr,\n        .try_expr_one,\n        .catch_expr,\n        .catch_let_expr,\n        .block_stmt,\n        .block_stmt_two,\n        .import_expr,\n        => return toks[cur],\n        .mut_ident_expr,\n        .enum_expr,\n        .match_case_catch_all,\n        => return tree.prevToken(toks[cur]),\n        .call_expr => cur = tree.extra[data[cur].range.start],\n        .async_call_expr => {\n            cur = tree.extra[data[cur].range.start];\n            const first_token = tree.firstToken(cur);\n            return tree.prevToken(first_token);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "function",
      "name": "firstToken",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to lastToken from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub fn lastToken(tree: Tree, node: Node.Index) Token.Index {\n    const tokens = tree.nodes.items(.token);\n    const ids = tree.nodes.items(.id);\n    const data = tree.nodes.items(.data);\n    const tok_ids = tree.tokens.items(.id);\n    var cur = node;\n    while (true) switch (ids[cur]) {\n        .ident_expr,\n        .mut_ident_expr,\n        .discard_expr,\n        .string_expr,\n        .int_expr,\n        .num_expr,\n        .true_expr,\n        .false_expr,\n        .this_expr,\n        .null_expr,\n        .break_expr,\n        .continue_expr,\n        .suspend_expr,\n        .member_access_expr,\n        => return tokens[cur],\n        .match_case,\n        .try_expr,\n        .fn_expr,\n        .match_expr,\n        .block_stmt,\n        => cur = tree.extra[data[cur].range.end - 1],\n        .fn_expr_one => cur = data[cur].bin.rhs,\n        .paren_expr => return tree.nextToken(tree.lastToken(data[cur].un)),\n        .tuple_expr,\n        .list_expr,\n        .map_expr,\n        .call_expr,\n        .async_call_expr,\n        => {\n            const next = tree.nextToken(tree.lastToken(tree.extra[data[cur].range.end - 1]));\n            return if (tok_ids[next] == .comma)\n                tree.nextToken(next)\n            else\n                next;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "function",
      "name": "lastToken",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to prevToken from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub fn prevToken(tree: Tree, tok: Token.Index) Token.Index {\n    const ids = tree.tokens.items(.id);\n    var i = tok - 1;\n    while (true) switch (ids[i]) {\n        // zig fmt: off\n        .indent_1, .indent_2, .indent_3, .indent_4, .indent_5,\n        .indent_6, .indent_7, .indent_8, .indent_9, .indent_10,\n        .indent_11, .indent_12, .indent_13, .indent_14, .indent_15,\n        .indent_16, .indent_17, .indent_18, .indent_19, .indent_20,\n        .indent_21, .indent_22, .indent_23, .indent_24, .indent_25,\n        .indent_26, .indent_27, .indent_28, .indent_29, .indent_30,\n        .indent_31, .indent_32, .nl => i -= 1,\n        else => return i,\n        // zig fmt: on\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "function",
      "name": "prevToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nextToken from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub fn nextToken(tree: Tree, tok: Token.Index) Token.Index {\n    const ids = tree.tokens.items(.id);\n    var i = tok + 1;\n    while (true) switch (ids[i]) {\n        // zig fmt: off\n        .indent_1, .indent_2, .indent_3, .indent_4, .indent_5,\n        .indent_6, .indent_7, .indent_8, .indent_9, .indent_10,\n        .indent_11, .indent_12, .indent_13, .indent_14, .indent_15,\n        .indent_16, .indent_17, .indent_18, .indent_19, .indent_20,\n        .indent_21, .indent_22, .indent_23, .indent_24, .indent_25,\n        .indent_26, .indent_27, .indent_28, .indent_29, .indent_30,\n        .indent_31, .indent_32, .nl => i += 1,\n        else => return i,\n        // zig fmt: on\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "function",
      "name": "nextToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lineDist from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub fn lineDist(tree: Tree, a: Token.Index, b: Token.Index) u32 {\n    var count: u32 = 0;\n    const ids = tree.tokens.items(.id);\n    var i = a;\n    while (i < b) : (i += 1) {\n        count += @intFromBool(ids[i] == .nl);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "function",
      "name": "lineDist",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to str from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub fn str(f: @This(), extra: []Index) []Token.Index {\n                return @ptrCast(extra[f.fmt_start..f.args_start]);\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "function",
      "name": "str",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to exprs from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub fn exprs(f: @This(), extra: []Index) []Index {\n                // there are N -1 expressions for N string parts\n                return extra[f.args_start..][0 .. f.args_start - f.fmt_start - 1];\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "function",
      "name": "exprs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub fn get(tree: Tree, node: Node.Index) Range {\n        const tokens = tree.nodes.items(.token);\n        var range = Range{\n            .start = undefined,\n            .colon_1 = tokens[node],\n            .end = null,\n            .colon_2 = null,\n            .step = null,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "function",
      "name": "get",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub fn get(tree: Tree, node: Node.Index) For {\n        const tokens = tree.nodes.items(.token);\n        var for_expr: For = undefined;\n        for_expr.for_tok = tokens[node];\n\n        const data = tree.nodes.items(.data);\n        if (tree.nodes.items(.id)[node] == .for_let_expr) {\n            for_expr.let_tok = tree.nextToken(tokens[node]);\n            for_expr.capture = tree.extra[data[node].cond.extra];\n            for_expr.in_tok = tree.nextToken(tree.lastToken(for_expr.capture.?));\n            for_expr.cond = data[node].cond.cond;\n            for_expr.body = tree.extra[data[node].cond.extra + 1];\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "function",
      "name": "get",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub fn get(tree: Tree, node: Node.Index) While {\n        const tokens = tree.nodes.items(.token);\n        var while_expr: While = undefined;\n        while_expr.while_tok = tokens[node];\n\n        const data = tree.nodes.items(.data);\n        if (tree.nodes.items(.id)[node] == .while_let_expr) {\n            while_expr.let_tok = tree.nextToken(tokens[node]);\n            while_expr.capture = tree.extra[data[node].cond.extra];\n            while_expr.eq_tok = tree.nextToken(tree.lastToken(while_expr.capture.?));\n            while_expr.cond = data[node].cond.cond;\n            while_expr.body = tree.extra[data[node].cond.extra + 1];\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "function",
      "name": "get",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub fn get(tree: Tree, node: Node.Index) If {\n        const tokens = tree.nodes.items(.token);\n        var if_expr: If = undefined;\n        if_expr.if_tok = tokens[node];\n\n        const data = tree.nodes.items(.data);\n        switch (tree.nodes.items(.id)[node]) {\n            .if_expr => {\n                if_expr.capture = null;\n                if_expr.cond = data[node].bin.lhs;\n                if_expr.then_body = data[node].bin.rhs;\n                if_expr.else_body = null;\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "function",
      "name": "get",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nodeItems from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub fn nodeItems(tree: Tree, node: Node.Index, buf: *[2]Node.Index) []const Node.Index {\n    const data = tree.nodes.items(.data);\n    switch (tree.nodes.items(.id)[node]) {\n        .tuple_expr_two,\n        .list_expr_two,\n        .map_expr_two,\n        .block_stmt_two,\n        .try_expr_one,\n        .fn_expr_one,\n        .call_expr_one,\n        .async_call_expr_one,\n        .match_expr_one,\n        .match_case_one,\n        => {\n            buf[0] = data[node].bin.lhs;\n            buf[1] = data[node].bin.rhs;\n            if (buf[1] != 0) {\n                return buf[0..2];\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "function",
      "name": "nodeItems",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Node from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub const Node = struct {\n    id: Id,\n    token: Token.Index,\n    data: Data,\n\n    pub const Data = union {\n        un: Index,\n        bin: struct {\n            lhs: Index,\n            rhs: Index,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "struct",
      "name": "Node",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Range from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub const Range = struct {\n    start: Node.Index,\n    colon_1: Token.Index,\n    end: ?Node.Index,\n    colon_2: ?Token.Index,\n    step: ?Node.Index,\n\n    pub fn get(tree: Tree, node: Node.Index) Range {\n        const tokens = tree.nodes.items(.token);\n        var range = Range{\n            .start = undefined,\n            .colon_1 = tokens[node],\n            .end = null,\n            .colon_2 = null,\n            .step = null,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "struct",
      "name": "Range",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to For from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub const For = struct {\n    for_tok: Token.Index,\n    let_tok: Token.Index,\n    capture: ?Node.Index,\n    in_tok: Token.Index,\n    cond: Node.Index,\n    body: Node.Index,\n\n    pub fn get(tree: Tree, node: Node.Index) For {\n        const tokens = tree.nodes.items(.token);\n        var for_expr: For = undefined;\n        for_expr.for_tok = tokens[node];\n\n        const data = tree.nodes.items(.data);\n        if (tree.nodes.items(.id)[node] == .for_let_expr) {\n            for_expr.let_tok = tree.nextToken(tokens[node]);\n            for_expr.capture = tree.extra[data[node].cond.extra];\n            for_expr.in_tok = tree.nextToken(tree.lastToken(for_expr.capture.?));\n            for_expr.cond = data[node].cond.cond;\n            for_expr.body = tree.extra[data[node].cond.extra + 1];\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "struct",
      "name": "For",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to While from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub const While = struct {\n    while_tok: Token.Index,\n    let_tok: Token.Index,\n    capture: ?Node.Index,\n    eq_tok: Token.Index,\n    cond: Node.Index,\n    body: Node.Index,\n\n    pub fn get(tree: Tree, node: Node.Index) While {\n        const tokens = tree.nodes.items(.token);\n        var while_expr: While = undefined;\n        while_expr.while_tok = tokens[node];\n\n        const data = tree.nodes.items(.data);\n        if (tree.nodes.items(.id)[node] == .while_let_expr) {\n            while_expr.let_tok = tree.nextToken(tokens[node]);\n            while_expr.capture = tree.extra[data[node].cond.extra];\n            while_expr.eq_tok = tree.nextToken(tree.lastToken(while_expr.capture.?));\n            while_expr.cond = data[node].cond.cond;\n            while_expr.body = tree.extra[data[node].cond.extra + 1];\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "struct",
      "name": "While",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to If from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Tree.zig",
    "response": "pub const If = struct {\n    if_tok: Token.Index,\n    let_tok: Token.Index,\n    capture: ?Node.Index,\n    eq_tok: Token.Index,\n    cond: Node.Index,\n    then_body: Node.Index,\n    else_tok: Token.Index,\n    else_body: ?Node.Index,\n\n    pub fn get(tree: Tree, node: Node.Index) If {\n        const tokens = tree.nodes.items(.token);\n        var if_expr: If = undefined;\n        if_expr.if_tok = tokens[node];\n\n        const data = tree.nodes.items(.data);\n        switch (tree.nodes.items(.id)[node]) {\n            .if_expr => {\n                if_expr.capture = null;\n                if_expr.cond = data[node].bin.lhs;\n                if_expr.then_body = data[node].bin.rhs;\n                if_expr.else_body = null;\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Tree.zig",
      "type": "struct",
      "name": "If",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn deinit(f: *Frame, vm: *Vm) void {\n        f.err_handlers.deinit(vm.gc.gpa);\n        f.stack.deinit(vm.gc.gpa);\n        f.* = undefined;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to newVal from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn newVal(f: *Frame, vm: *Vm, ref: Ref, ty: Type) !*Value {\n        const res = try f.newRef(vm, ref);\n        if (res.*) |some| {\n            // attempt to use old value for better performance in loops\n            switch (some.*) {\n                // simple values can be reused\n                .int, .num, .range, .native => return some,\n                // if string doesn't own it's contents it can be reused\n                .str => |s| if (s.capacity == 0) return some,\n                else => {}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "newVal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to newRef from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn newRef(f: *Frame, vm: *Vm, ref: Ref) !*?*Value {\n        const ref_int = @intFromEnum(ref);\n        if (ref_int < f.stack.items.len) {\n            return @ptrCast(&f.stack.items[ref_int]);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "newRef",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to refAssert from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "fn refAssert(f: *Frame, ref: Ref) **Value {\n        return &f.stack.items[@intFromEnum(ref)];\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "refAssert",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to val from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn val(f: *Frame, ref: Ref) *Value {\n        return f.stack.items[@intFromEnum(ref)];\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to valDupeSimple from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "fn valDupeSimple(f: *Frame, vm: *Vm, ref: Ref) !*Value {\n        const old = f.val(ref);\n        // do the opposite of newVal in case the value is added to an aggregate\n        switch (old.*) {\n            .int, .num, .range, .native => {}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "valDupeSimple",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to int from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn int(f: *Frame, vm: *Vm, ref: Ref) !?i64 {\n        const res = f.val(ref);\n        if (res.* != .int) {\n            try f.throw(vm, \"expected an integer\");\n            return null;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "int",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to num from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn num(f: *Frame, vm: *Vm, ref: Ref) !?*Value {\n        const res = f.val(ref);\n        switch (res.*) {\n            .int, .num => return res,\n            else => {\n                try f.throw(vm, \"expected a number\");\n                return null;\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "num",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ctx from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn ctx(f: *Frame, vm: *Vm) Context {\n        return .{ .this = Value.Null, .vm = vm, .frame = f }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "ctx",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ctxThis from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn ctxThis(f: *Frame, this: *Value, vm: *Vm) Context {\n        return .{ .this = this, .vm = vm, .frame = f }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "ctxThis",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fatal from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn fatal(f: *Frame, vm: *Vm, msg: []const u8) Error {\n        @branchHint(.cold);\n        return f.fatalExtra(vm, .{ .data = msg }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "fatal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fatalExtra from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn fatalExtra(f: *Frame, vm: *Vm, msg: Value.String, kind: bog.Errors.Kind) Error {\n        @branchHint(.cold);\n\n        const byte_offset = f.mod.debug_info.lines.get(f.body[f.ip - 1]).?;\n        try vm.errors.add(msg, f.mod.debug_info.source, f.mod.debug_info.path, byte_offset, kind);\n        if (f.caller_frame) |some| return some.fatalExtra(vm, .{ .data = \"called here\" }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "fatalExtra",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to throw from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn throw(f: *Frame, vm: *Vm, err: []const u8) !void {\n        if (f.err_handlers.get()) |handler| {\n            const handler_operand = try f.newRef(vm, handler.operand);\n            handler_operand.* = try vm.errorVal(err);\n            f.ip = handler.offset;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "throw",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to throwFmt from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn throwFmt(f: *Frame, vm: *Vm, comptime err: []const u8, args: anytype) !void {\n        if (f.err_handlers.get()) |handler| {\n            const handler_operand = try f.newRef(vm, handler.operand);\n            handler_operand.* = try vm.errorFmt(err, args);\n            f.ip = handler.offset;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "throwFmt",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to throw from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn throw(ctx: Context, err: []const u8) Value.NativeError {\n        try ctx.frame.throw(ctx.vm, err);\n        return error.Throw;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "throw",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to throwFmt from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn throwFmt(ctx: Context, comptime err: []const u8, args: anytype) Value.NativeError {\n        try ctx.frame.throwFmt(ctx.vm, err, args);\n        return error.Throw;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "throwFmt",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn init(allocator: Allocator, options: Options) Vm {\n    return .{\n        .gc = Gc.init(allocator, options.page_limit),\n        .errors = Errors.init(allocator),\n        .options = options,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn deinit(vm: *Vm) void {\n    vm.errors.deinit();\n    vm.gc.deinit();\n    vm.imports.deinit(vm.gc.gpa);\n    var it = vm.imported_modules.iterator();\n    while (it.next()) |mod| {\n        mod.value_ptr.*.deinit(vm.gc.gpa);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addPackage from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn addPackage(vm: *Vm, name: []const u8, comptime importable: anytype) Allocator.Error!void {\n    try vm.imports.putNoClobber(vm.gc.gpa, name, struct {\n        fn func(ctx: Context) Vm.Error!*bog.Value {\n            if (@typeInfo(@TypeOf(importable)) == .@\"fn\") {\n                return bog.Value.zigFnToBog(ctx.vm, importable);\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "addPackage",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to addStd from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn addStd(vm: *Vm) Allocator.Error!void {\n    try vm.addStdNoIo();\n    try vm.addPackage(\"std.io\", bog.std.io);\n    try vm.addPackage(\"std.fs\", bog.std.fs);\n    try vm.addPackage(\"std.os\", bog.std.os);\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "addStd",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to addStdNoIo from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn addStdNoIo(vm: *Vm) Allocator.Error!void {\n    try vm.addPackage(\"std.math\", bog.std.math);\n    try vm.addPackage(\"std.map\", bog.std.map);\n    try vm.addPackage(\"std.debug\", bog.std.debug);\n    try vm.addPackage(\"std.json\", bog.std.json);\n    try vm.addPackage(\"std.gc\", bog.std.gc);\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "addStdNoIo",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to compileAndRun from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn compileAndRun(vm: *Vm, file_path: []const u8) !*Value {\n    const mod = vm.importFile(file_path) catch |err| switch (err) {\n        error.ImportingDisabled => unreachable,\n        else => |e| return e,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "compileAndRun",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn run(vm: *Vm, f: *Frame) (Error || error{Suspended}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "run",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub fn deinit(e: *ErrHandlers, gpa: Allocator) void {\n        if (e.short.capacity != 4) {\n            gpa.free(e.long.ptr[0..e.long.capacity]);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to push from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "fn push(e: *ErrHandlers, gpa: Allocator, new: Handler) !void {\n        if (e.short.capacity != 4) {\n            var arr_list = std.ArrayList(Handler){\n                .items = e.long.ptr[0..e.long.len],\n                .capacity = e.long.capacity,\n                .allocator = gpa,\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "push",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to pop from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "fn pop(e: *ErrHandlers) Handler {\n        const handler = e.get().?;\n        e.short.len -= 1;\n        return handler;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "pop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "fn get(e: ErrHandlers) ?Handler {\n        return if (e.short.len == 0)\n            null\n        else if (e.short.capacity == 4)\n            e.short.arr[e.short.len - 1]\n        else\n            e.long.ptr[e.long.len - 1];\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "get",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to needNum from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "fn needNum(a: *Value, b: *Value) bool {\n    return a.* == .num or b.* == .num;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "needNum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to asNum from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "fn asNum(val: *Value) f64 {\n    return switch (val.*) {\n        .int => |v| @floatFromInt(v),\n        .num => |v| v,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "asNum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to checkZero from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "fn checkZero(val: *Value) bool {\n    switch (val.*) {\n        .int => |v| return v == 0,\n        .num => |v| return v == 0,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "checkZero",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isNegative from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "fn isNegative(val: *Value) bool {\n    switch (val.*) {\n        .int => |v| return v < 0,\n        .num => |v| return v < 0,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "isNegative",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getFrame from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "fn getFrame(vm: *Vm, f: *Frame) void {\n    const cached = vm.frame_cache.pop() orelse return;\n    f.stack = cached.s;\n    f.err_handlers = cached.e;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "getFrame",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to storeFrame from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "fn storeFrame(vm: *Vm, f: *Frame) !void {\n    f.stack.items.len = 0;\n    f.err_handlers.short.len = 0;\n    try vm.frame_cache.append(vm.gc.gpa, .{ .s = f.stack, .e = f.err_handlers }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "storeFrame",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to importFile from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "fn importFile(vm: *Vm, path: []const u8) !*Bytecode {\n    if (!vm.options.import_files) return error.ImportingDisabled;\n\n    var mod = mod: {\n        const source = try std.fs.cwd().readFileAlloc(vm.gc.gpa, path, vm.options.max_import_size);\n        errdefer vm.gc.gpa.free(source);\n\n        break :mod try bog.compile(vm.gc.gpa, source, path, &vm.errors);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "importFile",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to import from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "fn import(vm: *Vm, caller_frame: *Frame, id: []const u8) Error!*Value {\n    const mod = vm.imported_modules.get(id) orelse if (mem.endsWith(u8, id, bog.extension))\n        vm.importFile(id) catch |err| switch (err) {\n            error.ImportingDisabled => {\n                try caller_frame.throwFmt(\n                    vm,\n                    \"cannot import '{s}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "import",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to errorFmt from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "fn errorFmt(vm: *Vm, comptime fmt: []const u8, args: anytype) Vm.Error!*Value {\n    const str = try vm.gc.alloc(.str);\n    str.* = .{ .str = try Value.String.init(vm.gc.gpa, fmt, args) }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "errorFmt",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to errorVal from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "fn errorVal(vm: *Vm, msg: []const u8) !*Value {\n    const str = try vm.gc.alloc(.str);\n    str.* = Value.string(msg);\n\n    const err = try vm.gc.alloc(.err);\n    err.* = .{ .err = str }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "function",
      "name": "errorVal",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Options from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub const Options = struct {\n    /// can files be imported\n    import_files: bool = false,\n\n    /// run vm in repl mode\n    repl: bool = false,\n\n    /// maximum size of imported files\n    max_import_size: u32 = 5 * 1024 * 1024,\n\n    /// maximum amount of pages gc may allocate.\n    /// 1 page == 1 MiB.\n    /// default 2 GiB.\n    page_limit: u32 = 2048,\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "struct",
      "name": "Options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Frame from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub const Frame = struct {\n    /// List of instructions part of this function.\n    body: []const u32,\n    /// Index into `body`.\n    ip: u32 = 0,\n    /// Number of parameters current function has. Needed to calculate\n    /// a reference to instructions.\n    params: u32,\n    /// The module in which this function lives in.\n    mod: *Bytecode,\n    /// Values this function captures.\n    captures: []*Value,\n\n    /// Value of `this` as set by the caller.\n    this: *Value, // = Value.Null,\n    /// Frame of the function which called this, forms a call stack.\n    caller_frame: ?*Frame,\n    /// Frame of `mod.main`.\n    module_frame: *Frame,\n    /// This function frames stack.\n    stack: Stack = .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "struct",
      "name": "Frame",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Context from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "pub const Context = struct {\n    this: *Value, // = Value.Null,\n    vm: *Vm,\n    frame: *Vm.Frame,\n\n    pub fn throw(ctx: Context, err: []const u8) Value.NativeError {\n        try ctx.frame.throw(ctx.vm, err);\n        return error.Throw;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "struct",
      "name": "Context",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to copy from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "const copy: Value = if (needNum(lhs, rhs)) .{\n                    .int = std.math.lossyCast(i64, @divFloor(asNum(lhs), asNum(rhs))),\n                } else .{\n                    .int = std.math.divFloor(i64, lhs.int, rhs.int) catch {\n                        try f.throw(vm, \"operation overflowed\");",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "const",
      "name": "copy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to copy from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "const copy: Value = if (needNum(lhs, rhs)) .{\n                    .num = @rem(asNum(lhs), asNum(rhs)),\n                } else .{\n                    .int = @rem(lhs.int, rhs.int),\n                };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "const",
      "name": "copy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to copy from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "const copy: Value = if (needNum(lhs, rhs)) .{\n                    .num = asNum(lhs) * asNum(rhs),\n                } else .{\n                    .int = std.math.mul(i64, lhs.int, rhs.int) catch {\n                        try f.throw(vm, \"operation overflowed\");",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "const",
      "name": "copy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to copy from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "const copy: Value = if (needNum(lhs, rhs)) .{\n                    .num = std.math.pow(f64, asNum(lhs), asNum(rhs)),\n                } else .{\n                    .int = std.math.powi(i64, lhs.int, rhs.int) catch {\n                        try f.throw(vm, \"operation overflowed\");",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "const",
      "name": "copy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to copy from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "const copy: Value = if (needNum(lhs, rhs)) .{\n                    .num = asNum(lhs) + asNum(rhs),\n                } else .{\n                    .int = std.math.add(i64, lhs.int, rhs.int) catch {\n                        try f.throw(vm, \"operation overflowed\");",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "const",
      "name": "copy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to copy from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "const copy: Value = if (needNum(lhs, rhs)) .{\n                    .num = asNum(lhs) - asNum(rhs),\n                } else .{\n                    .int = std.math.sub(i64, lhs.int, rhs.int) catch {\n                        try f.throw(vm, \"operation overflowed\");",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "const",
      "name": "copy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to copy from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/Vm.zig",
    "response": "const copy: Value = if (operand.* == .num) .{\n                    .num = -operand.num,\n                } else .{\n                    .int = -operand.int,\n                };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/Vm.zig",
      "type": "const",
      "name": "copy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/bog.zig",
    "response": "pub fn init(alloc: Allocator) Errors {\n        return .{ .arena = zig_std.heap.ArenaAllocator.init(alloc) }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/bog.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/bog.zig",
    "response": "pub fn deinit(self: *Errors) void {\n        for (self.list.items) |*err| {\n            err.msg.deinit(self.arena.child_allocator);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/bog.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to add from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/bog.zig",
    "response": "pub fn add(\n        self: *Errors,\n        msg: @import(\"String.zig\"),\n        source: []const u8,\n        path: []const u8,\n        byte_offset: u32,\n        kind: Kind,\n    ) !void {\n        var start: u32 = 0;\n        // find the start of the line which is either a newline or a splice\n        var line_num: u32 = 1;\n        var i: u32 = 0;\n        while (i < byte_offset) : (i += 1) {\n            if (source[i] == '\\n') {\n                start = i + 1;\n                line_num += 1;\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/bog.zig",
      "type": "function",
      "name": "add",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to render from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/bog.zig",
    "response": "pub fn render(self: *Errors, writer: anytype) !void {\n        // TODO should be an arg\n        const tty = zig_std.io.tty.detectConfig(zig_std.io.getStdErr());\n        const gpa = self.arena.child_allocator;\n        for (self.list.items) |*e| {\n            const prefix = if (zig_std.fs.path.dirname(e.path) == null and e.path[0] != '<') \".\" ++ zig_std.fs.path.sep_str else \"\";\n            switch (e.kind) {\n                .err => {\n                    try tty.setColor(writer, .white);\n                    try writer.print(\"{s}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/bog.zig",
      "type": "function",
      "name": "render",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Errors from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/bog.zig",
    "response": "pub const Errors = struct {\n    list: List = .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/bog.zig",
      "type": "struct",
      "name": "Errors",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to bog_Vm_init from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/lib.zig",
    "response": "fn bog_Vm_init(vm: **bog.Vm, import_files: bool) Error {\n    const ptr = gpa.create(bog.Vm) catch |e| switch (e) {\n        error.OutOfMemory => return .OutOfMemory,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/lib.zig",
      "type": "function",
      "name": "bog_Vm_init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to bog_Vm_deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/lib.zig",
    "response": "fn bog_Vm_deinit(vm: *bog.Vm) void {\n    vm.deinit();\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/lib.zig",
      "type": "function",
      "name": "bog_Vm_deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to bog_Vm_addStd from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/lib.zig",
    "response": "fn bog_Vm_addStd(vm: *bog.Vm) callconv(.C) Error {\n    vm.addStd() catch |e| switch (e) {\n        error.OutOfMemory => return .OutOfMemory,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/lib.zig",
      "type": "function",
      "name": "bog_Vm_addStd",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to bog_Vm_addStdNoIo from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/lib.zig",
    "response": "fn bog_Vm_addStdNoIo(vm: *bog.Vm) callconv(.C) Error {\n    vm.addStdNoIo() catch |e| switch (e) {\n        error.OutOfMemory => return .OutOfMemory,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/lib.zig",
      "type": "function",
      "name": "bog_Vm_addStdNoIo",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to bog_Vm_run from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/lib.zig",
    "response": "fn bog_Vm_run(vm: *bog.Vm, res: **bog.Value, source: [*:0]const u8) Error {\n    res.* = vm.compileAndRun(span(source)) catch |e| switch (e) {\n        error.OutOfMemory => return .OutOfMemory,\n        error.TokenizeError => return .TokenizeError,\n        error.ParseError => return .ParseError,\n        error.CompileError => return .CompileError,\n        else => return .RuntimeError,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/lib.zig",
      "type": "function",
      "name": "bog_Vm_run",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to bog_Vm_call from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/lib.zig",
    "response": "fn bog_Vm_call(vm: *bog.Vm, res: **bog.Value, container: *bog.Value, func_name: [*:0]const u8) Error {\n    _ = vm;\n    _ = res;\n    _ = container;\n    _ = func_name;\n    if (true) return .RuntimeError;\n    // res.* = vm.run(container, span(func_name), .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/lib.zig",
      "type": "function",
      "name": "bog_Vm_call",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to bog_Vm_renderErrors from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/lib.zig",
    "response": "fn bog_Vm_renderErrors(vm: *bog.Vm, out: *std.c.FILE) Error {\n    vm.errors.render(std.io.cWriter(out)) catch return .IoError;\n\n    return .None;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/lib.zig",
      "type": "function",
      "name": "bog_Vm_renderErrors",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to bog_Errors_init from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/lib.zig",
    "response": "fn bog_Errors_init(errors: **bog.Errors) Error {\n    const ptr = gpa.create(bog.Errors) catch |e| switch (e) {\n        error.OutOfMemory => return .OutOfMemory,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/lib.zig",
      "type": "function",
      "name": "bog_Errors_init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to bog_Errors_deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/lib.zig",
    "response": "fn bog_Errors_deinit(errors: *bog.Errors) void {\n    errors.deinit();\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/lib.zig",
      "type": "function",
      "name": "bog_Errors_deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to bog_Errors_render from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/lib.zig",
    "response": "fn bog_Errors_render(errors: *bog.Errors, out: *std.c.FILE) Error {\n    errors.render(std.io.cWriter(out)) catch return .IoError;\n\n    return .None;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/lib.zig",
      "type": "function",
      "name": "bog_Errors_render",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to bog_parse from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/lib.zig",
    "response": "fn bog_parse(tree: **bog.Tree, source: [*:0]const u8, errors: *bog.Errors) Error {\n    tree.* = gpa.create(bog.Tree) catch return .OutOfMemory;\n    tree.*.* = bog.parse(gpa, span(source), \"dunno?\", errors) catch |e| switch (e) {\n        error.OutOfMemory => return .OutOfMemory,\n        error.TokenizeError => return .TokenizeError,\n        error.ParseError => return .ParseError,\n        error.NeedInput => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/lib.zig",
      "type": "function",
      "name": "bog_parse",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to bog_Tree_deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/lib.zig",
    "response": "fn bog_Tree_deinit(tree: *bog.Tree) void {\n    tree.deinit(gpa);\n    gpa.destroy(tree);\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/lib.zig",
      "type": "function",
      "name": "bog_Tree_deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to bog_Tree_render from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/lib.zig",
    "response": "fn bog_Tree_render(tree: *bog.Tree, out: *std.c.FILE, changed: ?*bool) Error {\n    const c = tree.render(std.io.cWriter(out)) catch return .IoError;\n    if (changed) |some| {\n        some.* = c;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/lib.zig",
      "type": "function",
      "name": "bog_Tree_render",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/main.zig",
    "response": "pub fn main() !void {\n    const gpa = state.allocator();\n\n    const args = try process.argsAlloc(gpa);\n    defer process.argsFree(gpa, args);\n\n    if (args.len > 1) {\n        if (mem.eql(u8, args[1], \"fmt\")) {\n            return fmt(gpa, args[2..]);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/main.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to help from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/main.zig",
    "response": "fn help() !void {\n    try std.io.getStdOut().writer().writeAll(usage);\n    process.exit(0);\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/main.zig",
      "type": "function",
      "name": "help",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/main.zig",
    "response": "fn run(gpa: std.mem.Allocator, args: []const []const u8) !void {\n    std.debug.assert(args.len > 0);\n    const file_name = args[0];\n\n    var vm = bog.Vm.init(gpa, .{ .import_files = true }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/main.zig",
      "type": "function",
      "name": "run",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to argsToBog from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/main.zig",
    "response": "fn argsToBog(ctx: bog.Vm.Context) bog.Vm.Error!*bog.Value {\n            const ret = try ctx.vm.gc.alloc(.list);\n            ret.* = .{ .list = .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/main.zig",
      "type": "function",
      "name": "argsToBog",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmt from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/main.zig",
    "response": "fn fmt(gpa: std.mem.Allocator, args: []const []const u8) !void {\n    if (args.len == 0) fatal(\"expected at least one file\", .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/main.zig",
      "type": "function",
      "name": "fmt",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmtFile from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/main.zig",
    "response": "fn fmtFile(gpa: std.mem.Allocator, name: []const u8) FmtError!bool {\n    const source = std.fs.cwd().readFileAlloc(gpa, name, 1024 * 1024) catch |e| switch (e) {\n        error.OutOfMemory => return error.OutOfMemory,\n        error.IsDir => {\n            var dir = std.fs.cwd().openDir(name, .{ .iterate = true }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/main.zig",
      "type": "function",
      "name": "fmtFile",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fatal from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/main.zig",
    "response": "fn fatal(comptime msg: []const u8, args: anytype) noreturn {\n    std.io.getStdErr().writer().print(msg ++ \"\\n\", args) catch {}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/main.zig",
      "type": "function",
      "name": "fatal",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getFileName from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/main.zig",
    "response": "fn getFileName(usage_arg: []const u8, args: []const []const u8) []const u8 {\n    if (args.len != 1) {\n        fatal(\"{s}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/main.zig",
      "type": "function",
      "name": "getFileName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to debugDump from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/main.zig",
    "response": "fn debugDump(gpa: std.mem.Allocator, args: []const []const u8) !void {\n    const file_name = getFileName(usage_debug, args);\n\n    var errors = bog.Errors.init(gpa);\n    defer errors.deinit();\n    var mod = mod: {\n        const source = std.fs.cwd().readFileAlloc(gpa, file_name, 1024 * 1024) catch |e| switch (e) {\n            error.OutOfMemory => return error.OutOfMemory,\n            else => |err| {\n                fatal(\"unable to open '{s}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/main.zig",
      "type": "function",
      "name": "debugDump",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to debugTokens from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/main.zig",
    "response": "fn debugTokens(gpa: std.mem.Allocator, args: []const []const u8) !void {\n    const file_name = getFileName(usage_debug, args);\n\n    const source = std.fs.cwd().readFileAlloc(gpa, file_name, 1024 * 1024) catch |e| switch (e) {\n        error.OutOfMemory => return error.OutOfMemory,\n        else => |err| {\n            fatal(\"unable to open '{s}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/main.zig",
      "type": "function",
      "name": "debugTokens",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to S from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/main.zig",
    "response": "const S = struct {\n        var _args: []const []const u8 = undefined;\n\n        fn argsToBog(ctx: bog.Vm.Context) bog.Vm.Error!*bog.Value {\n            const ret = try ctx.vm.gc.alloc(.list);\n            ret.* = .{ .list = .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/main.zig",
      "type": "struct",
      "name": "S",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to MultiArrayList from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn MultiArrayList(comptime S: type) type {\n    return struct {\n        bytes: [*]align(@alignOf(S)) u8 = undefined,\n        len: u32 = 0,\n        capacity: u32 = 0,\n\n        pub const Elem = S;\n\n        pub const Field = meta.FieldEnum(S);\n\n        /// A MultiArrayList.Slice contains cached start pointers for each field in the list.\n        /// These pointers are not normally stored to reduce the size of the list in memory.\n        /// If you are accessing multiple fields, call slice() first to compute the pointers,\n        /// and then get the field arrays from the slice.\n        pub const Slice = struct {\n            /// This array is indexed by the field index which can be obtained\n            /// by using @intFromEnum() on the Field enum\n            ptrs: [fields.len][*]u8,\n            len: u32,\n            capacity: u32,\n\n            pub fn items(self: Slice, comptime field: Field) []FieldType(field) {\n                const F = FieldType(field);\n                if (self.capacity == 0) {\n                    return &[_]F{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "MultiArrayList",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to toMultiArrayList from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn toMultiArrayList(self: Slice) Self {\n                if (self.ptrs.len == 0) {\n                    return .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "toMultiArrayList",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn deinit(self: *Slice, gpa: Allocator) void {\n                var other = self.toMultiArrayList();\n                other.deinit(gpa);\n                self.* = undefined;\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lessThan from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "fn lessThan(_: void, lhs: Data, rhs: Data) bool {\n                    return lhs.alignment > rhs.alignment;\n                }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "lessThan",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn deinit(self: *Self, gpa: Allocator) void {\n            gpa.free(self.allocatedBytes());\n            self.* = undefined;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toOwnedSlice from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn toOwnedSlice(self: *Self) Slice {\n            const result = self.slice();\n            self.* = .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "toOwnedSlice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to slice from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn slice(self: Self) Slice {\n            var result: Slice = .{\n                .ptrs = undefined,\n                .len = self.len,\n                .capacity = self.capacity,\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "slice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to items from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn items(self: Self, comptime field: Field) []FieldType(field) {\n            return self.slice().items(field);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "items",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to set from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn set(self: *Self, index: u32, elem: S) void {\n            const slices = self.slice();\n            inline for (fields, 0..) |field_info, i| {\n                slices.items(@enumFromInt(i))[index] = @field(elem, field_info.name);\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "set",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn get(self: Self, index: u32) S {\n            const slices = self.slice();\n            var result: S = undefined;\n            inline for (fields, 0..) |field_info, i| {\n                @field(result, field_info.name) = slices.items(@enumFromInt(i))[index];\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "get",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to append from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn append(self: *Self, gpa: Allocator, elem: S) !void {\n            try self.ensureUnusedCapacity(gpa, 1);\n            self.appendAssumeCapacity(elem);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "append",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to appendAssumeCapacity from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn appendAssumeCapacity(self: *Self, elem: S) void {\n            assert(self.len < self.capacity);\n            self.len += 1;\n            self.set(self.len - 1, elem);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "appendAssumeCapacity",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addOneAssumeCapacity from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn addOneAssumeCapacity(self: *Self) u32 {\n            assert(self.len < self.capacity);\n            const index = self.len;\n            self.len += 1;\n            return index;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "addOneAssumeCapacity",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to insert from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn insert(self: *Self, gpa: Allocator, index: u32, elem: S) !void {\n            try self.ensureUnusedCapacity(gpa, 1);\n            self.insertAssumeCapacity(index, elem);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "insert",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to insertAssumeCapacity from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn insertAssumeCapacity(self: *Self, index: u32, elem: S) void {\n            assert(self.len < self.capacity);\n            assert(index <= self.len);\n            self.len += 1;\n            const slices = self.slice();\n            inline for (fields, 0..) |field_info, field_index| {\n                const field_slice = slices.items(@enumFromInt(field_index));\n                var i: u32 = self.len - 1;\n                while (i > index) : (i -= 1) {\n                    field_slice[i] = field_slice[i - 1];\n                }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "insertAssumeCapacity",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to swapRemove from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn swapRemove(self: *Self, index: u32) void {\n            const slices = self.slice();\n            inline for (fields, 0..) |_, i| {\n                const field_slice = slices.items(@enumFromInt(i));\n                field_slice[index] = field_slice[self.len - 1];\n                field_slice[self.len - 1] = undefined;\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "swapRemove",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to orderedRemove from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn orderedRemove(self: *Self, index: u32) void {\n            const slices = self.slice();\n            inline for (fields, 0..) |_, field_index| {\n                const field_slice = slices.items(@enumFromInt(field_index));\n                var i = index;\n                while (i < self.len - 1) : (i += 1) {\n                    field_slice[i] = field_slice[i + 1];\n                }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "orderedRemove",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resize from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn resize(self: *Self, gpa: Allocator, new_len: u32) !void {\n            try self.ensureTotalCapacity(gpa, new_len);\n            self.len = new_len;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "resize",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to shrinkAndFree from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn shrinkAndFree(self: *Self, gpa: Allocator, new_len: u32) void {\n            if (new_len == 0) {\n                gpa.free(self.allocatedBytes());\n                self.* = .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "shrinkAndFree",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to shrinkRetainingCapacity from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn shrinkRetainingCapacity(self: *Self, new_len: u32) void {\n            self.len = new_len;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "shrinkRetainingCapacity",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ensureTotalCapacity from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn ensureTotalCapacity(self: *Self, gpa: Allocator, new_capacity: u32) !void {\n            var better_capacity = self.capacity;\n            if (better_capacity >= new_capacity) return;\n\n            while (true) {\n                better_capacity += better_capacity / 2 + 8;\n                if (better_capacity >= new_capacity) break;\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "ensureTotalCapacity",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to ensureUnusedCapacity from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn ensureUnusedCapacity(self: *Self, gpa: Allocator, additional_count: u32) !void {\n            return self.ensureTotalCapacity(gpa, self.len + additional_count);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "ensureUnusedCapacity",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to setCapacity from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn setCapacity(self: *Self, gpa: Allocator, new_capacity: u32) !void {\n            assert(new_capacity >= self.len);\n            const new_bytes = try gpa.alignedAlloc(\n                u8,\n                @alignOf(S),\n                capacityInBytes(new_capacity),\n            );\n            if (self.len == 0) {\n                gpa.free(self.allocatedBytes());\n                self.bytes = new_bytes.ptr;\n                self.capacity = new_capacity;\n                return;\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "setCapacity",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to clone from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn clone(self: Self, gpa: Allocator) !Self {\n            var result = Self{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "clone",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to lessThan from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "fn lessThan(ctx: @TypeOf(ctx), a_index: u32, b_index: u32) bool`\n        pub fn sort(self: Self, ctx: anytype) void {\n            const SortContext = struct {\n                sub_ctx: @TypeOf(ctx),\n                slice: Slice,\n\n                pub fn swap(sc: @This(), a_index: u32, b_index: u32) void {\n                    inline for (fields, 0..) |field_info, i| {\n                        if (@sizeOf(field_info.type) != 0) {\n                            const field: Field = @enumFromInt(i);\n                            const ptr = sc.slice.items(field);\n                            mem.swap(field_info.type, &ptr[a_index], &ptr[b_index]);\n                        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "lessThan",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lessThan from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub fn lessThan(sc: @This(), a_index: u32, b_index: u32) bool {\n                    return sc.sub_ctx.lessThan(a_index, b_index);\n                }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "lessThan",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to capacityInBytes from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "fn capacityInBytes(capacity: u32) u32 {\n            if (builtin.zig_backend == .stage2_c) {\n                var bytes: u32 = 0;\n                for (sizes.bytes) |size| bytes += size * capacity;\n                return bytes;\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "capacityInBytes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to allocatedBytes from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "fn allocatedBytes(self: Self) []align(@alignOf(S)) u8 {\n            return self.bytes[0..capacityInBytes(self.capacity)];\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "allocatedBytes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to FieldType from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "fn FieldType(comptime field: Field) type {\n            return meta.fieldInfo(S, field).type;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "function",
      "name": "FieldType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Slice from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "pub const Slice = struct {\n            /// This array is indexed by the field index which can be obtained\n            /// by using @intFromEnum() on the Field enum\n            ptrs: [fields.len][*]u8,\n            len: u32,\n            capacity: u32,\n\n            pub fn items(self: Slice, comptime field: Field) []FieldType(field) {\n                const F = FieldType(field);\n                if (self.capacity == 0) {\n                    return &[_]F{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "struct",
      "name": "Slice",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Data from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "const Data = struct {\n                size: u32,\n                size_index: u32,\n                alignment: u32,\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "struct",
      "name": "Data",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Sort from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "const Sort = struct {\n                fn lessThan(_: void, lhs: Data, rhs: Data) bool {\n                    return lhs.alignment > rhs.alignment;\n                }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "struct",
      "name": "Sort",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to SortContext from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "const SortContext = struct {\n                sub_ctx: @TypeOf(ctx),\n                slice: Slice,\n\n                pub fn swap(sc: @This(), a_index: u32, b_index: u32) void {\n                    inline for (fields, 0..) |field_info, i| {\n                        if (@sizeOf(field_info.type) != 0) {\n                            const field: Field = @enumFromInt(i);\n                            const ptr = sc.slice.items(field);\n                            mem.swap(field_info.type, &ptr[a_index], &ptr[b_index]);\n                        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "struct",
      "name": "SortContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to casted_ptr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "const casted_ptr: [*]F = if (@sizeOf(F) == 0)\n                    undefined\n                else\n                    @ptrCast(@alignCast(byte_ptr));",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "const",
      "name": "casted_ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to field from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "const field: Field = @enumFromInt(i);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "const",
      "name": "field",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to field from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "const field: Field = @enumFromInt(i);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "const",
      "name": "field",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to field from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "const field: Field = @enumFromInt(i);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "const",
      "name": "field",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to field from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "const field: Field = @enumFromInt(i);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "const",
      "name": "field",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to field from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "const field: Field = @enumFromInt(i);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "const",
      "name": "field",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to sizes_vector from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "const sizes_vector: @Vector(sizes.bytes.len, u32) = sizes.bytes;",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "const",
      "name": "sizes_vector",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to capacity_vector from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/multi_array_list.zig",
    "response": "const capacity_vector: @Vector(sizes.bytes.len, u32) = @splat(capacity);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/multi_array_list.zig",
      "type": "const",
      "name": "capacity_vector",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parse from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "pub fn parse(gpa: Allocator, source: []const u8, path: []const u8, errors: *bog.Errors) (Parser.Error || bog.Tokenizer.Error)!Tree {\n    var tokens = try bog.tokenize(gpa, source, path, errors);\n    errdefer tokens.deinit(gpa);\n\n    var parser: Parser = .{\n        .errors = errors,\n        .source = source,\n        .path = path,\n        .tok_ids = tokens.items(.id),\n        .tok_starts = tokens.items(.start),\n        .extra = std.ArrayList(Node.Index).init(gpa),\n        .node_buf = std.ArrayList(Node.Index).init(gpa),\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "parse",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseRepl from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "pub fn parseRepl(repl: *@import(\"repl.zig\").Repl) Parser.Error!?Node.Index {\n    repl.parser.tok_ids = repl.tokenizer.tokens.items(.id);\n    repl.parser.tok_starts = repl.tokenizer.tokens.items(.start);\n    repl.parser.source = repl.tokenizer.it.bytes;\n    const start_i = repl.parser.tok_i;\n    errdefer repl.parser.tok_i = start_i;\n    defer repl.parser.tok_i -= 1; // go before EOF\n\n    repl.parser.skipNl();\n    if (repl.parser.eatToken(.eof, .skip_nl)) |_| return null;\n    const ret = try repl.parser.stmt(0);\n    repl.parser.skipNl();\n    _ = try repl.parser.expectToken(.eof, .skip_nl);\n\n    repl.tree = .{\n        .root_nodes = repl.parser.node_buf.items,\n        .tokens = repl.tokenizer.tokens,\n        .extra = repl.parser.extra.items,\n        .nodes = repl.parser.nodes,\n        .source = repl.tokenizer.it.bytes,\n        .path = \"<stdin>\",\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "parseRepl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addUn from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn addUn(p: *Parser, id: Node.Id, token: Token.Index, op: Node.Index) !Node.Index {\n        const index = p.nodes.len;\n        try p.nodes.append(p.extra.allocator, .{\n            .id = id,\n            .token = token,\n            .data = .{ .un = op }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "addUn",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to addBin from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn addBin(p: *Parser, id: Node.Id, token: Token.Index, lhs: Node.Index, rhs: Node.Index) !Node.Index {\n        const index = p.nodes.len;\n        try p.nodes.append(p.extra.allocator, .{\n            .id = id,\n            .token = token,\n            .data = .{ .bin = .{ .lhs = lhs, .rhs = rhs }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "addBin",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to addList from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn addList(p: *Parser, id: Node.Id, token: Token.Index, nodes: []const Node.Index) Allocator.Error!Node.Index {\n        const start: u32 = @intCast(p.extra.items.len);\n        try p.extra.appendSlice(nodes);\n\n        const index = p.nodes.len;\n        try p.nodes.append(p.extra.allocator, .{\n            .id = id,\n            .token = token,\n            .data = .{ .range = .{ .start = start, .end = @intCast(p.extra.items.len) }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "addList",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to addCond from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn addCond(p: *Parser, id: Node.Id, token: Token.Index, cond: Node.Index, nodes: []const Node.Index) Allocator.Error!Node.Index {\n        const start: u32 = @intCast(p.extra.items.len);\n        try p.extra.appendSlice(nodes);\n\n        const index = p.nodes.len;\n        try p.nodes.append(p.extra.allocator, .{\n            .id = id,\n            .token = token,\n            .data = .{ .cond = .{ .cond = cond, .extra = start }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "addCond",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to decl from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn decl(p: *Parser, level: u8) Error!?Node.Index {\n        const let_tok = p.eatToken(.keyword_let, .skip_nl) orelse return null;\n        const dest = try p.primaryExpr(.skip_nl, level);\n        _ = try p.expectToken(.equal, .keep_nl);\n        const init = try p.blockOrExpr(.keep_nl, level);\n        return try p.addBin(.decl, let_tok, dest, init);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "decl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to func from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn func(p: *Parser, skip_nl: SkipNl, level: u8) Error!?Node.Index {\n        const fn_tok = p.eatToken(.keyword_fn, .skip_nl) orelse return null;\n        _ = try p.expectToken(.l_paren, .skip_nl);\n\n        const node_buf_top = p.node_buf.items.len;\n        defer p.node_buf.items.len = node_buf_top;\n\n        var end = false;\n        while (true) {\n            if (p.eatToken(.r_paren, skip_nl)) |_| {\n                break;\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "func",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stmt from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn stmt(p: *Parser, level: u8) Error!Node.Index {\n        if (try p.decl(level)) |node| return node;\n        return p.assignExpr(.keep_nl, level);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "stmt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to assignExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn assignExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!Node.Index {\n        const lhs = try p.expr(skip_nl, level);\n        const tok = p.tok_i;\n        switch (p.tok_ids[tok]) {\n            .equal,\n            .plus_equal,\n            .minus_equal,\n            .asterisk_equal,\n            .asterisk_asterisk_equal,\n            .slash_equal,\n            .slash_slash_equal,\n            .percent_equal,\n            .l_arr_arr_equal,\n            .r_arr_arr_equal,\n            .ampersand_equal,\n            .pipe_equal,\n            .caret_equal,\n            => {\n                p.tok_i += 1;\n                return try p.addBin(switch (p.tok_ids[tok]) {\n                    .equal => .assign,\n                    .plus_equal => .add_assign,\n                    .minus_equal => .sub_assign,\n                    .asterisk_equal => .mul_assign,\n                    .asterisk_asterisk_equal => .pow_assign,\n                    .slash_equal => .div_assign,\n                    .slash_slash_equal => .div_floor_assign,\n                    .percent_equal => .rem_assign,\n                    .l_arr_arr_equal => .l_shift_assign,\n                    .r_arr_arr_equal => .r_shift_assign,\n                    .ampersand_equal => .bit_and_assign,\n                    .pipe_equal => .bit_or_assign,\n                    .caret_equal => .bit_xor_assign,\n                    else => unreachable,\n                }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "assignExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to blockOrExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn blockOrExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!Node.Index {\n        if (skip_nl == .keep_nl) if (try p.block(level)) |node| return node;\n        p.skipNl();\n        return try p.assignExpr(skip_nl, level);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "blockOrExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to block from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn block(p: *Parser, level: u8) Error!?Node.Index {\n        const nl = p.eatToken(.nl, .keep_nl) orelse return null;\n        const node_buf_top = p.node_buf.items.len;\n        defer p.node_buf.items.len = node_buf_top;\n\n        const new_level = indent: {\n            const indent = p.eatIndentExtra();\n            if (indent == null or indent.? <= level)\n                return p.reportErr(\"expected indentation\", p.tok_i);\n            p.tok_i += 1;\n\n            break :indent indent.?;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "block",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to expr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn expr(p: *Parser, skip_nl: SkipNl, level: u8) Error!Node.Index {\n        if (try p.jumpExpr(skip_nl, level)) |node| return node;\n        if (try p.func(skip_nl, level)) |node| return node;\n        return p.boolExpr(skip_nl, level);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "expr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to jumpExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn jumpExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!?Node.Index {\n        const tok = p.tok_i;\n        const id: Node.Id = switch (p.tok_ids[tok]) {\n            .keyword_return => .return_expr,\n            .keyword_break => .break_expr,\n            .keyword_continue => .continue_expr,\n            .keyword_throw => .throw_expr,\n            .keyword_suspend => .suspend_expr,\n            .keyword_resume => .resume_expr,\n            else => return null,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "jumpExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to boolExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn boolExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!Node.Index {\n        if (p.eatToken(.keyword_not, skip_nl)) |tok| {\n            p.skipNl();\n            return p.addUn(.bool_not_expr, tok, try p.comparisonExpr(skip_nl, level));\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "boolExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to comparisonExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn comparisonExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!Node.Index {\n        const lhs = try p.rangeExpr(skip_nl, level);\n\n        // we can safely skip any newlines here\n        const start = p.tok_i;\n        p.skipNl();\n        const tok = p.nextToken(.skip_nl);\n        const id = p.tok_ids[tok];\n        switch (id) {\n            .l_arr => return p.addBin(.less_than_expr, tok, lhs, try p.rangeExpr(skip_nl, level)),\n            .l_arr_equal => return p.addBin(.less_than_equal_expr, tok, lhs, try p.rangeExpr(skip_nl, level)),\n            .r_arr => return p.addBin(.greater_than_expr, tok, lhs, try p.rangeExpr(skip_nl, level)),\n            .r_arr_equal => return p.addBin(.greater_than_equal_expr, tok, lhs, try p.rangeExpr(skip_nl, level)),\n            .equal_equal => return p.addBin(.equal_expr, tok, lhs, try p.rangeExpr(skip_nl, level)),\n            .bang_equal => return p.addBin(.not_equal_expr, tok, lhs, try p.rangeExpr(skip_nl, level)),\n            .keyword_in => return p.addBin(.in_expr, tok, lhs, try p.rangeExpr(skip_nl, level)),\n            .keyword_is => return p.addUn(.is_expr, try p.typeName(skip_nl), lhs),\n            else => {\n                p.tok_i = start;\n                return lhs;\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "comparisonExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to typeName from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn typeName(p: *Parser, skip_nl: SkipNl) Error!Token.Index {\n        return p.eatToken(.keyword_error, skip_nl) orelse\n            p.eatToken(.keyword_fn, skip_nl) orelse\n            p.eatToken(.keyword_null, skip_nl) orelse\n            p.eatToken(.identifier, skip_nl) orelse\n            p.reportErr(\"expected type name\", p.tok_i);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "typeName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rangeExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn rangeExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!Node.Index {\n        const start = try p.bitExpr(skip_nl, level);\n        const colon_1 = p.eatToken(.colon, skip_nl) orelse return start;\n\n        var end: Node.Index = null_node;\n        var colon_2 = p.eatToken(.colon, skip_nl);\n        if (colon_2 == null) {\n            switch (p.tok_ids[p.tok_i]) {\n                .eof, .nl, .r_paren, .r_brace, .r_bracket, .keyword_else, .keyword_catch, .comma, .colon => {}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "rangeExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to bitExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn bitExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!Node.Index {\n        var lhs = try p.shiftExpr(skip_nl, level);\n\n        if (p.eatTokenNoNl(.ampersand)) |t| {\n            var tok = t;\n            while (true) {\n                p.skipNl();\n                lhs = try p.addBin(.bit_and_expr, tok, lhs, try p.shiftExpr(skip_nl, level));\n                if (p.eatTokenNoNl(.ampersand)) |tt| tok = tt else break;\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "bitExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to shiftExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn shiftExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!Node.Index {\n        const lhs = try p.addExpr(skip_nl, level);\n\n        // we can safely skip any newlines here\n        const start = p.tok_i;\n        p.skipNl();\n        const tok = p.nextToken(.skip_nl);\n        switch (p.tok_ids[tok]) {\n            .l_arr_arr => {\n                p.skipNl();\n                return p.addBin(.l_shift_expr, tok, lhs, try p.addExpr(skip_nl, level));\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "shiftExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn addExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!Node.Index {\n        var lhs = try p.mulExpr(skip_nl, level);\n\n        while (true) {\n            const tok = p.nextToken(skip_nl);\n            switch (p.tok_ids[tok]) {\n                .minus => {\n                    p.skipNl();\n                    lhs = try p.addBin(.sub_expr, tok, lhs, try p.mulExpr(skip_nl, level));\n                }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "addExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to mulExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn mulExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!Node.Index {\n        var lhs = try p.castExpr(skip_nl, level);\n\n        while (true) {\n            // we can safely skip any newlines here\n            const start = p.tok_i;\n            p.skipNl();\n            const tok = p.nextToken(.skip_nl);\n            switch (p.tok_ids[tok]) {\n                .asterisk => {\n                    p.skipNl();\n                    lhs = try p.addBin(.mul_expr, tok, lhs, try p.castExpr(skip_nl, level));\n                }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "mulExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to castExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn castExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!Node.Index {\n        var lhs = try p.prefixExpr(skip_nl, level);\n\n        if (p.eatTokenNoNl(.keyword_as)) |_| {\n            p.skipNl();\n            lhs = try p.addUn(.as_expr, try p.typeName(skip_nl), lhs);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "castExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to prefixExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn prefixExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!Node.Index {\n        const tok = p.nextToken(skip_nl);\n        switch (p.tok_ids[tok]) {\n            .minus => {\n                p.skipNl();\n                return p.addUn(.negate_expr, tok, try p.powerExpr(skip_nl, level));\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "prefixExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to powerExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn powerExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!Node.Index {\n        const primary = try p.suffixExpr(skip_nl, level);\n        if (p.eatTokenNoNl(.asterisk_asterisk)) |tok| {\n            p.skipNl();\n            return p.addBin(.pow_expr, tok, primary, try p.powerExpr(skip_nl, level));\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "powerExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to suffixExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn suffixExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!Node.Index {\n        const is_async = p.eatToken(.keyword_async, .skip_nl) != null;\n        var lhs = try p.primaryExpr(skip_nl, level);\n        while (true) {\n            if (try p.suffixOp(lhs, skip_nl, level)) |some| {\n                lhs = some;\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "suffixExpr",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to suffixOp from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn suffixOp(p: *Parser, lhs: Node.Index, skip_nl: SkipNl, level: u8) Error!?Node.Index {\n        if (p.eatToken(.l_bracket, skip_nl)) |tok| {\n            p.skipNl();\n            const res = try p.addBin(.array_access_expr, tok, lhs, try p.expr(.skip_nl, level));\n            _ = try p.expectToken(.r_bracket, .keep_nl);\n            return res;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "suffixOp",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callArgs from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn callArgs(p: *Parser, is_async: bool, lhs: Node.Index, skip_nl: SkipNl, level: u8) Error!?Node.Index {\n        const tok = p.eatToken(.l_paren, .skip_nl) orelse return null;\n        const args = try p.listParser(skip_nl, level, spreadExpr, .r_paren, lhs);\n        const ops = [2][2]Node.Id{ .{ .call_expr_one, .call_expr }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "callArgs",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to spreadExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn spreadExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!Node.Index {\n        const ellipsis = p.eatToken(.ellipsis, skip_nl);\n        const operand = try p.expr(skip_nl, level);\n        if (ellipsis) |some| {\n            return p.addUn(.spread_expr, some, operand);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "spreadExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to primaryExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn primaryExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!Node.Index {\n        const tok = p.nextToken(skip_nl);\n        switch (p.tok_ids[tok]) {\n            .keyword_mut => {\n                p.skipNl();\n                const ident = try p.expectToken(.identifier, skip_nl);\n                return p.addUn(.mut_ident_expr, ident, null_node);\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "primaryExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to formatString from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn formatString(p: *Parser, skip_nl: SkipNl, level: u8) Error!?Node.Index {\n        const first = p.eatToken(.format_start, .skip_nl) orelse return null;\n\n        var toks = std.ArrayList(Token.Index).init(p.extra.allocator);\n        defer toks.deinit();\n        try toks.append(first);\n\n        const node_buf_top = p.node_buf.items.len;\n        defer p.node_buf.items.len = node_buf_top;\n\n        while (true) {\n            try p.node_buf.append(try p.expr(.skip_nl, level));\n            _ = p.eatToken(.equal, .skip_nl);\n\n            if (p.eatToken(.format, .skip_nl)) |tok| {\n                try toks.append(tok);\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "formatString",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to initializer from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn initializer(p: *Parser, skip_nl: SkipNl, level: u8) Error!?Node.Index {\n        if (p.eatToken(.l_brace, .skip_nl)) |tok| {\n            const elems = try p.listParser(skip_nl, level, mapItem, .r_brace, null);\n            switch (elems.len) {\n                0 => return try p.addBin(.map_expr_two, tok, null_node, null_node),\n                1 => return try p.addBin(.map_expr_two, tok, elems[0], null_node),\n                2 => return try p.addBin(.map_expr_two, tok, elems[0], elems[1]),\n                else => return try p.addList(.map_expr, tok, elems),\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "initializer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to mapItem from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn mapItem(p: *Parser, _: SkipNl, level: u8) Error!Node.Index {\n        var tok = p.tok_i;\n        var key: Node.Index = null_node;\n        var value = try p.expr(.skip_nl, level);\n        if (p.eatToken(.equal, .skip_nl)) |eq| {\n            tok = eq;\n            key = value;\n            value = try p.expr(.skip_nl, level);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "mapItem",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to listParser from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn listParser(\n        p: *Parser,\n        skip_nl: SkipNl,\n        level: u8,\n        comptime parseFn: fn (*Parser, SkipNl, u8) Error!Node.Index,\n        term_id: Token.Id,\n        first: ?Node.Index,\n    ) Error![]Node.Index {\n        const node_buf_top = p.node_buf.items.len;\n        defer p.node_buf.items.len = node_buf_top;\n        if (first) |some| try p.node_buf.append(some);\n\n        var end = false;\n        while (true) {\n            if (p.eatToken(term_id, skip_nl)) |_| {\n                break;\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "listParser",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to ifExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn ifExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!?Node.Index {\n        const tok = p.eatToken(.keyword_if, .skip_nl) orelse return null;\n        const let = p.eatToken(.keyword_let, .skip_nl);\n        const dest = if (let) |_| try p.primaryExpr(.skip_nl, level) else null_node;\n        if (let) |_| _ = try p.expectToken(.equal, .skip_nl);\n        const cond = try p.expr(.keep_nl, level);\n        const then_body = try p.blockOrExpr(skip_nl, level);\n        const @\"else\" = p.eatTokenNoNl(.keyword_else);\n        const else_body = if (@\"else\") |_| try p.blockOrExpr(skip_nl, level) else null_node;\n\n        if (dest == null_node and else_body == null_node) {\n            return try p.addBin(.if_expr, tok, cond, then_body);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "ifExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to whileExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn whileExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!?Node.Index {\n        const tok = p.eatToken(.keyword_while, .skip_nl) orelse return null;\n        const let = p.eatToken(.keyword_let, .skip_nl);\n        const dest = if (let) |_| try p.primaryExpr(.skip_nl, level) else null_node;\n        if (let) |_| _ = try p.expectToken(.equal, .skip_nl);\n        const cond = try p.expr(.keep_nl, level);\n        const body = try p.blockOrExpr(skip_nl, level);\n\n        if (dest == null_node) {\n            return try p.addBin(.while_expr, tok, cond, body);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "whileExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn forExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!?Node.Index {\n        const tok = p.eatToken(.keyword_for, .skip_nl) orelse return null;\n        const let = p.eatToken(.keyword_let, .skip_nl);\n        const dest = if (let) |_| try p.primaryExpr(.skip_nl, level) else null_node;\n        if (let) |_| _ = try p.expectToken(.keyword_in, .skip_nl);\n        const cond = try p.expr(.keep_nl, level);\n        const body = try p.blockOrExpr(skip_nl, level);\n\n        if (dest == null_node) {\n            return try p.addBin(.for_expr, tok, cond, body);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "forExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to matchExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn matchExpr(p: *Parser, level: u8) Error!?Node.Index {\n        const tok = p.eatToken(.keyword_match, .skip_nl) orelse return null;\n        const cond = try p.expr(.keep_nl, level);\n        _ = try p.expectToken(.nl, .keep_nl);\n\n        const node_buf_top = p.node_buf.items.len;\n        defer p.node_buf.items.len = node_buf_top;\n\n        // in case we need it in match_expr\n        try p.node_buf.append(cond);\n\n        const new_level = indent: {\n            const indent = p.eatIndentExtra();\n            if (indent == null or indent.? <= level)\n                return p.reportErr(\"expected indentation\", p.tok_i);\n            p.tok_i += 1;\n            break :indent indent.?;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "matchExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to matchCase from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn matchCase(p: *Parser, level: u8) Error!Node.Index {\n        if (p.eatToken(.keyword_let, .skip_nl)) |_| {\n            const dest = try p.primaryExpr(.skip_nl, level);\n            const arr = try p.expectToken(.equal_rarr, .keep_nl);\n            const body = try p.blockOrExpr(.keep_nl, level);\n            return p.addBin(.match_case_let, arr, dest, body);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "matchCase",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tryExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn tryExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!?Node.Index {\n        const tok = p.eatToken(.keyword_try, .keep_nl) orelse return null;\n        const body = try p.blockOrExpr(.keep_nl, level);\n\n        const node_buf_top = p.node_buf.items.len;\n        defer p.node_buf.items.len = node_buf_top;\n        // in case we need it in try_expr\n        try p.node_buf.append(body);\n\n        while (try p.catchExpr(skip_nl, level)) |catch_expr| {\n            try p.node_buf.append(catch_expr);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "tryExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to catchExpr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn catchExpr(p: *Parser, skip_nl: SkipNl, level: u8) Error!?Node.Index {\n        const tok = p.eatTokenNoNl(.keyword_catch) orelse return null;\n\n        if (p.eatToken(.keyword_let, .skip_nl)) |_| {\n            return try p.addBin(.catch_let_expr, tok, try p.primaryExpr(.keep_nl, level), try p.blockOrExpr(skip_nl, level));\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "catchExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reportErr from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn reportErr(p: *Parser, msg: []const u8, tok: Token.Index) Error {\n        if (p.repl and p.tok_ids[p.tok_i] == .eof) return error.NeedInput;\n        try p.errors.add(.{ .data = msg }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "reportErr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to skipNl from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn skipNl(p: *Parser) void {\n        _ = p.eatToken(.nl, .skip_nl);\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "skipNl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eatIndent from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn eatIndent(p: *Parser, level: u8) !bool {\n        const indent = p.eatIndentExtra() orelse return false;\n        if (indent > level) return p.reportErr(\"unexpected indentation\", p.tok_i);\n        if (indent != level) return false;\n        p.tok_i += 1;\n        return true;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "eatIndent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eatIndentExtra from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn eatIndentExtra(p: *Parser) ?u8 {\n        return switch (p.tok_ids[p.tok_i]) {\n            .indent_1 => 1,\n            .indent_2 => 2,\n            .indent_3 => 3,\n            .indent_4 => 4,\n            .indent_5 => 5,\n            .indent_6 => 6,\n            .indent_7 => 7,\n            .indent_8 => 8,\n            .indent_9 => 9,\n            .indent_10 => 10,\n            .indent_11 => 11,\n            .indent_12 => 12,\n            .indent_13 => 13,\n            .indent_14 => 14,\n            .indent_15 => 15,\n            .indent_16 => 16,\n            .indent_17 => 17,\n            .indent_18 => 18,\n            .indent_19 => 19,\n            .indent_20 => 20,\n            .indent_21 => 21,\n            .indent_22 => 22,\n            .indent_23 => 23,\n            .indent_24 => 24,\n            .indent_25 => 25,\n            .indent_26 => 26,\n            .indent_27 => 27,\n            .indent_28 => 28,\n            .indent_29 => 29,\n            .indent_30 => 30,\n            .indent_31 => 31,\n            .indent_32 => 32,\n            else => return null,\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "eatIndentExtra",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nextToken from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn nextToken(p: *Parser, skip_nl: SkipNl) Token.Index {\n        const result = p.tok_i;\n        p.tok_i += 1;\n\n        if (p.tok_i >= p.tok_ids.len) return result;\n        while (true) {\n            switch (p.tok_ids[p.tok_i]) {\n                // skip nl and indent if they are not meaningful\n                // zig fmt: off\n                .indent_1, .indent_2, .indent_3, .indent_4,\n                .indent_5, .indent_6, .indent_7, .indent_8,\n                .indent_9, .indent_10, .indent_11, .indent_12,\n                .indent_13, .indent_14, .indent_15, .indent_16,\n                .indent_17, .indent_18, .indent_19, .indent_20,\n                .indent_21, .indent_22, .indent_23, .indent_24,\n                .indent_25, .indent_26, .indent_27, .indent_28,\n                .indent_29, .indent_30, .indent_31, .indent_32,\n                // zig fmt: on\n                => if (skip_nl == .keep_nl) break,\n                .nl => if (skip_nl == .keep_nl and p.tok_i + 1 <= p.tok_ids.len) break,\n                else => break,\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "nextToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eatToken from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn eatToken(p: *Parser, id: Token.Id, skip_nl: SkipNl) ?Token.Index {\n        return if (p.tok_ids[p.tok_i] == id) p.nextToken(skip_nl) else null;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "eatToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eatTokenNoNl from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn eatTokenNoNl(p: *Parser, id: Token.Id) ?Token.Index {\n        const start = p.tok_i;\n        p.skipNl();\n        if (p.eatToken(id, .keep_nl)) |tok| return tok else {\n            p.tok_i = start;\n            return null;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "eatTokenNoNl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to expectToken from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "fn expectToken(p: *Parser, id: Token.Id, skip_nl: SkipNl) !Token.Index {\n        if (p.eatToken(id, skip_nl)) |tok| return tok;\n        try p.errors.add(try @import(\"String.zig\").init(\n            p.errors.arena.child_allocator,\n            \"expected '{s}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "function",
      "name": "expectToken",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Parser from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "pub const Parser = struct {\n    tok_ids: []const Token.Id,\n    tok_i: u32 = 0,\n    tok_starts: []const u32,\n    nodes: Node.List = .{}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "struct",
      "name": "Parser",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to null_node from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "const null_node: Node.Index = 0;",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "const",
      "name": "null_node",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to start from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "const start: u32 = @intCast(p.extra.items.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "const",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to start from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "const start: u32 = @intCast(p.extra.items.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "const",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to id from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "const id: Node.Id = switch (p.tok_ids[tok]) {\n            .keyword_return => .return_expr,\n            .keyword_break => .break_expr,\n            .keyword_continue => .continue_expr,\n            .keyword_throw => .throw_expr,\n            .keyword_suspend => .suspend_expr,\n            .keyword_resume => .resume_expr,\n            else => return null,\n        };",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "const",
      "name": "id",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to fmt_start from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "const fmt_start: u32 = @intCast(p.extra.items.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "const",
      "name": "fmt_start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to args_start from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/parser.zig",
    "response": "const args_start: u32 = @intCast(p.extra.items.len);",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/parser.zig",
      "type": "const",
      "name": "args_start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to render from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "pub fn render(tree: Tree, writer: anytype) @TypeOf(writer).Error!bool {\n    var change_writer = changeDetectionWriter(tree.source, writer);\n    var aiw = AutoIndentingWriter(@TypeOf(change_writer.writer())){ .indent_delta = indent_delta, .underlying_writer = change_writer.writer() }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "render",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderNode from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "fn renderNode(tree: Tree, node: Node.Index, aiw: anytype, space: Space) @TypeOf(aiw.*).Error!void {\n    const ids = tree.nodes.items(.id);\n    const tokens = tree.nodes.items(.token);\n    const data = tree.nodes.items(.data);\n    switch (ids[node]) {\n        .ident_expr,\n        .string_expr,\n        .int_expr,\n        .num_expr,\n        .true_expr,\n        .false_expr,\n        .this_expr,\n        .null_expr,\n        .discard_expr,\n        .break_expr,\n        .continue_expr,\n        .suspend_expr,\n        => try renderToken(tree, tokens[node], aiw, space),\n        .mut_ident_expr => {\n            try renderToken(tree, tree.prevToken(tokens[node]), aiw, .space);\n            try renderToken(tree, tokens[node], aiw, space);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "renderNode",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderCommaList from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "fn renderCommaList(tree: Tree, nodes: []const Node.Index, last_token: Token.Index, aiw: anytype, space: Space) !void {\n    if (nodes.len == 0) return;\n\n    const ids = tree.tokens.items(.id);\n    const prev = ids[last_token - 1];\n    if (prev == .comma or prev == .nl or hasComment(tree, tree.prevToken(last_token), last_token) or\n        tree.lineDist(tree.firstToken(nodes[0]), last_token) > 0)\n    {\n        try aiw.insertNewline();\n        aiw.pushIndent();\n        for (nodes) |node| {\n            try renderNode(tree, node, aiw, .comma);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "renderCommaList",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to hasComment from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "fn hasComment(tree: Tree, start_token: Token.Index, end_token: Token.Index) bool {\n    const starts = tree.tokens.items(.start);\n    const slice = tree.source[starts[start_token]..starts[end_token]];\n    return mem.indexOfScalar(u8, slice, '#') != null;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "hasComment",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderComments from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "fn renderComments(tree: Tree, start: usize, end: usize, aiw: anytype) !bool {\n    // borrowed from std/zig/render.zig\n    var index: usize = start;\n    while (mem.indexOfScalar(u8, tree.source[index..end], '#')) |offset| {\n        const comment_start = index + offset;\n\n        // If there is no newline, the comment ends with EOF\n        const newline_index = mem.indexOfScalar(u8, tree.source[comment_start..end], '\\n');\n        const newline = if (newline_index) |i| comment_start + i else null;\n\n        const untrimmed_comment = tree.source[comment_start .. newline orelse tree.source.len];\n        const trimmed_comment = mem.trimRight(u8, untrimmed_comment, &std.ascii.whitespace);\n\n        // Don't leave any whitespace at the start of the file\n        if (index != 0) {\n            if (index == start and mem.containsAtLeast(u8, tree.source[index..comment_start], 2, \"\\n\")) {\n                // Leave up to one empty line before the first comment\n                try aiw.insertNewline();\n                try aiw.insertNewline();\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "renderComments",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeFixingWhitespace from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "fn writeFixingWhitespace(writer: anytype, slice: []const u8) !void {\n    for (slice) |byte| switch (byte) {\n        '\\t' => try writer.writeAll(\" \" ** 4),\n        '\\r' => {}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "writeFixingWhitespace",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getBlockIndent from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "fn getBlockIndent(tree: Tree, node: Node.Index, space: Space) Space {\n    const ids = tree.nodes.items(.id);\n    return switch (ids[node]) {\n        .block_stmt,\n        .block_stmt_two,\n        => .newline,\n        else => space,\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "getBlockIndent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isBlock from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "fn isBlock(tree: Tree, node: Node.Index) bool {\n    const ids = tree.nodes.items(.id);\n    const data = tree.nodes.items(.data);\n    var cur = node;\n    while (true) switch (ids[cur]) {\n        .match_expr => return !isBlock(tree, tree.extra[data[cur].range.end - 1]),\n        .block_stmt => return !isBlock(tree, tree.extra[data[cur].range.end - 1]),\n        .match_expr_one => return !isBlock(tree, data[cur].bin.rhs),\n        .block_stmt_two => {\n            const bin = data[cur].bin;\n            if (bin.rhs != 0) cur = bin.rhs else cur = bin.lhs;\n            return !isBlock(tree, cur);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "isBlock",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to renderToken from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "fn renderToken(tree: Tree, token: Token.Index, aiw: anytype, space: Space) !void {\n    const slice = tree.tokenSlice(token);\n    const starts = tree.tokens.items(.end);\n    const ends = tree.tokens.items(.end);\n    try aiw.writer().writeAll(slice);\n    switch (space) {\n        .none => {}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "renderToken",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to AutoIndentingWriter from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "fn AutoIndentingWriter(comptime UnderlyingWriter: type) type {\n    return struct {\n        const Self = @This();\n        pub const Error = UnderlyingWriter.Error;\n        pub const Writer = std.io.Writer(*Self, Error, write);\n\n        underlying_writer: UnderlyingWriter,\n\n        /// Offset into the source at which formatting has been disabled with\n        /// a `zig fmt: off` comment.\n        ///\n        /// If non-null, the AutoIndentingStream will not write any bytes\n        /// to the underlying writer. It will however continue to track the\n        /// indentation level.\n        disabled_offset: ?usize = null,\n\n        indent_count: usize = 0,\n        indent_delta: usize,\n        current_line_empty: bool = true,\n        /// automatically popped when applied\n        indent_one_shot_count: usize = 0,\n        /// the most recently applied indent\n        applied_indent: usize = 0,\n        /// not used until the next line\n        indent_next_line: usize = 0,\n\n        pub fn writer(self: *Self) Writer {\n            return .{ .context = self }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "AutoIndentingWriter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "pub fn write(self: *Self, bytes: []const u8) Error!usize {\n            if (bytes.len == 0)\n                return @as(usize, 0);\n\n            try self.applyIndent();\n            return self.writeNoIndent(bytes);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "write",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to setIndentDelta from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "pub fn setIndentDelta(self: *Self, new_indent_delta: usize) void {\n            if (self.indent_delta == new_indent_delta) {\n                return;\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "setIndentDelta",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeNoIndent from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "fn writeNoIndent(self: *Self, bytes: []const u8) Error!usize {\n            if (bytes.len == 0)\n                return @as(usize, 0);\n\n            if (self.disabled_offset == null) try self.underlying_writer.writeAll(bytes);\n            if (bytes[bytes.len - 1] == '\\n')\n                self.resetLine();\n            return bytes.len;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "writeNoIndent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to insertNewline from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "pub fn insertNewline(self: *Self) Error!void {\n            _ = try self.writeNoIndent(\"\\n\");\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "insertNewline",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resetLine from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "fn resetLine(self: *Self) void {\n            self.current_line_empty = true;\n            self.indent_next_line = 0;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "resetLine",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to maybeInsertNewline from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "pub fn maybeInsertNewline(self: *Self) Error!void {\n            if (!self.current_line_empty)\n                try self.insertNewline();\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "maybeInsertNewline",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pushIndent from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "pub fn pushIndent(self: *Self) void {\n            self.indent_count += 1;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "pushIndent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pushIndentOneShot from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "pub fn pushIndentOneShot(self: *Self) void {\n            self.indent_one_shot_count += 1;\n            self.pushIndent();\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "pushIndentOneShot",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lockOneShotIndent from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "pub fn lockOneShotIndent(self: *Self) usize {\n            const locked_count = self.indent_one_shot_count;\n            self.indent_one_shot_count = 0;\n            return locked_count;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "lockOneShotIndent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pushIndentNextLine from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "pub fn pushIndentNextLine(self: *Self) void {\n            self.indent_next_line += 1;\n            self.pushIndent();\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "pushIndentNextLine",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to popIndent from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "pub fn popIndent(self: *Self) void {\n            assert(self.indent_count != 0);\n            self.indent_count -= 1;\n\n            if (self.indent_next_line > 0)\n                self.indent_next_line -= 1;\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "popIndent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applyIndent from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "fn applyIndent(self: *Self) Error!void {\n            const current_indent = self.currentIndent();\n            if (self.current_line_empty and current_indent > 0) {\n                if (self.disabled_offset == null) {\n                    try self.underlying_writer.writeByteNTimes(' ', current_indent);\n                }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "applyIndent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isLineOverIndented from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "pub fn isLineOverIndented(self: *Self) bool {\n            if (self.current_line_empty) return false;\n            return self.applied_indent > self.currentIndent();\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "isLineOverIndented",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to currentIndent from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/render.zig",
    "response": "fn currentIndent(self: *Self) usize {\n            var indent_current: usize = 0;\n            if (self.indent_count > 0) {\n                const indent_count = self.indent_count - self.indent_next_line;\n                indent_current = indent_count * self.indent_delta;\n            }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/render.zig",
      "type": "function",
      "name": "currentIndent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/repl.zig",
    "response": "pub fn run(gpa: Allocator, in: File, out: File) !void {\n    var repl: Repl = undefined;\n    try repl.init(gpa);\n    defer repl.deinit();\n\n    const writer = out.writer();\n\n    repl.vm.gc.stack_protect_start = @frameAddress();\n\n    const frame_val = try repl.vm.gc.alloc(.frame);\n    frame_val.* = .{ .frame = &repl.frame }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/repl.zig",
      "type": "function",
      "name": "run",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/repl.zig",
    "response": "fn init(repl: *Repl, gpa: Allocator) !void {\n        repl.buffer = try ArrayList(u8).initCapacity(gpa, std.heap.pageSize());\n        errdefer repl.buffer.deinit();\n\n        if (builtin.os.tag != .windows) {\n            repl.ln = linenoise.Linenoise.init(gpa);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/repl.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/repl.zig",
    "response": "fn deinit(repl: *Repl) void {\n        const gpa = repl.vm.gc.gpa;\n        repl.buffer.deinit();\n        repl.ln.deinit();\n        repl.tokenizer.tokens.deinit(gpa);\n        repl.parser.node_buf.deinit();\n        repl.parser.extra.deinit();\n        repl.parser.nodes.deinit(gpa);\n        repl.compiler.deinit();\n        repl.code.deinit(gpa);\n        repl.arena.deinit();\n        repl.frame.deinit(&repl.vm);\n        repl.vm.deinit();\n        repl.* = undefined;\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/repl.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to handleLine from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/repl.zig",
    "response": "fn handleLine(repl: *Repl, in: File, out: File) !void {\n        const buffer_start = repl.buffer.items.len;\n        errdefer |e| if (e == error.CompileError) {\n            repl.buffer.shrinkAndFree(buffer_start);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/repl.zig",
      "type": "function",
      "name": "handleLine",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to readLine from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/repl.zig",
    "response": "fn readLine(repl: *Repl, in: File, out: File, prompt: []const u8) !void {\n        _ = in;\n        _ = out;\n        if (repl.ln.linenoise(prompt)) |maybe_line| {\n            const line = maybe_line orelse return error.EndOfStream;\n            defer repl.ln.allocator.free(line);\n\n            try repl.buffer.appendSlice(line);\n            try repl.buffer.append('\\n');\n\n            try repl.ln.history.add(line);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/repl.zig",
      "type": "function",
      "name": "readLine",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Repl from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/repl.zig",
    "response": "pub const Repl = struct {\n    buffer: ArrayList(u8),\n    ln: linenoise.Linenoise,\n    tokenizer: bog.Tokenizer,\n    parser: bog.Parser,\n    tree: bog.Tree,\n    compiler: bog.Compiler,\n    bytecode: bog.Bytecode,\n    code: bog.Compiler.Code,\n    arena: std.heap.ArenaAllocator,\n    vm: Vm,\n    frame: Vm.Frame,\n\n    const tokenize = @import(\"tokenizer.zig\").tokenizeRepl;\n    const parse = @import(\"parser.zig\").parseRepl;\n    const compile = @import(\"Compiler.zig\").compileRepl;\n\n    fn init(repl: *Repl, gpa: Allocator) !void {\n        repl.buffer = try ArrayList(u8).initCapacity(gpa, std.heap.pageSize());\n        errdefer repl.buffer.deinit();\n\n        if (builtin.os.tag != .windows) {\n            repl.ln = linenoise.Linenoise.init(gpa);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/repl.zig",
      "type": "struct",
      "name": "Repl",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to collect from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/std.zig",
    "response": "pub fn collect(ctx: @import(\"bog.zig\").Vm.Context) i64 {\n        return @intCast(ctx.vm.gc.collect());\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/std.zig",
      "type": "function",
      "name": "collect",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to gc from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/std.zig",
    "response": "pub const gc = struct {\n    pub fn collect(ctx: @import(\"bog.zig\").Vm.Context) i64 {\n        return @intCast(ctx.vm.gc.collect());\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/std.zig",
      "type": "struct",
      "name": "gc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to assert from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/std/debug.zig",
    "response": "pub fn assert(val: bool) !void {\n    if (!val) return error.AssertionFailed;\n}",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/std/debug.zig",
      "type": "function",
      "name": "assert",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to open from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/std/fs.zig",
    "response": "pub fn open(ctx: Vm.Context, path: []const u8) !*Value {\n    // TODO take options as parameters\n    const res = try ctx.vm.gc.alloc(.native_val);\n    res.* = .{ .native_val = .{\n        .vtable = Value.NativeVal.VTable.make(File),\n        .type_id = Value.NativeVal.typeId(File),\n        .ptr = try ctx.vm.gc.gpa.create(File),\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/std/fs.zig",
      "type": "function",
      "name": "open",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to typeName from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/std/fs.zig",
    "response": "pub fn typeName(_: *anyopaque) []const u8 {\n        return \"File\";\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/std/fs.zig",
      "type": "function",
      "name": "typeName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/std/fs.zig",
    "response": "pub fn deinit(a: *anyopaque, gpa: std.mem.Allocator) void {\n        gpa.destroy(Value.NativeVal.unwrap(a, File));\n    }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/std/fs.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to get from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/std/fs.zig",
    "response": "pub fn get(_: *anyopaque, ctx: Vm.Context, index: *const Value, res: *?*Value) Value.NativeError!void {\n        switch (index.*) {\n            .str => |*s| {\n                if (res.* == null) {\n                    res.* = try ctx.vm.gc.alloc(.int);\n                }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/std/fs.zig",
      "type": "function",
      "name": "get",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to close from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/std/fs.zig",
    "response": "pub fn close(file: Value.This(*File), ctx: Vm.Context) !void {\n            if (file.t.state == .closed) return ctx.throw(\"closing an already closed file\");\n            file.t.state = .closed;\n            file.t.base.close();\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/std/fs.zig",
      "type": "function",
      "name": "close",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to read from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/std/fs.zig",
    "response": "pub fn read(file: Value.This(*File), ctx: Vm.Context) ![]u8 {\n            if (file.t.state == .closed) return ctx.throw(\"reading from a closed file\");\n            return file.t.base.readToEndAlloc(ctx.vm.gc.gpa, std.math.maxInt(u32));\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/std/fs.zig",
      "type": "function",
      "name": "read",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/std/fs.zig",
    "response": "pub fn write(file: Value.This(*File), ctx: Vm.Context, str: []const u8) !void {\n            if (file.t.state == .closed) return ctx.throw(\"writing to a closed file\");\n            try file.t.base.writeAll(str);\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/std/fs.zig",
      "type": "function",
      "name": "write",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to File from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/std/fs.zig",
    "response": "const File = struct {\n    base: std.fs.File,\n    state: enum { open, closed }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/std/fs.zig",
      "type": "struct",
      "name": "File",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to methods from Vexu/toy-lang",
    "context": "Repository: Vexu/toy-lang (584 ⭐)\nFile: src/std/fs.zig",
    "response": "pub const methods = struct {\n        pub fn close(file: Value.This(*File), ctx: Vm.Context) !void {\n            if (file.t.state == .closed) return ctx.throw(\"closing an already closed file\");\n            file.t.state = .closed;\n            file.t.base.close();\n        }",
    "metadata": {
      "repo": "Vexu/toy-lang",
      "stars": 584,
      "file": "src/std/fs.zig",
      "type": "struct",
      "name": "methods",
      "difficulty": "easy"
    }
  }
]