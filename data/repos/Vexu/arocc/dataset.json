[
  {
    "instruction": "Write a Zig function similar to generateDef from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build.zig",
    "response": "fn generateDef(b: *Build, input_name: []const u8) Build.Module.Import {\n    const cache = struct {\n        var exe: ?*Build.Step.Compile = null;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build.zig",
      "type": "function",
      "name": "generateDef",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addFuzzStep from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build.zig",
    "response": "fn addFuzzStep(b: *Build, target: std.Build.ResolvedTarget, afl_clang_lto_path: []const u8, aro_module: *std.Build.Module) !void {\n    const fuzz_step = b.step(\"fuzz\", \"Build executable for fuzz testing.\");\n    const fuzz_lib = b.addLibrary(.{\n        .name = \"fuzz-lib\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"test/fuzz/fuzz_lib.zig\"),\n            .optimize = .Debug,\n            .target = target,\n            .single_threaded = true,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build.zig",
      "type": "function",
      "name": "addFuzzStep",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to build from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build.zig",
    "response": "pub fn build(b: *Build) !void {\n    // Standard target options allows the person running `zig build` to choose\n    // what target to build for. Here we do not override the defaults, which\n    // means any target is allowed, and the default is native. Other options\n    // for restricting supported target set are available.\n    const target = b.standardTargetOptions(.{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build.zig",
      "type": "function",
      "name": "build",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to cache from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build.zig",
    "response": "const cache = struct {\n        var exe: ?*Build.Step.Compile = null;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build.zig",
      "type": "struct",
      "name": "cache",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to fmt_dirs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build.zig",
    "response": "const fmt_dirs: []const []const u8 = &.{ \"build\", \"build.zig\", \"src\", \"test\" };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build.zig",
      "type": "const",
      "name": "fmt_dirs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to tracy_c_flags from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build.zig",
    "response": "const tracy_c_flags: []const []const u8 = if (target.result.isMinGW())\n            &[_][]const u8{ \"-DTRACY_ENABLE=1\", \"-fno-sanitize=undefined\", \"-D_WIN32_WINNT=0x601\" }\n        else\n            &[_][]const u8{ \"-DTRACY_ENABLE=1\", \"-fno-sanitize=undefined\" };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build.zig",
      "type": "const",
      "name": "tracy_c_flags",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn main() !void {\n    var debug_allocator: std.heap.DebugAllocator(.{ .stack_trace_frames = 0 }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to lessThan from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn lessThan(_: void, a_str: []const u8, b_str: []const u8) bool {\n            return std.mem.lessThan(u8, a_str, b_str);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "lessThan",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to with from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn with(comptime Properties: type) type {{\n        \\\\return struct {{\n        \\\\\n    , .{input_path}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "with",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromName from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn fromName(name: []const u8) ?Properties {\n        \\\\    const data_index = tagFromName(name) orelse return null;\n        \\\\    return data[@intFromEnum(data_index)];\n        \\\\}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "fromName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tagFromName from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn tagFromName(name: []const u8) ?Tag {\n        \\\\    const unique_index = uniqueIndex(name) orelse return null;\n        \\\\    return @enumFromInt(unique_index - 1);\n        \\\\}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "tagFromName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromTag from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn fromTag(tag: Tag) Properties {\n        \\\\    return data[@intFromEnum(tag)];\n        \\\\}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "fromTag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nameFromTagIntoBuf from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn nameFromTagIntoBuf(tag: Tag, name_buf: []u8) []u8 {\n        \\\\    std.debug.assert(name_buf.len >= longest_name);\n        \\\\    const unique_index = @intFromEnum(tag) + 1;\n        \\\\    return nameFromUniqueIndex(unique_index, name_buf);\n        \\\\}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "nameFromTagIntoBuf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nameFromTag from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn nameFromTag(tag: Tag) NameBuf {\n        \\\\    var name_buf: NameBuf = undefined;\n        \\\\    const unique_index = @intFromEnum(tag) + 1;\n        \\\\    const name = nameFromUniqueIndex(unique_index, &name_buf.buf);\n        \\\\    name_buf.len = @intCast(name.len);\n        \\\\    return name_buf;\n        \\\\}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "nameFromTag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to span from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn span(self: *const NameBuf) []const u8 {\n        \\\\        return self.buf[0..self.len];\n        \\\\    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "span",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to exists from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn exists(name: []const u8) bool {\n        \\\\    if (name.len < shortest_name or name.len > longest_name) return false;\n        \\\\\n        \\\\    var index: u16 = 0;\n        \\\\    for (name) |c| {\n        \\\\        index = findInList(dafsa[index].child_index, c) orelse return false;\n        \\\\    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "exists",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findInList from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn findInList(first_child_index: u16, char: u8) ?u16 {\n        \\\\\n    );\n    try writer.print(\"    @setEvalBranchQuota({d}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "findInList",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to uniqueIndex from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn uniqueIndex(name: []const u8) ?u16 {\n        \\\\    if (name.len < shortest_name or name.len > longest_name) return null;\n        \\\\\n        \\\\    var index: u16 = 0;\n        \\\\    var node_index: u16 = 0;\n        \\\\\n        \\\\    for (name) |c| {\n        \\\\        const child_index = findInList(dafsa[node_index].child_index, c) orelse return null;\n        \\\\        var sibling_index = dafsa[node_index].child_index;\n        \\\\        while (true) {\n        \\\\            const sibling_c = dafsa[sibling_index].char;\n        \\\\            std.debug.assert(sibling_c != 0);\n        \\\\            if (sibling_c < c) {\n        \\\\                index += dafsa[sibling_index].number;\n        \\\\            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "uniqueIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nameFromUniqueIndex from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn nameFromUniqueIndex(index: u16, buf: []u8) []u8 {\n        \\\\    std.debug.assert(index >= 1 and index <= data.len);\n        \\\\\n        \\\\    var node_index: u16 = 0;\n        \\\\    var count: u16 = index;\n        \\\\    var w = std.Io.Writer.fixed(buf);\n        \\\\\n        \\\\    while (true) {\n        \\\\        var sibling_index = dafsa[node_index].child_index;\n        \\\\        while (true) {\n        \\\\            if (dafsa[sibling_index].number > 0 and dafsa[sibling_index].number < count) {\n        \\\\                count -= dafsa[sibling_index].number;\n        \\\\            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "nameFromUniqueIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeData from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "fn writeData(writer: *std.Io.Writer, values: []const Value) !void {\n    try writer.writeAll(\"pub const data = blk: {\\n\");\n    try writer.print(\"    @setEvalBranchQuota({d}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "writeData",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn init(allocator: Allocator) !DafsaBuilder {\n        var arena = std.heap.ArenaAllocator.init(allocator);\n        errdefer arena.deinit();\n\n        const root = try arena.allocator().create(Node);\n        root.* = .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn deinit(db: *DafsaBuilder) void {\n        db.arena.promote(db.allocator).deinit();\n        db.unchecked_nodes.deinit(db.allocator);\n        db.minimized_nodes.deinit(db.allocator);\n        db.* = undefined;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn hash(ctx: @This(), key: *Node) u64 {\n                _ = ctx;\n                var hasher = std.hash.Wyhash.init(0);\n                std.hash.autoHash(&hasher, key.children);\n                std.hash.autoHash(&hasher, key.is_terminal);\n                return hasher.final();\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "hash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn eql(ctx: @This(), a: *Node, b: *Node) bool {\n                _ = ctx;\n                return a.is_terminal == b.is_terminal and std.mem.eql(?*Node, &a.children, &b.children);\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to calcNumbers from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn calcNumbers(db: *Node) void {\n            db.number = @intFromBool(db.is_terminal);\n            for (db.children) |maybe_child| {\n                const child = maybe_child orelse continue;\n                // A node's number is the sum of the\n                // numbers of its immediate child nodes.\n                child.calcNumbers();\n                db.number += child.number;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "calcNumbers",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to numDirectChildren from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn numDirectChildren(db: *const Node) u8 {\n            var num: u8 = 0;\n            for (db.children) |child| {\n                if (child != null) num += 1;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "numDirectChildren",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to insert from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn insert(db: *DafsaBuilder, str: []const u8) !void {\n        if (std.mem.order(u8, str, db.previous_word) == .lt) {\n            @panic(\"insertion order must be sorted\");\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "insert",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to minimize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn minimize(db: *DafsaBuilder, down_to: usize) !void {\n        if (db.unchecked_nodes.items.len == 0) return;\n        while (db.unchecked_nodes.items.len > down_to) {\n            const unchecked_node = db.unchecked_nodes.pop().?;\n            if (db.minimized_nodes.getPtr(unchecked_node.child)) |child| {\n                unchecked_node.parent.children[unchecked_node.char] = child.*;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "minimize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to finish from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub fn finish(db: *DafsaBuilder) !void {\n        try db.minimize(0);\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "finish",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nodeCount from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "fn nodeCount(db: *const DafsaBuilder) usize {\n        return db.minimized_nodes.count();\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "nodeCount",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to edgeCount from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "fn edgeCount(db: *const DafsaBuilder) usize {\n        var count: usize = 0;\n        var it = db.minimized_nodes.iterator();\n        while (it.next()) |entry| {\n            for (entry.key_ptr.*.children) |child| {\n                if (child != null) count += 1;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "edgeCount",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to contains from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "fn contains(db: *const DafsaBuilder, str: []const u8) bool {\n        var node = db.root;\n        for (str) |c| {\n            node = node.children[c] orelse return false;\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "contains",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to calcNumbers from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "fn calcNumbers(db: *const DafsaBuilder) void {\n        db.root.calcNumbers();\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "calcNumbers",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getUniqueIndex from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "fn getUniqueIndex(db: *const DafsaBuilder, str: []const u8) ?usize {\n        var index: usize = 0;\n        var node = db.root;\n\n        for (str) |c| {\n            const child = node.children[c] orelse return null;\n            for (node.children, 0..) |sibling, sibling_c| {\n                if (sibling == null) continue;\n                if (sibling_c < c) {\n                    index += sibling.?.number;\n                }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "getUniqueIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeDafsa from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "fn writeDafsa(db: *const DafsaBuilder, writer: *std.Io.Writer) !void {\n        try writer.writeAll(\"const dafsa = [_]Node{\\n\");\n\n        // write root\n        try writer.writeAll(\"    .{ .char = 0, .end_of_word = false, .end_of_list = true, .number = 0, .child_index = 1 }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "writeDafsa",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeDafsaChildren from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "fn writeDafsaChildren(\n        db: *const DafsaBuilder,\n        node: *Node,\n        writer: *std.Io.Writer,\n        queue: *std.ArrayList(*Node),\n        child_indexes: *std.AutoHashMapUnmanaged(*Node, usize),\n        first_available_index: usize,\n    ) !usize {\n        var cur_available_index = first_available_index;\n        const num_children = node.numDirectChildren();\n        var child_i: usize = 0;\n        for (node.children, 0..) |maybe_child, c_usize| {\n            const child = maybe_child orelse continue;\n            const c: u8 = @intCast(c_usize);\n            const is_last_child = child_i == num_children - 1;\n\n            if (!child_indexes.contains(child)) {\n                const child_num_children = child.numDirectChildren();\n                if (child_num_children > 0) {\n                    child_indexes.putAssumeCapacityNoClobber(child, cur_available_index);\n                    cur_available_index += child_num_children;\n                }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "function",
      "name": "writeDafsaChildren",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to NameBuf from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "pub const NameBuf = struct {\n        \\\\    buf: [longest_name]u8 = undefined,\n        \\\\    len: std.math.IntFittingRange(0, longest_name),\n        \\\\\n        \\\\    pub fn span(self: *const NameBuf) []const u8 {\n        \\\\        return self.buf[0..self.len];\n        \\\\    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "struct",
      "name": "NameBuf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Value from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "const Value = struct {\n    name: []const u8,\n    properties: []const []const u8,\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "struct",
      "name": "Value",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to DafsaBuilder from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "const DafsaBuilder = struct {\n    root: *Node,\n    arena: std.heap.ArenaAllocator.State,\n    allocator: Allocator,\n    unchecked_nodes: std.ArrayListUnmanaged(UncheckedNode),\n    minimized_nodes: std.HashMapUnmanaged(*Node, *Node, Node.DuplicateContext, std.hash_map.default_max_load_percentage),\n    previous_word_buf: [128]u8 = undefined,\n    previous_word: []u8 = &[_]u8{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "struct",
      "name": "DafsaBuilder",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to UncheckedNode from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "const UncheckedNode = struct {\n        parent: *Node,\n        char: u8,\n        child: *Node,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "struct",
      "name": "UncheckedNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Node from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "const Node = struct {\n        children: [256]?*Node = @splat(null),\n        is_terminal: bool = false,\n        number: usize = 0,\n\n        const DuplicateContext = struct {\n            pub fn hash(ctx: @This(), key: *Node) u64 {\n                _ = ctx;\n                var hasher = std.hash.Wyhash.init(0);\n                std.hash.autoHash(&hasher, key.children);\n                std.hash.autoHash(&hasher, key.is_terminal);\n                return hasher.final();\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "struct",
      "name": "Node",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to c from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: build/generate_def.zig",
    "response": "const c: u8 = @intCast(c_usize);",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "build/generate_def.zig",
      "type": "const",
      "name": "c",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "pub fn init(code: []const u8) Disassembler {\n    return .{ .code = code }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "pub fn next(dis: *Disassembler) Error!?Instruction {\n    const prefixes = dis.parsePrefixes() catch |err| switch (err) {\n        error.EndOfStream => return null,\n        else => |e| return e,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to inst from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "fn inst(encoding: Encoding, args: struct {\n    prefix: Instruction.Prefix = .none,\n    op1: Instruction.Operand = .none,\n    op2: Instruction.Operand = .none,\n    op3: Instruction.Operand = .none,\n    op4: Instruction.Operand = .none,\n}) Instruction {\n    return .{ .encoding = encoding, .prefix = args.prefix, .ops = .{\n        args.op1,\n        args.op2,\n        args.op3,\n        args.op4,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "inst",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parsePrefixes from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "fn parsePrefixes(dis: *Disassembler) !Prefixes {\n    const rex_prefix_mask: u4 = 0b0100;\n    var stream = std.io.fixedBufferStream(dis.code[dis.pos..]);\n    const reader = stream.reader();\n\n    var res: Prefixes = .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "parsePrefixes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseEncoding from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "fn parseEncoding(dis: *Disassembler, prefixes: Prefixes) !?Encoding {\n    const o_mask: u8 = 0b1111_1000;\n\n    var opcode: [3]u8 = .{ 0, 0, 0 }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "parseEncoding",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseGpRegister from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "fn parseGpRegister(low_enc: u3, is_extended: bool, rex: Rex, bit_size: u64) Register {\n    const reg_id: u4 = @as(u4, @intCast(@intFromBool(is_extended))) << 3 | low_enc;\n    const reg = @as(Register, @enumFromInt(reg_id)).toBitSize(bit_size);\n    return switch (reg) {\n        .spl => if (rex.present or rex.isSet()) .spl else .ah,\n        .dil => if (rex.present or rex.isSet()) .dil else .bh,\n        .bpl => if (rex.present or rex.isSet()) .bpl else .ch,\n        .sil => if (rex.present or rex.isSet()) .sil else .dh,\n        else => reg,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "parseGpRegister",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseImm from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "fn parseImm(dis: *Disassembler, kind: Encoding.Op) !Immediate {\n    var stream = std.io.fixedBufferStream(dis.code[dis.pos..]);\n    var creader = std.io.countingReader(stream.reader());\n    const reader = creader.reader();\n    const imm = switch (kind) {\n        .imm8s, .rel8 => Immediate.s(try reader.readInt(i8, .little)),\n        .imm16s, .rel16 => Immediate.s(try reader.readInt(i16, .little)),\n        .imm32s, .rel32 => Immediate.s(try reader.readInt(i32, .little)),\n        .imm8 => Immediate.u(try reader.readInt(u8, .little)),\n        .imm16 => Immediate.u(try reader.readInt(u16, .little)),\n        .imm32 => Immediate.u(try reader.readInt(u32, .little)),\n        .imm64 => Immediate.u(try reader.readInt(u64, .little)),\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "parseImm",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseOffset from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "fn parseOffset(dis: *Disassembler) !u64 {\n    var stream = std.io.fixedBufferStream(dis.code[dis.pos..]);\n    const reader = stream.reader();\n    const offset = try reader.readInt(u64, .little);\n    dis.pos += 8;\n    return offset;\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "parseOffset",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to direct from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "fn direct(self: ModRm) bool {\n        return self.mod == 0b11;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "direct",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rip from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "fn rip(self: ModRm) bool {\n        return self.mod == 0 and self.op2 == 0b101;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "rip",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sib from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "fn sib(self: ModRm) bool {\n        return !self.direct() and self.op2 == 0b100;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "sib",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseModRmByte from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "fn parseModRmByte(dis: *Disassembler) !ModRm {\n    if (dis.code[dis.pos..].len == 0) return error.EndOfStream;\n    const modrm_byte = dis.code[dis.pos];\n    dis.pos += 1;\n    const mod: u2 = @as(u2, @truncate(modrm_byte >> 6));\n    const op1: u3 = @as(u3, @truncate(modrm_byte >> 3));\n    const op2: u3 = @as(u3, @truncate(modrm_byte));\n    return ModRm{ .mod = mod, .op1 = op1, .op2 = op2 }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "parseModRmByte",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to segmentRegister from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "fn segmentRegister(prefixes: LegacyPrefixes) Register {\n    if (prefixes.prefix_2e) return .cs;\n    if (prefixes.prefix_36) return .ss;\n    if (prefixes.prefix_26) return .es;\n    if (prefixes.prefix_64) return .fs;\n    if (prefixes.prefix_65) return .gs;\n    return .ds;\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "segmentRegister",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to scaleIndex from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "fn scaleIndex(self: Sib, rex: Rex) ?Memory.ScaleIndex {\n        if (self.index == 0b100 and !rex.x) return null;\n        return .{\n            .scale = @as(u4, 1) << self.scale,\n            .index = parseGpRegister(self.index, rex.x, rex, 64),\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "scaleIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to baseReg from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "fn baseReg(self: Sib, modrm: ModRm, prefixes: Prefixes) ?Register {\n        if (self.base == 0b101 and modrm.mod == 0) {\n            if (self.scaleIndex(prefixes.rex)) |_| return null;\n            return segmentRegister(prefixes.legacy);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "baseReg",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseSibByte from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "fn parseSibByte(dis: *Disassembler) !Sib {\n    if (dis.code[dis.pos..].len == 0) return error.EndOfStream;\n    const sib_byte = dis.code[dis.pos];\n    dis.pos += 1;\n    const scale: u2 = @as(u2, @truncate(sib_byte >> 6));\n    const index: u3 = @as(u3, @truncate(sib_byte >> 3));\n    const base: u3 = @as(u3, @truncate(sib_byte));\n    return Sib{ .scale = scale, .index = index, .base = base }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "parseSibByte",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseDisplacement from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "fn parseDisplacement(dis: *Disassembler, modrm: ModRm, sib: ?Sib) !i32 {\n    var stream = std.io.fixedBufferStream(dis.code[dis.pos..]);\n    var creader = std.io.countingReader(stream.reader());\n    const reader = creader.reader();\n    const disp = disp: {\n        if (sib) |info| {\n            if (info.base == 0b101 and modrm.mod == 0) {\n                break :disp try reader.readInt(i32, .little);\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "function",
      "name": "parseDisplacement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Prefixes from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "const Prefixes = struct {\n    legacy: LegacyPrefixes = .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "struct",
      "name": "Prefixes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to op2 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "const op2: Instruction.Operand = if (enc.data.op_en == .oi) .{\n                .imm = try dis.parseImm(enc.data.ops[1]),\n            } else .none;",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "const",
      "name": "op2",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to op2 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "const op2: Instruction.Operand = switch (act_enc.data.op_en) {\n                    .mi => .{ .imm = try dis.parseImm(act_enc.data.ops[1]) },\n                    .m1 => .{ .imm = Immediate.u(1) },\n                    .mc => .{ .reg = .cl },\n                    .m => .none,\n                    else => unreachable,\n                };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "const",
      "name": "op2",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to op2 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "const op2: Instruction.Operand = switch (act_enc.data.op_en) {\n                .mi => .{ .imm = try dis.parseImm(act_enc.data.ops[1]) },\n                .m1 => .{ .imm = Immediate.u(1) },\n                .mc => .{ .reg = .cl },\n                .m => .none,\n                else => unreachable,\n            };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "const",
      "name": "op2",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to op3 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "const op3: Instruction.Operand = switch (enc.data.op_en) {\n                .mri => .{ .imm = try dis.parseImm(enc.data.ops[2]) },\n                .mrc => .{ .reg = .cl },\n                .mr => .none,\n                else => unreachable,\n            };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "const",
      "name": "op3",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to op3 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "const op3: Instruction.Operand = switch (enc.data.op_en) {\n                    .rm => .none,\n                    .rmi => .{ .imm = try dis.parseImm(enc.data.ops[2]) },\n                    else => unreachable,\n                };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "const",
      "name": "op3",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to op3 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "const op3: Instruction.Operand = switch (enc.data.op_en) {\n                .rmi => .{ .imm = try dis.parseImm(enc.data.ops[2]) },\n                .rm => .none,\n                else => unreachable,\n            };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "const",
      "name": "op3",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to rex_prefix_mask from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "const rex_prefix_mask: u4 = 0b0100;",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "const",
      "name": "rex_prefix_mask",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to o_mask from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "const o_mask: u8 = 0b1111_1000;",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "const",
      "name": "o_mask",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to reg_id from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "const reg_id: u4 = @as(u4, @intCast(@intFromBool(is_extended))) << 3 | low_enc;",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "const",
      "name": "reg_id",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to mod from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "const mod: u2 = @as(u2, @truncate(modrm_byte >> 6));",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "const",
      "name": "mod",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to op1 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "const op1: u3 = @as(u3, @truncate(modrm_byte >> 3));",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "const",
      "name": "op1",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to op2 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "const op2: u3 = @as(u3, @truncate(modrm_byte));",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "const",
      "name": "op2",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to scale from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "const scale: u2 = @as(u2, @truncate(sib_byte >> 6));",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "const",
      "name": "scale",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to index from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "const index: u3 = @as(u3, @truncate(sib_byte >> 3));",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "const",
      "name": "index",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to base from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Disassembler.zig",
    "response": "const base: u3 = @as(u3, @truncate(sib_byte));",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Disassembler.zig",
      "type": "const",
      "name": "base",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findByMnemonic from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn findByMnemonic(\n    prefix: Instruction.Prefix,\n    mnemonic: Mnemonic,\n    ops: []const Instruction.Operand,\n) !?Encoding {\n    var input_ops = [1]Op{.none}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "findByMnemonic",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findByOpcode from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn findByOpcode(opc: []const u8, prefixes: struct {\n    legacy: LegacyPrefixes,\n    rex: Rex,\n}, modrm_ext: ?u3) ?Encoding {\n    for (mnemonic_to_encodings_map, 0..) |encs, mnemonic_int| for (encs) |data| {\n        const enc = Encoding{ .mnemonic = @as(Mnemonic, @enumFromInt(mnemonic_int)), .data = data }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "findByOpcode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to opcode from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn opcode(encoding: *const Encoding) []const u8 {\n    return encoding.data.opc[0..encoding.data.opc_len];\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "opcode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to mandatoryPrefix from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn mandatoryPrefix(encoding: *const Encoding) ?u8 {\n    const prefix = encoding.data.opc[0];\n    return switch (prefix) {\n        0x66, 0xf2, 0xf3 => prefix,\n        else => null,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "mandatoryPrefix",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to modRmExt from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn modRmExt(encoding: Encoding) u3 {\n    return switch (encoding.data.op_en) {\n        .m, .mi, .m1, .mc, .vmi => encoding.data.modrm_ext,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "modRmExt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to format from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn format(\n    encoding: Encoding,\n    comptime fmt: []const u8,\n    options: std.fmt.FormatOptions,\n    writer: anytype,\n) !void {\n    _ = options;\n    _ = fmt;\n\n    var opc = encoding.opcode();\n    if (encoding.data.mode.isVex()) {\n        try writer.writeAll(\"VEX.\");\n\n        try writer.writeAll(switch (encoding.data.mode) {\n            .vex_128_w0, .vex_128_w1, .vex_128_wig => \"128\",\n            .vex_256_w0, .vex_256_w1, .vex_256_wig => \"256\",\n            .vex_lig_w0, .vex_lig_w1, .vex_lig_wig => \"LIG\",\n            .vex_lz_w0, .vex_lz_w1, .vex_lz_wig => \"LZ\",\n            else => unreachable,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "format",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromOperand from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn fromOperand(operand: Instruction.Operand) Op {\n        return switch (operand) {\n            .none => .none,\n\n            .reg => |reg| switch (reg.class()) {\n                .general_purpose => if (reg.to64() == .rax)\n                    switch (reg) {\n                        .al => .al,\n                        .ax => .ax,\n                        .eax => .eax,\n                        .rax => .rax,\n                        else => unreachable,\n                    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "fromOperand",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to immBitSize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn immBitSize(op: Op) u64 {\n        return switch (op) {\n            .none, .o16, .o32, .o64, .moffs, .m, .sreg => unreachable,\n            .al, .cl, .r8, .rm8, .r32_m8 => unreachable,\n            .ax, .r16, .rm16 => unreachable,\n            .eax, .r32, .rm32, .r32_m16 => unreachable,\n            .rax, .r64, .rm64, .r64_m16 => unreachable,\n            .st, .mm, .mm_m64 => unreachable,\n            .xmm0, .xmm, .xmm_m8, .xmm_m16, .xmm_m32, .xmm_m64, .xmm_m128 => unreachable,\n            .ymm, .ymm_m256 => unreachable,\n            .m8, .m16, .m32, .m64, .m80, .m128, .m256 => unreachable,\n            .unity => 1,\n            .imm8, .imm8s, .rel8 => 8,\n            .imm16, .imm16s, .rel16 => 16,\n            .imm32, .imm32s, .rel32 => 32,\n            .imm64 => 64,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "immBitSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to regBitSize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn regBitSize(op: Op) u64 {\n        return switch (op) {\n            .none, .o16, .o32, .o64, .moffs, .m, .sreg => unreachable,\n            .unity, .imm8, .imm8s, .imm16, .imm16s, .imm32, .imm32s, .imm64 => unreachable,\n            .rel8, .rel16, .rel32 => unreachable,\n            .m8, .m16, .m32, .m64, .m80, .m128, .m256 => unreachable,\n            .al, .cl, .r8, .rm8 => 8,\n            .ax, .r16, .rm16 => 16,\n            .eax, .r32, .rm32, .r32_m8, .r32_m16 => 32,\n            .rax, .r64, .rm64, .r64_m16, .mm, .mm_m64 => 64,\n            .st => 80,\n            .xmm0, .xmm, .xmm_m8, .xmm_m16, .xmm_m32, .xmm_m64, .xmm_m128 => 128,\n            .ymm, .ymm_m256 => 256,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "regBitSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to memBitSize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn memBitSize(op: Op) u64 {\n        return switch (op) {\n            .none, .o16, .o32, .o64, .moffs, .m, .sreg => unreachable,\n            .unity, .imm8, .imm8s, .imm16, .imm16s, .imm32, .imm32s, .imm64 => unreachable,\n            .rel8, .rel16, .rel32 => unreachable,\n            .al, .cl, .r8, .ax, .r16, .eax, .r32, .rax, .r64 => unreachable,\n            .st, .mm, .xmm0, .xmm, .ymm => unreachable,\n            .m8, .rm8, .r32_m8, .xmm_m8 => 8,\n            .m16, .rm16, .r32_m16, .r64_m16, .xmm_m16 => 16,\n            .m32, .rm32, .xmm_m32 => 32,\n            .m64, .rm64, .mm_m64, .xmm_m64 => 64,\n            .m80 => 80,\n            .m128, .xmm_m128 => 128,\n            .m256, .ymm_m256 => 256,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "memBitSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isSigned from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn isSigned(op: Op) bool {\n        return switch (op) {\n            .unity, .imm8, .imm16, .imm32, .imm64 => false,\n            .imm8s, .imm16s, .imm32s => true,\n            .rel8, .rel16, .rel32 => true,\n            else => unreachable,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "isSigned",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isUnsigned from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn isUnsigned(op: Op) bool {\n        return !op.isSigned();\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "isUnsigned",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isRegister from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn isRegister(op: Op) bool {\n        // zig fmt: off\n        return switch (op) {\n            .cl,\n            .al, .ax, .eax, .rax,\n            .r8, .r16, .r32, .r64,\n            .rm8, .rm16, .rm32, .rm64,\n            .r32_m8, .r32_m16, .r64_m16,\n            .st, .mm, .mm_m64,\n            .xmm0, .xmm, .xmm_m8, .xmm_m16, .xmm_m32, .xmm_m64, .xmm_m128,\n            .ymm, .ymm_m256,\n            => true,\n            else => false,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "isRegister",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isImmediate from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn isImmediate(op: Op) bool {\n        // zig fmt: off\n        return switch (op) {\n            .imm8, .imm16, .imm32, .imm64, \n            .imm8s, .imm16s, .imm32s,\n            .rel8, .rel16, .rel32,\n            .unity,\n            => true,\n            else => false,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "isImmediate",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isMemory from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn isMemory(op: Op) bool {\n        // zig fmt: off\n        return switch (op) {\n            .rm8, .rm16, .rm32, .rm64,\n            .r32_m8, .r32_m16, .r64_m16,\n            .m8, .m16, .m32, .m64, .m80, .m128, .m256,\n            .m,\n            .mm_m64,\n            .xmm_m8, .xmm_m16, .xmm_m32, .xmm_m64, .xmm_m128,\n            .ymm_m256,\n            => true,\n            else => false,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "isMemory",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isSegmentRegister from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn isSegmentRegister(op: Op) bool {\n        return switch (op) {\n            .moffs, .sreg => true,\n            else => false,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "isSegmentRegister",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to class from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn class(op: Op) bits.Register.Class {\n        return switch (op) {\n            else => unreachable,\n            .al, .ax, .eax, .rax, .cl => .general_purpose,\n            .r8, .r16, .r32, .r64 => .general_purpose,\n            .rm8, .rm16, .rm32, .rm64 => .general_purpose,\n            .r32_m8, .r32_m16, .r64_m16 => .general_purpose,\n            .sreg => .segment,\n            .st => .x87,\n            .mm, .mm_m64 => .mmx,\n            .xmm0, .xmm, .xmm_m8, .xmm_m16, .xmm_m32, .xmm_m64, .xmm_m128 => .sse,\n            .ymm, .ymm_m256 => .sse,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "class",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isSubset from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn isSubset(op: Op, target: Op) bool {\n        switch (op) {\n            .o16, .o32, .o64 => unreachable,\n            .moffs, .sreg => return op == target,\n            .none => switch (target) {\n                .o16, .o32, .o64, .none => return true,\n                else => return false,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "isSubset",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isShort from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn isShort(mode: Mode) bool {\n        return switch (mode) {\n            .short, .rex_short => true,\n            else => false,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "isShort",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isLong from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn isLong(mode: Mode) bool {\n        return switch (mode) {\n            .long,\n            .vex_128_w1,\n            .vex_256_w1,\n            .vex_lig_w1,\n            .vex_lz_w1,\n            => true,\n            else => false,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "isLong",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isRex from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn isRex(mode: Mode) bool {\n        return switch (mode) {\n            else => false,\n            .rex, .rex_short => true,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "isRex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isVex from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn isVex(mode: Mode) bool {\n        return switch (mode) {\n            // zig fmt: off\n            else => false,\n            .vex_128_w0, .vex_128_w1, .vex_128_wig,\n            .vex_256_w0, .vex_256_w1, .vex_256_wig,\n            .vex_lig_w0, .vex_lig_w1, .vex_lig_wig,\n            .vex_lz_w0,  .vex_lz_w1,  .vex_lz_wig,\n            => true,\n            // zig fmt: on\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "isVex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isVecLong from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "pub fn isVecLong(mode: Mode) bool {\n        return switch (mode) {\n            // zig fmt: off\n            else => unreachable,\n            .vex_128_w0, .vex_128_w1, .vex_128_wig,\n            .vex_lig_w0, .vex_lig_w1, .vex_lig_wig,\n            .vex_lz_w0,  .vex_lz_w1,  .vex_lz_wig,\n            => false,\n            .vex_256_w0, .vex_256_w1, .vex_256_wig,\n            => true,\n            // zig fmt: on\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "isVecLong",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to estimateInstructionLength from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "fn estimateInstructionLength(prefix: Prefix, encoding: Encoding, ops: []const Operand) usize {\n    var inst = Instruction{\n        .prefix = prefix,\n        .encoding = encoding,\n        .ops = [1]Operand{.none}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "estimateInstructionLength",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lessThan from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "fn lessThan(_: void, lhs: encodings.Entry, rhs: encodings.Entry) bool {\n            return @intFromEnum(lhs[0]) < @intFromEnum(rhs[0]);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "function",
      "name": "lessThan",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Data from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Encoding.zig",
    "response": "const Data = struct {\n    op_en: OpEn,\n    ops: [4]Op,\n    opc_len: u3,\n    opc: [7]u8,\n    modrm_ext: u3,\n    mode: Mode,\n    feature: Feature,\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Encoding.zig",
      "type": "struct",
      "name": "Data",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lowerMir from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Lower.zig",
    "response": "pub fn lowerMir(lower: *Lower, index: Mir.Inst.Index) Error!struct {\n    insts: []const Instruction,\n    relocs: []const Reloc,\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Lower.zig",
      "type": "function",
      "name": "lowerMir",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fail from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Lower.zig",
    "response": "pub fn fail(lower: *Lower, comptime format: []const u8, args: anytype) Error {\n    @branchHint(.cold);\n    assert(lower.err_msg == null);\n    lower.err_msg = try std.fmt.allocPrint(lower.gpa, format, args);\n    return error.LowerFail;\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Lower.zig",
      "type": "function",
      "name": "fail",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to imm from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Lower.zig",
    "response": "fn imm(lower: Lower, ops: Mir.Inst.Ops, i: u32) Immediate {\n    return switch (ops) {\n        .rri_s,\n        .ri_s,\n        .i_s,\n        .mi_s,\n        .rmi_s,\n        => Immediate.s(@bitCast(i)),\n\n        .rrri,\n        .rri_u,\n        .ri_u,\n        .i_u,\n        .mi_u,\n        .rmi,\n        .rmi_u,\n        .mri,\n        .rrm,\n        .rrmi,\n        => Immediate.u(i),\n\n        .ri64 => Immediate.u(lower.mir.extraData(Mir.Imm64, i).data.decode()),\n\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Lower.zig",
      "type": "function",
      "name": "imm",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to mem from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Lower.zig",
    "response": "fn mem(lower: Lower, payload: u32) Memory {\n    return lower.mir.resolveFrameLoc(lower.mir.extraData(Mir.Memory, payload).data).decode();\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Lower.zig",
      "type": "function",
      "name": "mem",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reloc from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Lower.zig",
    "response": "fn reloc(lower: *Lower, target: Reloc.Target) Immediate {\n    lower.result_relocs[lower.result_relocs_len] = .{\n        .lowered_inst_index = lower.result_insts_len,\n        .target = target,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Lower.zig",
      "type": "function",
      "name": "reloc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to emit from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Lower.zig",
    "response": "fn emit(lower: *Lower, prefix: Prefix, mnemonic: Mnemonic, ops: []const Operand) Error!void {\n    const needsZigGot = struct {\n        fn needsZigGot(sym: bits.Symbol, ctx: *link.File) bool {\n            const elf_file = ctx.cast(link.File.Elf).?;\n            const sym_index = elf_file.zigObjectPtr().?.symbol(sym.sym_index);\n            return elf_file.symbol(sym_index).flags.needs_zig_got;\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Lower.zig",
      "type": "function",
      "name": "emit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generic from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Lower.zig",
    "response": "fn generic(lower: *Lower, inst: Mir.Inst) Error!void {\n    const fixes = switch (inst.ops) {\n        .none => inst.data.none.fixes,\n        .inst => inst.data.inst.fixes,\n        .i_s, .i_u => inst.data.i.fixes,\n        .r => inst.data.r.fixes,\n        .rr => inst.data.rr.fixes,\n        .rrr => inst.data.rrr.fixes,\n        .rrrr => inst.data.rrrr.fixes,\n        .rrri => inst.data.rrri.fixes,\n        .rri_s, .rri_u => inst.data.rri.fixes,\n        .ri_s, .ri_u => inst.data.ri.fixes,\n        .ri64, .rm, .rmi_s, .mr => inst.data.rx.fixes,\n        .mrr, .rrm => inst.data.rrx.fixes,\n        .rmi, .mri => inst.data.rix.fixes,\n        .rrmi => inst.data.rrix.fixes,\n        .mi_u, .mi_s => inst.data.x.fixes,\n        .m => inst.data.x.fixes,\n        .extern_fn_reloc, .got_reloc, .direct_reloc, .import_reloc, .tlv_reloc => ._,\n        else => return lower.fail(\"TODO lower .{s}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Lower.zig",
      "type": "function",
      "name": "generic",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pushPopRegList from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Lower.zig",
    "response": "fn pushPopRegList(lower: *Lower, comptime mnemonic: Mnemonic, inst: Mir.Inst) Error!void {\n    const callee_preserved_regs = abi.getCalleePreservedRegs(lower.cc);\n    var it = inst.data.reg_list.iterator(.{ .direction = switch (mnemonic) {\n        .push => .reverse,\n        .pop => .forward,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Lower.zig",
      "type": "function",
      "name": "pushPopRegList",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Reloc from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Lower.zig",
    "response": "pub const Reloc = struct {\n    lowered_inst_index: u8,\n    target: Target,\n\n    const Target = union(enum) {\n        inst: Mir.Inst.Index,\n        linker_reloc: bits.Symbol,\n        linker_extern_fn: bits.Symbol,\n        linker_got: bits.Symbol,\n        linker_direct: bits.Symbol,\n        linker_import: bits.Symbol,\n        linker_tlv: bits.Symbol,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Lower.zig",
      "type": "struct",
      "name": "Reloc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to needsZigGot from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Lower.zig",
    "response": "const needsZigGot = struct {\n        fn needsZigGot(sym: bits.Symbol, ctx: *link.File) bool {\n            const elf_file = ctx.cast(link.File.Elf).?;\n            const sym_index = elf_file.zigObjectPtr().?.symbol(sym.sym_index);\n            return elf_file.symbol(sym_index).flags.needs_zig_got;\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Lower.zig",
      "type": "struct",
      "name": "needsZigGot",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to page_size from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Lower.zig",
    "response": "const page_size: i32 = 1 << 12;",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Lower.zig",
      "type": "const",
      "name": "page_size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromCondition from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub fn fromCondition(cc: bits.Condition) Fixes {\n            return switch (cc) {\n                inline else => |cc_tag| @field(Fixes, \"_\" ++ @tagName(cc_tag)),\n                .z_and_np, .nz_or_p => unreachable,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "function",
      "name": "fromCondition",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getIndexForReg from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "fn getIndexForReg(registers: []const Register, reg: Register) BitSet.MaskInt {\n        for (registers, 0..) |cpreg, i| {\n            if (reg.id() == cpreg.id()) return @intCast(i);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "function",
      "name": "getIndexForReg",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to push from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub fn push(self: *Self, registers: []const Register, reg: Register) void {\n        const index = getIndexForReg(registers, reg);\n        self.bitset.set(index);\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "function",
      "name": "push",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isSet from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub fn isSet(self: Self, registers: []const Register, reg: Register) bool {\n        const index = getIndexForReg(registers, reg);\n        return self.bitset.isSet(index);\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "function",
      "name": "isSet",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to iterator from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub fn iterator(self: Self, comptime options: std.bit_set.IteratorOptions) BitSet.Iterator(options) {\n        return self.bitset.iterator(options);\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "function",
      "name": "iterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to count from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub fn count(self: Self) i32 {\n        return @intCast(self.bitset.count());\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "function",
      "name": "count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to size from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub fn size(self: Self) i32 {\n        return @intCast(self.bitset.count() * 8);\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "function",
      "name": "size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub fn encode(v: u64) Imm64 {\n        return .{\n            .msb = @truncate(v >> 32),\n            .lsb = @truncate(v),\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub fn decode(imm: Imm64) u64 {\n        var res: u64 = 0;\n        res |= @as(u64, @intCast(imm.msb)) << 32;\n        res |= @as(u64, @intCast(imm.lsb));\n        return res;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub fn encode(mem: bits.Memory) Memory {\n        assert(mem.base != .reloc or mem.mod != .off);\n        return .{\n            .info = .{\n                .base = mem.base,\n                .mod = mem.mod,\n                .size = switch (mem.mod) {\n                    .rm => |rm| rm.size,\n                    .off => undefined,\n                }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to decode from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub fn decode(mem: Memory) encoder.Instruction.Memory {\n        switch (mem.info.mod) {\n            .rm => {\n                if (mem.info.base == .reg and @as(Register, @enumFromInt(mem.base)) == .rip) {\n                    assert(mem.info.index == .none and mem.info.scale == .@\"1\");\n                    return encoder.Instruction.Memory.rip(mem.info.size, @bitCast(mem.off));\n                }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "function",
      "name": "decode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub fn deinit(mir: *Mir, gpa: std.mem.Allocator) void {\n    mir.instructions.deinit(gpa);\n    gpa.free(mir.extra);\n    mir.frame_locs.deinit(gpa);\n    mir.* = undefined;\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to extraData from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub fn extraData(mir: Mir, comptime T: type, index: u32) struct { data: T, end: u32 }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "function",
      "name": "extraData",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveFrameLoc from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub fn resolveFrameLoc(mir: Mir, mem: Memory) Memory {\n    return switch (mem.info.base) {\n        .none, .reg, .reloc => mem,\n        .frame => if (mir.frame_locs.len > 0) Memory{\n            .info = .{\n                .base = .reg,\n                .mod = mem.info.mod,\n                .size = mem.info.size,\n                .index = mem.info.index,\n                .scale = mem.info.scale,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "function",
      "name": "resolveFrameLoc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FixedTag from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub const FixedTag = struct { Fixes, Tag }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "struct",
      "name": "FixedTag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to RegisterList from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub const RegisterList = struct {\n    bitset: BitSet = BitSet.initEmpty(),\n\n    const BitSet = IntegerBitSet(32);\n    const Self = @This();\n\n    fn getIndexForReg(registers: []const Register, reg: Register) BitSet.MaskInt {\n        for (registers, 0..) |cpreg, i| {\n            if (reg.id() == cpreg.id()) return @intCast(i);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "struct",
      "name": "RegisterList",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Imm32 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub const Imm32 = struct {\n    imm: u32,\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "struct",
      "name": "Imm32",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Imm64 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub const Imm64 = struct {\n    msb: u32,\n    lsb: u32,\n\n    pub fn encode(v: u64) Imm64 {\n        return .{\n            .msb = @truncate(v >> 32),\n            .lsb = @truncate(v),\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "struct",
      "name": "Imm64",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Memory from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub const Memory = struct {\n    info: Info,\n    base: u32,\n    off: u32,\n    extra: u32,\n\n    pub const Info = packed struct(u32) {\n        base: @typeInfo(bits.Memory.Base).Union.tag_type.?,\n        mod: @typeInfo(bits.Memory.Mod).Union.tag_type.?,\n        size: bits.Memory.Size,\n        index: Register,\n        scale: bits.Memory.Scale,\n        _: u16 = undefined,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "struct",
      "name": "Memory",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FrameLoc from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/Mir.zig",
    "response": "pub const FrameLoc = struct {\n    base: Register,\n    disp: i32,\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/Mir.zig",
      "type": "struct",
      "name": "FrameLoc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveCallingConvention from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/abi.zig",
    "response": "pub fn resolveCallingConvention(\n    cc: std.builtin.CallingConvention,\n    target: std.Target,\n) std.builtin.CallingConvention {\n    return switch (cc) {\n        .Unspecified, .C => switch (target.os.tag) {\n            else => .SysV,\n            .windows => .Win64,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/abi.zig",
      "type": "function",
      "name": "resolveCallingConvention",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getCalleePreservedRegs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/abi.zig",
    "response": "pub fn getCalleePreservedRegs(cc: std.builtin.CallingConvention) []const Register {\n    return switch (cc) {\n        .SysV => &SysV.callee_preserved_regs,\n        .Win64 => &Win64.callee_preserved_regs,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/abi.zig",
      "type": "function",
      "name": "getCalleePreservedRegs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getCallerPreservedRegs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/abi.zig",
    "response": "pub fn getCallerPreservedRegs(cc: std.builtin.CallingConvention) []const Register {\n    return switch (cc) {\n        .SysV => &SysV.caller_preserved_regs,\n        .Win64 => &Win64.caller_preserved_regs,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/abi.zig",
      "type": "function",
      "name": "getCallerPreservedRegs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getCAbiIntParamRegs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/abi.zig",
    "response": "pub fn getCAbiIntParamRegs(cc: std.builtin.CallingConvention) []const Register {\n    return switch (cc) {\n        .SysV => &SysV.c_abi_int_param_regs,\n        .Win64 => &Win64.c_abi_int_param_regs,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/abi.zig",
      "type": "function",
      "name": "getCAbiIntParamRegs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getCAbiSseParamRegs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/abi.zig",
    "response": "pub fn getCAbiSseParamRegs(cc: std.builtin.CallingConvention) []const Register {\n    return switch (cc) {\n        .SysV => &SysV.c_abi_sse_param_regs,\n        .Win64 => &Win64.c_abi_sse_param_regs,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/abi.zig",
      "type": "function",
      "name": "getCAbiSseParamRegs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getCAbiIntReturnRegs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/abi.zig",
    "response": "pub fn getCAbiIntReturnRegs(cc: std.builtin.CallingConvention) []const Register {\n    return switch (cc) {\n        .SysV => &SysV.c_abi_int_return_regs,\n        .Win64 => &Win64.c_abi_int_return_regs,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/abi.zig",
      "type": "function",
      "name": "getCAbiIntReturnRegs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getCAbiSseReturnRegs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/abi.zig",
    "response": "pub fn getCAbiSseReturnRegs(cc: std.builtin.CallingConvention) []const Register {\n    return switch (cc) {\n        .SysV => &SysV.c_abi_sse_return_regs,\n        .Win64 => &Win64.c_abi_sse_return_regs,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/abi.zig",
      "type": "function",
      "name": "getCAbiSseReturnRegs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to SysV from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/abi.zig",
    "response": "pub const SysV = struct {\n    /// Note that .rsp and .rbp also belong to this set, however, we never expect to use them\n    /// for anything else but stack offset tracking therefore we exclude them from this set.\n    pub const callee_preserved_regs = [_]Register{ .rbx, .r12, .r13, .r14, .r15 }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/abi.zig",
      "type": "struct",
      "name": "SysV",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Win64 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/abi.zig",
    "response": "pub const Win64 = struct {\n    /// Note that .rsp and .rbp also belong to this set, however, we never expect to use them\n    /// for anything else but stack offset tracking therefore we exclude them from this set.\n    pub const callee_preserved_regs = [_]Register{ .rbx, .rsi, .rdi, .r12, .r13, .r14, .r15 }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/abi.zig",
      "type": "struct",
      "name": "Win64",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromCompareOperatorSigned from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn fromCompareOperatorSigned(op: std.math.CompareOperator) Condition {\n        return switch (op) {\n            .gte => .ge,\n            .gt => .g,\n            .neq => .ne,\n            .lt => .l,\n            .lte => .le,\n            .eq => .e,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "fromCompareOperatorSigned",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromCompareOperatorUnsigned from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn fromCompareOperatorUnsigned(op: std.math.CompareOperator) Condition {\n        return switch (op) {\n            .gte => .ae,\n            .gt => .a,\n            .neq => .ne,\n            .lt => .b,\n            .lte => .be,\n            .eq => .e,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "fromCompareOperatorUnsigned",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromCompareOperator from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn fromCompareOperator(\n        signedness: std.builtin.Signedness,\n        op: std.math.CompareOperator,\n    ) Condition {\n        return switch (signedness) {\n            .signed => fromCompareOperatorSigned(op),\n            .unsigned => fromCompareOperatorUnsigned(op),\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "fromCompareOperator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to negate from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn negate(cond: Condition) Condition {\n        return switch (cond) {\n            .a => .na,\n            .ae => .nae,\n            .b => .nb,\n            .be => .nbe,\n            .c => .nc,\n            .e => .ne,\n            .g => .ng,\n            .ge => .nge,\n            .l => .nl,\n            .le => .nle,\n            .na => .a,\n            .nae => .ae,\n            .nb => .b,\n            .nbe => .be,\n            .nc => .c,\n            .ne => .e,\n            .ng => .g,\n            .nge => .ge,\n            .nl => .l,\n            .nle => .le,\n            .no => .o,\n            .np => .p,\n            .ns => .s,\n            .nz => .z,\n            .o => .no,\n            .p => .np,\n            .pe => .po,\n            .po => .pe,\n            .s => .ns,\n            .z => .nz,\n\n            .z_and_np => .nz_or_p,\n            .nz_or_p => .z_and_np,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "negate",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to class from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn class(reg: Register) Class {\n        return switch (@intFromEnum(reg)) {\n            // zig fmt: off\n            @intFromEnum(Register.rax)  ... @intFromEnum(Register.r15)   => .general_purpose,\n            @intFromEnum(Register.eax)  ... @intFromEnum(Register.r15d)  => .general_purpose,\n            @intFromEnum(Register.ax)   ... @intFromEnum(Register.r15w)  => .general_purpose,\n            @intFromEnum(Register.al)   ... @intFromEnum(Register.r15b)  => .general_purpose,\n            @intFromEnum(Register.ah)   ... @intFromEnum(Register.bh)    => .general_purpose,\n\n            @intFromEnum(Register.ymm0) ... @intFromEnum(Register.ymm15) => .sse,\n            @intFromEnum(Register.xmm0) ... @intFromEnum(Register.xmm15) => .sse,\n            @intFromEnum(Register.mm0)  ... @intFromEnum(Register.mm7)   => .mmx,\n            @intFromEnum(Register.st0)  ... @intFromEnum(Register.st7)   => .x87,\n\n            @intFromEnum(Register.es)   ... @intFromEnum(Register.gs)    => .segment,\n\n            else => unreachable,\n            // zig fmt: on\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "class",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to id from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn id(reg: Register) u6 {\n        const base = switch (@intFromEnum(reg)) {\n            // zig fmt: off\n            @intFromEnum(Register.rax)  ... @intFromEnum(Register.r15)   => @intFromEnum(Register.rax),\n            @intFromEnum(Register.eax)  ... @intFromEnum(Register.r15d)  => @intFromEnum(Register.eax),\n            @intFromEnum(Register.ax)   ... @intFromEnum(Register.r15w)  => @intFromEnum(Register.ax),\n            @intFromEnum(Register.al)   ... @intFromEnum(Register.r15b)  => @intFromEnum(Register.al),\n            @intFromEnum(Register.ah)   ... @intFromEnum(Register.bh)    => @intFromEnum(Register.ah),\n\n            @intFromEnum(Register.ymm0) ... @intFromEnum(Register.ymm15) => @intFromEnum(Register.ymm0) - 16,\n            @intFromEnum(Register.xmm0) ... @intFromEnum(Register.xmm15) => @intFromEnum(Register.xmm0) - 16,\n            @intFromEnum(Register.mm0)  ... @intFromEnum(Register.mm7)   => @intFromEnum(Register.mm0) - 32,\n            @intFromEnum(Register.st0)  ... @intFromEnum(Register.st7)   => @intFromEnum(Register.st0) - 40,\n\n            @intFromEnum(Register.es)   ... @intFromEnum(Register.gs)    => @intFromEnum(Register.es) - 48,\n\n            else => unreachable,\n            // zig fmt: on\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "id",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to bitSize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn bitSize(reg: Register) u10 {\n        return switch (@intFromEnum(reg)) {\n            // zig fmt: off\n            @intFromEnum(Register.rax)  ... @intFromEnum(Register.r15)   => 64,\n            @intFromEnum(Register.eax)  ... @intFromEnum(Register.r15d)  => 32,\n            @intFromEnum(Register.ax)   ... @intFromEnum(Register.r15w)  => 16,\n            @intFromEnum(Register.al)   ... @intFromEnum(Register.r15b)  => 8,\n            @intFromEnum(Register.ah)   ... @intFromEnum(Register.bh)    => 8,\n\n            @intFromEnum(Register.ymm0) ... @intFromEnum(Register.ymm15) => 256,\n            @intFromEnum(Register.xmm0) ... @intFromEnum(Register.xmm15) => 128,\n            @intFromEnum(Register.mm0)  ... @intFromEnum(Register.mm7)   => 64,\n            @intFromEnum(Register.st0)  ... @intFromEnum(Register.st7)   => 80,\n\n            @intFromEnum(Register.es)   ... @intFromEnum(Register.gs)    => 16,\n\n            else => unreachable,\n            // zig fmt: on\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "bitSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isExtended from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn isExtended(reg: Register) bool {\n        return switch (@intFromEnum(reg)) {\n            // zig fmt: off\n            @intFromEnum(Register.r8)  ... @intFromEnum(Register.r15)    => true,\n            @intFromEnum(Register.r8d) ... @intFromEnum(Register.r15d)   => true,\n            @intFromEnum(Register.r8w) ... @intFromEnum(Register.r15w)   => true,\n            @intFromEnum(Register.r8b) ... @intFromEnum(Register.r15b)   => true,\n\n            @intFromEnum(Register.ymm8) ... @intFromEnum(Register.ymm15) => true,\n            @intFromEnum(Register.xmm8) ... @intFromEnum(Register.xmm15) => true,\n\n            else => false,\n            // zig fmt: on\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "isExtended",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to enc from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn enc(reg: Register) u4 {\n        const base = switch (@intFromEnum(reg)) {\n            // zig fmt: off\n            @intFromEnum(Register.rax)  ... @intFromEnum(Register.r15)   => @intFromEnum(Register.rax),\n            @intFromEnum(Register.eax)  ... @intFromEnum(Register.r15d)  => @intFromEnum(Register.eax),\n            @intFromEnum(Register.ax)   ... @intFromEnum(Register.r15w)  => @intFromEnum(Register.ax),\n            @intFromEnum(Register.al)   ... @intFromEnum(Register.r15b)  => @intFromEnum(Register.al),\n            @intFromEnum(Register.ah)   ... @intFromEnum(Register.bh)    => @intFromEnum(Register.ah) - 4,\n\n            @intFromEnum(Register.ymm0) ... @intFromEnum(Register.ymm15) => @intFromEnum(Register.ymm0),\n            @intFromEnum(Register.xmm0) ... @intFromEnum(Register.xmm15) => @intFromEnum(Register.xmm0),\n            @intFromEnum(Register.mm0)  ... @intFromEnum(Register.mm7)   => @intFromEnum(Register.mm0),\n            @intFromEnum(Register.st0)  ... @intFromEnum(Register.st7)   => @intFromEnum(Register.st0),\n\n            @intFromEnum(Register.es)   ... @intFromEnum(Register.gs)    => @intFromEnum(Register.es),\n\n            else => unreachable,\n            // zig fmt: on\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "enc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lowEnc from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn lowEnc(reg: Register) u3 {\n        return @truncate(reg.enc());\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "lowEnc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toBitSize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn toBitSize(reg: Register, bit_size: u64) Register {\n        return switch (bit_size) {\n            8 => reg.to8(),\n            16 => reg.to16(),\n            32 => reg.to32(),\n            64 => reg.to64(),\n            128 => reg.to128(),\n            256 => reg.to256(),\n            else => unreachable,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "toBitSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to gpBase from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "fn gpBase(reg: Register) u7 {\n        assert(reg.class() == .general_purpose);\n        return switch (@intFromEnum(reg)) {\n            // zig fmt: off\n            @intFromEnum(Register.rax)  ... @intFromEnum(Register.r15)   => @intFromEnum(Register.rax),\n            @intFromEnum(Register.eax)  ... @intFromEnum(Register.r15d)  => @intFromEnum(Register.eax),\n            @intFromEnum(Register.ax)   ... @intFromEnum(Register.r15w)  => @intFromEnum(Register.ax),\n            @intFromEnum(Register.al)   ... @intFromEnum(Register.r15b)  => @intFromEnum(Register.al),\n            @intFromEnum(Register.ah)   ... @intFromEnum(Register.bh)    => @intFromEnum(Register.ah) - 4,\n            else => unreachable,\n            // zig fmt: on\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "gpBase",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to to64 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn to64(reg: Register) Register {\n        return @enumFromInt(@intFromEnum(reg) - reg.gpBase() + @intFromEnum(Register.rax));\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "to64",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to to32 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn to32(reg: Register) Register {\n        return @enumFromInt(@intFromEnum(reg) - reg.gpBase() + @intFromEnum(Register.eax));\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "to32",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to to16 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn to16(reg: Register) Register {\n        return @enumFromInt(@intFromEnum(reg) - reg.gpBase() + @intFromEnum(Register.ax));\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "to16",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to to8 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn to8(reg: Register) Register {\n        return @enumFromInt(@intFromEnum(reg) - reg.gpBase() + @intFromEnum(Register.al));\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "to8",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sseBase from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "fn sseBase(reg: Register) u7 {\n        assert(reg.class() == .sse);\n        return switch (@intFromEnum(reg)) {\n            @intFromEnum(Register.ymm0)...@intFromEnum(Register.ymm15) => @intFromEnum(Register.ymm0),\n            @intFromEnum(Register.xmm0)...@intFromEnum(Register.xmm15) => @intFromEnum(Register.xmm0),\n            else => unreachable,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "sseBase",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to to256 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn to256(reg: Register) Register {\n        return @enumFromInt(@intFromEnum(reg) - reg.sseBase() + @intFromEnum(Register.ymm0));\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "to256",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to to128 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn to128(reg: Register) Register {\n        return @enumFromInt(@intFromEnum(reg) - reg.sseBase() + @intFromEnum(Register.xmm0));\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "to128",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dwarfNum from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn dwarfNum(reg: Register) u6 {\n        return switch (reg.class()) {\n            .general_purpose => if (reg.isExtended())\n                reg.enc()\n            else\n                @as(u3, @truncate(@as(u24, 0o54673120) >> @as(u5, reg.enc()) * 3)),\n            .sse => 17 + @as(u6, reg.enc()),\n            .x87 => 33 + @as(u6, reg.enc()),\n            .mmx => 41 + @as(u6, reg.enc()),\n            .segment => 50 + @as(u6, reg.enc()),\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "dwarfNum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isNamed from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn isNamed(fi: FrameIndex) bool {\n        return @intFromEnum(fi) < named_count;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "isNamed",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to format from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn format(\n        fi: FrameIndex,\n        comptime fmt: []const u8,\n        options: std.fmt.FormatOptions,\n        writer: anytype,\n    ) @TypeOf(writer).Error!void {\n        try writer.writeAll(\"FrameIndex\");\n        if (fi.isNamed()) {\n            try writer.writeByte('.');\n            try writer.writeAll(@tagName(fi));\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "format",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to format from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn format(\n        sym: Symbol,\n        comptime fmt: []const u8,\n        options: std.fmt.FormatOptions,\n        writer: anytype,\n    ) @TypeOf(writer).Error!void {\n        try writer.writeAll(\"Symbol(\");\n        try std.fmt.formatType(sym.atom_index, fmt, options, writer, 0);\n        try writer.writeAll(\", \");\n        try std.fmt.formatType(sym.sym_index, fmt, options, writer, 0);\n        try writer.writeByte(')');\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "format",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to isExtended from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn isExtended(self: Base) bool {\n            return switch (self) {\n                .none, .frame, .reloc => false, // rsp, rbp, and rip are not extended\n                .reg => |reg| reg.isExtended(),\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "isExtended",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromSize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn fromSize(size: u32) Size {\n            return switch (size) {\n                1...1 => .byte,\n                2...2 => .word,\n                3...4 => .dword,\n                5...8 => .qword,\n                9...16 => .xword,\n                17...32 => .yword,\n                33...64 => .zword,\n                else => unreachable,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "fromSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromBitSize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn fromBitSize(bit_size: u64) Size {\n            return switch (bit_size) {\n                8 => .byte,\n                16 => .word,\n                32 => .dword,\n                64 => .qword,\n                80 => .tbyte,\n                128 => .xword,\n                256 => .yword,\n                512 => .zword,\n                else => unreachable,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "fromBitSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to bitSize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn bitSize(s: Size) u64 {\n            return switch (s) {\n                .none => 0,\n                .byte => 8,\n                .word => 16,\n                .dword => 32,\n                .qword => 64,\n                .tbyte => 80,\n                .xword => 128,\n                .yword => 256,\n                .zword => 512,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "bitSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to format from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn format(\n            s: Size,\n            comptime _: []const u8,\n            _: std.fmt.FormatOptions,\n            writer: anytype,\n        ) @TypeOf(writer).Error!void {\n            if (s == .none) return;\n            try writer.writeAll(@tagName(s));\n            try writer.writeAll(\" ptr\");\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "format",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to u from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn u(x: u64) Immediate {\n        return .{ .unsigned = x }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "u",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to s from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn s(x: i32) Immediate {\n        return .{ .signed = x }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "s",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to asSigned from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn asSigned(imm: Immediate, bit_size: u64) i64 {\n        return switch (imm) {\n            .signed => |x| switch (bit_size) {\n                1, 8 => @as(i8, @intCast(x)),\n                16 => @as(i16, @intCast(x)),\n                32, 64 => x,\n                else => unreachable,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "asSigned",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to asUnsigned from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub fn asUnsigned(imm: Immediate, bit_size: u64) u64 {\n        return switch (imm) {\n            .signed => |x| switch (bit_size) {\n                1, 8 => @as(u8, @bitCast(@as(i8, @intCast(x)))),\n                16 => @as(u16, @bitCast(@as(i16, @intCast(x)))),\n                32, 64 => @as(u32, @bitCast(x)),\n                else => unreachable,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "function",
      "name": "asUnsigned",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Symbol from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub const Symbol = struct {\n    /// Index of the containing atom.\n    atom_index: u32,\n    /// Index into the linker's symbol table.\n    sym_index: u32,\n\n    pub fn format(\n        sym: Symbol,\n        comptime fmt: []const u8,\n        options: std.fmt.FormatOptions,\n        writer: anytype,\n    ) @TypeOf(writer).Error!void {\n        try writer.writeAll(\"Symbol(\");\n        try std.fmt.formatType(sym.atom_index, fmt, options, writer, 0);\n        try writer.writeAll(\", \");\n        try std.fmt.formatType(sym.sym_index, fmt, options, writer, 0);\n        try writer.writeByte(')');\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "struct",
      "name": "Symbol",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Memory from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/bits.zig",
    "response": "pub const Memory = struct {\n    base: Base,\n    mod: Mod,\n\n    pub const Base = union(enum(u2)) {\n        none,\n        reg: Register,\n        frame: FrameIndex,\n        reloc: Symbol,\n\n        pub const Tag = @typeInfo(Base).Union.tag_type.?;\n\n        pub fn isExtended(self: Base) bool {\n            return switch (self) {\n                .none, .frame, .reloc => false, // rsp, rbp, and rip are not extended\n                .reg => |reg| reg.isExtended(),\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/bits.zig",
      "type": "struct",
      "name": "Memory",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to moffs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn moffs(reg: Register, offset: u64) Memory {\n            assert(reg.class() == .segment);\n            return .{ .moffs = .{ .seg = reg, .offset = offset }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "moffs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sib from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn sib(ptr_size: PtrSize, args: struct {\n            disp: i32 = 0,\n            base: Base = .none,\n            scale_index: ?ScaleIndex = null,\n        }) Memory {\n            if (args.scale_index) |si| assert(std.math.isPowerOfTwo(si.scale));\n            return .{ .sib = .{\n                .base = args.base,\n                .disp = args.disp,\n                .ptr_size = ptr_size,\n                .scale_index = if (args.scale_index) |si| si else ScaleIndex.none,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "sib",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rip from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn rip(ptr_size: PtrSize, disp: i32) Memory {\n            return .{ .rip = .{ .ptr_size = ptr_size, .disp = disp }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "rip",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isSegmentRegister from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn isSegmentRegister(mem: Memory) bool {\n            return switch (mem) {\n                .moffs => true,\n                .rip => false,\n                .sib => |s| switch (s.base) {\n                    .none, .frame, .reloc => false,\n                    .reg => |reg| reg.class() == .segment,\n                }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "isSegmentRegister",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to base from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn base(mem: Memory) Base {\n            return switch (mem) {\n                .moffs => |m| .{ .reg = m.seg }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "base",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to scaleIndex from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn scaleIndex(mem: Memory) ?ScaleIndex {\n            return switch (mem) {\n                .moffs, .rip => null,\n                .sib => |s| if (s.scale_index.scale > 0) s.scale_index else null,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "scaleIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to bitSize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn bitSize(mem: Memory) u64 {\n            return switch (mem) {\n                .rip => |r| r.ptr_size.bitSize(),\n                .sib => |s| s.ptr_size.bitSize(),\n                .moffs => 64,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "bitSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to bitSize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn bitSize(op: Operand) u64 {\n            return switch (op) {\n                .none => unreachable,\n                .reg => |reg| reg.bitSize(),\n                .mem => |mem| mem.bitSize(),\n                .imm => unreachable,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "bitSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isSegmentRegister from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn isSegmentRegister(op: Operand) bool {\n            return switch (op) {\n                .none => unreachable,\n                .reg => |reg| reg.class() == .segment,\n                .mem => |mem| mem.isSegmentRegister(),\n                .imm => unreachable,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "isSegmentRegister",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isBaseExtended from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn isBaseExtended(op: Operand) bool {\n            return switch (op) {\n                .none, .imm => false,\n                .reg => |reg| reg.isExtended(),\n                .mem => |mem| mem.base().isExtended(),\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "isBaseExtended",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isIndexExtended from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn isIndexExtended(op: Operand) bool {\n            return switch (op) {\n                .none, .reg, .imm => false,\n                .mem => |mem| if (mem.scaleIndex()) |si| si.index.isExtended() else false,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "isIndexExtended",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to format from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn format(\n            op: Operand,\n            comptime unused_format_string: []const u8,\n            options: std.fmt.FormatOptions,\n            writer: anytype,\n        ) !void {\n            _ = op;\n            _ = unused_format_string;\n            _ = options;\n            _ = writer;\n            @compileError(\"do not format Operand directly; use fmtPrint() instead\");\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "format",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmt from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn fmt(\n            ctx: FormatContext,\n            comptime unused_format_string: []const u8,\n            options: std.fmt.FormatOptions,\n            writer: anytype,\n        ) @TypeOf(writer).Error!void {\n            _ = unused_format_string;\n            _ = options;\n            const op = ctx.op;\n            const enc_op = ctx.enc_op;\n            switch (op) {\n                .none => {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "fmt",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmtPrint from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn fmtPrint(op: Operand, enc_op: Encoding.Op) std.fmt.Formatter(fmt) {\n            return .{ .data = .{ .op = op, .enc_op = enc_op }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "fmtPrint",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to new from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn new(prefix: Prefix, mnemonic: Mnemonic, ops: []const Operand) !Instruction {\n        const encoding = (try Encoding.findByMnemonic(prefix, mnemonic, ops)) orelse {\n            log.err(\"no encoding found for: {s}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "new",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to format from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn format(\n        inst: Instruction,\n        comptime unused_format_string: []const u8,\n        options: std.fmt.FormatOptions,\n        writer: anytype,\n    ) @TypeOf(writer).Error!void {\n        _ = unused_format_string;\n        _ = options;\n        if (inst.prefix != .none) try writer.print(\"{s}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "format",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to encode from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn encode(inst: Instruction, writer: anytype, comptime opts: Options) !void {\n        const encoder = Encoder(@TypeOf(writer), opts){ .writer = writer }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "encode",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to encodeOpcode from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn encodeOpcode(inst: Instruction, encoder: anytype) !void {\n        const opcode = inst.encoding.opcode();\n        const first = @intFromBool(inst.encoding.mandatoryPrefix() != null);\n        const final = opcode.len - 1;\n        for (opcode[first..final]) |byte| try encoder.opcode_1byte(byte);\n        switch (inst.encoding.data.op_en) {\n            .o, .oi => try encoder.opcode_withReg(opcode[final], inst.ops[0].reg.lowEnc()),\n            else => try encoder.opcode_1byte(opcode[final]),\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "encodeOpcode",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to encodeLegacyPrefixes from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn encodeLegacyPrefixes(inst: Instruction, encoder: anytype) !void {\n        const enc = inst.encoding;\n        const data = enc.data;\n        const op_en = data.op_en;\n\n        var legacy = LegacyPrefixes{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "encodeLegacyPrefixes",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to encodeRexPrefix from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn encodeRexPrefix(inst: Instruction, encoder: anytype) !void {\n        const op_en = inst.encoding.data.op_en;\n\n        var rex = Rex{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "encodeRexPrefix",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to encodeVexPrefix from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn encodeVexPrefix(inst: Instruction, encoder: anytype) !void {\n        const op_en = inst.encoding.data.op_en;\n        const opc = inst.encoding.opcode();\n        const mand_pre = inst.encoding.mandatoryPrefix();\n\n        var vex = Vex{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "encodeVexPrefix",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to encodeMandatoryPrefix from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn encodeMandatoryPrefix(inst: Instruction, encoder: anytype) !void {\n        const prefix = inst.encoding.mandatoryPrefix() orelse return;\n        try encoder.opcode_1byte(prefix);\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "encodeMandatoryPrefix",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to encodeMemory from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn encodeMemory(encoding: Encoding, mem: Memory, operand: Operand, encoder: anytype) !void {\n        const operand_enc = switch (operand) {\n            .reg => |reg| reg.lowEnc(),\n            .none => encoding.modRmExt(),\n            else => unreachable,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "encodeMemory",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to encodeImm from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn encodeImm(imm: Immediate, kind: Encoding.Op, encoder: anytype) !void {\n        const raw = imm.asUnsigned(kind.immBitSize());\n        switch (kind.immBitSize()) {\n            8 => try encoder.imm8(@as(u8, @intCast(raw))),\n            16 => try encoder.imm16(@as(u16, @intCast(raw))),\n            32 => try encoder.imm32(@as(u32, @intCast(raw))),\n            64 => try encoder.imm64(raw),\n            else => unreachable,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "encodeImm",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to setSegmentOverride from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn setSegmentOverride(self: *LegacyPrefixes, reg: Register) void {\n        assert(reg.class() == .segment);\n        switch (reg) {\n            .cs => self.prefix_2e = true,\n            .ss => self.prefix_36 = true,\n            .es => self.prefix_26 = true,\n            .fs => self.prefix_64 = true,\n            .gs => self.prefix_65 = true,\n            .ds => {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "setSegmentOverride",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to set16BitOverride from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn set16BitOverride(self: *LegacyPrefixes) void {\n        self.prefix_66 = true;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "set16BitOverride",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to Encoder from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn Encoder(comptime T: type, comptime opts: Options) type {\n    return struct {\n        writer: T,\n\n        const Self = @This();\n        pub const options = opts;\n\n        // --------\n        // Prefixes\n        // --------\n\n        /// Encodes legacy prefixes\n        pub fn legacyPrefixes(self: Self, prefixes: LegacyPrefixes) !void {\n            if (@as(u16, @bitCast(prefixes)) != 0) {\n                // Hopefully this path isn't taken very often, so we'll do it the slow way for now\n\n                // LOCK\n                if (prefixes.prefix_f0) try self.writer.writeByte(0xf0);\n                // REPNZ, REPNE, REP, Scalar Double-precision\n                if (prefixes.prefix_f2) try self.writer.writeByte(0xf2);\n                // REPZ, REPE, REP, Scalar Single-precision\n                if (prefixes.prefix_f3) try self.writer.writeByte(0xf3);\n\n                // CS segment override or Branch not taken\n                if (prefixes.prefix_2e) try self.writer.writeByte(0x2e);\n                // DS segment override\n                if (prefixes.prefix_36) try self.writer.writeByte(0x36);\n                // ES segment override\n                if (prefixes.prefix_26) try self.writer.writeByte(0x26);\n                // FS segment override\n                if (prefixes.prefix_64) try self.writer.writeByte(0x64);\n                // GS segment override\n                if (prefixes.prefix_65) try self.writer.writeByte(0x65);\n\n                // Branch taken\n                if (prefixes.prefix_3e) try self.writer.writeByte(0x3e);\n\n                // Operand size override\n                if (prefixes.prefix_66) try self.writer.writeByte(0x66);\n\n                // Address size override\n                if (prefixes.prefix_67) try self.writer.writeByte(0x67);\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "Encoder",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to prefix16BitMode from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn prefix16BitMode(self: Self) !void {\n            try self.writer.writeByte(0x66);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "prefix16BitMode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rex from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn rex(self: Self, fields: Rex) !void {\n            if (!fields.present and !fields.isSet()) return;\n\n            var byte: u8 = 0b0100_0000;\n\n            if (fields.w) byte |= 0b1000;\n            if (fields.r) byte |= 0b0100;\n            if (fields.x) byte |= 0b0010;\n            if (fields.b) byte |= 0b0001;\n\n            try self.writer.writeByte(byte);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "rex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to vex from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn vex(self: Self, fields: Vex) !void {\n            if (fields.is3Byte()) {\n                try self.writer.writeByte(0b1100_0100);\n\n                try self.writer.writeByte(\n                    @as(u8, ~@intFromBool(fields.r)) << 7 |\n                        @as(u8, ~@intFromBool(fields.x)) << 6 |\n                        @as(u8, ~@intFromBool(fields.b)) << 5 |\n                        @as(u8, @intFromEnum(fields.m)) << 0,\n                );\n\n                try self.writer.writeByte(\n                    @as(u8, @intFromBool(fields.w)) << 7 |\n                        @as(u8, ~fields.v.enc()) << 3 |\n                        @as(u8, @intFromBool(fields.l)) << 2 |\n                        @as(u8, @intFromEnum(fields.p)) << 0,\n                );\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "vex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to opcode_1byte from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn opcode_1byte(self: Self, opcode: u8) !void {\n            try self.writer.writeByte(opcode);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "opcode_1byte",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to opcode_2byte from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn opcode_2byte(self: Self, prefix: u8, opcode: u8) !void {\n            try self.writer.writeAll(&.{ prefix, opcode }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "opcode_2byte",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to opcode_3byte from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn opcode_3byte(self: Self, prefix_1: u8, prefix_2: u8, opcode: u8) !void {\n            try self.writer.writeAll(&.{ prefix_1, prefix_2, opcode }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "opcode_3byte",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to opcode_withReg from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn opcode_withReg(self: Self, opcode: u8, reg: u3) !void {\n            assert(opcode & 0b111 == 0);\n            try self.writer.writeByte(opcode | reg);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "opcode_withReg",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to modRm from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn modRm(self: Self, mod: u2, reg_or_opx: u3, rm: u3) !void {\n            try self.writer.writeByte(@as(u8, mod) << 6 | @as(u8, reg_or_opx) << 3 | rm);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "modRm",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to modRm_direct from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn modRm_direct(self: Self, reg_or_opx: u3, rm: u3) !void {\n            try self.modRm(0b11, reg_or_opx, rm);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "modRm_direct",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to modRm_indirectDisp0 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn modRm_indirectDisp0(self: Self, reg_or_opx: u3, rm: u3) !void {\n            assert(rm != 4 and rm != 5);\n            try self.modRm(0b00, reg_or_opx, rm);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "modRm_indirectDisp0",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to modRm_SIBDisp0 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn modRm_SIBDisp0(self: Self, reg_or_opx: u3) !void {\n            try self.modRm(0b00, reg_or_opx, 0b100);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "modRm_SIBDisp0",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to modRm_RIPDisp32 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn modRm_RIPDisp32(self: Self, reg_or_opx: u3) !void {\n            try self.modRm(0b00, reg_or_opx, 0b101);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "modRm_RIPDisp32",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to modRm_indirectDisp8 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn modRm_indirectDisp8(self: Self, reg_or_opx: u3, rm: u3) !void {\n            assert(rm != 4);\n            try self.modRm(0b01, reg_or_opx, rm);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "modRm_indirectDisp8",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to modRm_SIBDisp8 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn modRm_SIBDisp8(self: Self, reg_or_opx: u3) !void {\n            try self.modRm(0b01, reg_or_opx, 0b100);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "modRm_SIBDisp8",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to modRm_indirectDisp32 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn modRm_indirectDisp32(self: Self, reg_or_opx: u3, rm: u3) !void {\n            assert(rm != 4);\n            try self.modRm(0b10, reg_or_opx, rm);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "modRm_indirectDisp32",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to modRm_SIBDisp32 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn modRm_SIBDisp32(self: Self, reg_or_opx: u3) !void {\n            try self.modRm(0b10, reg_or_opx, 0b100);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "modRm_SIBDisp32",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sib from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn sib(self: Self, scale: u2, index: u3, base: u3) !void {\n            try self.writer.writeByte(@as(u8, scale) << 6 | @as(u8, index) << 3 | base);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "sib",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sib_scaleIndexBase from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn sib_scaleIndexBase(self: Self, scale: u2, index: u3, base: u3) !void {\n            assert(base != 5);\n\n            try self.sib(scale, index, base);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "sib_scaleIndexBase",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sib_scaleIndexDisp32 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn sib_scaleIndexDisp32(self: Self, scale: u2, index: u3) !void {\n            // scale is actually ignored\n            // index = 4 means no index if and only if we haven't extended the register\n            // TODO enforce this\n            // base = 5 means no base, if mod == 0.\n            try self.sib(scale, index, 5);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "sib_scaleIndexDisp32",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sib_base from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn sib_base(self: Self, base: u3) !void {\n            assert(base != 5);\n\n            // scale is actually ignored\n            // index = 4 means no index\n            try self.sib(0, 4, base);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "sib_base",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sib_disp32 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn sib_disp32(self: Self) !void {\n            // scale is actually ignored\n            // index = 4 means no index\n            // base = 5 means no base, if mod == 0.\n            try self.sib(0, 4, 5);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "sib_disp32",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sib_scaleIndexBaseDisp8 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn sib_scaleIndexBaseDisp8(self: Self, scale: u2, index: u3, base: u3) !void {\n            try self.sib(scale, index, base);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "sib_scaleIndexBaseDisp8",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sib_baseDisp8 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn sib_baseDisp8(self: Self, base: u3) !void {\n            // scale is ignored\n            // index = 4 means no index\n            try self.sib(0, 4, base);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "sib_baseDisp8",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sib_scaleIndexBaseDisp32 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn sib_scaleIndexBaseDisp32(self: Self, scale: u2, index: u3, base: u3) !void {\n            try self.sib(scale, index, base);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "sib_scaleIndexBaseDisp32",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sib_baseDisp32 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn sib_baseDisp32(self: Self, base: u3) !void {\n            // scale is ignored\n            // index = 4 means no index\n            try self.sib(0, 4, base);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "sib_baseDisp32",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to disp8 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn disp8(self: Self, disp: i8) !void {\n            try self.writer.writeByte(@as(u8, @bitCast(disp)));\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "disp8",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to disp32 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn disp32(self: Self, disp: i32) !void {\n            try self.writer.writeInt(i32, disp, .little);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "disp32",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to imm8 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn imm8(self: Self, imm: u8) !void {\n            try self.writer.writeByte(imm);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "imm8",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to imm16 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn imm16(self: Self, imm: u16) !void {\n            try self.writer.writeInt(u16, imm, .little);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "imm16",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to imm32 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn imm32(self: Self, imm: u32) !void {\n            try self.writer.writeInt(u32, imm, .little);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "imm32",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to imm64 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn imm64(self: Self, imm: u64) !void {\n            try self.writer.writeInt(u64, imm, .little);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "imm64",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isSet from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn isSet(rex: Rex) bool {\n        return rex.w or rex.r or rex.x or rex.b;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "isSet",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is3Byte from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn is3Byte(vex: Vex) bool {\n        return vex.w or vex.x or vex.b or vex.m != .@\"0f\";\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "is3Byte",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn next(it: *Tokenizer) !Token {\n            var result = Token{\n                .id = .eof,\n                .start = it.pos,\n                .end = it.pos,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to seekTo from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn seekTo(it: *Tokenizer, pos: usize) void {\n            it.pos = pos;\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "seekTo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn init(input: []const u8) Assembler {\n        return .{\n            .it = Tokenizer{ .input = input }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to assemble from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub fn assemble(as: *Assembler, writer: anytype) !void {\n        while (try as.next()) |parsed_inst| {\n            const inst = try Instruction.new(.none, parsed_inst.mnemonic, &parsed_inst.ops);\n            try inst.encode(writer);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "assemble",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn next(as: *Assembler) ParseError!?ParseResult {\n        try as.skip(2, .{ .space, .new_line }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to source from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn source(as: *Assembler, token: Tokenizer.Token) []const u8 {\n        return as.it.input[token.start..token.end];\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "source",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to peek from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn peek(as: *Assembler) Tokenizer.Error!Tokenizer.Token.Id {\n        const pos = as.it.pos;\n        const next_tok = try as.it.next();\n        const id = next_tok.id;\n        as.it.seekTo(pos);\n        return id;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "peek",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to expect from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn expect(as: *Assembler, id: Tokenizer.Token.Id) ParseError!Tokenizer.Token {\n        const next_tok_id = try as.peek();\n        if (next_tok_id == id) return as.it.next();\n        return error.UnexpectedToken;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "expect",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to skip from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn skip(as: *Assembler, comptime num: comptime_int, tok_ids: [num]Tokenizer.Token.Id) Tokenizer.Error!void {\n        outer: while (true) {\n            const pos = as.it.pos;\n            const next_tok = try as.it.next();\n            inline for (tok_ids) |tok_id| {\n                if (next_tok.id == tok_id) continue :outer;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "skip",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to mnemonicFromString from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn mnemonicFromString(bytes: []const u8) ?Instruction.Mnemonic {\n        const ti = @typeInfo(Instruction.Mnemonic).Enum;\n        inline for (ti.fields) |field| {\n            if (std.mem.eql(u8, bytes, field.name)) {\n                return @field(Instruction.Mnemonic, field.name);\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "mnemonicFromString",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseOperandRule from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn parseOperandRule(as: *Assembler, rule: anytype, ops: *[4]Instruction.Operand) ParseError!void {\n        inline for (rule, 0..) |cond, i| {\n            comptime assert(i < 4);\n            if (i > 0) {\n                _ = try as.expect(.comma);\n                try as.skip(1, .{.space}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "parseOperandRule",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to registerFromString from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn registerFromString(bytes: []const u8) ?Register {\n        const ti = @typeInfo(Register).Enum;\n        inline for (ti.fields) |field| {\n            if (std.mem.eql(u8, bytes, field.name)) {\n                return @field(Register, field.name);\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "registerFromString",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseMemory from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn parseMemory(as: *Assembler) ParseError!Instruction.Memory {\n        const ptr_size: ?Instruction.Memory.PtrSize = blk: {\n            const pos = as.it.pos;\n            const ptr_size = as.parsePtrSize() catch |err| switch (err) {\n                error.UnexpectedToken => {\n                    as.it.seekTo(pos);\n                    break :blk null;\n                }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "parseMemory",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseMemoryRule from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn parseMemoryRule(as: *Assembler, rule: anytype) ParseError!Instruction.MemoryParseResult {\n        var res: MemoryParseResult = .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "parseMemoryRule",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parsePtrSize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "fn parsePtrSize(as: *Assembler) ParseError!Instruction.Memory.PtrSize {\n        const size = try as.expect(.string);\n        try as.skip(1, .{.space}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "function",
      "name": "parsePtrSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Instruction from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub const Instruction = struct {\n    prefix: Prefix = .none,\n    encoding: Encoding,\n    ops: [4]Operand = .{.none}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "struct",
      "name": "Instruction",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ScaleIndex from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub const ScaleIndex = struct {\n            scale: u4,\n            index: Register,\n\n            const none = ScaleIndex{ .scale = 0, .index = undefined }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "struct",
      "name": "ScaleIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Sib from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub const Sib = struct {\n            ptr_size: PtrSize,\n            base: Base,\n            scale_index: ScaleIndex,\n            disp: i32,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "struct",
      "name": "Sib",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Rip from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub const Rip = struct {\n            ptr_size: PtrSize,\n            disp: i32,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "struct",
      "name": "Rip",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Moffs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub const Moffs = struct {\n            seg: Register,\n            offset: u64,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "struct",
      "name": "Moffs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FormatContext from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "const FormatContext = struct {\n            op: Operand,\n            enc_op: Encoding.Op,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "struct",
      "name": "FormatContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Options from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub const Options = struct { allow_frame_locs: bool = false, allow_symbols: bool = false }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "struct",
      "name": "Options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Rex from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub const Rex = struct {\n    w: bool = false,\n    r: bool = false,\n    x: bool = false,\n    b: bool = false,\n    present: bool = false,\n\n    pub fn isSet(rex: Rex) bool {\n        return rex.w or rex.r or rex.x or rex.b;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "struct",
      "name": "Rex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Vex from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "pub const Vex = struct {\n    w: bool = false,\n    r: bool = false,\n    x: bool = false,\n    b: bool = false,\n    l: bool = false,\n    p: enum(u2) {\n        none = 0b00,\n        @\"66\" = 0b01,\n        f3 = 0b10,\n        f2 = 0b11,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "struct",
      "name": "Vex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Assembler from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "const Assembler = struct {\n    it: Tokenizer,\n\n    const Tokenizer = struct {\n        input: []const u8,\n        pos: usize = 0,\n\n        const Error = error{InvalidToken}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "struct",
      "name": "Assembler",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Token from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "const Token = struct {\n            id: Id,\n            start: usize,\n            end: usize,\n\n            const Id = enum {\n                eof,\n\n                space,\n                new_line,\n\n                colon,\n                comma,\n                open_br,\n                close_br,\n                plus,\n                minus,\n                star,\n\n                string,\n                numeral,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "struct",
      "name": "Token",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ParseResult from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "const ParseResult = struct {\n        mnemonic: Instruction.Mnemonic,\n        ops: [4]Instruction.Operand,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "struct",
      "name": "ParseResult",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to MemoryParseResult from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "const MemoryParseResult = struct {\n        rip: bool = false,\n        base: ?Register = null,\n        scale_index: ?Instruction.Memory.ScaleIndex = null,\n        disp: ?i32 = null,\n        offset: ?u64 = null,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "struct",
      "name": "MemoryParseResult",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to leading from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "const leading: usize = if (mand_pre) |_| 1 else 0;",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "const",
      "name": "leading",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to imm from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "const imm: Immediate = if (is_neg) blk: {\n                        const imm = try std.fmt.parseInt(i32, as.source(imm_tok), 0);",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "const",
      "name": "imm",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr_size from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encoder.zig",
    "response": "const ptr_size: ?Instruction.Memory.PtrSize = blk: {\n            const pos = as.it.pos;",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encoder.zig",
      "type": "const",
      "name": "ptr_size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Entry from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/arch/x86_64/encodings.zig",
    "response": "pub const Entry = struct { Mnemonic, OpEn, []const Op, []const u8, modrm_ext, Mode, Feature }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/arch/x86_64/encodings.zig",
      "type": "struct",
      "name": "Entry",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to arch from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/lib.zig",
    "response": "pub const arch = struct {\n    pub const x86_64 = struct {\n        pub const abi = @import(\"arch/x86_64/abi.zig\");\n        pub const bits = @import(\"arch/x86_64/bits.zig\");\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/lib.zig",
      "type": "struct",
      "name": "arch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to RegisterManager from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn RegisterManager(\n    comptime Function: type,\n    comptime Register: type,\n    comptime Inst: type,\n    comptime tracked_registers: []const Register,\n) type {\n    // architectures which do not have a concept of registers should\n    // refrain from using RegisterManager\n    assert(tracked_registers.len > 0); // see note above\n\n    return struct {\n        /// Tracks the AIR instruction allocated to every register. If\n        /// no instruction is allocated to a register (i.e. the\n        /// register is free), the value in that slot is undefined.\n        ///\n        /// The key must be canonical register.\n        registers: TrackedRegisters = undefined,\n        /// Tracks which registers are free (in which case the\n        /// corresponding bit is set to 1)\n        free_registers: RegisterBitSet = RegisterBitSet.initFull(),\n        /// Tracks all registers allocated in the course of this\n        /// function\n        allocated_registers: RegisterBitSet = RegisterBitSet.initEmpty(),\n        /// Tracks registers which are locked from being allocated\n        locked_registers: RegisterBitSet = RegisterBitSet.initEmpty(),\n\n        const Self = @This();\n\n        pub const TrackedRegisters = [tracked_registers.len]Inst;\n        pub const TrackedIndex = std.math.IntFittingRange(0, tracked_registers.len - 1);\n        pub const RegisterBitSet = StaticBitSet(tracked_registers.len);\n\n        fn getFunction(self: *Self) *Function {\n            return @fieldParentPtr(\"register_manager\", self);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "RegisterManager",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to excludeRegister from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "fn excludeRegister(reg: Register, register_class: RegisterBitSet) bool {\n            const index = indexOfRegIntoTracked(reg) orelse return true;\n            return !register_class.isSet(index);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "excludeRegister",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to markRegIndexAllocated from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "fn markRegIndexAllocated(self: *Self, tracked_index: TrackedIndex) void {\n            self.allocated_registers.set(tracked_index);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "markRegIndexAllocated",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to markRegAllocated from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "fn markRegAllocated(self: *Self, reg: Register) void {\n            self.markRegIndexAllocated(indexOfRegIntoTracked(reg) orelse return);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "markRegAllocated",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to markRegIndexUsed from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "fn markRegIndexUsed(self: *Self, tracked_index: TrackedIndex) void {\n            self.free_registers.unset(tracked_index);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "markRegIndexUsed",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to markRegUsed from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "fn markRegUsed(self: *Self, reg: Register) void {\n            self.markRegIndexUsed(indexOfRegIntoTracked(reg) orelse return);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "markRegUsed",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to markRegIndexFree from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "fn markRegIndexFree(self: *Self, tracked_index: TrackedIndex) void {\n            self.free_registers.set(tracked_index);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "markRegIndexFree",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to markRegFree from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "fn markRegFree(self: *Self, reg: Register) void {\n            self.markRegIndexFree(indexOfRegIntoTracked(reg) orelse return);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "markRegFree",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to indexOfReg from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn indexOfReg(\n            comptime set: []const Register,\n            reg: Register,\n        ) ?std.math.IntFittingRange(0, set.len - 1) {\n            const Id = @TypeOf(reg.id());\n            comptime var min_id: Id = std.math.maxInt(Id);\n            comptime var max_id: Id = std.math.minInt(Id);\n            inline for (set) |elem| {\n                const elem_id = comptime elem.id();\n                min_id = @min(elem_id, min_id);\n                max_id = @max(elem_id, max_id);\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "indexOfReg",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to indexOfRegIntoTracked from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn indexOfRegIntoTracked(reg: Register) ?TrackedIndex {\n            return indexOfReg(tracked_registers, reg);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "indexOfRegIntoTracked",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to regAtTrackedIndex from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn regAtTrackedIndex(tracked_index: TrackedIndex) Register {\n            return tracked_registers[tracked_index];\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "regAtTrackedIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isRegIndexFree from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn isRegIndexFree(self: Self, tracked_index: TrackedIndex) bool {\n            return self.free_registers.isSet(tracked_index);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "isRegIndexFree",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isRegFree from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn isRegFree(self: Self, reg: Register) bool {\n            return self.isRegIndexFree(indexOfRegIntoTracked(reg) orelse return true);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "isRegFree",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isRegAllocated from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn isRegAllocated(self: Self, reg: Register) bool {\n            const index = indexOfRegIntoTracked(reg) orelse return false;\n            return self.allocated_registers.isSet(index);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "isRegAllocated",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isRegIndexLocked from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "fn isRegIndexLocked(self: Self, tracked_index: TrackedIndex) bool {\n            return self.locked_registers.isSet(tracked_index);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "isRegIndexLocked",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isRegLocked from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn isRegLocked(self: Self, reg: Register) bool {\n            return self.isRegIndexLocked(indexOfRegIntoTracked(reg) orelse return false);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "isRegLocked",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lockRegIndex from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn lockRegIndex(self: *Self, tracked_index: TrackedIndex) ?RegisterLock {\n            log.debug(\"locking {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "lockRegIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lockReg from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn lockReg(self: *Self, reg: Register) ?RegisterLock {\n            return self.lockRegIndex(indexOfRegIntoTracked(reg) orelse return null);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "lockReg",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lockRegIndexAssumeUnused from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn lockRegIndexAssumeUnused(self: *Self, tracked_index: TrackedIndex) RegisterLock {\n            log.debug(\"locking asserting free {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "lockRegIndexAssumeUnused",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lockRegAssumeUnused from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn lockRegAssumeUnused(self: *Self, reg: Register) RegisterLock {\n            return self.lockRegIndexAssumeUnused(indexOfRegIntoTracked(reg) orelse unreachable);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "lockRegAssumeUnused",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lockRegs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn lockRegs(\n            self: *Self,\n            comptime count: comptime_int,\n            regs: [count]Register,\n        ) [count]?RegisterLock {\n            var results: [count]?RegisterLock = undefined;\n            for (&results, regs) |*result, reg| result.* = self.lockReg(reg);\n            return results;\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "lockRegs",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to lockRegsAssumeUnused from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn lockRegsAssumeUnused(\n            self: *Self,\n            comptime count: comptime_int,\n            regs: [count]Register,\n        ) [count]RegisterLock {\n            var results: [count]RegisterLock = undefined;\n            for (&results, regs) |*result, reg| result.* = self.lockRegAssumeUnused(reg);\n            return results;\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "lockRegsAssumeUnused",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to unlockReg from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn unlockReg(self: *Self, lock: RegisterLock) void {\n            log.debug(\"unlocking {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "unlockReg",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lockedRegsExist from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn lockedRegsExist(self: Self) bool {\n            return self.locked_registers.count() > 0;\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "lockedRegsExist",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tryAllocRegs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn tryAllocRegs(\n            self: *Self,\n            comptime count: comptime_int,\n            insts: [count]?Inst,\n            register_class: RegisterBitSet,\n        ) ?[count]Register {\n            comptime assert(count > 0 and count <= tracked_registers.len);\n\n            var free_and_not_locked_registers = self.free_registers;\n            free_and_not_locked_registers.setIntersection(register_class);\n\n            var unlocked_registers = self.locked_registers;\n            unlocked_registers.toggleAll();\n\n            free_and_not_locked_registers.setIntersection(unlocked_registers);\n\n            if (free_and_not_locked_registers.count() < count) return null;\n\n            var regs: [count]Register = undefined;\n            var i: usize = 0;\n            for (tracked_registers) |reg| {\n                if (i >= count) break;\n                if (excludeRegister(reg, register_class)) continue;\n                if (self.isRegLocked(reg)) continue;\n                if (!self.isRegFree(reg)) continue;\n\n                regs[i] = reg;\n                i += 1;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "tryAllocRegs",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to tryAllocReg from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn tryAllocReg(self: *Self, inst: ?Inst, register_class: RegisterBitSet) ?Register {\n            return if (tryAllocRegs(self, 1, .{inst}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "tryAllocReg",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to allocRegs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn allocRegs(\n            self: *Self,\n            comptime count: comptime_int,\n            insts: [count]?Inst,\n            register_class: RegisterBitSet,\n        ) AllocateRegistersError![count]Register {\n            comptime assert(count > 0 and count <= tracked_registers.len);\n\n            var locked_registers = self.locked_registers;\n            locked_registers.setIntersection(register_class);\n\n            if (count > register_class.count() - locked_registers.count()) return error.OutOfRegisters;\n\n            const result = self.tryAllocRegs(count, insts, register_class) orelse blk: {\n                // We'll take over the first count registers. Spill\n                // the instructions that were previously there to a\n                // stack allocations.\n                var regs: [count]Register = undefined;\n                var i: usize = 0;\n                for (tracked_registers) |reg| {\n                    if (i >= count) break;\n                    if (excludeRegister(reg, register_class)) break;\n                    if (self.isRegLocked(reg)) continue;\n\n                    log.debug(\"allocReg {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "allocRegs",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to allocReg from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn allocReg(\n            self: *Self,\n            inst: ?Inst,\n            register_class: RegisterBitSet,\n        ) AllocateRegistersError!Register {\n            return (try self.allocRegs(1, .{inst}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "allocReg",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getRegIndex from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "fn getRegIndex(\n            self: *Self,\n            tracked_index: TrackedIndex,\n            inst: ?Inst,\n        ) AllocateRegistersError!void {\n            log.debug(\"getReg {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "getRegIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getReg from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn getReg(self: *Self, reg: Register, inst: ?Inst) AllocateRegistersError!void {\n            return self.getRegIndex(indexOfRegIntoTracked(reg) orelse return, inst);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "getReg",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getKnownReg from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn getKnownReg(\n            self: *Self,\n            comptime reg: Register,\n            inst: ?Inst,\n        ) AllocateRegistersError!void {\n            return self.getRegIndex((comptime indexOfRegIntoTracked(reg)) orelse return, inst);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "getKnownReg",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getRegIndexAssumeFree from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "fn getRegIndexAssumeFree(\n            self: *Self,\n            tracked_index: TrackedIndex,\n            inst: ?Inst,\n        ) void {\n            log.debug(\"getRegAssumeFree {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "getRegIndexAssumeFree",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getRegAssumeFree from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn getRegAssumeFree(self: *Self, reg: Register, inst: ?Inst) void {\n            self.getRegIndexAssumeFree(indexOfRegIntoTracked(reg) orelse return, inst);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "getRegAssumeFree",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to freeRegIndex from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "fn freeRegIndex(self: *Self, tracked_index: TrackedIndex) void {\n            log.debug(\"freeing register {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "freeRegIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to freeReg from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub fn freeReg(self: *Self, reg: Register) void {\n            self.freeRegIndex(indexOfRegIntoTracked(reg) orelse return);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "function",
      "name": "freeReg",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to RegisterLock from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: deps/zig/register_manager.zig",
    "response": "pub const RegisterLock = struct { tracked_index: TrackedIndex }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "deps/zig/register_manager.zig",
      "type": "struct",
      "name": "RegisterLock",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toSyntax from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn toSyntax(kind: Kind) Syntax {\n        return switch (kind) {\n            .c23 => .c23,\n            .declspec => .declspec,\n            .gnu => .gnu,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "toSyntax",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to initSlice from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn initSlice(slice: []const Attribute) Iterator {\n        return .{ .source = null, .slice = slice, .index = 0 }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "initSlice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to initType from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn initType(qt: QualType, comp: *const Compilation) Iterator {\n        return .{ .source = .{ .qt = qt, .comp = comp }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "initType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn next(self: *Iterator) ?struct { Attribute, usize }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to requiredArgCount from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn requiredArgCount(attr: Tag) u32 {\n    switch (attr) {\n        inline else => |tag| {\n            comptime var needed = 0;\n            comptime {\n                const fields = @typeInfo(@field(attributes, @tagName(tag))).@\"struct\".fields;\n                for (fields) |arg_field| {\n                    if (!mem.eql(u8, arg_field.name, \"__name_tok\") and @typeInfo(arg_field.type) != .optional) needed += 1;\n                }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "requiredArgCount",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to maxArgCount from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn maxArgCount(attr: Tag) u32 {\n    switch (attr) {\n        inline else => |tag| {\n            comptime var max = 0;\n            comptime {\n                const fields = @typeInfo(@field(attributes, @tagName(tag))).@\"struct\".fields;\n                for (fields) |arg_field| {\n                    if (!mem.eql(u8, arg_field.name, \"__name_tok\")) max += 1;\n                }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "maxArgCount",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to UnwrapOptional from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "fn UnwrapOptional(comptime T: type) type {\n    return switch (@typeInfo(T)) {\n        .optional => |optional| optional.child,\n        else => T,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "UnwrapOptional",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to quoteChar from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "fn quoteChar(attr: Tag) []const u8 {\n        switch (attr) {\n            .calling_convention => unreachable,\n            inline else => |tag| {\n                const fields = @typeInfo(@field(attributes, @tagName(tag))).@\"struct\".fields;\n\n                if (fields.len == 0) unreachable;\n                const Unwrapped = UnwrapOptional(fields[0].type);\n                if (@typeInfo(Unwrapped) != .@\"enum\") unreachable;\n\n                return if (Unwrapped.opts.enum_kind == .identifier) \"'\" else \"\\\"\";\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "quoteChar",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to choices from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn choices(attr: Tag) []const u8 {\n        switch (attr) {\n            .calling_convention => unreachable,\n            inline else => |tag| {\n                const fields = @typeInfo(@field(attributes, @tagName(tag))).@\"struct\".fields;\n\n                if (fields.len == 0) unreachable;\n                const Unwrapped = UnwrapOptional(fields[0].type);\n                if (@typeInfo(Unwrapped) != .@\"enum\") unreachable;\n\n                const enum_fields = @typeInfo(Unwrapped).@\"enum\".fields;\n                const quote = comptime quoteChar(@enumFromInt(@intFromEnum(tag)));\n                comptime var values: []const u8 = quote ++ enum_fields[0].name ++ quote;\n                inline for (enum_fields[1..]) |enum_field| {\n                    values = values ++ \", \";\n                    values = values ++ quote ++ enum_field.name ++ quote;\n                }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "choices",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to wantsIdentEnum from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn wantsIdentEnum(attr: Tag) bool {\n    switch (attr) {\n        .calling_convention => return false,\n        inline else => |tag| {\n            const fields = @typeInfo(@field(attributes, @tagName(tag))).@\"struct\".fields;\n\n            if (fields.len == 0) return false;\n            const Unwrapped = UnwrapOptional(fields[0].type);\n            if (@typeInfo(Unwrapped) != .@\"enum\") return false;\n\n            return Unwrapped.opts.enum_kind == .identifier;\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "wantsIdentEnum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to diagnoseIdent from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn diagnoseIdent(attr: Tag, arguments: *Arguments, ident: TokenIndex, p: *Parser) !bool {\n    switch (attr) {\n        inline else => |tag| {\n            const fields = @typeInfo(@field(attributes, @tagName(tag))).@\"struct\".fields;\n            if (fields.len == 0) unreachable;\n            const Unwrapped = UnwrapOptional(fields[0].type);\n            if (@typeInfo(Unwrapped) != .@\"enum\") unreachable;\n            if (std.meta.stringToEnum(Unwrapped, normalize(p.tokSlice(ident)))) |enum_val| {\n                @field(@field(arguments, @tagName(tag)), fields[0].name) = enum_val;\n                return false;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "diagnoseIdent",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to wantsAlignment from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn wantsAlignment(attr: Tag, idx: usize) bool {\n    switch (attr) {\n        inline else => |tag| {\n            const fields = @typeInfo(@field(attributes, @tagName(tag))).@\"struct\".fields;\n            if (fields.len == 0) return false;\n\n            return switch (idx) {\n                inline 0...fields.len - 1 => |i| UnwrapOptional(fields[i].type) == Alignment,\n                else => false,\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "wantsAlignment",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to diagnoseAlignment from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn diagnoseAlignment(attr: Tag, arguments: *Arguments, arg_idx: u32, res: Parser.Result, arg_start: TokenIndex, p: *Parser) !bool {\n    switch (attr) {\n        inline else => |tag| {\n            const arg_fields = @typeInfo(@field(attributes, @tagName(tag))).@\"struct\".fields;\n            if (arg_fields.len == 0) unreachable;\n\n            switch (arg_idx) {\n                inline 0...arg_fields.len - 1 => |arg_i| {\n                    if (UnwrapOptional(arg_fields[arg_i].type) != Alignment) unreachable;\n\n                    if (!res.val.is(.int, p.comp)) {\n                        try p.err(arg_start, .alignas_unavailable, .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "diagnoseAlignment",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to diagnoseField from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "fn diagnoseField(\n    comptime decl: ZigType.Declaration,\n    comptime field: ZigType.StructField,\n    comptime Wanted: type,\n    arguments: *Arguments,\n    res: Parser.Result,\n    arg_start: TokenIndex,\n    node: Tree.Node,\n    p: *Parser,\n) !bool {\n    const string = \"a string\";\n    const identifier = \"an identifier\";\n    const int = \"an integer constant\";\n    const alignment = \"an integer constant\";\n    const nullptr_t = \"nullptr\";\n    const float = \"a floating point number\";\n    const complex_float = \"a complex floating point number\";\n    const expression = \"an expression\";\n\n    const expected: []const u8 = switch (Wanted) {\n        Value => string,\n        Identifier => identifier,\n        u32 => int,\n        Alignment => alignment,\n        CallingConvention => identifier,\n        else => switch (@typeInfo(Wanted)) {\n            .@\"enum\" => if (Wanted.opts.enum_kind == .string) string else identifier,\n            else => unreachable,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "diagnoseField",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to diagnose from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn diagnose(attr: Tag, arguments: *Arguments, arg_idx: u32, res: Parser.Result, arg_start: TokenIndex, node: Tree.Node, p: *Parser) !bool {\n    switch (attr) {\n        inline else => |tag| {\n            const decl = @typeInfo(attributes).@\"struct\".decls[@intFromEnum(tag)];\n            const max_arg_count = comptime maxArgCount(tag);\n            if (arg_idx >= max_arg_count) {\n                try p.err(arg_start, .attribute_too_many_args, .{ @tagName(attr), max_arg_count }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "diagnose",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to ArgumentsForTag from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn ArgumentsForTag(comptime tag: Tag) type {\n    const decl = @typeInfo(attributes).@\"struct\".decls[@intFromEnum(tag)];\n    return @field(attributes, decl.name);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "ArgumentsForTag",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to initArguments from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn initArguments(tag: Tag, name_tok: TokenIndex) Arguments {\n    switch (tag) {\n        inline else => |arg_tag| {\n            const union_element = @field(attributes, @tagName(arg_tag));\n            const init = std.mem.zeroInit(union_element, .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "initArguments",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromString from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn fromString(kind: Kind, namespace: ?[]const u8, name: []const u8) ?Tag {\n    const Properties = struct {\n        tag: Tag,\n        gnu: bool = false,\n        declspec: bool = false,\n        c23: bool = false,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "fromString",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to normalize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn normalize(name: []const u8) []const u8 {\n    if (name.len >= 4 and mem.startsWith(u8, name, \"__\") and mem.endsWith(u8, name, \"__\")) {\n        return name[2 .. name.len - 2];\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "normalize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ignoredAttrErr from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "fn ignoredAttrErr(p: *Parser, tok: TokenIndex, attr: Attribute.Tag, context: []const u8) !void {\n    try p.err(tok, .ignored_attribute, .{ @tagName(attr), context }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "ignoredAttrErr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applyVariableAttributes from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn applyVariableAttributes(p: *Parser, qt: QualType, attr_buf_start: usize, diagnostic: ?Parser.Diagnostic) !QualType {\n    const gpa = p.comp.gpa;\n    const attrs = p.attr_buf.items(.attr)[attr_buf_start..];\n    const toks = p.attr_buf.items(.tok)[attr_buf_start..];\n    p.attr_application_buf.items.len = 0;\n    var base_qt = qt;\n    var common = false;\n    var nocommon = false;\n    for (attrs, toks) |attr, tok| switch (attr.tag) {\n        // zig fmt: off\n        .alias, .may_alias, .deprecated, .unavailable, .unused, .warn_if_not_aligned, .weak, .used,\n        .noinit, .retain, .persistent, .section, .mode, .asm_label, .nullability, .unaligned, .selectany, .internal_linkage,\n         => try p.attr_application_buf.append(gpa, attr),\n        // zig fmt: on\n        .common => if (nocommon) {\n            try p.err(tok, .ignore_common, .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "applyVariableAttributes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applyFieldAttributes from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn applyFieldAttributes(p: *Parser, field_qt: *QualType, attr_buf_start: usize) ![]const Attribute {\n    const attrs = p.attr_buf.items(.attr)[attr_buf_start..];\n    const toks = p.attr_buf.items(.tok)[attr_buf_start..];\n    p.attr_application_buf.items.len = 0;\n    for (attrs, toks) |attr, tok| switch (attr.tag) {\n        // zig fmt: off\n        .@\"packed\", .may_alias, .deprecated, .unavailable, .unused, .warn_if_not_aligned,\n        .mode, .warn_unused_result, .nodiscard, .nullability, .unaligned,\n        => try p.attr_application_buf.append(p.comp.gpa, attr),\n        // zig fmt: on\n        .vector_size => try attr.applyVectorSize(p, tok, field_qt),\n        .aligned => try attr.applyAligned(p, field_qt.*, null),\n        .calling_convention => try applyCallingConvention(attr, p, tok, field_qt.*),\n        else => try ignoredAttrErr(p, tok, attr.tag, \"fields\"),\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "applyFieldAttributes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applyTypeAttributes from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn applyTypeAttributes(p: *Parser, qt: QualType, attr_buf_start: usize, diagnostic: ?Parser.Diagnostic) !QualType {\n    const gpa = p.comp.gpa;\n    const attrs = p.attr_buf.items(.attr)[attr_buf_start..];\n    const toks = p.attr_buf.items(.tok)[attr_buf_start..];\n    p.attr_application_buf.items.len = 0;\n    var base_qt = qt;\n    for (attrs, toks) |attr, tok| switch (attr.tag) {\n        // zig fmt: off\n        .@\"packed\", .may_alias, .deprecated, .unavailable, .unused, .warn_if_not_aligned, .mode, .nullability, .unaligned,\n         => try p.attr_application_buf.append(gpa, attr),\n        // zig fmt: on\n        .transparent_union => try attr.applyTransparentUnion(p, tok, base_qt),\n        .vector_size => try attr.applyVectorSize(p, tok, &base_qt),\n        .aligned => try attr.applyAligned(p, base_qt, diagnostic),\n        .designated_init => if (base_qt.is(p.comp, .@\"struct\")) {\n            try p.attr_application_buf.append(gpa, attr);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "applyTypeAttributes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applyFunctionAttributes from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn applyFunctionAttributes(p: *Parser, qt: QualType, attr_buf_start: usize) !QualType {\n    const gpa = p.comp.gpa;\n    const attrs = p.attr_buf.items(.attr)[attr_buf_start..];\n    const toks = p.attr_buf.items(.tok)[attr_buf_start..];\n    p.attr_application_buf.items.len = 0;\n    var base_qt = qt;\n    var hot = false;\n    var cold = false;\n    var @\"noinline\" = false;\n    var always_inline = false;\n    for (attrs, toks) |attr, tok| switch (attr.tag) {\n        // zig fmt: off\n        .noreturn, .unused, .used, .warning, .deprecated, .unavailable, .weak, .pure, .leaf,\n        .@\"const\", .warn_unused_result, .section, .returns_nonnull, .returns_twice, .@\"error\",\n        .externally_visible, .retain, .flatten, .gnu_inline, .alias, .asm_label, .nodiscard,\n        .reproducible, .unsequenced, .nothrow, .nullability, .unaligned, .internal_linkage,\n         => try p.attr_application_buf.append(gpa, attr),\n        // zig fmt: on\n        .hot => if (cold) {\n            try p.err(tok, .ignore_hot, .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "applyFunctionAttributes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applyLabelAttributes from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn applyLabelAttributes(p: *Parser, attr_buf_start: usize) !QualType {\n    const gpa = p.comp.gpa;\n    const attrs = p.attr_buf.items(.attr)[attr_buf_start..];\n    const toks = p.attr_buf.items(.tok)[attr_buf_start..];\n    p.attr_application_buf.items.len = 0;\n    var hot = false;\n    var cold = false;\n    for (attrs, toks) |attr, tok| switch (attr.tag) {\n        .unused => try p.attr_application_buf.append(gpa, attr),\n        .hot => if (cold) {\n            try p.err(tok, .ignore_hot, .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "applyLabelAttributes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applyStatementAttributes from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn applyStatementAttributes(p: *Parser, expr_start: TokenIndex, attr_buf_start: usize) !QualType {\n    const attrs = p.attr_buf.items(.attr)[attr_buf_start..];\n    const toks = p.attr_buf.items(.tok)[attr_buf_start..];\n    p.attr_application_buf.items.len = 0;\n    for (attrs, toks) |attr, tok| switch (attr.tag) {\n        .fallthrough => {\n            for (p.tok_ids[p.tok_i..]) |tok_id| {\n                switch (tok_id) {\n                    .keyword_case, .keyword_default, .eof => {\n                        try p.attr_application_buf.append(p.comp.gpa, attr);\n                        break;\n                    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "applyStatementAttributes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applyEnumeratorAttributes from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub fn applyEnumeratorAttributes(p: *Parser, qt: QualType, attr_buf_start: usize) !QualType {\n    const attrs = p.attr_buf.items(.attr)[attr_buf_start..];\n    const toks = p.attr_buf.items(.tok)[attr_buf_start..];\n    p.attr_application_buf.items.len = 0;\n    for (attrs, toks) |attr, tok| switch (attr.tag) {\n        .deprecated, .unavailable => try p.attr_application_buf.append(p.comp.gpa, attr),\n        else => try ignoredAttrErr(p, tok, attr.tag, \"enums\"),\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "applyEnumeratorAttributes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applyAligned from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "fn applyAligned(attr: Attribute, p: *Parser, qt: QualType, diagnostic: ?Parser.Diagnostic) !void {\n    if (attr.args.aligned.alignment) |alignment| alignas: {\n        if (attr.syntax != .keyword) break :alignas;\n\n        const align_tok = attr.args.aligned.__name_tok;\n        if (diagnostic) |d| try p.err(align_tok, d, .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "applyAligned",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applyTransparentUnion from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "fn applyTransparentUnion(attr: Attribute, p: *Parser, tok: TokenIndex, qt: QualType) !void {\n    const union_ty = qt.get(p.comp, .@\"union\") orelse {\n        return p.err(tok, .transparent_union_wrong_type, .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "applyTransparentUnion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applyVectorSize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "fn applyVectorSize(attr: Attribute, p: *Parser, tok: TokenIndex, qt: *QualType) !void {\n    if (qt.isInvalid()) return;\n    const scalar_kind = qt.scalarKind(p.comp);\n    if (scalar_kind != .int and scalar_kind != .float) {\n        if (qt.get(p.comp, .@\"enum\")) |enum_ty| {\n            if (p.comp.langopts.emulate == .clang and enum_ty.incomplete) {\n                return; // Clang silently ignores vector_size on incomplete enums.\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "applyVectorSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applyFormat from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "fn applyFormat(attr: Attribute, p: *Parser, qt: QualType) !void {\n    // TODO validate\n    _ = qt;\n    try p.attr_application_buf.append(p.comp.gpa, attr);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "applyFormat",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applyCallingConvention from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "fn applyCallingConvention(attr: Attribute, p: *Parser, tok: TokenIndex, qt: QualType) !void {\n    if (!qt.is(p.comp, .func)) {\n        return p.err(tok, .callconv_non_func, .{ p.tok_ids[tok].symbol(), qt }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "applyCallingConvention",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applySelected from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "fn applySelected(qt: QualType, p: *Parser) !QualType {\n    if (p.attr_application_buf.items.len == 0) return qt;\n    if (qt.isInvalid()) return qt;\n    return (try p.comp.type_store.put(p.comp.gpa, .{ .attributed = .{\n        .base = qt,\n        .attributes = p.attr_application_buf.items,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "function",
      "name": "applySelected",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Iterator from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const Iterator = struct {\n    source: ?struct {\n        qt: QualType,\n        comp: *const Compilation,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "Iterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Formatting from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const Formatting = struct {\n    /// The quote char (single or double) to use when printing identifiers/strings corresponding\n    /// to the enum in the first field of the `attr`. Identifier enums use single quotes, string enums\n    /// use double quotes\n    fn quoteChar(attr: Tag) []const u8 {\n        switch (attr) {\n            .calling_convention => unreachable,\n            inline else => |tag| {\n                const fields = @typeInfo(@field(attributes, @tagName(tag))).@\"struct\".fields;\n\n                if (fields.len == 0) unreachable;\n                const Unwrapped = UnwrapOptional(fields[0].type);\n                if (@typeInfo(Unwrapped) != .@\"enum\") unreachable;\n\n                return if (Unwrapped.opts.enum_kind == .identifier) \"'\" else \"\\\"\";\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "Formatting",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Alignment from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const Alignment = struct {\n    node: Tree.Node.OptIndex = .null,\n    requested: u32,\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "Alignment",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Identifier from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const Identifier = struct {\n    tok: TokenIndex = 0,\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "Identifier",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to attributes from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "const attributes = struct {\n    pub const access = struct {\n        access_mode: enum {\n            read_only,\n            read_write,\n            write_only,\n            none,\n\n            const opts = struct {\n                const enum_kind = .identifier;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "attributes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to alias from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const alias = struct {\n        alias: Value,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "alias",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to aligned from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const aligned = struct {\n        alignment: ?Alignment = null,\n        __name_tok: TokenIndex,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "aligned",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to alloc_align from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const alloc_align = struct {\n        position: u32,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "alloc_align",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to alloc_size from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const alloc_size = struct {\n        position_1: u32,\n        position_2: ?u32 = null,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "alloc_size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to allocate from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const allocate = struct {\n        segname: Value,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "allocate",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to allocator from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const allocator = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "allocator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to always_inline from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const always_inline = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "always_inline",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to appdomain from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const appdomain = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "appdomain",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to artificial from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const artificial = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "artificial",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to assume_aligned from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const assume_aligned = struct {\n        alignment: Alignment,\n        offset: ?u32 = null,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "assume_aligned",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to cleanup from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const cleanup = struct {\n        function: Identifier,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "cleanup",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to code_seg from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const code_seg = struct {\n        segname: Value,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "code_seg",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to constructor from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const constructor = struct {\n        priority: ?u32 = null,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "constructor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to copy from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const copy = struct {\n        function: Identifier,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "copy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to deprecated from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const deprecated = struct {\n        msg: ?Value = null,\n        __name_tok: TokenIndex,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "deprecated",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to designated_init from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const designated_init = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "designated_init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to destructor from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const destructor = struct {\n        priority: ?u32 = null,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "destructor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to dllexport from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const dllexport = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "dllexport",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to dllimport from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const dllimport = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "dllimport",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to externally_visible from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const externally_visible = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "externally_visible",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to fallthrough from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const fallthrough = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "fallthrough",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to format from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const format = struct {\n        archetype: enum {\n            printf,\n            scanf,\n            strftime,\n            strfmon,\n\n            const opts = struct {\n                const enum_kind = .identifier;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "format",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to format_arg from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const format_arg = struct {\n        string_index: u32,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "format_arg",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to gnu_inline from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const gnu_inline = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "gnu_inline",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ifunc from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const ifunc = struct {\n        resolver: Value,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "ifunc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to interrupt from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const interrupt = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "interrupt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to interrupt_handler from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const interrupt_handler = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "interrupt_handler",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to jitintrinsic from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const jitintrinsic = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "jitintrinsic",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to may_alias from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const may_alias = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "may_alias",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to mode from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const mode = struct {\n        mode: enum {\n            // zig fmt: off\n                byte,  word,  pointer,\n                BI,    QI,    HI,\n                PSI,   SI,    PDI,\n                DI,    TI,    OI,\n                XI,    QF,    HF,\n                TQF,   SF,    DF,\n                XF,    SD,    DD,\n                TD,    TF,    QQ,\n                HQ,    SQ,    DQ,\n                TQ,    UQQ,   UHQ,\n                USQ,   UDQ,   UTQ,\n                HA,    SA,    DA,\n                TA,    UHA,   USA,\n                UDA,   UTA,   CC,\n                BLK,   VOID,  QC,\n                HC,    SC,    DC,\n                XC,    TC,    CQI,\n                CHI,   CSI,   CDI,\n                CTI,   COI,   CPSI,\n                BND32, BND64,\n                // zig fmt: on\n\n            const opts = struct {\n                const enum_kind = .identifier;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "mode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to no_address_safety_analysis from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const no_address_safety_analysis = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "no_address_safety_analysis",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to no_instrument_function from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const no_instrument_function = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "no_instrument_function",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to no_profile_instrument_function from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const no_profile_instrument_function = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "no_profile_instrument_function",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to no_reorder from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const no_reorder = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "no_reorder",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to no_sanitize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const no_sanitize = struct {\n        /// Todo: represent args as union?\n        alignment: Value,\n        object_size: ?Value = null,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "no_sanitize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to no_sanitize_address from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const no_sanitize_address = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "no_sanitize_address",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to no_sanitize_coverage from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const no_sanitize_coverage = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "no_sanitize_coverage",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to no_sanitize_thread from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const no_sanitize_thread = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "no_sanitize_thread",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to no_sanitize_undefined from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const no_sanitize_undefined = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "no_sanitize_undefined",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to no_split_stack from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const no_split_stack = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "no_split_stack",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to no_stack_limit from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const no_stack_limit = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "no_stack_limit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to no_stack_protector from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const no_stack_protector = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "no_stack_protector",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to nodiscard from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const nodiscard = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "nodiscard",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to nonnull from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "const nonnull = struct {\n    //    //            arg_index: []const u32,\n    //        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "nonnull",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to nonstring from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const nonstring = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "nonstring",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to optimize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "const optimize = struct {\n    //    //            optimize, // u32 | []const u8 -- optimize?\n    //        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "optimize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to patchable_function_entry from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const patchable_function_entry = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "patchable_function_entry",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to persistent from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const persistent = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "persistent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to reproducible from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const reproducible = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "reproducible",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to returns_nonnull from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const returns_nonnull = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "returns_nonnull",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to returns_twice from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const returns_twice = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "returns_twice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to safebuffers from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const safebuffers = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "safebuffers",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to scalar_storage_order from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const scalar_storage_order = struct {\n        order: enum {\n            @\"little-endian\",\n            @\"big-endian\",\n\n            const opts = struct {\n                const enum_kind = .string;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "scalar_storage_order",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to section from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const section = struct {\n        name: Value,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "section",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to selectany from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const selectany = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "selectany",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to sentinel from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const sentinel = struct {\n        position: ?u32 = null,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "sentinel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to simd from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const simd = struct {\n        mask: ?enum {\n            notinbranch,\n            inbranch,\n\n            const opts = struct {\n                const enum_kind = .string;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "simd",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to spectre from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const spectre = struct {\n        arg: enum {\n            nomitigation,\n\n            const opts = struct {\n                const enum_kind = .identifier;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "spectre",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to stack_protect from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const stack_protect = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "stack_protect",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to symver from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const symver = struct {\n        version: Value, // TODO: validate format \"name2@nodename\"\n\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "symver",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to target from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const target = struct {\n        options: Value, // TODO: multiple arguments\n\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "target",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to target_clones from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const target_clones = struct {\n        options: Value, // TODO: multiple arguments\n\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "target_clones",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to tls_model from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const tls_model = struct {\n        model: enum {\n            @\"global-dynamic\",\n            @\"local-dynamic\",\n            @\"initial-exec\",\n            @\"local-exec\",\n\n            const opts = struct {\n                const enum_kind = .string;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "tls_model",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to transparent_union from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const transparent_union = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "transparent_union",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to unavailable from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const unavailable = struct {\n        msg: ?Value = null,\n        __name_tok: TokenIndex,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "unavailable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to uninitialized from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const uninitialized = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "uninitialized",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to unsequenced from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const unsequenced = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "unsequenced",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to uuid from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const uuid = struct {\n        uuid: Value,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "uuid",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to vector_size from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const vector_size = struct {\n        bytes: u32, // TODO: validate \"The bytes argument must be a positive power-of-two multiple of the base type size\"\n\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "vector_size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to visibility from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const visibility = struct {\n        visibility_type: enum {\n            default,\n            hidden,\n            internal,\n            protected,\n\n            const opts = struct {\n                const enum_kind = .string;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "visibility",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to warn_if_not_aligned from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const warn_if_not_aligned = struct {\n        alignment: Alignment,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "warn_if_not_aligned",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to warn_unused_result from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const warn_unused_result = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "warn_unused_result",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to warning from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const warning = struct {\n        msg: Value,\n        __name_tok: TokenIndex,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "warning",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to weakref from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const weakref = struct {\n        target: ?Value = null,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "weakref",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to zero_call_used_regs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const zero_call_used_regs = struct {\n        choice: enum {\n            skip,\n            used,\n            @\"used-gpr\",\n            @\"used-arg\",\n            @\"used-gpr-arg\",\n            all,\n            @\"all-gpr\",\n            @\"all-arg\",\n            @\"all-gpr-arg\",\n\n            const opts = struct {\n                const enum_kind = .string;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "zero_call_used_regs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to asm_label from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const asm_label = struct {\n        name: Value,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "asm_label",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to calling_convention from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const calling_convention = struct {\n        cc: CallingConvention,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "calling_convention",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to nullability from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const nullability = struct {\n        kind: enum {\n            nonnull,\n            nullable,\n            nullable_result,\n            unspecified,\n\n            const opts = struct {\n                const enum_kind = .identifier;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "nullability",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to unaligned from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const unaligned = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "unaligned",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to pcs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const pcs = struct {\n        kind: enum {\n            aapcs,\n            @\"aapcs-vfp\",\n\n            const opts = struct {\n                const enum_kind = .string;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "pcs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to riscv_vector_cc from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const riscv_vector_cc = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "riscv_vector_cc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to aarch64_sve_pcs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const aarch64_sve_pcs = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "aarch64_sve_pcs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to aarch64_vector_pcs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const aarch64_vector_pcs = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "aarch64_vector_pcs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to vectorcall from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const vectorcall = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "vectorcall",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to internal_linkage from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "pub const internal_linkage = struct {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "internal_linkage",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Properties from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "const Properties = struct {\n        tag: Tag,\n        gnu: bool = false,\n        declspec: bool = false,\n        c23: bool = false,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "struct",
      "name": "Properties",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to expected from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "const expected: []const u8 = switch (Wanted) {\n        Value => string,\n        Identifier => identifier,\n        u32 => int,\n        Alignment => alignment,\n        CallingConvention => identifier,\n        else => switch (@typeInfo(Wanted)) {\n            .@\"enum\" => if (Wanted.opts.enum_kind == .string) string else identifier,\n            else => unreachable,\n        },\n    };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "const",
      "name": "expected",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to actual_kind from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Attribute.zig",
    "response": "const actual_kind: Kind = if (namespace) |ns| blk: {\n        const normalized_ns = normalize(ns);",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Attribute.zig",
      "type": "const",
      "name": "actual_kind",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins.zig",
    "response": "pub fn deinit(b: *Builtins, gpa: std.mem.Allocator) void {\n    b._name_to_type_map.deinit(gpa);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to specForSize from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins.zig",
    "response": "fn specForSize(comp: *const Compilation, size_bits: u32) TypeStore.Builder.Specifier {\n    var qt: QualType = .short;\n    if (qt.bitSizeof(comp) == size_bits) return .short;\n\n    qt = .int;\n    if (qt.bitSizeof(comp) == size_bits) return .int;\n\n    qt = .long;\n    if (qt.bitSizeof(comp) == size_bits) return .long;\n\n    qt = .long_long;\n    if (qt.bitSizeof(comp) == size_bits) return .long_long;\n\n    unreachable;\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins.zig",
      "type": "function",
      "name": "specForSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to createType from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins.zig",
    "response": "fn createType(desc: TypeDescription, it: *TypeDescription.TypeIterator, comp: *Compilation) !QualType {\n    var parser: Parser = undefined;\n    parser.comp = comp;\n    var builder: TypeStore.Builder = .{ .parser = &parser, .error_on_invalid = true }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins.zig",
      "type": "function",
      "name": "createType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to createBuiltin from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins.zig",
    "response": "fn createBuiltin(comp: *Compilation, param_str: [*:0]const u8) !QualType {\n    var it = TypeDescription.TypeIterator.init(param_str);\n\n    const ret_ty_desc = it.next().?;\n    const ret_ty = try createType(ret_ty_desc, &it, comp);\n    var param_count: usize = 0;\n    var params: [32]TypeStore.Type.Func.Param = undefined;\n    while (it.next()) |desc| : (param_count += 1) {\n        params[param_count] = .{ .name_tok = 0, .qt = try createType(desc, &it, comp), .name = .empty, .node = .null }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins.zig",
      "type": "function",
      "name": "createBuiltin",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lookup from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins.zig",
    "response": "pub fn lookup(b: *const Builtins, name: []const u8) Expanded {\n    return b._name_to_type_map.get(name).?;\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins.zig",
      "type": "function",
      "name": "lookup",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getOrCreate from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins.zig",
    "response": "pub fn getOrCreate(b: *Builtins, comp: *Compilation, name: []const u8) !?Expanded {\n    if (b._name_to_type_map.get(name)) |expanded| return expanded;\n\n    const builtin = fromName(comp, name) orelse return null;\n    if (builtin.features) |_| {\n        // TODO check features\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins.zig",
      "type": "function",
      "name": "getOrCreate",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromName from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins.zig",
    "response": "pub fn fromName(comp: *Compilation, name: []const u8) ?FromName {\n    if (fromNameExtra(name, .common)) |found| return found;\n    switch (comp.target.cpu.arch) {\n        .aarch64, .aarch64_be => if (fromNameExtra(name, .aarch64)) |found| return found,\n        .amdgcn => if (fromNameExtra(name, .amdgcn)) |found| return found,\n        .arm, .armeb, .thumb, .thumbeb => if (fromNameExtra(name, .arm)) |found| return found,\n        .bpfeb, .bpfel => if (fromNameExtra(name, .bpf)) |found| return found,\n        .hexagon => if (fromNameExtra(name, .hexagon)) |found| return found,\n        .loongarch32, .loongarch64 => if (fromNameExtra(name, .loongarch)) |found| return found,\n        .mips64, .mips64el, .mips, .mipsel => if (fromNameExtra(name, .mips)) |found| return found,\n        .nvptx, .nvptx64 => if (fromNameExtra(name, .nvptx)) |found| return found,\n        .powerpc64, .powerpc64le, .powerpc, .powerpcle => if (fromNameExtra(name, .powerpc)) |found| return found,\n        .riscv32, .riscv32be, .riscv64, .riscv64be => if (fromNameExtra(name, .riscv)) |found| return found,\n        .s390x => if (fromNameExtra(name, .s390x)) |found| return found,\n        .ve => if (fromNameExtra(name, .ve)) |found| return found,\n        .xcore => if (fromNameExtra(name, .xcore)) |found| return found,\n        .x86_64 => {\n            if (fromNameExtra(name, .x86_64)) |found| return found;\n            if (fromNameExtra(name, .x86)) |found| return found;\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins.zig",
      "type": "function",
      "name": "fromName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromNameExtra from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins.zig",
    "response": "fn fromNameExtra(name: []const u8, comptime arch: std.meta.Tag(Tag)) ?FromName {\n    const list = @field(@This(), @tagName(arch));\n    const tag = list.tagFromName(name) orelse return null;\n    const builtin = list.data[@intFromEnum(tag)];\n\n    return .{\n        .tag = @unionInit(Tag, @tagName(arch), tag),\n        .param_str = builtin.param_str,\n        .header = builtin.header,\n        .language = builtin.language,\n        .attributes = builtin.attributes,\n        .features = if (@hasField(@TypeOf(builtin), \"features\")) builtin.features else null,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins.zig",
      "type": "function",
      "name": "fromNameExtra",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to BuiltinBase from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins.zig",
    "response": "const BuiltinBase = struct {\n    param_str: [*:0]const u8,\n    language: properties.Language = .all_languages,\n    attributes: properties.Attributes = .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins.zig",
      "type": "struct",
      "name": "BuiltinBase",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to BuiltinTarget from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins.zig",
    "response": "const BuiltinTarget = struct {\n    param_str: [*:0]const u8,\n    language: properties.Language = .all_languages,\n    attributes: properties.Attributes = .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins.zig",
      "type": "struct",
      "name": "BuiltinTarget",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Expanded from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins.zig",
    "response": "pub const Expanded = struct {\n    tag: Tag,\n    qt: QualType,\n    language: properties.Language = .all_languages,\n    attributes: properties.Attributes = .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins.zig",
      "type": "struct",
      "name": "Expanded",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FromName from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins.zig",
    "response": "pub const FromName = struct {\n    tag: Tag,\n    param_str: [*:0]const u8,\n    language: properties.Language = .all_languages,\n    attributes: properties.Attributes = .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins.zig",
      "type": "struct",
      "name": "FromName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to expanded from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins.zig",
    "response": "const expanded: Expanded = .{\n        .tag = builtin.tag,\n        .qt = try createBuiltin(comp, builtin.param_str),\n        .attributes = builtin.attributes,\n        .header = builtin.header,\n        .language = builtin.language,\n    };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins.zig",
      "type": "const",
      "name": "expanded",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins/TypeDescription.zig",
    "response": "pub fn init(str: [*:0]const u8) ComponentIterator {\n        return .{\n            .str = str,\n            .idx = 0,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins/TypeDescription.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to peek from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins/TypeDescription.zig",
    "response": "pub fn peek(self: *ComponentIterator) ?Component {\n        const idx = self.idx;\n        defer self.idx = idx;\n        return self.next();\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins/TypeDescription.zig",
      "type": "function",
      "name": "peek",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins/TypeDescription.zig",
    "response": "pub fn next(self: *ComponentIterator) ?Component {\n        const c = self.str[self.idx];\n        if (c == 0) return null;\n        self.idx += 1;\n        switch (c) {\n            'L' => {\n                if (self.str[self.idx] != 'L') return .{ .prefix = .L }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins/TypeDescription.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins/TypeDescription.zig",
    "response": "pub fn init(param_str: [*:0]const u8) TypeIterator {\n        return .{\n            .param_str = param_str,\n            .prefix = undefined,\n            .spec = undefined,\n            .suffix = undefined,\n            .idx = 0,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins/TypeDescription.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins/TypeDescription.zig",
    "response": "pub fn next(self: *TypeIterator) ?TypeDescription {\n        var it = ComponentIterator.init(self.param_str[self.idx..]);\n        defer self.idx += it.idx;\n\n        var prefix_count: usize = 0;\n        var maybe_spec: ?Spec = null;\n        var suffix_count: usize = 0;\n        while (it.peek()) |component| {\n            switch (component) {\n                .prefix => |prefix| {\n                    if (maybe_spec != null) break;\n                    self.prefix[prefix_count] = prefix;\n                    prefix_count += 1;\n                }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins/TypeDescription.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ComponentIterator from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins/TypeDescription.zig",
    "response": "pub const ComponentIterator = struct {\n    str: [*:0]const u8,\n    idx: usize,\n\n    pub fn init(str: [*:0]const u8) ComponentIterator {\n        return .{\n            .str = str,\n            .idx = 0,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins/TypeDescription.zig",
      "type": "struct",
      "name": "ComponentIterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to TypeIterator from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins/TypeDescription.zig",
    "response": "pub const TypeIterator = struct {\n    param_str: [*:0]const u8,\n    prefix: [4]Prefix,\n    spec: Spec,\n    suffix: [4]Suffix,\n    idx: usize,\n\n    pub fn init(param_str: [*:0]const u8) TypeIterator {\n        return .{\n            .param_str = param_str,\n            .prefix = undefined,\n            .spec = undefined,\n            .suffix = undefined,\n            .idx = 0,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins/TypeDescription.zig",
      "type": "struct",
      "name": "TypeIterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to makeNan from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins/eval.zig",
    "response": "fn makeNan(comptime T: type, str: []const u8) T {\n    const UnsignedSameSize = std.meta.Int(.unsigned, @bitSizeOf(T));\n    const parsed = std.fmt.parseUnsigned(UnsignedSameSize, str[0 .. str.len - 1], 0) catch 0;\n    const bits: switch (T) {\n        f32 => u23,\n        f64 => u52,\n        f80 => u63,\n        f128 => u112,\n        else => @compileError(\"Invalid type for makeNan\"),\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins/eval.zig",
      "type": "function",
      "name": "makeNan",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to eval from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins/eval.zig",
    "response": "pub fn eval(expanded: Builtins.Expanded, p: *Parser, args: []const Tree.Node.Index) !Value {\n    if (!expanded.attributes.const_evaluable) return .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins/eval.zig",
      "type": "function",
      "name": "eval",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to bits from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins/eval.zig",
    "response": "const bits: switch (T) {\n        f32 => u23,\n        f64 => u52,\n        f80 => u63,\n        f128 => u112,\n        else => @compileError(\"Invalid type for makeNan\"),\n    } = @truncate(parsed);",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins/eval.zig",
      "type": "const",
      "name": "bits",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to qt from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins/eval.zig",
    "response": "const qt: QualType = switch (tag) {\n                    .__builtin_inff => .float,\n                    .__builtin_inf => .double,\n                    .__builtin_infl => .long_double,\n                    else => unreachable,\n                };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins/eval.zig",
      "type": "const",
      "name": "qt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to f from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins/eval.zig",
    "response": "const f: Interner.Key.Float = switch (qt.bitSizeof(p.comp)) {\n                    32 => .{ .f32 = std.math.inf(f32) },\n                    64 => .{ .f64 = std.math.inf(f64) },\n                    80 => .{ .f80 = std.math.inf(f80) },\n                    128 => .{ .f128 = std.math.inf(f128) },\n                    else => unreachable,\n                };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins/eval.zig",
      "type": "const",
      "name": "f",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to f from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins/eval.zig",
    "response": "const f: Interner.Key.Float = switch (Type.Float.double.bits(p.comp)) {\n                    32 => .{ .f32 = makeNan(f32, bytes) },\n                    64 => .{ .f64 = makeNan(f64, bytes) },\n                    80 => .{ .f80 = makeNan(f80, bytes) },\n                    128 => .{ .f128 = makeNan(f128, bytes) },\n                    else => unreachable,\n                };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins/eval.zig",
      "type": "const",
      "name": "f",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isVarArgs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Builtins/properties.zig",
    "response": "pub fn isVarArgs(param_str: [*:0]const u8) bool {\n    const slice = std.mem.sliceTo(param_str, 0);\n    return slice[slice.len - 1] == '.';\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Builtins/properties.zig",
      "type": "function",
      "name": "isVarArgs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fail from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn fail(c: *CodeGen, comptime fmt: []const u8, args: anytype) error{ FatalError, OutOfMemory }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "fail",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to genIr from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "pub fn genIr(tree: *const Tree) Compilation.Error!Ir {\n    const gpa = tree.comp.gpa;\n    var c: CodeGen = .{\n        .builder = .{\n            .gpa = tree.comp.gpa,\n            .interner = &tree.comp.interner,\n            .arena = std.heap.ArenaAllocator.init(gpa),\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "genIr",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to genType from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn genType(c: *CodeGen, qt: QualType) !Interner.Ref {\n    const base = qt.base(c.comp);\n    const key: Interner.Key = switch (base.type) {\n        .void => return .void,\n        .bool => return .i1,\n        .@\"struct\" => |record| {\n            if (c.record_cache.get(base.qt.unqualified())) |some| return some;\n\n            const elem_buf_top = c.record_elem_buf.items.len;\n            defer c.record_elem_buf.items.len = elem_buf_top;\n\n            for (record.fields) |field| {\n                if (field.bit_width != .null) {\n                    return c.fail(\"TODO lower struct bitfields\", .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "genType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genFn from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn genFn(c: *CodeGen, function: Node.Function) Error!void {\n    const name = c.tree.tokSlice(function.name_tok);\n    const func_ty = function.qt.base(c.comp).type.func;\n    c.ret_nodes.items.len = 0;\n\n    try c.builder.startFn();\n\n    for (func_ty.params) |param| {\n        // TODO handle calling convention here\n        const arg = try c.builder.addArg(try c.genType(param.qt));\n\n        const size: u32 = @intCast(param.qt.sizeof(c.comp)); // TODO add error in parser\n        const @\"align\" = param.qt.alignof(c.comp);\n        const alloc = try c.builder.addAlloc(size, @\"align\");\n        try c.builder.addStore(alloc, arg);\n        try c.symbols.append(c.comp.gpa, .{ .name = param.name, .val = alloc }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "genFn",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to addUn from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn addUn(c: *CodeGen, tag: Ir.Inst.Tag, operand: Ir.Ref, qt: QualType) !Ir.Ref {\n    return c.builder.addInst(tag, .{ .un = operand }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "addUn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addBin from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn addBin(c: *CodeGen, tag: Ir.Inst.Tag, lhs: Ir.Ref, rhs: Ir.Ref, qt: QualType) !Ir.Ref {\n    return c.builder.addInst(tag, .{ .bin = .{ .lhs = lhs, .rhs = rhs }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "addBin",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addBranch from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn addBranch(c: *CodeGen, cond: Ir.Ref, true_label: Ir.Ref, false_label: Ir.Ref) !void {\n    if (true_label == c.bool_end_label) {\n        if (false_label == c.bool_end_label) {\n            try c.phi_nodes.append(c.comp.gpa, .{ .label = c.builder.current_label, .value = cond }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "addBranch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addBoolPhi from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn addBoolPhi(c: *CodeGen, value: bool) !void {\n    const val = try c.builder.addConstant((try Value.int(@intFromBool(value), c.comp)).ref(), .i1);\n    try c.phi_nodes.append(c.comp.gpa, .{ .label = c.builder.current_label, .value = val }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "addBoolPhi",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genStmt from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn genStmt(c: *CodeGen, node: Node.Index) Error!void {\n    _ = try c.genExpr(node);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "genStmt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genExpr from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn genExpr(c: *CodeGen, node_index: Node.Index) Error!Ir.Ref {\n    if (c.tree.value_map.get(node_index)) |val| {\n        return c.builder.addConstant(val.ref(), try c.genType(node_index.qt(c.tree)));\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "genExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genLval from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn genLval(c: *CodeGen, node_index: Node.Index) Error!Ir.Ref {\n    assert(c.tree.isLval(node_index));\n    const node = node_index.get(c.tree);\n    switch (node) {\n        .string_literal_expr => {\n            const val = c.tree.value_map.get(node_index).?;\n            return c.builder.addConstant(val.ref(), .ptr);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "genLval",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genBoolExpr from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn genBoolExpr(c: *CodeGen, base: Node.Index, true_label: Ir.Ref, false_label: Ir.Ref) Error!void {\n    var node = base;\n    while (true) switch (node.get(c.tree)) {\n        .paren_expr => |un| node = un.operand,\n        else => break,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "genBoolExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genBuiltinCall from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn genBuiltinCall(c: *CodeGen, builtin: Builtins.Expanded, arg_nodes: []const Node.Index, qt: QualType) Error!Ir.Ref {\n    _ = arg_nodes;\n    _ = qt;\n    return c.fail(\"TODO CodeGen.genBuiltinCall {t}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "genBuiltinCall",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genCall from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn genCall(c: *CodeGen, call: Node.Call) Error!Ir.Ref {\n    // Detect direct calls.\n    const fn_ref = blk: {\n        const callee = call.callee.get(c.tree);\n        if (callee != .cast or callee.cast.kind != .function_to_pointer) {\n            break :blk try c.genExpr(call.callee);\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "genCall",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genCompoundAssign from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn genCompoundAssign(c: *CodeGen, bin: Node.Binary) Error!Ir.Ref {\n    const lhs = try c.genLval(bin.lhs);\n\n    const old_dummy = c.compound_assign_dummy;\n    defer c.compound_assign_dummy = old_dummy;\n    c.compound_assign_dummy = lhs;\n\n    const rhs = try c.genExpr(bin.rhs);\n    try c.builder.addStore(lhs, rhs);\n    return rhs;\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "genCompoundAssign",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genBinOp from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn genBinOp(c: *CodeGen, bin: Node.Binary, tag: Ir.Inst.Tag) Error!Ir.Ref {\n    const lhs = try c.genExpr(bin.lhs);\n    const rhs = try c.genExpr(bin.rhs);\n    return c.addBin(tag, lhs, rhs, bin.qt);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "genBinOp",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genComparison from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn genComparison(c: *CodeGen, bin: Node.Binary, tag: Ir.Inst.Tag) Error!Ir.Ref {\n    const lhs = try c.genExpr(bin.lhs);\n    const rhs = try c.genExpr(bin.rhs);\n\n    return c.builder.addInst(tag, .{ .bin = .{ .lhs = lhs, .rhs = rhs }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "genComparison",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genPtrArithmetic from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn genPtrArithmetic(c: *CodeGen, ptr: Ir.Ref, offset: Ir.Ref, offset_ty: QualType, qt: QualType) Error!Ir.Ref {\n    // TODO consider adding a getelemptr instruction\n    const size = qt.childType(c.comp).sizeof(c.comp);\n    if (size == 1) {\n        return c.builder.addInst(.add, .{ .bin = .{ .lhs = ptr, .rhs = offset }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "genPtrArithmetic",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genInitializer from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn genInitializer(c: *CodeGen, ptr: Ir.Ref, dest_ty: QualType, initializer: Node.Index) Error!void {\n    const node = initializer.get(c.tree);\n    switch (node) {\n        .array_init_expr,\n        .struct_init_expr,\n        .union_init_expr,\n        .array_filler_expr,\n        .default_init_expr,\n        => return c.fail(\"TODO CodeGen.genInitializer {s}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "genInitializer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genVar from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "fn genVar(c: *CodeGen, decl: Node.Variable) Error!void {\n    _ = decl;\n    return c.fail(\"TODO CodeGen.genVar\\n\", .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "function",
      "name": "genVar",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to WipSwitch from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "const WipSwitch = struct {\n    cases: Cases = .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "struct",
      "name": "WipSwitch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Symbol from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "const Symbol = struct {\n    name: StringId,\n    val: Ir.Ref,\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "struct",
      "name": "Symbol",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to key from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "const key: Interner.Key = switch (base.type) {\n        .void => return .void,\n        .bool => return .i1,\n        .@\"struct\" => |record| {\n            if (c.record_cache.get(base.qt.unqualified())) |some| return some;",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "const",
      "name": "key",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to size from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "const size: u32 = @intCast(param.qt.sizeof(c.comp));",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "const",
      "name": "size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to size from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "const size: u32 = @intCast(variable.qt.sizeof(c.comp));",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "const",
      "name": "size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ref from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "const ref: Ir.Ref = @enumFromInt(c.builder.instructions.len);",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "const",
      "name": "ref",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to size from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "const size: u32 = @intCast(literal.qt.sizeof(c.comp));",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "const",
      "name": "size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ref from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/CodeGen.zig",
    "response": "const ref: Ir.Ref = @enumFromInt(c.builder.instructions.len);",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/CodeGen.zig",
      "type": "const",
      "name": "ref",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to loadAll from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn loadAll(allocator: std.mem.Allocator) !Environment {\n        var env: Environment = .{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "loadAll",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn deinit(self: *Environment, allocator: std.mem.Allocator) void {\n        inline for (@typeInfo(@TypeOf(self.*)).@\"struct\".fields) |field| {\n            if (@field(self, field.name)) |slice| {\n                allocator.free(slice);\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to sourceEpoch from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn sourceEpoch(self: *const Environment) !SourceEpoch {\n        const max_timestamp = 253402300799; // Dec 31 9999 23:59:59\n\n        if (self.source_date_epoch) |epoch| {\n            const parsed = std.fmt.parseInt(u64, epoch, 10) catch return error.InvalidEpoch;\n            if (parsed > max_timestamp) return error.InvalidEpoch;\n            return .{ .provided = parsed }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "sourceEpoch",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn init(gpa: Allocator, arena: Allocator, diagnostics: *Diagnostics, cwd: std.fs.Dir) Compilation {\n    return .{\n        .gpa = gpa,\n        .arena = arena,\n        .diagnostics = diagnostics,\n        .cwd = cwd,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to initDefault from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn initDefault(gpa: Allocator, arena: Allocator, diagnostics: *Diagnostics, cwd: std.fs.Dir) !Compilation {\n    var comp: Compilation = .{\n        .gpa = gpa,\n        .arena = arena,\n        .diagnostics = diagnostics,\n        .environment = try Environment.loadAll(gpa),\n        .cwd = cwd,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "initDefault",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn deinit(comp: *Compilation) void {\n    const gpa = comp.gpa;\n    for (comp.pragma_handlers.values()) |pragma| {\n        pragma.deinit(pragma, comp);\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to internString from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn internString(comp: *Compilation, str: []const u8) !StringInterner.StringId {\n    return comp.string_interner.intern(comp.gpa, str);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "internString",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateSystemDefines from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn generateSystemDefines(comp: *Compilation, w: *std.Io.Writer) !void {\n    const define = struct {\n        fn define(_w: *std.Io.Writer, name: []const u8) !void {\n            try _w.print(\"#define {s}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "generateSystemDefines",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to defineStd from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn defineStd(_w: *std.Io.Writer, name: []const u8, is_gnu: bool) !void {\n            if (is_gnu) {\n                try _w.print(\"#define {s}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "defineStd",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateBuiltinMacros from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn generateBuiltinMacros(comp: *Compilation, system_defines_mode: SystemDefinesMode) AddSourceError!Source {\n    try comp.type_store.initNamedTypes(comp);\n\n    var allocating: std.Io.Writer.Allocating = try .initCapacity(comp.gpa, 2 << 13);\n    defer allocating.deinit();\n\n    comp.writeBuiltinMacros(system_defines_mode, &allocating.writer) catch |err| switch (err) {\n        error.WriteFailed, error.OutOfMemory => return error.OutOfMemory,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "generateBuiltinMacros",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeBuiltinMacros from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn writeBuiltinMacros(comp: *Compilation, system_defines_mode: SystemDefinesMode, w: *std.Io.Writer) !void {\n    if (system_defines_mode == .include_system_defines) {\n        try w.writeAll(\n            \\\\#define __VERSION__ \"Aro\n        ++ \" \" ++ @import(\"backend\").version_str ++ \"\\\"\\n\" ++\n            \\\\#define __Aro__\n            \\\\\n        );\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "writeBuiltinMacros",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateFloatMacros from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn generateFloatMacros(w: *std.Io.Writer, prefix: []const u8, semantics: target_util.FPSemantics, ext: []const u8) !void {\n    const denormMin = semantics.chooseValue(\n        []const u8,\n        .{\n            \"5.9604644775390625e-8\",\n            \"1.40129846e-45\",\n            \"4.9406564584124654e-324\",\n            \"3.64519953188247460253e-4951\",\n            \"4.94065645841246544176568792868221e-324\",\n            \"6.47517511943802511092443895822764655e-4966\",\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "generateFloatMacros",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateTypeMacro from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn generateTypeMacro(comp: *const Compilation, w: *std.Io.Writer, name: []const u8, qt: QualType) !void {\n    try w.print(\"#define {s}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "generateTypeMacro",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to float80Type from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn float80Type(comp: *const Compilation) ?QualType {\n    if (comp.langopts.emulate != .gcc) return null;\n    return target_util.float80Type(comp.target);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "float80Type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to intLeastN from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn intLeastN(comp: *const Compilation, bits: usize, signedness: std.builtin.Signedness) QualType {\n    if (bits == 64 and (comp.target.os.tag.isDarwin() or comp.target.cpu.arch.isWasm())) {\n        // WebAssembly and Darwin use `long long` for `int_least64_t` and `int_fast64_t`.\n        return if (signedness == .signed) .long_long else .ulong_long;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "intLeastN",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateFastOrLeastType from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn generateFastOrLeastType(\n    comp: *Compilation,\n    bits: usize,\n    kind: enum { least, fast },\n    signedness: std.builtin.Signedness,\n    w: *std.Io.Writer,\n) !void {\n    const ty = comp.intLeastN(bits, signedness); // defining the fast types as the least types is permitted\n\n    var buf: [32]u8 = undefined;\n    const suffix = \"_TYPE__\";\n    const base_name = switch (signedness) {\n        .signed => \"__INT_\",\n        .unsigned => \"__UINT_\",\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "generateFastOrLeastType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateFastAndLeastWidthTypes from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn generateFastAndLeastWidthTypes(comp: *Compilation, w: *std.Io.Writer) !void {\n    const sizes = [_]usize{ 8, 16, 32, 64 }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "generateFastAndLeastWidthTypes",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateExactWidthTypes from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn generateExactWidthTypes(comp: *Compilation, w: *std.Io.Writer) !void {\n    try comp.generateExactWidthType(w, .schar);\n\n    if (QualType.short.sizeof(comp) > QualType.char.sizeof(comp)) {\n        try comp.generateExactWidthType(w, .short);\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "generateExactWidthTypes",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateFmt from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn generateFmt(comp: *const Compilation, prefix: []const u8, w: *std.Io.Writer, qt: QualType) !void {\n    const unsigned = qt.signedness(comp) == .unsigned;\n    const modifier = qt.formatModifier(comp);\n    const formats = if (unsigned) \"ouxX\" else \"di\";\n    for (formats) |c| {\n        try w.print(\"#define {s}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "generateFmt",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateSuffixMacro from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn generateSuffixMacro(comp: *const Compilation, prefix: []const u8, w: *std.Io.Writer, qt: QualType) !void {\n    return w.print(\"#define {s}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "generateSuffixMacro",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateExactWidthType from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn generateExactWidthType(comp: *Compilation, w: *std.Io.Writer, original_qt: QualType) !void {\n    var qt = original_qt;\n    const width = qt.sizeof(comp) * 8;\n    const unsigned = qt.signedness(comp) == .unsigned;\n\n    if (width == 16) {\n        qt = if (unsigned) try comp.type_store.int16.makeIntUnsigned(comp) else comp.type_store.int16;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "generateExactWidthType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to hasFloat128 from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn hasFloat128(comp: *const Compilation) bool {\n    return target_util.hasFloat128(comp.target);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "hasFloat128",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hasHalfPrecisionFloatABI from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn hasHalfPrecisionFloatABI(comp: *const Compilation) bool {\n    return comp.langopts.allow_half_args_and_returns or target_util.hasHalfPrecisionFloatABI(comp.target);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "hasHalfPrecisionFloatABI",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateIntMax from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn generateIntMax(comp: *const Compilation, w: *std.Io.Writer, name: []const u8, qt: QualType) !void {\n    const unsigned = qt.signedness(comp) == .unsigned;\n    const max: u128 = switch (qt.bitSizeof(comp)) {\n        8 => if (unsigned) std.math.maxInt(u8) else std.math.maxInt(i8),\n        16 => if (unsigned) std.math.maxInt(u16) else std.math.maxInt(i16),\n        32 => if (unsigned) std.math.maxInt(u32) else std.math.maxInt(i32),\n        64 => if (unsigned) std.math.maxInt(u64) else std.math.maxInt(i64),\n        128 => if (unsigned) std.math.maxInt(u128) else std.math.maxInt(i128),\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "generateIntMax",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to wcharMax from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn wcharMax(comp: *const Compilation) u32 {\n    const unsigned = comp.type_store.wchar.signedness(comp) == .unsigned;\n    return switch (comp.type_store.wchar.bitSizeof(comp)) {\n        8 => if (unsigned) std.math.maxInt(u8) else std.math.maxInt(i8),\n        16 => if (unsigned) std.math.maxInt(u16) else std.math.maxInt(i16),\n        32 => if (unsigned) std.math.maxInt(u32) else std.math.maxInt(i32),\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "wcharMax",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateExactWidthIntMax from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn generateExactWidthIntMax(comp: *Compilation, w: *std.Io.Writer, original_qt: QualType) !void {\n    var qt = original_qt;\n    const bit_count: u8 = @intCast(qt.sizeof(comp) * 8);\n    const unsigned = qt.signedness(comp) == .unsigned;\n\n    if (bit_count == 64) {\n        qt = if (unsigned) try comp.type_store.int64.makeIntUnsigned(comp) else comp.type_store.int64;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "generateExactWidthIntMax",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateIntWidth from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn generateIntWidth(comp: *Compilation, w: *std.Io.Writer, name: []const u8, qt: QualType) !void {\n    try w.print(\"#define __{s}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "generateIntWidth",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateIntMaxAndWidth from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn generateIntMaxAndWidth(comp: *Compilation, w: *std.Io.Writer, name: []const u8, qt: QualType) !void {\n    try comp.generateIntMax(w, name, qt);\n    try comp.generateIntWidth(w, name, qt);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "generateIntMaxAndWidth",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateSizeofType from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn generateSizeofType(comp: *Compilation, w: *std.Io.Writer, name: []const u8, qt: QualType) !void {\n    try w.print(\"#define {s}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "generateSizeofType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to nextLargestIntSameSign from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn nextLargestIntSameSign(comp: *const Compilation, qt: QualType) ?QualType {\n    assert(qt.isInt(comp));\n    const candidates: [4]QualType = if (qt.signedness(comp) == .signed)\n        .{ .short, .int, .long, .long_long }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "nextLargestIntSameSign",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to maxArrayBytes from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn maxArrayBytes(comp: *const Compilation) u64 {\n    const max_bits = @min(61, comp.target.ptrBitWidth());\n    return (@as(u64, 1) << @truncate(max_bits)) - 1;\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "maxArrayBytes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fixedEnumTagType from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn fixedEnumTagType(comp: *const Compilation) ?QualType {\n    switch (comp.langopts.emulate) {\n        .msvc => return .int,\n        .clang => if (comp.target.os.tag == .windows) return .int,\n        .gcc => {}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "fixedEnumTagType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getCharSignedness from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn getCharSignedness(comp: *const Compilation) std.builtin.Signedness {\n    return comp.langopts.char_signedness_override orelse comp.target.cCharSignedness();\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "getCharSignedness",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addBuiltinIncludeDir from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn addBuiltinIncludeDir(comp: *Compilation, aro_dir: []const u8, override_resource_dir: ?[]const u8) !void {\n    const gpa = comp.gpa;\n    const arena = comp.arena;\n    try comp.system_include_dirs.ensureUnusedCapacity(gpa, 1);\n    if (override_resource_dir) |resource_dir| {\n        comp.system_include_dirs.appendAssumeCapacity(try std.fs.path.join(arena, &.{ resource_dir, \"include\" }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "addBuiltinIncludeDir",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addSystemIncludeDir from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn addSystemIncludeDir(comp: *Compilation, path: []const u8) !void {\n    try comp.system_include_dirs.append(comp.gpa, try comp.arena.dupe(u8, path));\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "addSystemIncludeDir",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getSource from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn getSource(comp: *const Compilation, id: Source.Id) Source {\n    if (id == .generated) return .{\n        .path = \"<scratch space>\",\n        .buf = comp.generated_buf.items,\n        .id = .generated,\n        .splice_locs = &.{}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "getSource",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addSourceFromOwnedBuffer from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn addSourceFromOwnedBuffer(comp: *Compilation, path: []const u8, buf: []u8, kind: Source.Kind) !Source {\n    assert(buf.len <= std.math.maxInt(u32));\n    try comp.sources.ensureUnusedCapacity(comp.gpa, 1);\n\n    var contents = buf;\n    const duped_path = try comp.gpa.dupe(u8, path);\n    errdefer comp.gpa.free(duped_path);\n\n    var splice_list: std.ArrayList(u32) = .empty;\n    defer splice_list.deinit(comp.gpa);\n\n    const source_id: Source.Id = @enumFromInt(comp.sources.count() + 2);\n\n    var i: u32 = 0;\n    var backslash_loc: u32 = undefined;\n    var state: enum {\n        beginning_of_file,\n        bom1,\n        bom2,\n        start,\n        back_slash,\n        cr,\n        back_slash_cr,\n        trailing_ws,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "addSourceFromOwnedBuffer",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to addNewlineEscapeError from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn addNewlineEscapeError(\n    comp: *Compilation,\n    path: []const u8,\n    buf: []const u8,\n    splice_locs: []const u32,\n    byte_offset: u32,\n    line: u32,\n    kind: Source.Kind,\n) !void {\n    // Temporary source for getting the location for errors.\n    var tmp_source: Source = .{\n        .path = path,\n        .buf = buf,\n        .id = undefined,\n        .kind = kind,\n        .splice_locs = splice_locs,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "addNewlineEscapeError",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addSourceFromBuffer from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn addSourceFromBuffer(comp: *Compilation, path: []const u8, buf: []const u8) AddSourceError!Source {\n    if (comp.sources.get(path)) |some| return some;\n    if (buf.len > std.math.maxInt(u32)) return error.FileTooBig;\n\n    const contents = try comp.gpa.dupe(u8, buf);\n    errdefer comp.gpa.free(contents);\n\n    return comp.addSourceFromOwnedBuffer(path, contents, .user);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "addSourceFromBuffer",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to addSourceFromPath from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn addSourceFromPath(comp: *Compilation, path: []const u8) !Source {\n    return comp.addSourceFromPathExtra(path, .user);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "addSourceFromPath",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addSourceFromPathExtra from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn addSourceFromPathExtra(comp: *Compilation, path: []const u8, kind: Source.Kind) !Source {\n    if (comp.sources.get(path)) |some| return some;\n\n    if (mem.indexOfScalar(u8, path, 0) != null) {\n        return error.FileNotFound;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "addSourceFromPathExtra",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addSourceFromFile from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn addSourceFromFile(comp: *Compilation, file: std.fs.File, path: []const u8, kind: Source.Kind) !Source {\n    const contents = try comp.getFileContents(file, .unlimited);\n    errdefer comp.gpa.free(contents);\n    return comp.addSourceFromOwnedBuffer(path, contents, kind);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "addSourceFromFile",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to hasInclude from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn hasInclude(\n    comp: *Compilation,\n    filename: []const u8,\n    includer_token_source: Source.Id,\n    /// angle bracket vs quotes\n    include_type: IncludeType,\n    /// __has_include vs __has_include_next\n    which: WhichInclude,\n    opt_dep_file: ?*DepFile,\n) Compilation.Error!bool {\n    if (try FindInclude.run(comp, filename, include_type, switch (which) {\n        .next => .{ .only_search_after_dir = comp.getSource(includer_token_source).path }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "hasInclude",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn run(\n        comp: *Compilation,\n        include_path: []const u8,\n        include_type: IncludeType,\n        search_strat: union(enum) {\n            allow_same_dir: []const u8,\n            only_search,\n            only_search_after_dir: []const u8,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "run",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to checkIncludeDir from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn checkIncludeDir(find: *FindInclude, include_dir: []const u8, kind: Source.Kind) Allocator.Error!?Result {\n        if (find.wait_for) |wait_for| {\n            if (std.mem.eql(u8, include_dir, wait_for)) find.wait_for = null;\n            return null;\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "checkIncludeDir",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to checkMsCwdIncludeDir from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn checkMsCwdIncludeDir(find: *FindInclude, source_id: Source.Id) Allocator.Error!?Result {\n        const path = find.comp.getSource(source_id).path;\n        const dir = std.fs.path.dirname(path) orelse \".\";\n        if (find.wait_for) |wait_for| {\n            if (std.mem.eql(u8, dir, wait_for)) find.wait_for = null;\n            return null;\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "checkMsCwdIncludeDir",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to checkFrameworkDir from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn checkFrameworkDir(find: *FindInclude, framework_dir: []const u8, kind: Source.Kind) Allocator.Error!?Result {\n        if (find.wait_for) |wait_for| {\n            match: {\n                // If this is a match, then `wait_for` looks like '.../Foo.framework/Headers'.\n                const wait_framework = std.fs.path.dirname(wait_for) orelse break :match;\n                const wait_framework_dir = std.fs.path.dirname(wait_framework) orelse break :match;\n                if (!std.mem.eql(u8, framework_dir, wait_framework_dir)) break :match;\n                find.wait_for = null;\n            }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "checkFrameworkDir",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to check from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn check(\n        find: *FindInclude,\n        comptime format: []const u8,\n        args: anytype,\n        kind: Source.Kind,\n        used_ms_search_rule: bool,\n    ) Allocator.Error!?Result {\n        const comp = find.comp;\n\n        var stack_fallback = std.heap.stackFallback(path_buf_stack_limit, comp.gpa);\n        const sfa = stack_fallback.get();\n        const header_path = try std.fmt.allocPrint(sfa, format, args);\n        defer sfa.free(header_path);\n        find.comp.normalizePath(header_path);\n        const source = comp.addSourceFromPathExtra(header_path, kind) catch |err| switch (err) {\n            error.OutOfMemory => |e| return e,\n            else => return null,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "check",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to getPathContents from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn getPathContents(comp: *Compilation, path: []const u8, limit: std.Io.Limit) ![]u8 {\n    if (mem.indexOfScalar(u8, path, 0) != null) {\n        return error.FileNotFound;\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "getPathContents",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getFileContents from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn getFileContents(comp: *Compilation, file: std.fs.File, limit: std.Io.Limit) ![]u8 {\n    var file_buf: [4096]u8 = undefined;\n    var file_reader = file.reader(&file_buf);\n\n    var allocating: std.Io.Writer.Allocating = .init(comp.gpa);\n    defer allocating.deinit();\n    if (file_reader.getSize()) |size| {\n        const limited_size = limit.minInt64(size);\n        if (limited_size > std.math.maxInt(u32)) return error.FileTooBig;\n        try allocating.ensureUnusedCapacity(limited_size);\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "getFileContents",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to normalizePath from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn normalizePath(comp: *Compilation, path: []u8) void {\n    if (comp.langopts.ms_extensions and @import(\"builtin\").target.os.tag != .windows) {\n        std.mem.replaceScalar(u8, path, std.fs.path.sep_windows, std.fs.path.sep_posix);\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "normalizePath",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findEmbed from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn findEmbed(\n    comp: *Compilation,\n    filename: []const u8,\n    includer_token_source: Source.Id,\n    /// angle bracket vs quotes\n    include_type: IncludeType,\n    limit: std.Io.Limit,\n    opt_dep_file: ?*DepFile,\n) !?[]u8 {\n    if (std.fs.path.isAbsolute(filename)) {\n        if (comp.getPathContents(filename, limit)) |some| {\n            errdefer comp.gpa.free(some);\n            if (opt_dep_file) |dep_file| try dep_file.addDependencyDupe(comp.gpa, comp.arena, filename);\n            return some;\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "findEmbed",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to findInclude from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn findInclude(\n    comp: *Compilation,\n    filename: []const u8,\n    includer_token: Token,\n    /// angle bracket vs quotes\n    include_type: IncludeType,\n    /// include vs include_next\n    which: WhichInclude,\n) Compilation.Error!?Source {\n    const found = try FindInclude.run(comp, filename, include_type, switch (which) {\n        .next => .{ .only_search_after_dir = comp.getSource(includer_token.source).path }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "findInclude",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addPragmaHandler from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn addPragmaHandler(comp: *Compilation, name: []const u8, handler: *Pragma) Allocator.Error!void {\n    try comp.pragma_handlers.putNoClobber(comp.gpa, name, handler);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "addPragmaHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to addDefaultPragmaHandlers from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn addDefaultPragmaHandlers(comp: *Compilation) Allocator.Error!void {\n    const GCC = @import(\"pragmas/gcc.zig\");\n    var gcc = try GCC.init(comp.gpa);\n    errdefer gcc.deinit(gcc, comp);\n\n    const Once = @import(\"pragmas/once.zig\");\n    var once = try Once.init(comp.gpa);\n    errdefer once.deinit(once, comp);\n\n    const Message = @import(\"pragmas/message.zig\");\n    var message = try Message.init(comp.gpa);\n    errdefer message.deinit(message, comp);\n\n    const Pack = @import(\"pragmas/pack.zig\");\n    var pack = try Pack.init(comp.gpa);\n    errdefer pack.deinit(pack, comp);\n\n    try comp.addPragmaHandler(\"GCC\", gcc);\n    try comp.addPragmaHandler(\"once\", once);\n    try comp.addPragmaHandler(\"message\", message);\n    try comp.addPragmaHandler(\"pack\", pack);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "addDefaultPragmaHandlers",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getPragma from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn getPragma(comp: *Compilation, name: []const u8) ?*Pragma {\n    return comp.pragma_handlers.get(name);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "getPragma",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pragmaEvent from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn pragmaEvent(comp: *Compilation, event: PragmaEvent) void {\n    for (comp.pragma_handlers.values()) |pragma| {\n        const maybe_func = switch (event) {\n            .before_preprocess => pragma.beforePreprocess,\n            .before_parse => pragma.beforeParse,\n            .after_parse => pragma.afterParse,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "pragmaEvent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to locSlice from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn locSlice(comp: *const Compilation, loc: Source.Location) []const u8 {\n    var tmp_tokenizer = Tokenizer{\n        .buf = comp.getSource(loc.id).buf,\n        .langopts = comp.langopts,\n        .index = loc.byte_offset,\n        .source = .generated,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "locSlice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getSourceMTimeUncached from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn getSourceMTimeUncached(comp: *const Compilation, source_id: Source.Id) ?u64 {\n    const source = comp.getSource(source_id);\n    if (comp.cwd.statFile(source.path)) |stat| {\n        const mtime = @divTrunc(stat.mtime, std.time.ns_per_s);\n        return std.math.cast(u64, mtime);\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "getSourceMTimeUncached",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isTargetArch from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn isTargetArch(comp: *const Compilation, query: []const u8) bool {\n    return target_util.isArch(comp.target, query);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "isTargetArch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isTargetOs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn isTargetOs(comp: *const Compilation, query: []const u8) !bool {\n    return target_util.isOs(comp.target, query);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "isTargetOs",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to isTargetVendor from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn isTargetVendor(comp: *const Compilation, query: []const u8) bool {\n    return target_util.isVendor(comp.vendor, query);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "isTargetVendor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isTargetEnvironment from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn isTargetEnvironment(comp: *const Compilation, query: []const u8) bool {\n    return target_util.isEnvironment(comp.target, query);\n}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "isTargetEnvironment",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isTargetVariantOs from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn isTargetVariantOs(comp: *const Compilation, query: []const u8) bool {\n    if (comp.target.os.tag.isDarwin()) {\n        const variant_target = comp.darwin_target_variant orelse return false;\n        return target_util.isOs(variant_target, query);\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "isTargetVariantOs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isTargetVariantEnvironment from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn isTargetVariantEnvironment(comp: *const Compilation, query: []const u8) bool {\n    if (comp.target.os.tag.isDarwin()) {\n        const variant_target = comp.darwin_target_variant orelse return false;\n        return target_util.isEnvironment(variant_target, query);\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "isTargetVariantEnvironment",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to Type from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub fn Type(comptime self: CharUnitSize) type {\n        return switch (self) {\n            .@\"1\" => u8,\n            .@\"2\" => u16,\n            .@\"4\" => u32,\n        }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "Type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addSourceFromBuffer from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn addSourceFromBuffer(str: []const u8, expected: []const u8, warning_count: u32, splices: []const u32) !void {\n            var arena: std.heap.ArenaAllocator = .init(std.testing.allocator);\n            defer arena.deinit();\n            var diagnostics: Diagnostics = .{ .output = .ignore }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "addSourceFromBuffer",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to withAllocationFailures from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn withAllocationFailures(allocator: std.mem.Allocator) !void {\n            var arena: std.heap.ArenaAllocator = .init(allocator);\n            defer arena.deinit();\n            var diagnostics: Diagnostics = .{ .output = .ignore }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "withAllocationFailures",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "fn run(arena: Allocator, buf: []const u8) !void {\n            var diagnostics: Diagnostics = .{ .output = .ignore }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "function",
      "name": "run",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to define from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "const define = struct {\n        fn define(_w: *std.Io.Writer, name: []const u8) !void {\n            try _w.print(\"#define {s}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "struct",
      "name": "define",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to defineStd from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "const defineStd = struct {\n        fn defineStd(_w: *std.Io.Writer, name: []const u8, is_gnu: bool) !void {\n            if (is_gnu) {\n                try _w.print(\"#define {s}",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "struct",
      "name": "defineStd",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FindInclude from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "const FindInclude = struct {\n    comp: *Compilation,\n    include_path: []const u8,\n    /// We won't actually consider any include directories until after this directory.\n    wait_for: ?[]const u8,\n\n    const Result = struct {\n        source: Source.Id,\n        kind: Source.Kind,\n        used_ms_search_rule: bool,\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "struct",
      "name": "FindInclude",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Diagnostic from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub const Diagnostic = struct {\n    fmt: []const u8,\n    kind: Diagnostics.Message.Kind,\n    opt: ?Diagnostics.Option = null,\n    extension: bool = false,\n\n    pub const backslash_newline_escape: Diagnostic = .{\n        .fmt = \"backslash and newline separated by space\",\n        .kind = .warning,\n        .opt = .@\"backslash-newline-escape\",\n    }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "struct",
      "name": "Diagnostic",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Test from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "const Test = struct {\n        fn addSourceFromBuffer(str: []const u8, expected: []const u8, warning_count: u32, splices: []const u32) !void {\n            var arena: std.heap.ArenaAllocator = .init(std.testing.allocator);\n            defer arena.deinit();\n            var diagnostics: Diagnostics = .{ .output = .ignore }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "struct",
      "name": "Test",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Test from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "const Test = struct {\n        fn run(arena: Allocator, buf: []const u8) !void {\n            var diagnostics: Diagnostics = .{ .output = .ignore }",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "struct",
      "name": "Test",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to default from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub const default: @This() = .{ .provided = 0 };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "const",
      "name": "default",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to val from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "const val: ?[]const u8 = std.process.getEnvVarOwned(allocator, env_var_name) catch |err| switch (err) {\n                error.OutOfMemory => |e| return e,\n                error.EnvironmentVariableNotFound => null,\n                error.InvalidWtf8 => null,\n            };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "const",
      "name": "val",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to candidates from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "const candidates: [5]QualType = switch (signedness) {\n        .signed => .{ .schar, .short, .int, .long, .long_long },\n        .unsigned => .{ .uchar, .ushort, .uint, .ulong, .ulong_long },\n    };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "const",
      "name": "candidates",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to max from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "const max: u128 = switch (qt.bitSizeof(comp)) {\n        8 => if (unsigned) std.math.maxInt(u8) else std.math.maxInt(i8),\n        16 => if (unsigned) std.math.maxInt(u16) else std.math.maxInt(i16),\n        32 => if (unsigned) std.math.maxInt(u32) else std.math.maxInt(i32),\n        64 => if (unsigned) std.math.maxInt(u64) else std.math.maxInt(i64),\n        128 => if (unsigned) std.math.maxInt(u128) else std.math.maxInt(i128),\n        else => unreachable,\n    };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "const",
      "name": "max",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to bit_count from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "const bit_count: u8 = @intCast(qt.sizeof(comp) * 8);",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "const",
      "name": "bit_count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to candidates from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "const candidates: [4]QualType = if (qt.signedness(comp) == .signed)\n        .{ .short, .int, .long, .long_long }\n    else\n        .{ .ushort, .uint, .ulong, .ulong_long };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "const",
      "name": "candidates",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to source_id from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "const source_id: Source.Id = @enumFromInt(comp.sources.count() + 2);",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "const",
      "name": "source_id",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to source from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "const source: Source = .{\n        .id = source_id,\n        .path = duped_path,\n        .buf = contents,\n        .splice_locs = splice_locs,\n        .kind = kind,\n    };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "const",
      "name": "source",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to diagnostic from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "const diagnostic: Diagnostic = .backslash_newline_escape;",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "const",
      "name": "diagnostic",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to framework_name from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "const framework_name: []const u8, const header_sub_path: []const u8 = f: {\n            const i = std.mem.indexOfScalar(u8, find.include_path, '/') orelse return null;",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "const",
      "name": "framework_name",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to diagnostic from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "const diagnostic: Diagnostic = .ms_search_rule;",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "const",
      "name": "diagnostic",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to backslash_newline_escape from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub const backslash_newline_escape: Diagnostic = .{\n        .fmt = \"backslash and newline separated by space\",\n        .kind = .warning,\n        .opt = .@\"backslash-newline-escape\",\n    };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "const",
      "name": "backslash_newline_escape",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ms_search_rule from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub const ms_search_rule: Diagnostic = .{\n        .fmt = \"#include resolved using non-portable Microsoft search rules as: {s}\",\n        .kind = .warning,\n        .opt = .@\"microsoft-include\",\n        .extension = true,\n    };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "const",
      "name": "ms_search_rule",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ctrl_z_eof from Vexu/arocc",
    "context": "Repository: Vexu/arocc (1509 ⭐)\nFile: src/aro/Compilation.zig",
    "response": "pub const ctrl_z_eof: Diagnostic = .{\n        .fmt = \"treating Ctrl-Z as end-of-file is a Microsoft extension\",\n        .kind = .off,\n        .opt = .@\"microsoft-end-of-file\",\n        .extension = true,\n    };",
    "metadata": {
      "repo": "Vexu/arocc",
      "stars": 1509,
      "file": "src/aro/Compilation.zig",
      "type": "const",
      "name": "ctrl_z_eof",
      "difficulty": "easy"
    }
  }
]