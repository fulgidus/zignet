[
  {
    "instruction": "Write a Zig function similar to main from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: .github/workflows/prepare_release_payload.zig",
    "response": "pub fn main() !void {\n    var arena_allocator: std.heap.ArenaAllocator = .init(std.heap.page_allocator);\n    const arena = arena_allocator.allocator();\n\n    const metadata_source = try std.fs.cwd().readFileAlloc(\"zig-out/release.json\", arena, .limited(std.math.maxInt(u32)));\n    const artifacts_dir = try std.fs.cwd().openDir(\"zig-out/artifacts\", .{ .iterate = true }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": ".github/workflows/prepare_release_payload.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to createRequestBody from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: .github/workflows/prepare_release_payload.zig",
    "response": "fn createRequestBody(\n    writer: *std.Io.Writer,\n    artifacts_dir: std.fs.Dir,\n    metadata: Metadata,\n    compatibility: []const u8,\n) !void {\n    var write_stream: std.json.Stringify = .{\n        .writer = writer,\n        .options = .{ .whitespace = .indent_2 }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": ".github/workflows/prepare_release_payload.zig",
      "type": "function",
      "name": "createRequestBody",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Metadata from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: .github/workflows/prepare_release_payload.zig",
    "response": "pub const Metadata = struct {\n    zlsVersion: []const u8,\n    zigVersion: []const u8,\n    minimumBuildZigVersion: []const u8,\n    minimumRuntimeZigVersion: []const u8,\n    files: []const []const u8,\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": ".github/workflows/prepare_release_payload.zig",
      "type": "struct",
      "name": "Metadata",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: build.zig",
    "response": "pub fn build(b: *Build) !void {\n    const target = b.standardTargetOptions(.{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "build.zig",
      "type": "function",
      "name": "build",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getVersion from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: build.zig",
    "response": "fn getVersion(b: *Build) std.SemanticVersion {\n    const version_string = b.option([]const u8, \"version-string\", \"Override the version of this build. Must be a semantic version.\");\n    if (version_string) |semver_string| {\n        return std.SemanticVersion.parse(semver_string) catch |err| {\n            std.debug.panic(\"Expected -Dversion-string={s}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "build.zig",
      "type": "function",
      "name": "getVersion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to createZLSModule from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: build.zig",
    "response": "fn createZLSModule(\n    b: *Build,\n    options: struct {\n        target: Build.ResolvedTarget,\n        optimize: std.builtin.OptimizeMode,\n        tracy_enable: bool,\n        tracy_options: *std.Build.Module,\n        build_options: *std.Build.Module,\n        version_data: *std.Build.Module,\n    },\n) *std.Build.Module {\n    const diffz_module = b.dependency(\"diffz\", .{\n        .target = options.target,\n        .optimize = options.optimize,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "build.zig",
      "type": "function",
      "name": "createZLSModule",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to createTracyModule from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: build.zig",
    "response": "fn createTracyModule(\n    b: *Build,\n    options: struct {\n        target: Build.ResolvedTarget,\n        optimize: std.builtin.OptimizeMode,\n        enable: bool,\n        tracy_options: *std.Build.Module,\n    },\n) *Build.Module {\n    const tracy_module = b.createModule(.{\n        .root_source_file = b.path(\"src/tracy.zig\"),\n        .target = options.target,\n        .optimize = options.optimize,\n        .imports = &.{\n            .{ .name = \"options\", .module = options.tracy_options }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "build.zig",
      "type": "function",
      "name": "createTracyModule",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to release from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: build.zig",
    "response": "fn release(b: *Build, release_artifacts: []const *Build.Step.Compile, released_zls_version: std.SemanticVersion) void {\n    std.debug.assert(release_artifacts.len > 0);\n\n    const release_step = b.step(\"release\", \"Build all release artifacts. (requires tar and 7z)\");\n    const release_minisign = b.option(bool, \"release-minisign\", \"Sign release artifacts with Minisign\") orelse false;\n\n    if (released_zls_version.pre != null and released_zls_version.build == null) {\n        release_step.addError(\"Cannot build release because the ZLS version could not be resolved\", .{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "build.zig",
      "type": "function",
      "name": "release",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to zls_version from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: build.zig",
    "response": "const zls_version: std.SemanticVersion = .{ .major = 0, .minor = 16, .patch = 0, .pre = \"dev\" };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "build.zig",
      "type": "const",
      "name": "zls_version",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to args from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: build.zig",
    "response": "const args: []const ?[]const u8 = &.{\n            \"wasmtime\",\n            \"--dir=.\",\n            b.fmt(\"--dir={f}::/lib\", .{b.graph.zig_lib_directory}),\n            b.fmt(\"--dir={s}::/cache\", .{b.cache_root.join(b.allocator, &.{\"zls\"}) catch @panic(\"OOM\")}),\n            \"--\",\n            null,\n        };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "build.zig",
      "type": "const",
      "name": "args",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to argv from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: build.zig",
    "response": "const argv: []const []const u8 = &.{\n        \"git\", \"-C\", b.pathFromRoot(\".\"), \"--git-dir\", \".git\", \"describe\", \"--match\", \"*.*.*\", \"--tags\",\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "build.zig",
      "type": "const",
      "name": "argv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to extensions from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: build.zig",
    "response": "const extensions: []const FileExtension = if (is_windows) &.{.zip} else &.{ .@\"tar.xz\", .@\"tar.gz\" };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "build.zig",
      "type": "const",
      "name": "extensions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to install_dir from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: build.zig",
    "response": "const install_dir: std.Build.InstallDir = .{ .custom = \"artifacts\" };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "build.zig",
      "type": "const",
      "name": "install_dir",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to min_build_zig_simple from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: build.zig",
    "response": "const min_build_zig_simple: std.SemanticVersion = .{ .major = min_build_zig.major, .minor = min_build_zig.minor, .patch = 0 };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "build.zig",
      "type": "const",
      "name": "min_build_zig_simple",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to min_runtime_zig_simple from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: build.zig",
    "response": "const min_runtime_zig_simple: std.SemanticVersion = .{ .major = min_runtime_zig.major, .minor = min_runtime_zig.minor, .patch = 0 };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "build.zig",
      "type": "const",
      "name": "min_runtime_zig_simple",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to zls_version_simple from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: build.zig",
    "response": "const zls_version_simple: std.SemanticVersion = .{ .major = zls_version.major, .minor = zls_version.minor, .patch = 0 };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "build.zig",
      "type": "const",
      "name": "zls_version_simple",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to current_zig_simple from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: build.zig",
    "response": "const current_zig_simple: std.SemanticVersion = .{ .major = builtin.zig_version.major, .minor = builtin.zig_version.minor, .patch = 0 };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "build.zig",
      "type": "const",
      "name": "current_zig_simple",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dupe from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/BuildAssociatedConfig.zig",
    "response": "pub fn dupe(self: BuildOption, allocator: std.mem.Allocator) !BuildOption {\n        const copy_name = try allocator.dupe(u8, self.name);\n        errdefer allocator.free(copy_name);\n        const copy_value = if (self.value) |val|\n            try allocator.dupe(u8, val)\n        else\n            null;\n        return .{\n            .name = copy_name,\n            .value = copy_value,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/BuildAssociatedConfig.zig",
      "type": "function",
      "name": "dupe",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to formatParam from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/BuildAssociatedConfig.zig",
    "response": "pub fn formatParam(self: BuildOption, allocator: std.mem.Allocator) ![]const u8 {\n        if (self.value) |val| {\n            return try std.fmt.allocPrint(allocator, \"-D{s}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/BuildAssociatedConfig.zig",
      "type": "function",
      "name": "formatParam",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to BuildOption from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/BuildAssociatedConfig.zig",
    "response": "pub const BuildOption = struct {\n    name: []const u8,\n    value: ?[]const u8 = null,\n\n    /// Duplicates the `BuildOption`, copying internal strings. Caller owns returned option with contents\n    /// allocated using `allocator`.\n    pub fn dupe(self: BuildOption, allocator: std.mem.Allocator) !BuildOption {\n        const copy_name = try allocator.dupe(u8, self.name);\n        errdefer allocator.free(copy_name);\n        const copy_value = if (self.value) |val|\n            try allocator.dupe(u8, val)\n        else\n            null;\n        return .{\n            .name = copy_name,\n            .value = copy_value,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/BuildAssociatedConfig.zig",
      "type": "struct",
      "name": "BuildOption",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DiagnosticsCollection.zig",
    "response": "pub fn deinit(collection: *DiagnosticsCollection) void {\n    for (collection.tag_set.values()) |*entry| {\n        entry.error_bundle.deinit(collection.allocator);\n        if (entry.error_bundle_src_base_path) |src_path| collection.allocator.free(src_path);\n        for (entry.diagnostics_set.keys(), entry.diagnostics_set.values()) |uri, *lsp_diagnostic| {\n            collection.allocator.free(uri);\n            lsp_diagnostic.arena.promote(collection.allocator).deinit();\n            lsp_diagnostic.error_bundle.deinit(collection.allocator);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DiagnosticsCollection.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to pushSingleDocumentDiagnostics from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DiagnosticsCollection.zig",
    "response": "pub fn pushSingleDocumentDiagnostics(\n    collection: *DiagnosticsCollection,\n    tag: Tag,\n    document_uri: []const u8,\n    /// LSP and ErrorBundle will not override each other.\n    ///\n    /// Takes ownership on success.\n    diagnostics: union(enum) {\n        lsp: struct {\n            arena: std.heap.ArenaAllocator.State,\n            diagnostics: []lsp.types.Diagnostic,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DiagnosticsCollection.zig",
      "type": "function",
      "name": "pushSingleDocumentDiagnostics",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pushErrorBundle from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DiagnosticsCollection.zig",
    "response": "pub fn pushErrorBundle(\n    collection: *DiagnosticsCollection,\n    /// All changes will affect diagnostics with the same tag.\n    tag: Tag,\n    /// * If the `version` is greater than the old version, all diagnostics get removed and the errors from `error_bundle` get added and the `version` is updated.\n    /// * If the `version` is equal   to   the old version, the errors from `error_bundle` get added.\n    /// * If the `version` is less    than the old version, the errors from `error_bundle` are ignored.\n    version: u32,\n    /// Used to resolve relative `std.zig.ErrorBundle.SourceLocation.src_path`\n    ///\n    /// The current implementation assumes that the base path is always the same for the same tag.\n    src_base_path: ?[]const u8,\n    error_bundle: std.zig.ErrorBundle,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DiagnosticsCollection.zig",
      "type": "function",
      "name": "pushErrorBundle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to clearErrorBundle from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DiagnosticsCollection.zig",
    "response": "pub fn clearErrorBundle(collection: *DiagnosticsCollection, tag: Tag) void {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    collection.mutex.lock();\n    defer collection.mutex.unlock();\n\n    const item = collection.tag_set.getPtr(tag) orelse return;\n\n    collectUrisFromErrorBundle(\n        collection.allocator,\n        item.error_bundle,\n        item.error_bundle_src_base_path,\n        &collection.outdated_files,\n    ) catch |err| switch (err) {\n        error.OutOfMemory => return,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DiagnosticsCollection.zig",
      "type": "function",
      "name": "clearErrorBundle",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to collectUrisFromErrorBundle from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DiagnosticsCollection.zig",
    "response": "fn collectUrisFromErrorBundle(\n    allocator: std.mem.Allocator,\n    error_bundle: std.zig.ErrorBundle,\n    src_base_path: ?[]const u8,\n    uri_set: *std.StringArrayHashMapUnmanaged(void),\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DiagnosticsCollection.zig",
      "type": "function",
      "name": "collectUrisFromErrorBundle",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to pathToUri from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DiagnosticsCollection.zig",
    "response": "fn pathToUri(allocator: std.mem.Allocator, base_path: ?[]const u8, src_path: []const u8) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DiagnosticsCollection.zig",
      "type": "function",
      "name": "pathToUri",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to publishDiagnostics from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DiagnosticsCollection.zig",
    "response": "pub fn publishDiagnostics(collection: *DiagnosticsCollection) (std.mem.Allocator.Error || std.posix.WriteError)!void {\n    const transport = collection.transport orelse return;\n\n    var arena_allocator: std.heap.ArenaAllocator = .init(collection.allocator);\n    defer arena_allocator.deinit();\n\n    while (true) {\n        const json_message = blk: {\n            collection.mutex.lock();\n            defer collection.mutex.unlock();\n\n            const entry = collection.outdated_files.pop() orelse break;\n            defer collection.allocator.free(entry.key);\n            const document_uri = entry.key;\n\n            _ = arena_allocator.reset(.retain_capacity);\n\n            var diagnostics: std.ArrayList(lsp.types.Diagnostic) = .empty;\n            try collection.collectLspDiagnosticsForDocument(document_uri, collection.offset_encoding, arena_allocator.allocator(), &diagnostics);\n\n            const notification: lsp.TypedJsonRPCNotification(lsp.types.PublishDiagnosticsParams) = .{\n                .method = \"textDocument/publishDiagnostics\",\n                .params = .{\n                    .uri = document_uri,\n                    .diagnostics = diagnostics.items,\n                }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DiagnosticsCollection.zig",
      "type": "function",
      "name": "publishDiagnostics",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to collectLspDiagnosticsForDocument from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DiagnosticsCollection.zig",
    "response": "fn collectLspDiagnosticsForDocument(\n    collection: *DiagnosticsCollection,\n    document_uri: []const u8,\n    offset_encoding: offsets.Encoding,\n    arena: std.mem.Allocator,\n    diagnostics: *std.ArrayList(lsp.types.Diagnostic),\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DiagnosticsCollection.zig",
      "type": "function",
      "name": "collectLspDiagnosticsForDocument",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to convertErrorBundleToLSPDiangostics from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DiagnosticsCollection.zig",
    "response": "fn convertErrorBundleToLSPDiangostics(\n    eb: std.zig.ErrorBundle,\n    error_bundle_src_base_path: ?[]const u8,\n    document_uri: []const u8,\n    offset_encoding: offsets.Encoding,\n    arena: std.mem.Allocator,\n    diagnostics: *std.ArrayList(lsp.types.Diagnostic),\n    is_single_document: bool,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DiagnosticsCollection.zig",
      "type": "function",
      "name": "convertErrorBundleToLSPDiangostics",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to errorBundleSourceLocationToRange from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DiagnosticsCollection.zig",
    "response": "fn errorBundleSourceLocationToRange(\n    error_bundle: std.zig.ErrorBundle,\n    src_loc: std.zig.ErrorBundle.SourceLocation,\n    offset_encoding: offsets.Encoding,\n) lsp.types.Range {\n    // We assume that the span is inside of the source line\n    const source_line_range_utf8: lsp.types.Range = .{\n        .start = .{ .line = 0, .character = src_loc.column - (src_loc.span_main - src_loc.span_start) }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DiagnosticsCollection.zig",
      "type": "function",
      "name": "errorBundleSourceLocationToRange",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to createTestingErrorBundle from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DiagnosticsCollection.zig",
    "response": "fn createTestingErrorBundle(\n    messages: []const struct {\n        message: []const u8,\n        count: u32 = 1,\n        source_location: struct {\n            src_path: []const u8,\n            line: u32,\n            column: u32,\n            span_start: u32,\n            span_main: u32,\n            span_end: u32,\n            source_line: ?[]const u8,\n        } = .{ .src_path = testing_src_path, .line = 0, .column = 0, .span_start = 0, .span_main = 0, .span_end = 0, .source_line = \"\" },\n    },\n    compile_log_text: []const u8,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DiagnosticsCollection.zig",
      "type": "function",
      "name": "createTestingErrorBundle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to notification from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DiagnosticsCollection.zig",
    "response": "const notification: lsp.TypedJsonRPCNotification(lsp.types.PublishDiagnosticsParams) = .{\n                .method = \"textDocument/publishDiagnostics\",\n                .params = .{\n                    .uri = document_uri,\n                    .diagnostics = diagnostics.items,\n                },\n            };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DiagnosticsCollection.zig",
      "type": "const",
      "name": "notification",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to source_line_range_utf8 from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DiagnosticsCollection.zig",
    "response": "const source_line_range_utf8: lsp.types.Range = .{\n        .start = .{ .line = 0, .character = src_loc.column - (src_loc.span_main - src_loc.span_start) },\n        .end = .{ .line = 0, .character = src_loc.column + (src_loc.span_end - src_loc.span_main) },\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DiagnosticsCollection.zig",
      "type": "const",
      "name": "source_line_range_utf8",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn eql(self: @This(), a: Ast.TokenIndex, b: Ast.TokenIndex, b_index: usize) bool {\n        _ = b_index;\n        if (a == b) return true;\n        const a_name = offsets.identifierTokenToNameSlice(self.tree, a);\n        const b_name = offsets.identifierTokenToNameSlice(self.tree, b);\n        return std.mem.eql(u8, a_name, b_name);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn hash(self: @This(), token: Ast.TokenIndex) u32 {\n        const name = offsets.identifierTokenToNameSlice(self.tree, token);\n        return std.array_hash_map.hashString(name);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "hash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn hash(self: @This(), s: DeclarationLookup) u32 {\n        _ = self;\n        var hasher: std.hash.Wyhash = .init(0);\n        std.hash.autoHash(&hasher, s.scope);\n        hasher.update(s.name);\n        std.hash.autoHash(&hasher, s.kind);\n        return @truncate(hasher.final());\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "hash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn eql(self: @This(), a: DeclarationLookup, b: DeclarationLookup, b_index: usize) bool {\n        _ = self;\n        _ = b_index;\n        return a.scope == b.scope and a.kind == b.kind and std.mem.eql(u8, a.name, b.name);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn get(self: Param, tree: Ast) ?Ast.full.FnProto.Param {\n            var buffer: [1]Ast.Node.Index = undefined;\n            const func = tree.fullFnProto(&buffer, self.func).?;\n            var param_index: u16 = 0;\n            var it = func.iterate(&tree);\n            while (ast.nextFnParam(&it)) |param| : (param_index += 1) {\n                if (self.param_index == param_index) return param;\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "get",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getVarDeclNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn getVarDeclNode(self: AssignDestructure, tree: Ast) Ast.Node.Index {\n            const extra_index = tree.nodeData(self.node).extra_and_node[0];\n            return @enumFromInt(tree.extra_data[@intFromEnum(extra_index) + 1 ..][self.index]);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "getVarDeclNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getFullVarDecl from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn getFullVarDecl(self: AssignDestructure, tree: Ast) Ast.full.VarDecl {\n            return tree.fullVarDecl(self.getVarDeclNode(tree)).?;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "getFullVarDecl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getCase from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn getCase(self: Switch, tree: Ast) Ast.full.SwitchCase {\n            const extra_index = tree.nodeData(self.node).node_and_extra[1];\n            const cases = tree.extraDataSlice(tree.extraData(extra_index, Ast.Node.SubRange), Ast.Node.Index);\n            return tree.fullSwitchCase(cases[self.case_index]).?;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "getCase",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toOptional from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn toOptional(index: Index) OptionalIndex {\n            return @enumFromInt(@intFromEnum(index));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "toOptional",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to unwrap from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn unwrap(index: OptionalIndex) ?Index {\n            if (index == .none) return null;\n            return @enumFromInt(@intFromEnum(index));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "unwrap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn eql(a: Declaration, b: Declaration) bool {\n        return std.meta.eql(a, b);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nameToken from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn nameToken(decl: Declaration, tree: Ast) Ast.TokenIndex {\n        return switch (decl) {\n            .ast_node => |node| {\n                var buffer: [1]Ast.Node.Index = undefined;\n                const token_index = switch (tree.nodeTag(node)) {\n                    .local_var_decl,\n                    .global_var_decl,\n                    .simple_var_decl,\n                    .aligned_var_decl,\n                    => tree.nodeMainToken(node) + 1,\n                    .fn_proto,\n                    .fn_proto_multi,\n                    .fn_proto_one,\n                    .fn_proto_simple,\n                    .fn_decl,\n                    => tree.fullFnProto(&buffer, node).?.name_token.?,\n\n                    .container_field,\n                    .container_field_init,\n                    .container_field_align,\n                    => tree.nodeMainToken(node),\n\n                    else => unreachable,\n                }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "nameToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isContainer from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn isContainer(self: @This()) bool {\n            return switch (self) {\n                .container => true,\n                .block, .function, .other => false,\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "isContainer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toOptional from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn toOptional(index: Index) OptionalIndex {\n            return @enumFromInt(@intFromEnum(index));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "toOptional",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to unwrap from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn unwrap(index: OptionalIndex) ?Index {\n            if (index == .none) return null;\n            return @enumFromInt(@intFromEnum(index));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "unwrap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn deinit(context: *ScopeContext) void {\n        context.child_scopes_scratch.deinit(context.allocator);\n        context.child_declarations_scratch.deinit(context.allocator);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pushDeclaration from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn pushDeclaration(\n            pushed: PushedScope,\n            identifier_token: Ast.TokenIndex,\n            declaration: Declaration,\n            kind: DeclarationLookup.Kind,\n        ) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "pushDeclaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to finalize from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn finalize(pushed: PushedScope) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "finalize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to startScope from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn startScope(context: *ScopeContext, tag: Scope.Tag, data: Scope.Data, loc: Scope.SmallLoc) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "startScope",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pushChildScope from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn pushChildScope(\n        context: *ScopeContext,\n        scope_index: Scope.Index,\n        child_scope_index: Scope.Index,\n    ) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "pushChildScope",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn init(allocator: std.mem.Allocator, tree: Ast) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn deinit(scope: *DocumentScope, allocator: std.mem.Allocator) void {\n    scope.scopes.deinit(allocator);\n    scope.declarations.deinit(allocator);\n    scope.declaration_lookup_map.deinit(allocator);\n    scope.extra.deinit(allocator);\n\n    scope.global_enum_set.deinit(allocator);\n    scope.global_error_set.deinit(allocator);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to locToSmallLoc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn locToSmallLoc(loc: offsets.Loc) Scope.SmallLoc {\n    return .{\n        .start = @intCast(loc.start),\n        .end = @intCast(loc.end),\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "locToSmallLoc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkNodeEnsureScope from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkNodeEnsureScope(\n    context: *ScopeContext,\n    tree: Ast,\n    node_idx: Ast.Node.Index,\n    start_token: Ast.TokenIndex,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkNodeEnsureScope",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkNode(\n    context: *ScopeContext,\n    tree: Ast,\n    node_idx: Ast.Node.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkContainerDecl from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkContainerDecl(\n    context: *ScopeContext,\n    tree: Ast,\n    node_idx: Ast.Node.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkContainerDecl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkErrorSetNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkErrorSetNode(\n    context: *ScopeContext,\n    tree: Ast,\n    node_idx: Ast.Node.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkErrorSetNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkFuncNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkFuncNode(\n    context: *ScopeContext,\n    tree: Ast,\n    node_idx: Ast.Node.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkFuncNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkBlockNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkBlockNode(\n    context: *ScopeContext,\n    tree: Ast,\n    node_idx: Ast.Node.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkBlockNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkBlockNodeKeepOpen from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkBlockNodeKeepOpen(\n    context: *ScopeContext,\n    tree: Ast,\n    node_idx: Ast.Node.Index,\n    start_token: Ast.TokenIndex,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkBlockNodeKeepOpen",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkIfNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkIfNode(\n    context: *ScopeContext,\n    tree: Ast,\n    node_idx: Ast.Node.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkIfNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkCatchNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkCatchNode(\n    context: *ScopeContext,\n    tree: Ast,\n    node_idx: Ast.Node.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkCatchNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkWhileNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkWhileNode(\n    context: *ScopeContext,\n    tree: Ast,\n    node_idx: Ast.Node.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkWhileNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkForNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkForNode(\n    context: *ScopeContext,\n    tree: Ast,\n    node_idx: Ast.Node.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkForNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkSwitchNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkSwitchNode(\n    context: *ScopeContext,\n    tree: Ast,\n    node_idx: Ast.Node.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkSwitchNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkErrdeferNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkErrdeferNode(\n    context: *ScopeContext,\n    tree: Ast,\n    node_idx: Ast.Node.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkErrdeferNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkUnaryOpNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkUnaryOpNode(context: *ScopeContext, tree: Ast, node_idx: Ast.Node.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkUnaryOpNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkBinOpNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkBinOpNode(context: *ScopeContext, tree: Ast, node_idx: Ast.Node.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkBinOpNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkOptNodeAndOptNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkOptNodeAndOptNode(context: *ScopeContext, tree: Ast, node_idx: Ast.Node.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkOptNodeAndOptNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkNodeAndOptNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkNodeAndOptNode(context: *ScopeContext, tree: Ast, node_idx: Ast.Node.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkNodeAndOptNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to walkOtherNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "fn walkOtherNode(\n    context: *ScopeContext,\n    tree: Ast,\n    node_idx: Ast.Node.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "walkOtherNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getScopeTag from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn getScopeTag(\n    doc_scope: DocumentScope,\n    scope: Scope.Index,\n) Scope.Tag {\n    return doc_scope.scopes.items(.data)[@intFromEnum(scope)].tag;\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "getScopeTag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getScopeParent from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn getScopeParent(\n    doc_scope: DocumentScope,\n    scope: Scope.Index,\n) Scope.OptionalIndex {\n    return doc_scope.scopes.items(.parent_scope)[@intFromEnum(scope)];\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "getScopeParent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getScopeAstNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn getScopeAstNode(\n    doc_scope: DocumentScope,\n    scope: Scope.Index,\n) ?Ast.Node.Index {\n    const slice = doc_scope.scopes.slice();\n\n    const data = slice.items(.data)[@intFromEnum(scope)];\n\n    return switch (data.tag) {\n        .container, .function, .block => data.data.ast_node,\n        .other => null,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "getScopeAstNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getScopeDeclaration from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn getScopeDeclaration(\n    doc_scope: DocumentScope,\n    lookup: DeclarationLookup,\n) Declaration.OptionalIndex {\n    return if (doc_scope.declaration_lookup_map.getIndex(lookup)) |idx|\n        @enumFromInt(idx)\n    else\n        .none;\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "getScopeDeclaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getScopeDeclarationsConst from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn getScopeDeclarationsConst(\n    doc_scope: DocumentScope,\n    scope: Scope.Index,\n) []const Declaration.Index {\n    const slice = doc_scope.scopes.slice();\n\n    if (slice.items(.data)[@intFromEnum(scope)].is_child_decls_small) {\n        const small = &slice.items(.child_declarations)[@intFromEnum(scope)].small;\n\n        for (0..Scope.ChildDeclarations.small_size) |idx| {\n            if (small[idx] == .none) {\n                return @ptrCast(small[0..idx]);\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "getScopeDeclarationsConst",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getScopeChildScopesConst from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub fn getScopeChildScopesConst(\n    doc_scope: DocumentScope,\n    scope: Scope.Index,\n) []const Scope.Index {\n    const slice = doc_scope.scopes.slice();\n\n    if (slice.items(.data)[@intFromEnum(scope)].is_child_scopes_small) {\n        const small = &slice.items(.child_scopes)[@intFromEnum(scope)].small;\n\n        for (0..Scope.ChildScopes.small_size) |idx| {\n            if (small[idx] == .none) {\n                return @ptrCast(small[0..idx]);\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "function",
      "name": "getScopeChildScopesConst",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to IdentifierTokenContext from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub const IdentifierTokenContext = struct {\n    tree: Ast,\n\n    pub fn eql(self: @This(), a: Ast.TokenIndex, b: Ast.TokenIndex, b_index: usize) bool {\n        _ = b_index;\n        if (a == b) return true;\n        const a_name = offsets.identifierTokenToNameSlice(self.tree, a);\n        const b_name = offsets.identifierTokenToNameSlice(self.tree, b);\n        return std.mem.eql(u8, a_name, b_name);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "struct",
      "name": "IdentifierTokenContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to DeclarationLookup from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub const DeclarationLookup = struct {\n    pub const Kind = enum { field, other, label }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "struct",
      "name": "DeclarationLookup",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to DeclarationLookupContext from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub const DeclarationLookupContext = struct {\n    pub fn hash(self: @This(), s: DeclarationLookup) u32 {\n        _ = self;\n        var hasher: std.hash.Wyhash = .init(0);\n        std.hash.autoHash(&hasher, s.scope);\n        hasher.update(s.name);\n        std.hash.autoHash(&hasher, s.kind);\n        return @truncate(hasher.final());\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "struct",
      "name": "DeclarationLookupContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Param from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub const Param = struct {\n        param_index: u16,\n        func: Ast.Node.Index,\n\n        pub fn get(self: Param, tree: Ast) ?Ast.full.FnProto.Param {\n            var buffer: [1]Ast.Node.Index = undefined;\n            const func = tree.fullFnProto(&buffer, self.func).?;\n            var param_index: u16 = 0;\n            var it = func.iterate(&tree);\n            while (ast.nextFnParam(&it)) |param| : (param_index += 1) {\n                if (self.param_index == param_index) return param;\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "struct",
      "name": "Param",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to AssignDestructure from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub const AssignDestructure = struct {\n        /// tag is .assign_destructure\n        node: Ast.Node.Index,\n        index: u32,\n\n        pub fn getVarDeclNode(self: AssignDestructure, tree: Ast) Ast.Node.Index {\n            const extra_index = tree.nodeData(self.node).extra_and_node[0];\n            return @enumFromInt(tree.extra_data[@intFromEnum(extra_index) + 1 ..][self.index]);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "struct",
      "name": "AssignDestructure",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Switch from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub const Switch = struct {\n        /// tag is `.@\"switch\"` or `.switch_comma`\n        node: Ast.Node.Index,\n        /// is guaranteed to have a payload_token\n        case_index: u32,\n\n        pub fn getCase(self: Switch, tree: Ast) Ast.full.SwitchCase {\n            const extra_index = tree.nodeData(self.node).node_and_extra[1];\n            const cases = tree.extraDataSlice(tree.extraData(extra_index, Ast.Node.SubRange), Ast.Node.Index);\n            return tree.fullSwitchCase(cases[self.case_index]).?;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "struct",
      "name": "Switch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Scope from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "pub const Scope = struct {\n    pub const Tag = enum(u3) {\n        /// `tree.nodeTag(ast_node)` is ContainerDecl or Root or ErrorSetDecl\n        container,\n        /// `tree.nodeTag(ast_node)` is FnProto\n        function,\n        /// `tree.nodeTag(ast_node)` is Block\n        block,\n        other,\n\n        pub fn isContainer(self: @This()) bool {\n            return switch (self) {\n                .container => true,\n                .block, .function, .other => false,\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "struct",
      "name": "Scope",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ScopeContext from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "const ScopeContext = struct {\n    allocator: std.mem.Allocator,\n    tree: Ast,\n    doc_scope: *DocumentScope,\n\n    current_scope: Scope.OptionalIndex = .none,\n    child_scopes_scratch: std.ArrayList(Scope.Index) = .empty,\n    child_declarations_scratch: std.ArrayList(Declaration.Index) = .empty,\n\n    fn deinit(context: *ScopeContext) void {\n        context.child_scopes_scratch.deinit(context.allocator);\n        context.child_declarations_scratch.deinit(context.allocator);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "struct",
      "name": "ScopeContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to PushedScope from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "const PushedScope = struct {\n        context: *ScopeContext,\n\n        scope: Scope.Index,\n\n        scopes_start: u32,\n        declarations_start: u32,\n\n        fn pushDeclaration(\n            pushed: PushedScope,\n            identifier_token: Ast.TokenIndex,\n            declaration: Declaration,\n            kind: DeclarationLookup.Kind,\n        ) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "struct",
      "name": "PushedScope",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to declaration_index from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "const declaration_index: Declaration.Index = @enumFromInt(doc_scope.declarations.len - 1);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "const",
      "name": "declaration_index",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to new_scope_index from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "const new_scope_index: Scope.Index = @enumFromInt(context.doc_scope.scopes.len - 1);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "const",
      "name": "new_scope_index",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to identifier_token from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "const identifier_token: Ast.TokenIndex = @intCast(tok_i);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "const",
      "name": "identifier_token",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to decl from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "const decl: Declaration = if (if_node.error_token != null)\n            .{ .error_union_payload = .{ .identifier = name_token, .condition = if_node.ast.cond_expr } }\n        else\n            .{ .optional_payload = .{ .identifier = name_token, .condition = if_node.ast.cond_expr } };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "const",
      "name": "decl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to decl from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "const decl: Declaration = if (while_node.error_token != null)\n            .{ .error_union_payload = .{ .identifier = name_token, .condition = while_node.ast.cond_expr } }\n        else\n            .{ .optional_payload = .{ .identifier = name_token, .condition = while_node.ast.cond_expr } };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "const",
      "name": "decl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to switch_case from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentScope.zig",
    "response": "const switch_case: Ast.full.SwitchCase = tree.fullSwitchCase(case).?;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentScope.zig",
      "type": "const",
      "name": "switch_case",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to computeHash from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn computeHash(bytes: []const u8) Hash {\n    var hasher: Hasher = .init(&@splat(0));\n    hasher.update(bytes);\n    var hash: Hash = undefined;\n    hasher.final(&hash);\n    return hash;\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "computeHash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tryLockConfig from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn tryLockConfig(self: *BuildFile) ?BuildConfig {\n        self.impl.mutex.lock();\n        return if (self.impl.config) |cfg| cfg.value else {\n            self.impl.mutex.unlock();\n            return null;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "tryLockConfig",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to unlockConfig from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn unlockConfig(self: *BuildFile) void {\n        self.impl.mutex.unlock();\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "unlockConfig",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to collectBuildConfigPackageUris from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn collectBuildConfigPackageUris(\n        self: *BuildFile,\n        allocator: std.mem.Allocator,\n        package_uris: *std.ArrayList(Uri),\n    ) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "collectBuildConfigPackageUris",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to collectBuildConfigIncludePaths from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn collectBuildConfigIncludePaths(\n        self: *BuildFile,\n        allocator: std.mem.Allocator,\n        include_paths: *std.ArrayList([]const u8),\n    ) !bool {\n        const tracy_zone = tracy.trace(@src());\n        defer tracy_zone.end();\n\n        const build_config = self.tryLockConfig() orelse return false;\n        defer self.unlockConfig();\n\n        try include_paths.ensureUnusedCapacity(allocator, build_config.include_dirs.len);\n        for (build_config.include_dirs) |include_path| {\n            const absolute_path = if (std.fs.path.isAbsolute(include_path))\n                try allocator.dupe(u8, include_path)\n            else blk: {\n                const build_file_dir = std.fs.path.dirname(self.uri).?;\n                const build_file_path = try URI.toFsPath(allocator, build_file_dir);\n                defer allocator.free(build_file_path);\n                break :blk try std.fs.path.join(allocator, &.{ build_file_path, include_path }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "collectBuildConfigIncludePaths",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn deinit(self: *BuildFile, allocator: std.mem.Allocator) void {\n        allocator.free(self.uri);\n        if (self.impl.config) |cfg| cfg.deinit();\n        if (self.builtin_uri) |builtin_uri| allocator.free(builtin_uri);\n        if (self.build_associated_config) |cfg| cfg.deinit();\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn deinit(self: *@This(), allocator: std.mem.Allocator) void {\n                    allocator.free(self.potential_build_files);\n                    self.has_been_checked.deinit(allocator);\n                    self.* = undefined;\n                }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn init(\n        allocator: std.mem.Allocator,\n        uri: Uri,\n        text: [:0]const u8,\n        lsp_synced: bool,\n    ) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn deinit(self: *Handle) void {\n        const tracy_zone = tracy.trace(@src());\n        defer tracy_zone.end();\n\n        const status = self.getStatus();\n\n        const allocator = self.impl.allocator;\n\n        if (status.has_zzoiir) switch (self.tree.mode) {\n            .zig => self.impl.zzoiir.zig.deinit(allocator),\n            .zon => self.impl.zzoiir.zon.deinit(allocator),\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getImportUris from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn getImportUris(self: *Handle) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "getImportUris",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getDocumentScope from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn getDocumentScope(self: *Handle) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "getDocumentScope",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to create from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn create(handle: *Handle, allocator: std.mem.Allocator) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "create",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getDocumentScopeCached from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn getDocumentScopeCached(self: *Handle) DocumentScope {\n        if (builtin.mode == .Debug) {\n            std.debug.assert(self.getStatus().has_document_scope);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "getDocumentScopeCached",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to create from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn create(handle: *Handle, allocator: std.mem.Allocator) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "create",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getAssociatedBuildFileUri from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn getAssociatedBuildFileUri(self: *Handle, document_store: *DocumentStore) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "getAssociatedBuildFileUri",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getAssociatedBuildFileUri2 from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn getAssociatedBuildFileUri2(self: *Handle, document_store: *DocumentStore) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "getAssociatedBuildFileUri2",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getLazy from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn getLazy(\n        self: *Handle,\n        comptime T: type,\n        comptime name: []const u8,\n        comptime Context: type,\n    ) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "getLazy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getStatus from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn getStatus(self: *const Handle) Status {\n        return @bitCast(self.impl.status.load(.acquire));\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "getStatus",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isLspSynced from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn isLspSynced(self: *const Handle) bool {\n        return self.getStatus().lsp_synced;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "isLspSynced",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to setLspSynced from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn setLspSynced(self: *Handle, lsp_synced: bool) bool {\n        if (lsp_synced) {\n            return self.impl.status.bitSet(@offsetOf(Handle.Status, \"lsp_synced\"), .release) == 1;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "setLspSynced",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseTree from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn parseTree(allocator: std.mem.Allocator, new_text: [:0]const u8, mode: Ast.Mode) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "parseTree",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn deinit(self: *DocumentStore) void {\n    for (self.handles.keys(), self.handles.values()) |uri, handle| {\n        handle.deinit();\n        self.allocator.destroy(handle);\n        self.allocator.free(uri);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getHandle from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn getHandle(self: *DocumentStore, uri: Uri) ?*Handle {\n    self.lock.lockShared();\n    defer self.lock.unlockShared();\n    return self.handles.get(uri);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "getHandle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to readFile from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn readFile(self: *DocumentStore, uri: Uri) ?[:0]u8 {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    const file_path = URI.toFsPath(self.allocator, uri) catch |err| {\n        log.err(\"failed to parse URI '{s}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "readFile",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getOrLoadHandle from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn getOrLoadHandle(self: *DocumentStore, uri: Uri) ?*Handle {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    if (self.getHandle(uri)) |handle| return handle;\n    const file_contents = self.readFile(uri) orelse return null;\n    return self.createAndStoreDocument(uri, file_contents, false) catch |err| {\n        log.err(\"failed to store document '{s}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "getOrLoadHandle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getBuildFile from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn getBuildFile(self: *DocumentStore, uri: Uri) ?*BuildFile {\n    comptime std.debug.assert(supports_build_system);\n    self.lock.lockShared();\n    defer self.lock.unlockShared();\n    return self.build_files.get(uri);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "getBuildFile",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getOrLoadBuildFile from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn getOrLoadBuildFile(self: *DocumentStore, uri: Uri) ?*BuildFile {\n    comptime std.debug.assert(supports_build_system);\n\n    if (self.getBuildFile(uri)) |build_file| return build_file;\n\n    const new_build_file: *BuildFile = blk: {\n        self.lock.lock();\n        defer self.lock.unlock();\n\n        const gop = self.build_files.getOrPut(self.allocator, uri) catch return null;\n        if (gop.found_existing) return gop.value_ptr.*;\n\n        gop.value_ptr.* = self.allocator.create(BuildFile) catch |err| {\n            self.build_files.swapRemoveAt(gop.index);\n            log.debug(\"Failed to load build file {s}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "getOrLoadBuildFile",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to openLspSyncedDocument from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn openLspSyncedDocument(self: *DocumentStore, uri: Uri, text: []const u8) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "openLspSyncedDocument",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to closeLspSyncedDocument from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn closeLspSyncedDocument(self: *DocumentStore, uri: Uri) void {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    const kv = self.handles.fetchSwapRemove(uri) orelse {\n        log.warn(\"Document not found: {s}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "closeLspSyncedDocument",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to refreshLspSyncedDocument from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn refreshLspSyncedDocument(self: *DocumentStore, uri: Uri, new_text: [:0]const u8) !void {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    if (self.handles.get(uri)) |old_handle| {\n        if (!old_handle.isLspSynced()) {\n            log.warn(\"Document modified without being opened: {s}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "refreshLspSyncedDocument",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to refreshDocumentFromFileSystem from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn refreshDocumentFromFileSystem(self: *DocumentStore, uri: Uri, should_delete: bool) !bool {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    if (should_delete) {\n        const index = self.handles.getIndex(uri) orelse return false;\n        const handle = self.handles.values()[index];\n        if (handle.isLspSynced()) return false;\n\n        self.handles.swapRemoveAt(index);\n        const handle_uri = handle.uri;\n        handle.deinit();\n        self.allocator.destroy(handle);\n        self.allocator.free(handle_uri);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "refreshDocumentFromFileSystem",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to invalidateBuildFile from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn invalidateBuildFile(self: *DocumentStore, build_file_uri: Uri) void {\n    comptime std.debug.assert(supports_build_system);\n\n    if (self.config.zig_exe_path == null) return;\n    if (self.config.build_runner_path == null) return;\n    if (self.config.global_cache_dir == null) return;\n    if (self.config.zig_lib_dir == null) return;\n\n    const build_file = self.getBuildFile(build_file_uri) orelse return;\n\n    self.thread_pool.spawn(invalidateBuildFileWorker, .{ self, build_file }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "invalidateBuildFile",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sendMessageToClient from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn sendMessageToClient(allocator: std.mem.Allocator, transport: *lsp.Transport, message: anytype) !void {\n    const serialized = try std.json.Stringify.valueAlloc(\n        allocator,\n        message,\n        .{ .emit_null_optional_fields = false }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "sendMessageToClient",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to notifyBuildStart from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn notifyBuildStart(self: *DocumentStore) void {\n    if (!self.lsp_capabilities.supports_work_done_progress) return;\n\n    const transport = self.transport orelse return;\n\n    // Atomicity note: We do not actually care about memory surrounding the\n    // counter, we only care about the counter itself. We only need to ensure\n    // we aren't double entering/exiting\n    const prev = self.builds_in_progress.fetchAdd(1, .monotonic);\n    if (prev != 0) return;\n\n    sendMessageToClient(\n        self.allocator,\n        transport,\n        .{\n            .jsonrpc = \"2.0\",\n            .id = \"progress\",\n            .method = \"window/workDoneProgress/create\",\n            .params = lsp.types.WorkDoneProgressCreateParams{\n                .token = .{ .string = progress_token }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "notifyBuildStart",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to notifyBuildEnd from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn notifyBuildEnd(self: *DocumentStore, status: EndStatus) void {\n    if (!self.lsp_capabilities.supports_work_done_progress) return;\n\n    const transport = self.transport orelse return;\n\n    // Atomicity note: We do not actually care about memory surrounding the\n    // counter, we only care about the counter itself. We only need to ensure\n    // we aren't double entering/exiting\n    const prev = self.builds_in_progress.fetchSub(1, .monotonic);\n    if (prev != 1) return;\n\n    const message = switch (status) {\n        .failed => \"Failed\",\n        .success => \"Success\",\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "notifyBuildEnd",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to invalidateBuildFileWorker from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn invalidateBuildFileWorker(self: *DocumentStore, build_file: *BuildFile) void {\n    {\n        build_file.impl.mutex.lock();\n        defer build_file.impl.mutex.unlock();\n\n        switch (build_file.impl.build_runner_state) {\n            .idle => build_file.impl.build_runner_state = .running,\n            .running => {\n                build_file.impl.build_runner_state = .running_but_already_invalidated;\n                return;\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "invalidateBuildFileWorker",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isBuildFile from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn isBuildFile(uri: Uri) bool {\n    return std.mem.endsWith(u8, uri, \"/build.zig\");\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "isBuildFile",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isBuiltinFile from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn isBuiltinFile(uri: Uri) bool {\n    return std.mem.endsWith(u8, uri, \"/builtin.zig\");\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "isBuiltinFile",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isInStd from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn isInStd(uri: Uri) bool {\n    // TODO: Better logic for detecting std or subdirectories?\n    return std.mem.indexOf(u8, uri, \"/std/\") != null;\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "isInStd",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to loadBuildAssociatedConfiguration from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn loadBuildAssociatedConfiguration(allocator: std.mem.Allocator, build_file: BuildFile) !std.json.Parsed(BuildAssociatedConfig) {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    const build_file_path = try URI.toFsPath(allocator, build_file.uri);\n    defer allocator.free(build_file_path);\n    const config_file_path = try std.fs.path.resolve(allocator, &.{ build_file_path, \"..\", \"zls.build.json\" }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "loadBuildAssociatedConfiguration",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to prepareBuildRunnerArgs from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn prepareBuildRunnerArgs(self: *DocumentStore, build_file_uri: []const u8) ![][]const u8 {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    const base_args = &[_][]const u8{\n        self.config.zig_exe_path.?,\n        \"build\",\n        \"--build-runner\",\n        self.config.build_runner_path.?,\n        \"--zig-lib-dir\",\n        self.config.zig_lib_dir.?.path orelse \".\",\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "prepareBuildRunnerArgs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to loadBuildConfiguration from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn loadBuildConfiguration(self: *DocumentStore, build_file_uri: Uri, build_file_version: u32) !std.json.Parsed(BuildConfig) {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    std.debug.assert(self.config.zig_exe_path != null);\n    std.debug.assert(self.config.build_runner_path != null);\n    std.debug.assert(self.config.global_cache_dir != null);\n    std.debug.assert(self.config.zig_lib_dir != null);\n\n    const build_file_path = try URI.toFsPath(self.allocator, build_file_uri);\n    defer self.allocator.free(build_file_path);\n\n    const cwd = std.fs.path.dirname(build_file_path).?;\n\n    const args = try self.prepareBuildRunnerArgs(build_file_uri);\n    defer {\n        for (args) |arg| self.allocator.free(arg);\n        self.allocator.free(args);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "loadBuildConfiguration",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildDotZigExists from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn buildDotZigExists(dir_path: []const u8) bool {\n    var dir = std.fs.openDirAbsolute(dir_path, .{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "buildDotZigExists",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to collectPotentialBuildFiles from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn collectPotentialBuildFiles(self: *DocumentStore, uri: Uri) ![]*BuildFile {\n    if (isInStd(uri)) return &.{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "collectPotentialBuildFiles",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to createBuildFile from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn createBuildFile(self: *DocumentStore, uri: Uri) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "createBuildFile",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to uriAssociatedWithBuild from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn uriAssociatedWithBuild(\n    self: *DocumentStore,\n    build_file: *BuildFile,\n    uri: Uri,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "uriAssociatedWithBuild",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to uriInImports from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn uriInImports(\n    self: *DocumentStore,\n    checked_uris: *std.StringHashMapUnmanaged(void),\n    build_file_uri: Uri,\n    source_uri: Uri,\n    uri: Uri,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "uriInImports",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to createAndStoreDocument from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn createAndStoreDocument(\n    self: *DocumentStore,\n    uri: Uri,\n    text: [:0]const u8,\n    lsp_synced: bool,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "createAndStoreDocument",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to collectCIncludes from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn collectCIncludes(allocator: std.mem.Allocator, tree: Ast) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "collectCIncludes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to collectDependencies from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn collectDependencies(\n    store: *DocumentStore,\n    allocator: std.mem.Allocator,\n    handle: *Handle,\n    dependencies: *std.ArrayList(Uri),\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "collectDependencies",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to collectIncludeDirs from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn collectIncludeDirs(\n    store: *DocumentStore,\n    allocator: std.mem.Allocator,\n    handle: *Handle,\n    include_dirs: *std.ArrayList([]const u8),\n) !bool {\n    comptime std.debug.assert(supports_build_system);\n\n    var arena_allocator: std.heap.ArenaAllocator = .init(allocator);\n    defer arena_allocator.deinit();\n\n    const target_info: std.Target = .{\n        .cpu = .{\n            .arch = builtin.cpu.arch,\n            .model = undefined,\n            .features = undefined,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "collectIncludeDirs",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to collectCMacros from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn collectCMacros(\n    store: *DocumentStore,\n    allocator: std.mem.Allocator,\n    handle: *Handle,\n    c_macros: *std.ArrayList([]const u8),\n) !bool {\n    comptime std.debug.assert(supports_build_system);\n\n    const collected_all = switch (try handle.getAssociatedBuildFileUri2(store)) {\n        .none => true,\n        .unresolved => false,\n        .resolved => |build_file| blk: {\n            const build_config = build_file.tryLockConfig() orelse break :blk false;\n            defer build_file.unlockConfig();\n\n            try c_macros.ensureUnusedCapacity(allocator, build_config.c_macros.len);\n            for (build_config.c_macros) |c_macro| {\n                c_macros.appendAssumeCapacity(try allocator.dupe(u8, c_macro));\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "collectCMacros",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveCImport from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn resolveCImport(self: *DocumentStore, handle: *Handle, node: Ast.Node.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "resolveCImport",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to publishCimportDiagnostics from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn publishCimportDiagnostics(self: *DocumentStore, handle: *Handle) !void {\n    var wip: std.zig.ErrorBundle.Wip = undefined;\n    try wip.init(self.allocator);\n    defer wip.deinit();\n\n    const src_path = try wip.addString(\"\");\n\n    for (handle.cimports.items(.hash), handle.cimports.items(.node)) |hash, node| {\n        const result = blk: {\n            self.lock.lock();\n            defer self.lock.unlock();\n            break :blk self.cimports.get(hash) orelse continue;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "publishCimportDiagnostics",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to uriFromImportStr from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub fn uriFromImportStr(self: *DocumentStore, allocator: std.mem.Allocator, handle: *Handle, import_str: []const u8) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "uriFromImportStr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to uriFromFileImportStr from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "fn uriFromFileImportStr(allocator: std.mem.Allocator, handle: *Handle, import_str: []const u8) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "function",
      "name": "uriFromFileImportStr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Config from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub const Config = struct {\n    zig_exe_path: ?[]const u8,\n    zig_lib_dir: ?std.Build.Cache.Directory,\n    build_runner_path: ?[]const u8,\n    builtin_path: ?[]const u8,\n    global_cache_dir: ?std.Build.Cache.Directory,\n\n    pub const init: Config = .{\n        .zig_exe_path = null,\n        .zig_lib_dir = null,\n        .build_runner_path = null,\n        .builtin_path = null,\n        .global_cache_dir = null,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "struct",
      "name": "Config",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to BuildFile from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub const BuildFile = struct {\n    uri: Uri,\n    /// this build file may have an explicitly specified path to builtin.zig\n    builtin_uri: ?Uri = null,\n    /// config options extracted from zls.build.json\n    build_associated_config: ?std.json.Parsed(BuildAssociatedConfig) = null,\n    impl: struct {\n        mutex: std.Thread.Mutex = .{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "struct",
      "name": "BuildFile",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Handle from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub const Handle = struct {\n    uri: Uri,\n    tree: Ast,\n    /// Contains one entry for every cimport in the document\n    cimports: std.MultiArrayList(CImportHandle),\n\n    /// private field\n    impl: struct {\n        /// @bitCast from/to `Status`\n        status: std.atomic.Value(u32),\n        /// TODO can we avoid storing one allocator per Handle?\n        allocator: std.mem.Allocator,\n\n        lock: std.Thread.Mutex = .{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "struct",
      "name": "Handle",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ErrorMessage from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub const ErrorMessage = struct {\n    loc: offsets.Loc,\n    code: []const u8,\n    message: []const u8,\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "struct",
      "name": "ErrorMessage",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to CImportHandle from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub const CImportHandle = struct {\n    /// the `@cImport` node\n    node: Ast.Node.Index,\n    /// hash of c source file\n    hash: Hash,\n    /// c source file\n    source: []const u8,\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "struct",
      "name": "CImportHandle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to init from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "pub const init: Config = .{\n        .zig_exe_path = null,\n        .zig_lib_dir = null,\n        .build_runner_path = null,\n        .builtin_path = null,\n        .global_cache_dir = null,\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "const",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to package_uris from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "const package_uris: std.ArrayList([]const u8) = .empty;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "const",
      "name": "package_uris",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to include_paths from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "const include_paths: std.ArrayList([]u8) = .empty;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "const",
      "name": "include_paths",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to mode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "const mode: Ast.Mode = if (std.mem.eql(u8, std.fs.path.extension(uri), \".zon\")) .zon else .zig;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "const",
      "name": "mode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to new_build_file from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "const new_build_file: *BuildFile = blk: {\n        self.lock.lock();",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "const",
      "name": "new_build_file",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to diagnostic_tag from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "const diagnostic_tag: DiagnosticsCollection.Tag = tag: {\n        var hasher: std.hash.Wyhash = .init(47);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "const",
      "name": "diagnostic_tag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to parse_options from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "const parse_options: std.json.ParseOptions = .{\n        // We ignore unknown fields so people can roll\n        // their own build runners in libraries with\n        // the only requirement being general adherence\n        // to the BuildConfig type\n        .ignore_unknown_fields = true,\n        .allocate = .alloc_always,\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "const",
      "name": "parse_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to target_info from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "const target_info: std.Target = .{\n        .cpu = .{\n            .arch = builtin.cpu.arch,\n            .model = undefined,\n            .features = undefined,\n        },\n        .os = builtin.target.os,\n        .abi = .none,\n        .ofmt = comptime std.Target.ObjectFormat.default(builtin.os.tag, builtin.cpu.arch),\n        .dynamic_linker = std.Target.DynamicLinker.none,\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "const",
      "name": "target_info",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to native_paths from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "const native_paths: std.zig.system.NativePaths = try .detect(arena_allocator.allocator(), &target_info);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "const",
      "name": "native_paths",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to hash from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "const hash: Hash = handle.cimports.items(.hash)[index];",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "const",
      "name": "hash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to error_bundle from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/DocumentStore.zig",
    "response": "const error_bundle: std.zig.ErrorBundle = switch (result) {\n            .success => continue,\n            .failure => |bundle| bundle,\n        };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/DocumentStore.zig",
      "type": "const",
      "name": "error_bundle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn deinit(self: *ClientCapabilities, allocator: std.mem.Allocator) void {\n        if (self.client_name) |name| allocator.free(name);\n        self.* = undefined;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sendToClientResponse from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn sendToClientResponse(server: *Server, id: lsp.JsonRPCMessage.ID, result: anytype) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "sendToClientResponse",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sendToClientRequest from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn sendToClientRequest(server: *Server, id: lsp.JsonRPCMessage.ID, method: []const u8, params: anytype) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "sendToClientRequest",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sendToClientNotification from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn sendToClientNotification(server: *Server, method: []const u8, params: anytype) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "sendToClientNotification",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sendToClientResponseError from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn sendToClientResponseError(server: *Server, id: lsp.JsonRPCMessage.ID, err: lsp.JsonRPCMessage.Response.Error) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "sendToClientResponseError",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sendToClientInternal from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn sendToClientInternal(allocator: std.mem.Allocator, transport: ?*lsp.Transport, message: anytype) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "sendToClientInternal",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to showMessage from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "pub fn showMessage(\n    server: *Server,\n    message_type: types.MessageType,\n    comptime fmt: []const u8,\n    args: anytype,\n) void {\n    var message = std.fmt.allocPrint(server.allocator, fmt, args) catch return;\n    defer server.allocator.free(message);\n    switch (message_type) {\n        .Error => log.err(\"{s}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "showMessage",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to initAnalyser from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "pub fn initAnalyser(server: *Server, arena: std.mem.Allocator, handle: ?*DocumentStore.Handle) Analyser {\n    return .init(\n        server.allocator,\n        arena,\n        &server.document_store,\n        &server.ip,\n        handle,\n    );\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "initAnalyser",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to autofixWorkaround from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "pub fn autofixWorkaround(server: *Server) enum {\n    /// Autofix is implemented using `textDocument/willSaveWaitUntil`.\n    will_save_wait_until,\n    /// Autofix is implemented by send a `workspace/applyEdit` request after receiving a `textDocument/didSave` notification.\n    on_save,\n    /// No workaround implementation of autofix is possible.\n    unavailable,\n    /// The `force_autofix` config option is disabled.\n    none,\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "autofixWorkaround",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to autofix from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn autofix(server: *Server, arena: std.mem.Allocator, handle: *DocumentStore.Handle) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "autofix",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateDiagnostics from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn generateDiagnostics(server: *Server, handle: *DocumentStore.Handle) void {\n    if (!server.client_capabilities.supports_publish_diagnostics) return;\n    const do = struct {\n        fn do(param_server: *Server, param_handle: *DocumentStore.Handle) void {\n            diagnostics_gen.generateDiagnostics(param_server, param_handle) catch |err| switch (err) {\n                error.OutOfMemory => {}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "generateDiagnostics",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to initializeHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn initializeHandler(server: *Server, arena: std.mem.Allocator, request: types.InitializeParams) Error!types.InitializeResult {\n    var support_full_semantic_tokens = true;\n\n    if (request.clientInfo) |clientInfo| {\n        server.client_capabilities.client_name = try server.allocator.dupe(u8, clientInfo.name);\n\n        if (std.mem.startsWith(u8, clientInfo.name, \"Visual Studio Code\") or\n            std.mem.startsWith(u8, clientInfo.name, \"VSCodium\") or\n            std.mem.startsWith(u8, clientInfo.name, \"Code - OSS\"))\n        {\n            // VS Code doesn't really utilize `textDocument/semanticTokens/range`.\n            // This will cause some visual artifacts when scrolling through the\n            // document quickly but will considerably improve performance\n            // especially on large files.\n            support_full_semantic_tokens = false;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "initializeHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to initializedHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn initializedHandler(server: *Server, arena: std.mem.Allocator, notification: types.InitializedParams) Error!void {\n    _ = notification;\n\n    if (server.status != .initializing) {\n        log.warn(\"received a initialized notification but the server has not send a initialize request!\", .{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "initializedHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to shutdownHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn shutdownHandler(server: *Server, _: std.mem.Allocator, _: void) Error!?void {\n    defer server.status = .shutdown;\n    if (server.status != .initialized) return error.InvalidRequest; // received a shutdown request but the server is not initialized!\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "shutdownHandler",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to exitHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn exitHandler(server: *Server, _: std.mem.Allocator, _: void) Error!void {\n    server.status = switch (server.status) {\n        .initialized => .exiting_failure,\n        .shutdown => .exiting_success,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "exitHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to registerCapability from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn registerCapability(server: *Server, method: []const u8, registersOptions: ?types.LSPAny) Error!void {\n    const id = try std.fmt.allocPrint(server.allocator, \"register-{s}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "registerCapability",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to requestConfiguration from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn requestConfiguration(server: *Server) Error!void {\n    const configuration_items: [1]types.ConfigurationItem = .{\n        .{\n            .section = \"zls\",\n            .scopeUri = if (server.workspaces.items.len == 1) server.workspaces.items[0].uri else null,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "requestConfiguration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to handleConfiguration from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn handleConfiguration(server: *Server, json: std.json.Value) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "handleConfiguration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn init(server: *Server, uri: types.URI) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn deinit(workspace: *Workspace, allocator: std.mem.Allocator) void {\n        if (BuildOnSaveSupport.isSupportedComptime()) {\n            if (workspace.build_on_save) |*build_on_save| build_on_save.deinit();\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to sendManualWatchUpdate from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn sendManualWatchUpdate(workspace: *Workspace) void {\n        comptime std.debug.assert(BuildOnSaveSupport.isSupportedComptime());\n\n        const build_on_save = if (workspace.build_on_save) |*build_on_save| build_on_save else return;\n        const mode = workspace.build_on_save_mode orelse return;\n        if (mode != .manual) return;\n\n        build_on_save.sendManualWatchUpdate();\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "sendManualWatchUpdate",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to refreshBuildOnSave from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn refreshBuildOnSave(workspace: *Workspace, args: struct {\n        server: *Server,\n        /// Whether the build on save process should be restarted if it is already running.\n        restart: bool,\n    }) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "refreshBuildOnSave",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addWorkspace from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn addWorkspace(server: *Server, uri: types.URI) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "addWorkspace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to removeWorkspace from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn removeWorkspace(server: *Server, uri: types.URI) void {\n    for (server.workspaces.items, 0..) |workspace, i| {\n        if (std.mem.eql(u8, workspace.uri, uri)) {\n            var removed_workspace = server.workspaces.swapRemove(i);\n            removed_workspace.deinit(server.allocator);\n            log.info(\"removed Workspace Folder: {s}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "removeWorkspace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to didChangeWatchedFilesHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn didChangeWatchedFilesHandler(server: *Server, arena: std.mem.Allocator, notification: types.DidChangeWatchedFilesParams) Error!void {\n    var updated_files: usize = 0;\n    for (notification.changes) |change| {\n        const file_path = Uri.toFsPath(arena, change.uri) catch |err| switch (err) {\n            error.UnsupportedScheme => continue,\n            else => {\n                log.err(\"failed to parse URI '{s}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "didChangeWatchedFilesHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to didChangeWorkspaceFoldersHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn didChangeWorkspaceFoldersHandler(server: *Server, arena: std.mem.Allocator, notification: types.DidChangeWorkspaceFoldersParams) Error!void {\n    _ = arena;\n\n    for (notification.event.added) |folder| {\n        try server.addWorkspace(folder.uri);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "didChangeWorkspaceFoldersHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to didChangeConfigurationHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn didChangeConfigurationHandler(server: *Server, arena: std.mem.Allocator, notification: types.DidChangeConfigurationParams) Error!void {\n    const settings = switch (notification.settings) {\n        .null => {\n            if (server.client_capabilities.supports_configuration and\n                server.client_capabilities.supports_workspace_did_change_configuration_dynamic_registration)\n            {\n                // The client has informed us that the configuration options have\n                // changed. The will request them with `workspace/configuration`.\n                try server.requestConfiguration();\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "didChangeConfigurationHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveConfiguration from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "pub fn resolveConfiguration(server: *Server) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "resolveConfiguration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to createDocumentStoreConfig from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn createDocumentStoreConfig(config_manager: *const configuration.Manager) DocumentStore.Config {\n    return .{\n        .zig_exe_path = config_manager.config.zig_exe_path,\n        .zig_lib_dir = config_manager.zig_lib_dir,\n        .build_runner_path = config_manager.config.build_runner_path,\n        .builtin_path = config_manager.config.builtin_path,\n        .global_cache_dir = config_manager.global_cache_dir,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "createDocumentStoreConfig",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to openDocumentHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn openDocumentHandler(server: *Server, _: std.mem.Allocator, notification: types.DidOpenTextDocumentParams) Error!void {\n    if (notification.textDocument.text.len > DocumentStore.max_document_size) {\n        log.err(\"open document '{s}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "openDocumentHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to changeDocumentHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn changeDocumentHandler(server: *Server, _: std.mem.Allocator, notification: types.DidChangeTextDocumentParams) Error!void {\n    if (notification.contentChanges.len == 0) return;\n    const handle = server.document_store.getHandle(notification.textDocument.uri) orelse return;\n\n    const new_text = try diff.applyContentChanges(server.allocator, handle.tree.source, notification.contentChanges, server.offset_encoding);\n\n    if (new_text.len > DocumentStore.max_document_size) {\n        log.err(\"change document '{s}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "changeDocumentHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to saveDocumentHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn saveDocumentHandler(server: *Server, arena: std.mem.Allocator, notification: types.DidSaveTextDocumentParams) Error!void {\n    const uri = notification.textDocument.uri;\n\n    if (std.process.can_spawn and DocumentStore.isBuildFile(uri)) {\n        server.document_store.invalidateBuildFile(uri);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "saveDocumentHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to closeDocumentHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn closeDocumentHandler(server: *Server, _: std.mem.Allocator, notification: types.DidCloseTextDocumentParams) error{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "closeDocumentHandler",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to willSaveWaitUntilHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn willSaveWaitUntilHandler(server: *Server, arena: std.mem.Allocator, request: types.WillSaveTextDocumentParams) Error!?[]types.TextEdit {\n    if (server.autofixWorkaround() != .will_save_wait_until) return null;\n\n    switch (request.reason) {\n        .Manual => {}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "willSaveWaitUntilHandler",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to semanticTokensFullHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn semanticTokensFullHandler(server: *Server, arena: std.mem.Allocator, request: types.SemanticTokensParams) Error!?types.SemanticTokens {\n    if (server.config_manager.config.semantic_tokens == .none) return null;\n\n    const handle = server.document_store.getHandle(request.textDocument.uri) orelse return null;\n\n    // Workaround: The Ast on .zon files is unusable when an error occured on the root expr\n    if (handle.tree.mode == .zon and handle.tree.errors.len > 0) return null;\n\n    var analyser = server.initAnalyser(arena, handle);\n    defer analyser.deinit();\n    // semantic tokens can be quite expensive to compute on large files\n    // and disabling callsite references can help with bringing the cost down.\n    analyser.collect_callsite_references = false;\n\n    return try semantic_tokens.writeSemanticTokens(\n        arena,\n        &analyser,\n        handle,\n        null,\n        server.offset_encoding,\n        server.config_manager.config.semantic_tokens == .partial,\n        server.client_capabilities.supports_semantic_tokens_overlapping,\n    );\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "semanticTokensFullHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to semanticTokensRangeHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn semanticTokensRangeHandler(server: *Server, arena: std.mem.Allocator, request: types.SemanticTokensRangeParams) Error!?types.SemanticTokens {\n    if (server.config_manager.config.semantic_tokens == .none) return null;\n\n    const handle = server.document_store.getHandle(request.textDocument.uri) orelse return null;\n\n    // Workaround: The Ast on .zon files is unusable when an error occured on the root expr\n    if (handle.tree.mode == .zon and handle.tree.errors.len > 0) return null;\n\n    const loc = offsets.rangeToLoc(handle.tree.source, request.range, server.offset_encoding);\n\n    var analyser = server.initAnalyser(arena, handle);\n    defer analyser.deinit();\n    // semantic tokens can be quite expensive to compute on large files\n    // and disabling callsite references can help with bringing the cost down.\n    analyser.collect_callsite_references = false;\n\n    return try semantic_tokens.writeSemanticTokens(\n        arena,\n        &analyser,\n        handle,\n        loc,\n        server.offset_encoding,\n        server.config_manager.config.semantic_tokens == .partial,\n        server.client_capabilities.supports_semantic_tokens_overlapping,\n    );\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "semanticTokensRangeHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to completionHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn completionHandler(server: *Server, arena: std.mem.Allocator, request: types.CompletionParams) Error!lsp.ResultType(\"textDocument/completion\") {\n    const handle = server.document_store.getHandle(request.textDocument.uri) orelse return null;\n    if (handle.tree.mode == .zon) return null;\n\n    const source_index = offsets.positionToIndex(handle.tree.source, request.position, server.offset_encoding);\n\n    var analyser = server.initAnalyser(arena, handle);\n    defer analyser.deinit();\n\n    return .{\n        .CompletionList = try completions.completionAtIndex(server, &analyser, arena, handle, source_index) orelse return null,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "completionHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to signatureHelpHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn signatureHelpHandler(server: *Server, arena: std.mem.Allocator, request: types.SignatureHelpParams) Error!?types.SignatureHelp {\n    const handle = server.document_store.getHandle(request.textDocument.uri) orelse return null;\n    if (handle.tree.mode == .zon) return null;\n\n    const source_index = offsets.positionToIndex(handle.tree.source, request.position, server.offset_encoding);\n\n    const markup_kind: types.MarkupKind = if (server.client_capabilities.signature_help_supports_md) .markdown else .plaintext;\n\n    var analyser = server.initAnalyser(arena, handle);\n    defer analyser.deinit();\n\n    const signature_info = (try signature_help.getSignatureInfo(\n        &analyser,\n        arena,\n        handle,\n        source_index,\n        markup_kind,\n    )) orelse return null;\n\n    var signatures = try arena.alloc(types.SignatureInformation, 1);\n    signatures[0] = signature_info;\n\n    return .{\n        .signatures = signatures,\n        .activeSignature = 0,\n        .activeParameter = signature_info.activeParameter,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "signatureHelpHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to gotoDefinitionHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn gotoDefinitionHandler(\n    server: *Server,\n    arena: std.mem.Allocator,\n    request: types.DefinitionParams,\n) Error!lsp.ResultType(\"textDocument/definition\") {\n    return goto.gotoHandler(server, arena, .definition, request);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "gotoDefinitionHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to gotoTypeDefinitionHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn gotoTypeDefinitionHandler(server: *Server, arena: std.mem.Allocator, request: types.TypeDefinitionParams) Error!lsp.ResultType(\"textDocument/typeDefinition\") {\n    const response = (try goto.gotoHandler(server, arena, .type_definition, .{\n        .textDocument = request.textDocument,\n        .position = request.position,\n        .workDoneToken = request.workDoneToken,\n        .partialResultToken = request.partialResultToken,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "gotoTypeDefinitionHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to gotoImplementationHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn gotoImplementationHandler(server: *Server, arena: std.mem.Allocator, request: types.ImplementationParams) Error!lsp.ResultType(\"textDocument/implementation\") {\n    const response = (try goto.gotoHandler(server, arena, .definition, .{\n        .textDocument = request.textDocument,\n        .position = request.position,\n        .workDoneToken = request.workDoneToken,\n        .partialResultToken = request.partialResultToken,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "gotoImplementationHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to gotoDeclarationHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn gotoDeclarationHandler(server: *Server, arena: std.mem.Allocator, request: types.DeclarationParams) Error!lsp.ResultType(\"textDocument/declaration\") {\n    const response = (try goto.gotoHandler(server, arena, .declaration, .{\n        .textDocument = request.textDocument,\n        .position = request.position,\n        .workDoneToken = request.workDoneToken,\n        .partialResultToken = request.partialResultToken,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "gotoDeclarationHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to hoverHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn hoverHandler(server: *Server, arena: std.mem.Allocator, request: types.HoverParams) Error!?types.Hover {\n    const handle = server.document_store.getHandle(request.textDocument.uri) orelse return null;\n    if (handle.tree.mode == .zon) return null;\n    const source_index = offsets.positionToIndex(handle.tree.source, request.position, server.offset_encoding);\n\n    const markup_kind: types.MarkupKind = if (server.client_capabilities.hover_supports_md) .markdown else .plaintext;\n\n    var analyser = server.initAnalyser(arena, handle);\n    defer analyser.deinit();\n\n    return hover_handler.hover(\n        &analyser,\n        arena,\n        handle,\n        source_index,\n        markup_kind,\n        server.offset_encoding,\n    );\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "hoverHandler",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to documentSymbolsHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn documentSymbolsHandler(server: *Server, arena: std.mem.Allocator, request: types.DocumentSymbolParams) Error!lsp.ResultType(\"textDocument/documentSymbol\") {\n    const handle = server.document_store.getHandle(request.textDocument.uri) orelse return null;\n    if (handle.tree.mode == .zon) return null;\n    return .{\n        .array_of_DocumentSymbol = try document_symbol.getDocumentSymbols(arena, handle.tree, server.offset_encoding),\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "documentSymbolsHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to formattingHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn formattingHandler(server: *Server, arena: std.mem.Allocator, request: types.DocumentFormattingParams) Error!?[]types.TextEdit {\n    const handle = server.document_store.getHandle(request.textDocument.uri) orelse return null;\n\n    if (handle.tree.errors.len != 0) return null;\n\n    const formatted = try handle.tree.renderAlloc(arena);\n\n    if (std.mem.eql(u8, handle.tree.source, formatted)) return null;\n\n    const text_edits = try diff.edits(arena, handle.tree.source, formatted, server.offset_encoding);\n    return text_edits.items;\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "formattingHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to renameHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn renameHandler(server: *Server, arena: std.mem.Allocator, request: types.RenameParams) Error!?types.WorkspaceEdit {\n    const response = try references.referencesHandler(server, arena, .{ .rename = request }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "renameHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to prepareRenameHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn prepareRenameHandler(server: *Server, request: types.PrepareRenameParams) ?types.PrepareRenameResult {\n    const handle = server.document_store.getHandle(request.textDocument.uri) orelse return null;\n    const source_index = offsets.positionToIndex(handle.tree.source, request.position, server.offset_encoding);\n    const name_loc = Analyser.identifierLocFromIndex(handle.tree, source_index) orelse return null;\n    const name = offsets.locToSlice(handle.tree.source, name_loc);\n    return .{\n        .literal_1 = .{\n            .range = offsets.locToRange(handle.tree.source, name_loc, server.offset_encoding),\n            .placeholder = name,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "prepareRenameHandler",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to referencesHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn referencesHandler(server: *Server, arena: std.mem.Allocator, request: types.ReferenceParams) Error!?[]types.Location {\n    const response = try references.referencesHandler(server, arena, .{ .references = request }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "referencesHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to documentHighlightHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn documentHighlightHandler(server: *Server, arena: std.mem.Allocator, request: types.DocumentHighlightParams) Error!?[]types.DocumentHighlight {\n    const response = try references.referencesHandler(server, arena, .{ .highlight = request }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "documentHighlightHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to inlayHintHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn inlayHintHandler(server: *Server, arena: std.mem.Allocator, request: types.InlayHintParams) Error!?[]types.InlayHint {\n    const handle = server.document_store.getHandle(request.textDocument.uri) orelse return null;\n    if (handle.tree.mode == .zon) return null;\n\n    // The Language Server Specification does not provide a client capabilities that allows the client to specify the MarkupKind of inlay hints.\n    const hover_kind: types.MarkupKind = if (server.client_capabilities.hover_supports_md) .markdown else .plaintext;\n    const loc = offsets.rangeToLoc(handle.tree.source, request.range, server.offset_encoding);\n\n    var analyser = server.initAnalyser(arena, handle);\n    defer analyser.deinit();\n\n    return try inlay_hints.writeRangeInlayHint(\n        arena,\n        &server.config_manager.config,\n        &analyser,\n        handle,\n        loc,\n        hover_kind,\n        server.offset_encoding,\n    );\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "inlayHintHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to codeActionHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn codeActionHandler(server: *Server, arena: std.mem.Allocator, request: types.CodeActionParams) Error!lsp.ResultType(\"textDocument/codeAction\") {\n    const handle = server.document_store.getHandle(request.textDocument.uri) orelse return null;\n\n    // as of right now, only ast-check errors may get a code action\n    if (handle.tree.errors.len != 0) return null;\n    if (handle.tree.mode == .zon) return null;\n\n    var error_bundle = try diagnostics_gen.getAstCheckDiagnostics(server, handle);\n    defer error_bundle.deinit(server.allocator);\n\n    var analyser = server.initAnalyser(arena, handle);\n    defer analyser.deinit();\n\n    const only_kinds = if (request.context.only) |kinds| blk: {\n        var set: std.EnumSet(std.meta.Tag(types.CodeActionKind)) = .initEmpty();\n        for (kinds) |kind| {\n            set.setPresent(kind, true);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "codeActionHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to foldingRangeHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn foldingRangeHandler(server: *Server, arena: std.mem.Allocator, request: types.FoldingRangeParams) Error!?[]types.FoldingRange {\n    const handle = server.document_store.getHandle(request.textDocument.uri) orelse return null;\n\n    return try folding_range.generateFoldingRanges(arena, handle.tree, server.offset_encoding);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "foldingRangeHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to selectionRangeHandler from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn selectionRangeHandler(server: *Server, arena: std.mem.Allocator, request: types.SelectionRangeParams) Error!?[]types.SelectionRange {\n    const handle = server.document_store.getHandle(request.textDocument.uri) orelse return null;\n\n    return try selection_range.generateSelectionRanges(arena, handle, request.positions, server.offset_encoding);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "selectionRangeHandler",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to isBlockingMessage from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn isBlockingMessage(msg: Message) bool {\n    switch (msg) {\n        .request => |request| switch (request.params) {\n            .initialize,\n            .shutdown,\n            => return true,\n            .@\"textDocument/willSaveWaitUntil\",\n            .@\"textDocument/semanticTokens/full\",\n            .@\"textDocument/semanticTokens/range\",\n            .@\"textDocument/inlayHint\",\n            .@\"textDocument/completion\",\n            .@\"textDocument/signatureHelp\",\n            .@\"textDocument/definition\",\n            .@\"textDocument/typeDefinition\",\n            .@\"textDocument/implementation\",\n            .@\"textDocument/declaration\",\n            .@\"textDocument/hover\",\n            .@\"textDocument/documentSymbol\",\n            .@\"textDocument/formatting\",\n            .@\"textDocument/rename\",\n            .@\"textDocument/prepareRename\",\n            .@\"textDocument/references\",\n            .@\"textDocument/documentHighlight\",\n            .@\"textDocument/codeAction\",\n            .@\"textDocument/foldingRange\",\n            .@\"textDocument/selectionRange\",\n            => return false,\n            .other => return false,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "isBlockingMessage",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to create from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "pub fn create(options: CreateOptions) (std.mem.Allocator.Error || std.Thread.SpawnError)!*Server {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    const allocator = options.allocator;\n\n    const server = try allocator.create(Server);\n    errdefer allocator.destroy(server);\n\n    server.* = .{\n        .allocator = allocator,\n        .config_manager = options.config_manager orelse .init(allocator),\n        .document_store = .{\n            .allocator = allocator,\n            .config = undefined, // set below\n            .thread_pool = &server.thread_pool,\n            .diagnostics_collection = &server.diagnostics_collection,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "create",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to destroy from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "pub fn destroy(server: *Server) void {\n    server.thread_pool.deinit();\n    server.document_store.deinit();\n    server.ip.deinit(server.allocator);\n    for (server.workspaces.items) |*workspace| workspace.deinit(server.allocator);\n    server.workspaces.deinit(server.allocator);\n    server.diagnostics_collection.deinit();\n    server.client_capabilities.deinit(server.allocator);\n    server.config_manager.deinit();\n    for (server.pending_show_messages.items) |params| server.allocator.free(params.message);\n    server.pending_show_messages.deinit(server.allocator);\n    server.allocator.destroy(server);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "destroy",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to setTransport from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "pub fn setTransport(server: *Server, transport: *lsp.Transport) void {\n    server.transport = transport;\n    server.diagnostics_collection.transport = transport;\n    server.document_store.transport = transport;\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "setTransport",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to keepRunning from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "pub fn keepRunning(server: Server) bool {\n    switch (server.status) {\n        .exiting_success, .exiting_failure => return false,\n        else => return true,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "keepRunning",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to loop from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "pub fn loop(server: *Server) !void {\n    std.debug.assert(server.transport != null);\n    while (server.keepRunning()) {\n        const json_message = try server.transport.?.readJsonMessage(server.allocator);\n        defer server.allocator.free(json_message);\n\n        var arena_allocator: std.heap.ArenaAllocator = .init(server.allocator);\n        errdefer arena_allocator.deinit();\n\n        const message = message: {\n            const tracy_zone = tracy.traceNamed(@src(), \"Message.parse\");\n            defer tracy_zone.end();\n            break :message Message.parseFromSliceLeaky(\n                arena_allocator.allocator(),\n                json_message,\n                .{ .ignore_unknown_fields = true, .max_value_len = null, .allocate = .alloc_always }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "loop",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to sendJsonMessageSync from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "pub fn sendJsonMessageSync(server: *Server, json_message: []const u8) Error!?[]u8 {\n    const parsed_message = Message.parseFromSlice(\n        server.allocator,\n        json_message,\n        .{ .ignore_unknown_fields = true, .max_value_len = null, .allocate = .alloc_always }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "sendJsonMessageSync",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sendNotificationSync from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "pub fn sendNotificationSync(server: *Server, arena: std.mem.Allocator, comptime method: []const u8, params: lsp.ParamsType(method)) Error!void {\n    comptime std.debug.assert(lsp.isNotificationMethod(method));\n    const tracy_zone = tracy.traceNamed(@src(), \"sendNotificationSync(\" ++ method ++ \")\");\n    defer tracy_zone.end();\n    tracy_zone.setName(method);\n\n    const Params = std.meta.Tag(HandledNotificationParams);\n    if (!@hasField(Params, method)) return null;\n\n    return switch (@field(Params, method)) {\n        .initialized => try server.initializedHandler(arena, params),\n        .exit => try server.exitHandler(arena, params),\n        .@\"textDocument/didOpen\" => try server.openDocumentHandler(arena, params),\n        .@\"textDocument/didChange\" => try server.changeDocumentHandler(arena, params),\n        .@\"textDocument/didSave\" => try server.saveDocumentHandler(arena, params),\n        .@\"textDocument/didClose\" => try server.closeDocumentHandler(arena, params),\n        .@\"workspace/didChangeWatchedFiles\" => try server.didChangeWatchedFilesHandler(arena, params),\n        .@\"workspace/didChangeWorkspaceFolders\" => try server.didChangeWorkspaceFoldersHandler(arena, params),\n        .@\"workspace/didChangeConfiguration\" => try server.didChangeConfigurationHandler(arena, params),\n        .other => {}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "sendNotificationSync",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to sendMessageSync from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "pub fn sendMessageSync(server: *Server, arena: std.mem.Allocator, comptime method: []const u8, params: lsp.ParamsType(method)) Error!lsp.ResultType(method) {\n    comptime std.debug.assert(lsp.isRequestMethod(method) or lsp.isNotificationMethod(method));\n\n    if (comptime lsp.isRequestMethod(method)) {\n        return try server.sendRequestSync(arena, method, params);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "sendMessageSync",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to processMessage from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn processMessage(server: *Server, arena: std.mem.Allocator, message: Message) Error!?[]u8 {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    try server.validateMessage(message);\n\n    switch (message) {\n        .request => |request| switch (request.params) {\n            .other => return try server.sendToClientResponse(request.id, @as(?void, null)),\n            inline else => |params, method| {\n                const result = try server.sendRequestSync(arena, @tagName(method), params);\n                return try server.sendToClientResponse(request.id, result);\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "processMessage",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to processMessageReportError from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn processMessageReportError(server: *Server, arena_state: std.heap.ArenaAllocator.State, message: Message) void {\n    var arena_allocator = arena_state.promote(server.allocator);\n    defer arena_allocator.deinit();\n\n    if (server.processMessage(arena_allocator.allocator(), message)) |json_message| {\n        server.allocator.free(json_message orelse return);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "processMessageReportError",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to validateMessage from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn validateMessage(server: *const Server, message: Message) Error!void {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    const method = switch (message) {\n        .request => |request| switch (request.params) {\n            .other => |info| info.method,\n            else => @tagName(request.params),\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "validateMessage",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to handleResponse from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn handleResponse(server: *Server, response: lsp.JsonRPCMessage.Response) Error!void {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    if (response.id == null) {\n        log.warn(\"received response from client without id!\", .{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "handleResponse",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to formatMessage from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn formatMessage(message: Message, writer: *std.Io.Writer) std.Io.Writer.Error!void {\n    switch (message) {\n        .request => |request| try writer.print(\"request-{f}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "formatMessage",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmtMessage from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "fn fmtMessage(message: Message) std.fmt.Alt(Message, formatMessage) {\n    return .{ .data = message }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "function",
      "name": "fmtMessage",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to do from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const do = struct {\n        fn do(param_server: *Server, param_handle: *DocumentStore.Handle) void {\n            diagnostics_gen.generateDiagnostics(param_server, param_handle) catch |err| switch (err) {\n                error.OutOfMemory => {}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "struct",
      "name": "do",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Workspace from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const Workspace = struct {\n    uri: types.URI,\n    build_on_save: if (BuildOnSaveSupport.isSupportedComptime()) ?BuildOnSave else void,\n    build_on_save_mode: if (BuildOnSaveSupport.isSupportedComptime()) ?enum { watch, manual }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "struct",
      "name": "Workspace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to CreateOptions from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "pub const CreateOptions = struct {\n    /// Must be thread-safe unless the ZLS module is in single_threaded mode.\n    allocator: std.mem.Allocator,\n    /// Must be set when running `loop`. Controls how the server will send and receive messages.\n    transport: ?*lsp.Transport,\n    /// The `global_cache_path` will not be resolve automatically.\n    config: ?*const Config,\n    config_manager: ?configuration.Manager = null,\n    max_thread_count: usize = 4, // what is a good value here?\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "struct",
      "name": "CreateOptions",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to response from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const response: lsp.TypedJsonRPCResponse(@TypeOf(result)) = .{\n        .id = id,\n        .result_or_error = .{ .result = result },\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "response",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to request from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const request: lsp.TypedJsonRPCRequest(@TypeOf(params)) = .{\n        .id = id,\n        .method = method,\n        .params = params,\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "request",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to notification from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const notification: lsp.TypedJsonRPCNotification(@TypeOf(params)) = .{\n        .method = method,\n        .params = params,\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "notification",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to response from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const response: lsp.JsonRPCMessage = .{\n        .response = .{ .id = id, .result_or_error = .{ .@\"error\" = err } },\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "response",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to json_val from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const json_val: std.json.Value = .{ .object = fs_watcher_obj };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "json_val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to configuration_items from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const configuration_items: [1]types.ConfigurationItem = .{\n        .{\n            .section = \"zls\",\n            .scopeUri = if (server.workspaces.items.len == 1) server.workspaces.items[0].uri else null,\n        },\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "configuration_items",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to result from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const result: std.json.Value = switch (json) {\n        .array => |arr| blk: {\n            if (arr.items.len != 1) {\n                log.err(\"Response to 'workspace/configuration' expects an array of size 1 but received {d}\", .{arr.items.len});",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "result",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to maybe_root_dir from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const maybe_root_dir: ?[]const u8 = dir: {\n        if (server.workspaces.items.len != 1) break :dir null;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "maybe_root_dir",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to field from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const field: *?[]const u8 = &@field(new_config, file_config.name);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "field",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to new_zig_exe_path from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const new_zig_exe_path: bool = result.did_change.zig_exe_path;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "new_zig_exe_path",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to new_zig_lib_path from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const new_zig_lib_path: bool = result.did_change.zig_lib_path;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "new_zig_lib_path",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to new_build_runner_path from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const new_build_runner_path: bool = result.did_change.build_runner_path;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "new_build_runner_path",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to new_enable_build_on_save from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const new_enable_build_on_save: bool = result.did_change.enable_build_on_save;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "new_enable_build_on_save",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to new_build_on_save_args from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const new_build_on_save_args: bool = result.did_change.build_on_save_args;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "new_build_on_save_args",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to new_force_autofix from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const new_force_autofix: bool = result.did_change.force_autofix;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "new_force_autofix",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to markup_kind from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const markup_kind: types.MarkupKind = if (server.client_capabilities.signature_help_supports_md) .markdown else .plaintext;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "markup_kind",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to markup_kind from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const markup_kind: types.MarkupKind = if (server.client_capabilities.hover_supports_md) .markdown else .plaintext;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "markup_kind",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to hover_kind from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const hover_kind: types.MarkupKind = if (server.client_capabilities.hover_supports_md) .markdown else .plaintext;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "hover_kind",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to id from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/Server.zig",
    "response": "const id: []const u8 = switch (response.id.?) {\n        .string => |id| id,\n        .number => |id| {\n            log.warn(\"received response from client with id '{d}' that has no handler!\", .{id});",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/Server.zig",
      "type": "const",
      "name": "id",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isPositive from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isPositive(int: BigInt) bool {\n            switch (int.storage) {\n                .external => |external| return external.positive,\n                .internal => |internal| return internal.positive,\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isPositive",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getConst from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn getConst(int: BigInt, ip: *InternPool) std.math.big.int.Const {\n            switch (int.storage) {\n                .external => |external| return external,\n                .internal => |internal| return .{\n                    .positive = internal.positive,\n                    .limbs = internal.limbs.getUnprotectedSlice(ip),\n                }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getConst",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pack from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn pack(val: f64) F64Value {\n            return @bitCast(val);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "pack",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to unpack from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn unpack(val: F64Value) f64 {\n            return @bitCast(val);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "unpack",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pack from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn pack(val: f80) F80Value {\n            // f80 -> u80 -> u96 -> F80Value\n            return @bitCast(@as(u96, @as(u80, @bitCast(val))));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "pack",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to unpack from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn unpack(val: F80Value) f80 {\n            // F80Value -> u96 -> u80 -> f80\n            return @bitCast(@as(u80, @truncate(@as(u96, @bitCast(val)))));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "unpack",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pack from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn pack(val: f128) F128Value {\n            return @bitCast(val);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "pack",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to unpack from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn unpack(val: F128Value) f128 {\n            return @bitCast(val);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "unpack",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash32 from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn hash32(key: Key, ip: *InternPool) u32 {\n        return @truncate(key.hash64(ip));\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "hash32",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash64 from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn hash64(key: Key, ip: *InternPool) u64 {\n        var hasher: std.hash.Wyhash = .init(0);\n        key.hashWithHasher(&hasher, ip);\n        return hasher.final();\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "hash64",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hashWithHasher from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn hashWithHasher(key: Key, hasher: anytype, ip: *InternPool) void {\n        std.hash.autoHash(hasher, std.meta.activeTag(key));\n        switch (key) {\n            inline .simple_type,\n            .simple_value,\n            .pointer_type,\n            .array_type,\n            .struct_type,\n            .optional_type,\n            .error_union_type,\n            .enum_type,\n            .union_type,\n            .vector_type,\n            .anyframe_type,\n            // .int_u64_value,\n            // .int_i64_value,\n            .optional_value,\n            .slice,\n            .union_value,\n            .error_value,\n            .null_value,\n            .undefined_value,\n            .unknown_value,\n            => |*data| {\n                hasher.update(std.mem.asBytes(data));\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "hashWithHasher",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn eql(a: Key, b: Key, ip: *InternPool) bool {\n        return eqlCustom(a, b, ip, true);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eqlNoLock from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn eqlNoLock(a: Key, b: Key, ip: *const InternPool) bool {\n        return eqlCustom(a, b, @constCast(ip), false);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "eqlNoLock",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eqlCustom from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn eqlCustom(a: Key, b: Key, ip: *InternPool, should_lock: bool) bool {\n        const a_tag = std.meta.activeTag(a);\n        const b_tag = std.meta.activeTag(b);\n        if (a_tag != b_tag) return false;\n\n        switch (a) {\n            inline .simple_type,\n            .simple_value,\n            .int_type,\n            .pointer_type,\n            .array_type,\n            .struct_type,\n            .optional_type,\n            .error_union_type,\n            .enum_type,\n            .union_type,\n            .vector_type,\n            .anyframe_type,\n            .int_u64_value,\n            .int_i64_value,\n            .optional_value,\n            .slice,\n            .union_value,\n            .error_value,\n            .null_value,\n            .undefined_value,\n            .unknown_value,\n            => |a_info, t| {\n                return std.meta.eql(a_info, @field(b, @tagName(t)));\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "eqlCustom",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to at from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn at(slice: Slice, index: u32, ip: *InternPool) Index {\n            assert(index < slice.len);\n            ip.lock.lockShared();\n            defer ip.lock.unlockShared();\n            return @enumFromInt(ip.extra.items[slice.start + index]);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "at",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dupe from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn dupe(slice: Slice, gpa: Allocator, ip: *InternPool) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "dupe",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hashWithHasher from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn hashWithHasher(slice: Slice, hasher: anytype, ip: *InternPool) void {\n            std.hash.autoHash(hasher, slice.len);\n            if (slice.len == 0) return;\n            ip.lock.lockShared();\n            defer ip.lock.unlockShared();\n            hasher.update(std.mem.sliceAsBytes(slice.getUnprotectedSlice(ip)));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "hashWithHasher",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getUnprotectedSlice from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn getUnprotectedSlice(slice: Slice, ip: *const InternPool) []const Index {\n            if (slice.len == 0) return &.{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getUnprotectedSlice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmt from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn fmt(index: Index, ip: *InternPool) std.fmt.Alt(FormatContext, format) {\n        return fmtOptions(index, ip, .{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "fmt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmtDebug from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn fmtDebug(index: Index, ip: *InternPool) std.fmt.Alt(FormatContext, format) {\n        return fmtOptions(index, ip, .{ .debug = true }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "fmtDebug",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmtOptions from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn fmtOptions(index: Index, ip: *InternPool, options: FormatOptions) std.fmt.Alt(FormatContext, format) {\n        return .{ .data = .{ .index = index, .ip = ip, .options = options }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "fmtOptions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to at from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn at(slice: StringSlice, index: u32, ip: *InternPool) String {\n        assert(index < slice.len);\n        ip.lock.lockShared();\n        defer ip.lock.unlockShared();\n        return @enumFromInt(ip.extra.items[slice.start + index]);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "at",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dupe from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn dupe(slice: StringSlice, gpa: Allocator, ip: *InternPool) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "dupe",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hashWithHasher from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn hashWithHasher(slice: StringSlice, hasher: anytype, ip: *InternPool) void {\n        std.hash.autoHash(hasher, slice.len);\n        if (slice.len == 0) return;\n        ip.lock.lockShared();\n        defer ip.lock.unlockShared();\n        hasher.update(std.mem.sliceAsBytes(slice.getUnprotectedSlice(ip)));\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "hashWithHasher",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getUnprotectedSlice from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn getUnprotectedSlice(slice: StringSlice, ip: *const InternPool) []const String {\n        if (slice.len == 0) return &.{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getUnprotectedSlice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hashWithHasher from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn hashWithHasher(slice: LimbSlice, hasher: anytype, ip: *InternPool) void {\n        std.hash.autoHash(hasher, slice.len);\n        if (slice.len == 0) return;\n        ip.lock.lockShared();\n        defer ip.lock.unlockShared();\n        hasher.update(std.mem.sliceAsBytes(slice.getUnprotectedSlice(ip)));\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "hashWithHasher",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getUnprotectedSlice from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn getUnprotectedSlice(limbs: LimbSlice, ip: *InternPool) []std.math.big.Limb {\n        if (limbs.len == 0) return &.{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getUnprotectedSlice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toOptional from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn toOptional(i: Decl.Index) OptionalIndex {\n            return @enumFromInt(@intFromEnum(i));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "toOptional",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn init(oi: ?Decl.Index) OptionalIndex {\n            return if (oi) |index| index.toOptional() else .none;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to unwrap from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn unwrap(oi: OptionalIndex) ?Decl.Index {\n            if (oi == .none) return null;\n            return @enumFromInt(@intFromEnum(oi));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "unwrap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn init(gpa: Allocator) Allocator.Error!InternPool {\n    var ip: InternPool = .{\n        .map = .empty,\n        .items = .empty,\n        .extra = .empty,\n        .string_pool = .empty,\n        .lock = .{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn deinit(ip: *InternPool, gpa: Allocator) void {\n    ip.map.deinit(gpa);\n    ip.items.deinit(gpa);\n    ip.extra.deinit(gpa);\n    ip.string_pool.deinit(gpa);\n    ip.limbs.deinit(gpa);\n\n    var struct_it = ip.structs.iterator(0);\n    while (struct_it.next()) |item| {\n        item.fields.deinit(gpa);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to indexToKey from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn indexToKey(ip: *InternPool, index: Index) Key {\n    assert(index != .none);\n\n    ip.lock.lockShared();\n    defer ip.lock.unlockShared();\n    return ip.indexToKeyNoLock(index);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "indexToKey",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to indexToKeyNoLock from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn indexToKeyNoLock(ip: *const InternPool, index: Index) Key {\n    assert(index != .none);\n    const item = ip.items.get(@intFromEnum(index));\n    const data = item.data;\n    return switch (item.tag) {\n        .simple_type => .{ .simple_type = @enumFromInt(data) }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "indexToKeyNoLock",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn get(ip: *InternPool, gpa: Allocator, key: Key) Allocator.Error!Index {\n    const adapter: KeyAdapter = .{\n        .ip = ip,\n        .precomputed_hash = key.hash32(ip),\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "get",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to contains from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn contains(ip: *InternPool, key: Key) ?Index {\n    const adapter: KeyAdapter = .{\n        .ip = ip,\n        .precomputed_hash = key.hash32(ip),\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "contains",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getIndexSlice from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn getIndexSlice(ip: *InternPool, gpa: Allocator, data: []const Index) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getIndexSlice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getStringSlice from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn getStringSlice(ip: *InternPool, gpa: Allocator, data: []const String) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getStringSlice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getLimbSlice from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn getLimbSlice(ip: *InternPool, gpa: Allocator, data: []const std.math.big.Limb) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getLimbSlice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getDecl from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn getDecl(ip: *InternPool, index: InternPool.Decl.Index) *const InternPool.Decl {\n    ip.lock.lockShared();\n    defer ip.lock.unlockShared();\n    return ip.decls.at(@intFromEnum(index));\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getDecl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getDeclMut from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn getDeclMut(ip: *InternPool, index: InternPool.Decl.Index) *InternPool.Decl {\n    ip.lock.lockShared();\n    defer ip.lock.unlockShared();\n    return ip.decls.at(@intFromEnum(index));\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getDeclMut",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getStruct from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn getStruct(ip: *InternPool, index: Struct.Index) *const Struct {\n    ip.lock.lockShared();\n    defer ip.lock.unlockShared();\n    return ip.structs.at(@intFromEnum(index));\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getStruct",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getStructMut from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn getStructMut(ip: *InternPool, index: Struct.Index) *Struct {\n    ip.lock.lockShared();\n    defer ip.lock.unlockShared();\n    return ip.structs.at(@intFromEnum(index));\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getStructMut",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getEnum from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn getEnum(ip: *InternPool, index: Enum.Index) *const Enum {\n    ip.lock.lockShared();\n    defer ip.lock.unlockShared();\n    return ip.enums.at(@intFromEnum(index));\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getEnum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getEnumMut from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn getEnumMut(ip: *InternPool, index: Enum.Index) *Enum {\n    ip.lock.lockShared();\n    defer ip.lock.unlockShared();\n    return ip.enums.at(@intFromEnum(index));\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getEnumMut",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getUnion from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn getUnion(ip: *InternPool, index: Union.Index) *const Union {\n    ip.lock.lockShared();\n    defer ip.lock.unlockShared();\n    return ip.unions.at(@intFromEnum(index));\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getUnion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getUnionMut from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn getUnionMut(ip: *InternPool, index: Union.Index) *Union {\n    ip.lock.lockShared();\n    defer ip.lock.unlockShared();\n    return ip.unions.at(@intFromEnum(index));\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getUnionMut",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to createDecl from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn createDecl(ip: *InternPool, gpa: Allocator, decl: Decl) Allocator.Error!Decl.Index {\n    ip.lock.lock();\n    defer ip.lock.unlock();\n    try ip.decls.append(gpa, decl);\n    return @enumFromInt(ip.decls.count() - 1);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "createDecl",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to createStruct from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn createStruct(ip: *InternPool, gpa: Allocator, struct_info: Struct) Allocator.Error!Struct.Index {\n    ip.lock.lock();\n    defer ip.lock.unlock();\n    try ip.structs.append(gpa, struct_info);\n    return @enumFromInt(ip.structs.count() - 1);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "createStruct",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to createEnum from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn createEnum(ip: *InternPool, gpa: Allocator, enum_info: Enum) Allocator.Error!Enum.Index {\n    ip.lock.lock();\n    defer ip.lock.unlock();\n    try ip.enums.append(gpa, enum_info);\n    return @enumFromInt(ip.enums.count() - 1);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "createEnum",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to createUnion from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn createUnion(ip: *InternPool, gpa: Allocator, union_info: Union) Allocator.Error!Union.Index {\n    ip.lock.lock();\n    defer ip.lock.unlock();\n    try ip.unions.append(gpa, union_info);\n    return @enumFromInt(ip.unions.count() - 1);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "createUnion",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to addExtra from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn addExtra(ip: *InternPool, gpa: Allocator, comptime T: type, extra: T) Allocator.Error!u32 {\n    comptime if (@sizeOf(T) <= 4) {\n        @compileError(@typeName(T) ++ \" fits into a u32! Consider directly storing this extra in Item's data field\");\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "addExtra",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to extraData from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn extraData(ip: *const InternPool, comptime T: type, index: u32) T {\n    var result: T = undefined;\n    var i: u32 = 0;\n    inline for (std.meta.fields(T)) |field| {\n        const item = ip.extra.items[index + i];\n        i += 1;\n        @field(result, field.name) = switch (field.type) {\n            Index,\n            StringPool.String,\n            StringPool.OptionalString,\n            Decl.Index,\n            Decl.OptionalIndex,\n            std.builtin.Type.Pointer.Size,\n            // std.builtin.AddressSpace,\n            // std.builtin.CallingConvention,\n            => @enumFromInt(item),\n\n            u32,\n            i32,\n            std.StaticBitSet(32),\n            Key.Pointer.Flags,\n            Key.Pointer.PackedOffset,\n            Key.Function.Flags,\n            => @bitCast(item),\n\n            u64,\n            i64,\n            => blk: {\n                defer i += 1;\n                break :blk @bitCast([2]u32{ item, ip.extra.items[index + i] }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "extraData",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn eql(ctx: @This(), a: Key, b_void: void, b_map_index: usize) bool {\n        _ = b_void;\n        return a.eqlNoLock(ctx.ip.indexToKeyNoLock(@enumFromInt(b_map_index)), ctx.ip);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn hash(ctx: @This(), a: Key) u32 {\n        _ = a;\n        return ctx.precomputed_hash;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "hash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to coerce from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn coerce(\n    ip: *InternPool,\n    gpa: Allocator,\n    arena: Allocator,\n    dest_ty: Index,\n    inst: Index,\n    target: std.Target,\n    /// TODO make this a return value instead of out pointer\n    /// see `CoercionResult`\n    err_msg: *ErrorMsg,\n) Allocator.Error!Index {\n    assert(ip.isType(dest_ty));\n    if (dest_ty == .unknown_type) return .unknown_unknown;\n    switch (ip.typeOf(dest_ty)) {\n        .unknown_type => return .unknown_unknown,\n        .type_type => {}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "coerce",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to intFitsInType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn intFitsInType(\n    ip: *InternPool,\n    val: Index,\n    ty: Index,\n    target: std.Target,\n) Allocator.Error!bool {\n    if (ty == .comptime_int_type) return true;\n    const info = ip.intInfo(ty, target);\n\n    switch (ip.indexToKey(val)) {\n        .undefined_value, .unknown_value => return true,\n        inline .int_i64_value, .int_u64_value => |value| {\n            var buffer: [std.math.big.int.calcTwosCompLimbCount(64)]std.math.big.Limb = undefined;\n            var big_int: std.math.big.int.Mutable = .init(&buffer, value.int);\n            return big_int.toConst().fitsInTwosComp(info.signedness, info.bits);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "intFitsInType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to coerceInt from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn coerceInt(\n    ip: *InternPool,\n    gpa: Allocator,\n    dest_ty: Index,\n    val: Index,\n) Allocator.Error!Index {\n    switch (ip.indexToKey(val)) {\n        .int_i64_value => |int| return try ip.get(gpa, .{ .int_i64_value = .{ .int = int.int, .ty = dest_ty }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "coerceInt",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolvePeerTypes from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn resolvePeerTypes(ip: *InternPool, gpa: Allocator, types: []const Index, target: std.Target) Allocator.Error!Index {\n    if (builtin.mode == .Debug) {\n        for (types) |ty| {\n            assert(ip.isType(ty));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "resolvePeerTypes",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to dupe from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn dupe(child: *const InMemoryCoercionResult, arena: Allocator) Allocator.Error!*InMemoryCoercionResult {\n        const res = try arena.create(InMemoryCoercionResult);\n        res.* = child.*;\n        return res;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "dupe",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to coerceInMemoryAllowed from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn coerceInMemoryAllowed(\n    ip: *InternPool,\n    gpa: Allocator,\n    arena: Allocator,\n    dest_ty: Index,\n    src_ty: Index,\n    dest_is_const: bool,\n    target: std.Target,\n) Allocator.Error!InMemoryCoercionResult {\n    if (dest_ty == src_ty) return .ok;\n    if (ip.isUnknown(dest_ty) or ip.isUnknown(src_ty)) return .ok;\n\n    assert(ip.isType(dest_ty));\n    assert(ip.isType(src_ty));\n\n    const dest_key = ip.indexToKey(dest_ty);\n    const src_key = ip.indexToKey(src_ty);\n\n    const dest_tag = ip.zigTypeTag(dest_ty) orelse {\n        return .{ .no_match = .{\n            .actual = dest_ty,\n            .wanted = src_ty,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "coerceInMemoryAllowed",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to coerceInMemoryAllowedErrorSets from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn coerceInMemoryAllowedErrorSets(\n    ip: *InternPool,\n    gpa: Allocator,\n    arena: Allocator,\n    dest_ty: Index,\n    src_ty: Index,\n) !InMemoryCoercionResult {\n    if (dest_ty == src_ty) return .ok;\n    if (dest_ty == .anyerror_type) return .ok;\n    if (src_ty == .anyerror_type) return .from_anyerror;\n\n    const dest_set_names = try ip.indexToKey(dest_ty).error_set_type.names.dupe(gpa, ip);\n    defer gpa.free(dest_set_names);\n\n    const src_set_names = try ip.indexToKey(src_ty).error_set_type.names.dupe(gpa, ip);\n    defer gpa.free(src_set_names);\n\n    var missing_error_buf: std.ArrayList(String) = .empty;\n    defer missing_error_buf.deinit(gpa);\n\n    for (src_set_names) |name| {\n        if (std.mem.indexOfScalar(String, dest_set_names, name) == null) {\n            try missing_error_buf.append(gpa, name);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "coerceInMemoryAllowedErrorSets",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to coerceInMemoryAllowedFns from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn coerceInMemoryAllowedFns(\n    ip: *InternPool,\n    gpa: Allocator,\n    arena: Allocator,\n    dest_ty: Index,\n    src_ty: Index,\n    target: std.Target,\n) Allocator.Error!InMemoryCoercionResult {\n    const dest_info = ip.indexToKey(dest_ty).function_type;\n    const src_info = ip.indexToKey(src_ty).function_type;\n\n    if (dest_info.flags.is_var_args != src_info.flags.is_var_args) {\n        return .{ .fn_var_args = dest_info.flags.is_var_args }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "coerceInMemoryAllowedFns",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to coerceInMemoryAllowedPtrs from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn coerceInMemoryAllowedPtrs(\n    ip: *InternPool,\n    gpa: Allocator,\n    arena: Allocator,\n    dest_ty: Index,\n    src_ty: Index,\n    dest_is_const: bool,\n    target: std.Target,\n) Allocator.Error!InMemoryCoercionResult {\n    const dest_info = ip.indexToKey(dest_ty).pointer_type;\n    const src_info = ip.indexToKey(src_ty).pointer_type;\n\n    const ok_ptr_size = src_info.flags.size == dest_info.flags.size or\n        src_info.flags.size == .c or dest_info.flags.size == .c;\n    if (!ok_ptr_size) {\n        return .{ .ptr_size = .{\n            .actual = src_info.flags.size,\n            .wanted = dest_info.flags.size,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "coerceInMemoryAllowedPtrs",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to optionalPtrTy from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn optionalPtrTy(ip: *InternPool, ty: Index) Index {\n    switch (ip.indexToKey(ty)) {\n        .optional_type => |optional_info| switch (ip.indexToKey(optional_info.payload_type)) {\n            .pointer_type => |pointer_info| switch (pointer_info.flags.size) {\n                .slice, .c => return Index.none,\n                .many, .one => {\n                    if (pointer_info.flags.is_allowzero) return Index.none;\n\n                    // optionals of zero sized types behave like bools, not pointers\n                    if (ip.onePossibleValue(optional_info.payload_type) != Index.none) return Index.none;\n\n                    return optional_info.payload_type;\n                }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "optionalPtrTy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to panicOrElse from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn panicOrElse(comptime T: type, message: []const u8, value: T) T {\n    if (builtin.is_test) {\n        @panic(message);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "panicOrElse",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to zigTypeTag from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn zigTypeTag(ip: *InternPool, index: Index) ?std.builtin.TypeId {\n    ip.lock.lockShared();\n    defer ip.lock.unlockShared();\n    return switch (ip.items.items(.tag)[@intFromEnum(index)]) {\n        .simple_type => switch (@as(SimpleType, @enumFromInt(ip.items.items(.data)[@intFromEnum(index)]))) {\n            .f16,\n            .f32,\n            .f64,\n            .f80,\n            .f128,\n            .c_longdouble,\n            => .float,\n\n            .usize,\n            .isize,\n            .c_char,\n            .c_short,\n            .c_ushort,\n            .c_int,\n            .c_uint,\n            .c_long,\n            .c_ulong,\n            .c_longlong,\n            .c_ulonglong,\n            => .int,\n\n            .comptime_int => .comptime_int,\n            .comptime_float => .comptime_float,\n\n            .anyopaque => .@\"opaque\",\n            .bool => .bool,\n            .void => .void,\n            .type => .type,\n            .anyerror => .error_set,\n            .noreturn => .noreturn,\n            .anyframe_type => .@\"anyframe\",\n            .empty_struct_type => .@\"struct\",\n            .null_type => .null,\n            .undefined_type => .undefined,\n            .enum_literal_type => .enum_literal,\n\n            .atomic_order => .@\"enum\",\n            .atomic_rmw_op => .@\"enum\",\n            .calling_convention => .@\"enum\",\n            .address_space => .@\"enum\",\n            .float_mode => .@\"enum\",\n            .reduce_op => .@\"enum\",\n            .modifier => .@\"enum\",\n            .prefetch_options => .@\"struct\",\n            .export_options => .@\"struct\",\n            .extern_options => .@\"struct\",\n            .type_info => .@\"union\",\n\n            .unknown => null,\n            .generic_poison => null,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "zigTypeTag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to typeOf from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn typeOf(ip: *InternPool, index: Index) Index {\n    ip.lock.lockShared();\n    defer ip.lock.unlockShared();\n    const data = ip.items.items(.data)[@intFromEnum(index)];\n    return switch (ip.items.items(.tag)[@intFromEnum(index)]) {\n        .simple_value => switch (@as(SimpleValue, @enumFromInt(data))) {\n            .undefined_value => .undefined_type,\n            .void_value => .void_type,\n            .unreachable_value => .noreturn_type,\n            .null_value => .null_type,\n            .bool_true => .bool_type,\n            .bool_false => .bool_type,\n            .the_only_possible_value => unreachable,\n            .generic_poison => .generic_poison_type,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "typeOf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isType(ip: *InternPool, ty: Index) bool {\n    ip.lock.lockShared();\n    defer ip.lock.unlockShared();\n    return switch (ip.items.items(.tag)[@intFromEnum(ty)]) {\n        .simple_type,\n        .type_int_signed,\n        .type_int_unsigned,\n        .type_pointer,\n        .type_array,\n        .type_struct,\n        .type_optional,\n        .type_error_union,\n        .type_error_set,\n        .type_enum,\n        .type_function,\n        .type_union,\n        .type_tuple,\n        .type_vector,\n        .type_anyframe,\n        => true,\n\n        .simple_value,\n        .float_f16,\n        .float_f32,\n        .float_f64,\n        .float_f80,\n        .float_f128,\n        .float_comptime,\n        .int_u64,\n        .int_i64,\n        .int_big_positive,\n        .int_big_negative,\n        .optional_value,\n        .slice_value,\n        .aggregate_value,\n        .union_value,\n        .error_value,\n        .null_value,\n        .undefined_value,\n        => false,\n        .unknown_value => .unknown_type == @as(Index, @enumFromInt(ip.items.items(.data)[@intFromEnum(ty)])),\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isUnknown from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isUnknown(ip: *InternPool, index: Index) bool {\n    switch (index) {\n        .unknown_type, .unknown_unknown => return true,\n        else => {\n            ip.lock.lockShared();\n            defer ip.lock.unlockShared();\n            return ip.items.items(.tag)[@intFromEnum(index)] == .unknown_value;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isUnknown",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isUnknownDeep from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isUnknownDeep(ip: *InternPool, gpa: Allocator, index: Index) Allocator.Error!bool {\n    var set: std.AutoHashMapUnmanaged(Index, void) = .empty;\n    defer set.deinit(gpa);\n    return try ip.isUnknownDeepInternal(index, gpa, &set);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isUnknownDeep",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to isUnknownDeepInternal from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn isUnknownDeepInternal(\n    ip: *InternPool,\n    index: Index,\n    gpa: Allocator,\n    set: *std.AutoHashMapUnmanaged(Index, void),\n) Allocator.Error!bool {\n    const gop = try set.getOrPut(gpa, index);\n    if (gop.found_existing) return false;\n    return switch (ip.indexToKey(index)) {\n        .simple_type => |simple| switch (simple) {\n            .unknown => true,\n            else => false,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isUnknownDeepInternal",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to isSignedInt from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isSignedInt(ip: *InternPool, ty: Index, target: std.Target) bool {\n    return switch (ty) {\n        .c_char_type => target.cCharSignedness() == .signed,\n        .isize_type, .c_short_type, .c_int_type, .c_long_type, .c_longlong_type => true,\n        else => switch (ip.indexToKey(ty)) {\n            .int_type => |int_type| int_type.signedness == .signed,\n            else => false,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isSignedInt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isUnsignedInt from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isUnsignedInt(ip: *InternPool, ty: Index, target: std.Target) bool {\n    return switch (ty) {\n        .c_char_type => target.cCharSignedness() == .unsigned,\n        .usize_type, .c_ushort_type, .c_uint_type, .c_ulong_type, .c_ulonglong_type => true,\n        else => switch (ip.indexToKey(ty)) {\n            .int_type => |int_type| int_type.signedness == .unsigned,\n            else => false,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isUnsignedInt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to intInfo from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn intInfo(ip: *InternPool, ty: Index, target: std.Target) std.builtin.Type.Int {\n    var index = ty;\n    while (true) switch (index) {\n        .u1_type => return .{ .signedness = .unsigned, .bits = 1 }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "intInfo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toUnsigned from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn toUnsigned(ip: *InternPool, gpa: Allocator, ty: Index, target: std.Target) Allocator.Error!Index {\n    const tag = ip.zigTypeTag(ty) orelse unreachable;\n    return switch (tag) {\n        .int => try ip.get(gpa, .{ .int_type = .{\n            .signedness = .unsigned,\n            .bits = ip.intInfo(ty, target).bits,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "toUnsigned",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to floatBits from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn floatBits(ip: *InternPool, ty: Index, target: std.Target) u16 {\n    _ = ip;\n    return switch (ty) {\n        .f16_type => 16,\n        .f32_type => 32,\n        .f64_type => 64,\n        .f80_type => 80,\n        .f128_type, .comptime_float_type => 128,\n        .c_longdouble_type => target.cTypeBitSize(.longdouble),\n\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "floatBits",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isFloat from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isFloat(ip: *InternPool, ty: Index) bool {\n    _ = ip;\n    return switch (ty) {\n        .c_longdouble_type,\n        .f16_type,\n        .f32_type,\n        .f64_type,\n        .f80_type,\n        .f128_type,\n        .comptime_float_type,\n        => true,\n        else => false,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isFloat",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isSinglePointer from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isSinglePointer(ip: *InternPool, ty: Index) bool {\n    return switch (ip.indexToKey(ty)) {\n        .pointer_type => |pointer_info| pointer_info.flags.size == .one,\n        else => false,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isSinglePointer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isManyPointer from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isManyPointer(ip: *InternPool, ty: Index) bool {\n    return switch (ip.indexToKey(ty)) {\n        .pointer_type => |pointer_info| pointer_info.flags.size == .many,\n        else => false,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isManyPointer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isSlicePointer from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isSlicePointer(ip: *InternPool, ty: Index) bool {\n    return switch (ip.indexToKey(ty)) {\n        .pointer_type => |pointer_info| pointer_info.flags.size == .slice,\n        else => false,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isSlicePointer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isCPointer from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isCPointer(ip: *InternPool, ty: Index) bool {\n    return switch (ip.indexToKey(ty)) {\n        .pointer_type => |pointer_info| pointer_info.flags.size == .c,\n        else => false,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isCPointer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isConstPointer from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isConstPointer(ip: *InternPool, ty: Index) bool {\n    return switch (ip.indexToKey(ty)) {\n        .pointer_type => |pointer_info| pointer_info.flags.is_const,\n        else => false,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isConstPointer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ptrAllowsZero from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn ptrAllowsZero(ip: *InternPool, ty: Index) bool {\n    if (ip.indexToKey(ty).pointer_type.flags.is_allowzero) return true;\n    return ip.isPtrLikeOptional(ty);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "ptrAllowsZero",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isPtrLikeOptional from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isPtrLikeOptional(ip: *InternPool, ty: Index) bool {\n    return switch (ip.indexToKey(ty)) {\n        .optional_type => |optional_info| switch (ip.indexToKey(optional_info.payload_type)) {\n            .pointer_type => |pointer_info| switch (pointer_info.flags.size) {\n                .slice, .c => false,\n                .many, .one => !pointer_info.flags.is_allowzero,\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isPtrLikeOptional",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isPtrAtRuntime from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isPtrAtRuntime(ip: *InternPool, ty: Index) bool {\n    return switch (ip.indexToKey(ty)) {\n        .pointer_type => |pointer_info| pointer_info.flags.size != .slice,\n        .optional_type => |optional_info| switch (ip.indexToKey(optional_info.payload_type)) {\n            .pointer_type => |pointer_info| switch (pointer_info.flags.size) {\n                .slice, .c => false,\n                .many, .one => !pointer_info.flags.is_allowzero,\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isPtrAtRuntime",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to childType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn childType(ip: *InternPool, ty: Index) Index {\n    return switch (ip.indexToKey(ty)) {\n        .pointer_type => |pointer_info| pointer_info.elem_type,\n        .array_type => |array_info| array_info.child,\n        .optional_type => |optional_info| optional_info.payload_type,\n        .vector_type => |vector_info| vector_info.child,\n        .anyframe_type => |anyframe_info| anyframe_info.child,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "childType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to elemType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn elemType(ip: *InternPool, ty: Index) Index {\n    return switch (ip.indexToKey(ty)) {\n        .pointer_type => |pointer_info| switch (pointer_info.flags.size) {\n            .one => ip.childType(pointer_info.elem_type),\n            .many, .c, .slice => pointer_info.elem_type,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "elemType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to scalarType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn scalarType(ip: *InternPool, ty: Index) Index {\n    const tag = ip.zigTypeTag(ty) orelse return ty;\n    return switch (tag) {\n        .vector => ip.childType(ty),\n        else => ty,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "scalarType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to errorSetMerge from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn errorSetMerge(ip: *InternPool, gpa: Allocator, a_ty: Index, b_ty: Index) Allocator.Error!Index {\n    assert(ip.zigTypeTag(a_ty) == .error_set);\n    assert(ip.zigTypeTag(b_ty) == .error_set);\n\n    // Anything merged with anyerror is anyerror.\n    if (a_ty == .anyerror_type or b_ty == .anyerror_type) {\n        return .anyerror_type;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "errorSetMerge",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to vectorLen from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn vectorLen(ip: *InternPool, ty: Index) u32 {\n    return switch (ip.indexToKey(ty)) {\n        .vector_type => |vector_type| vector_type.len,\n        .tuple_type => |tuple| tuple.types.len,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "vectorLen",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sentinel from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn sentinel(ip: *InternPool, ty: Index) Index {\n    return switch (ip.indexToKey(ty)) {\n        .pointer_type => |pointer_info| pointer_info.sentinel,\n        .array_type => |array_info| array_info.sentinel,\n        .vector_type => .none,\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "sentinel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getNamespace from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn getNamespace(ip: *InternPool, ty: Index) NamespaceIndex {\n    return switch (ip.indexToKey(ty)) {\n        .struct_type => |struct_index| ip.getStruct(struct_index).namespace,\n        .enum_type => |enum_index| ip.getEnum(enum_index).namespace,\n        .union_type => |union_index| ip.getUnion(union_index).namespace,\n        else => .none,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getNamespace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to onePossibleValue from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn onePossibleValue(ip: *InternPool, ty: Index) Index {\n    return switch (ip.indexToKey(ty)) {\n        .simple_type => |simple| switch (simple) {\n            .f16,\n            .f32,\n            .f64,\n            .f80,\n            .f128,\n            .usize,\n            .isize,\n            .c_char,\n            .c_short,\n            .c_ushort,\n            .c_int,\n            .c_uint,\n            .c_long,\n            .c_ulong,\n            .c_longlong,\n            .c_ulonglong,\n            .c_longdouble,\n            .anyopaque,\n            .bool,\n            .type,\n            .anyerror,\n            .comptime_int,\n            .comptime_float,\n            .anyframe_type,\n            .enum_literal_type,\n            => Index.none,\n\n            .empty_struct_type => Index.empty_aggregate,\n            .void => Index.void_value,\n            .noreturn => Index.unreachable_value,\n            .null_type => Index.null_value,\n            .undefined_type => Index.undefined_value,\n\n            .atomic_order,\n            .atomic_rmw_op,\n            .calling_convention,\n            .address_space,\n            .float_mode,\n            .reduce_op,\n            .modifier,\n            .prefetch_options,\n            .export_options,\n            .extern_options,\n            .type_info,\n            => Index.none,\n\n            .unknown => unreachable,\n            .generic_poison => unreachable,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "onePossibleValue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to canHaveFields from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn canHaveFields(ip: *InternPool, ty: Index) bool {\n    return switch (ip.indexToKey(ty)) {\n        .simple_type => |simple| switch (simple) {\n            .type => true, // TODO\n            .unknown => true,\n            else => false,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "canHaveFields",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isIndexable from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isIndexable(ip: *InternPool, ty: Index) bool {\n    return switch (ip.indexToKey(ty)) {\n        .array_type, .vector_type => true,\n        .pointer_type => |pointer_info| switch (pointer_info.flags.size) {\n            .slice, .many, .c => true,\n            .one => ip.indexToKey(pointer_info.elem_type) == .array_type,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isIndexable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isNull from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isNull(ip: *InternPool, val: Index) bool {\n    return switch (ip.indexToKey(val)) {\n        .simple_value => |simple| switch (simple) {\n            .null_value => true,\n            else => false,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isNull",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isZero from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn isZero(ip: *InternPool, val: Index) bool {\n    return switch (ip.indexToKey(val)) {\n        .simple_value => |simple| switch (simple) {\n            .null_value => true,\n            .bool_true => false,\n            .bool_false => true,\n            .the_only_possible_value => true,\n            else => false,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "isZero",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toInt from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn toInt(ip: *InternPool, val: Index, comptime T: type) ?T {\n    comptime assert(@typeInfo(T) == .int);\n    return switch (ip.indexToKey(val)) {\n        .simple_value => |simple| switch (simple) {\n            .null_value => 0,\n            .bool_true => 1,\n            .bool_false => 0,\n            .the_only_possible_value => 0,\n            else => null,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "toInt",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getBigInt from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn getBigInt(ip: *InternPool, gpa: Allocator, ty: Index, int: std.math.big.int.Const) Allocator.Error!Index {\n    assert(ip.isType(ty));\n    return try ip.get(gpa, .{\n        .int_big_value = .{ .ty = ty, .storage = .{ .external = int }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getBigInt",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getNull from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn getNull(ip: *InternPool, gpa: Allocator, ty: Index) Allocator.Error!Index {\n    if (ty == .none) return Index.null_value;\n    assert(ip.isType(ty));\n    return try ip.get(gpa, .{ .null_value = .{ .ty = ty }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getNull",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getUndefined from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn getUndefined(ip: *InternPool, gpa: Allocator, ty: Index) Allocator.Error!Index {\n    assert(ip.isType(ty));\n    return try ip.get(gpa, .{ .undefined_value = .{ .ty = ty }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getUndefined",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getUnknown from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn getUnknown(ip: *InternPool, gpa: Allocator, ty: Index) Allocator.Error!Index {\n    assert(ip.isType(ty));\n    if (ty == .type_type) return Index.unknown_type;\n    if (ty == .unknown_type) return Index.unknown_unknown;\n    return try ip.get(gpa, .{ .unknown_value = .{ .ty = ty }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "getUnknown",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to format from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn format(ctx: FormatContext, writer: *std.Io.Writer) std.Io.Writer.Error!void {\n    if (ctx.options.debug and ctx.index == .none) {\n        return writer.writeAll(\".none\");\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "format",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to print from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn print(ip: *InternPool, index: Index, writer: *std.Io.Writer, options: FormatOptions) std.Io.Writer.Error!void {\n    var tv = index;\n    const ty = ip.typeOf(tv);\n    while (true) {\n        if (options.debug and ty != .type_type) try writer.print(\"@as({f}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "print",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to printInternal from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn printInternal(ip: *InternPool, ty: Index, writer: *std.Io.Writer, options: FormatOptions) std.Io.Writer.Error!?Index {\n    switch (ip.indexToKey(ty)) {\n        .simple_type => |simple| switch (simple) {\n            .f16,\n            .f32,\n            .f64,\n            .f80,\n            .f128,\n            .usize,\n            .isize,\n            .c_char,\n            .c_short,\n            .c_ushort,\n            .c_int,\n            .c_uint,\n            .c_long,\n            .c_ulong,\n            .c_longlong,\n            .c_ulonglong,\n            .c_longdouble,\n            .anyopaque,\n            .bool,\n            .void,\n            .type,\n            .anyerror,\n            .comptime_int,\n            .comptime_float,\n            .noreturn,\n            .anyframe_type,\n            => try writer.writeAll(@tagName(simple)),\n\n            .null_type => try writer.writeAll(\"@TypeOf(null)\"),\n            .undefined_type => try writer.writeAll(\"@TypeOf(undefined)\"),\n            .empty_struct_type => try writer.writeAll(\"@TypeOf(.{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "printInternal",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to render from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn render(ctx: FormatId, writer: *std.Io.Writer) std.Io.Writer.Error!void {\n        const locked_string = ctx.ip.string_pool.stringToSliceLock(ctx.string);\n        defer locked_string.release(&ctx.ip.string_pool);\n        try writer.print(\"{f}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "render",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmtId from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub fn fmtId(ip: *InternPool, string: String) std.fmt.Alt(FormatId, FormatId.render) {\n    return .{ .data = .{ .ip = ip, .string = string }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "fmtId",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to do from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn do(\n            intern_pool: *InternPool,\n            wait_group: *std.Thread.WaitGroup,\n            allocator: std.mem.Allocator,\n            count: usize,\n        ) void {\n            defer wait_group.finish();\n            // insert float_32_value from 0 to count + random work\n            for (0..count) |i| {\n                _ = intern_pool.get(allocator, .{ .float_32_value = @floatFromInt(i) }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "do",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to testResolvePeerTypes from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn testResolvePeerTypes(ip: *InternPool, a: Index, b: Index, expected: Index) !void {\n    try ip.testResolvePeerTypesInOrder(a, b, expected);\n    try ip.testResolvePeerTypesInOrder(b, a, expected);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "testResolvePeerTypes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to testResolvePeerTypesInOrder from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn testResolvePeerTypesInOrder(ip: *InternPool, lhs: Index, rhs: Index, expected: Index) !void {\n    const actual = try resolvePeerTypes(ip, std.testing.allocator, &.{ lhs, rhs }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "testResolvePeerTypesInOrder",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to testCoerce from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "fn testCoerce(ip: *InternPool, dest_ty: Index, inst: Index, expected: Index) !void {\n    assert(ip.isType(dest_ty));\n\n    const gpa = std.testing.allocator;\n    var arena_allocator: std.heap.ArenaAllocator = .init(gpa);\n    defer arena_allocator.deinit();\n    const arena = arena_allocator.allocator();\n\n    var err_msg: ErrorMsg = undefined;\n    const actual = try ip.coerce(gpa, arena, dest_ty, inst, builtin.target, &err_msg);\n    if (expected == actual) return;\n\n    std.debug.print(\n        \\\\expression: @as({f}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "function",
      "name": "testCoerce",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Pointer from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const Pointer = struct {\n        elem_type: Index,\n        sentinel: Index = .none,\n        flags: Flags,\n        packed_offset: PackedOffset = .{ .bit_offset = 0, .host_size = 0 }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Pointer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Array from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const Array = struct {\n        // TODO convert this into an enum and have `std.math.maxInt(u64)` represent unknown length,\n        len: u64,\n        child: Index,\n        sentinel: Index = .none,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Array",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Optional from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const Optional = struct {\n        payload_type: Index,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Optional",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ErrorUnion from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const ErrorUnion = struct {\n        // .none if inferred error set\n        error_set_type: Index,\n        payload_type: Index,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "ErrorUnion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ErrorSet from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const ErrorSet = struct {\n        owner_decl: Decl.OptionalIndex,\n        names: StringSlice,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "ErrorSet",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Function from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const Function = struct {\n        args: Index.Slice,\n        /// zig only lets the first 32 arguments be `comptime`\n        args_is_comptime: std.StaticBitSet(32) = .initEmpty(),\n        /// zig only lets the first 32 arguments be generic\n        args_is_generic: std.StaticBitSet(32) = .initEmpty(),\n        /// zig only lets the first 32 arguments be `noalias`\n        args_is_noalias: std.StaticBitSet(32) = .initEmpty(),\n        return_type: Index,\n        flags: Flags = .{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Function",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Tuple from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const Tuple = struct {\n        types: Index.Slice,\n        /// Index.none elements are used to indicate runtime-known.\n        values: Index.Slice,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Tuple",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Vector from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const Vector = struct {\n        // TODO convert this into an enum and have `std.math.maxInt(u32)` represent unknown length,\n        len: u32,\n        child: Index,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Vector",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to AnyFrame from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const AnyFrame = struct {\n        child: Index,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "AnyFrame",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to U64Value from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const U64Value = struct {\n        ty: Index,\n        int: u64,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "U64Value",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to I64Value from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const I64Value = struct {\n        ty: Index,\n        int: i64,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "I64Value",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to BigInt from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const BigInt = struct {\n        ty: Index,\n        storage: union(enum) {\n            /// The limbs are stored outside of the `InternPool` and are managed by the caller of\n            /// the `Internpool.get` function.\n            /// Use this field when inserting a new BigInt into the `InternPool` instead of manually\n            /// storing the limbs in the `InternPool` with `getLimbSlice` because `Internpool.get`\n            /// function can perform deduplication of big ints to avoid storing the limbs twice.\n            /// See `InternPool.getBigInt`.\n            ///\n            /// This field will never be active as the returned `Key` from `InternPool.get`.\n            external: std.math.big.int.Const,\n            /// The limbs are stored in the `InternPool`.\n            /// This field will always be active as the returned `Key` from `InternPool.get`.\n            internal: struct {\n                positive: bool,\n                limbs: LimbSlice,\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "BigInt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to OptionalValue from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const OptionalValue = struct {\n        ty: Index,\n        val: Index,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "OptionalValue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Slice from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const Slice = struct {\n        ty: Index,\n        ptr: Index,\n        len: Index,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Slice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Aggregate from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const Aggregate = struct {\n        ty: Index,\n        values: Index.Slice,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Aggregate",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to UnionValue from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const UnionValue = struct {\n        ty: Index,\n        field_index: u32,\n        val: Index,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "UnionValue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ErrorValue from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const ErrorValue = struct {\n        ty: Index,\n        error_tag_name: String,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "ErrorValue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to NullValue from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const NullValue = struct {\n        ty: Index,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "NullValue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to UndefinedValue from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const UndefinedValue = struct {\n        ty: Index,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "UndefinedValue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to UnknownValue from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const UnknownValue = struct {\n        /// asserts that this is not .type_type because that is a the same as .unknown_type\n        ty: Index,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "UnknownValue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to BigIntInternal from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const BigIntInternal = struct {\n        ty: Index,\n        limbs: LimbSlice,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "BigIntInternal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Item from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const Item = struct {\n    tag: Tag,\n    /// The doc comments on the respective Tag explain how to interpret this.\n    data: u32,\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Item",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Slice from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const Slice = struct {\n        start: u32,\n        len: u32,\n\n        pub const empty: Slice = .{\n            .start = std.math.maxInt(u32),\n            .len = 0,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Slice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to StringSlice from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const StringSlice = struct {\n    start: u32,\n    len: u32,\n\n    pub const empty: StringSlice = .{\n        .start = std.math.maxInt(u32),\n        .len = 0,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "StringSlice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to LimbSlice from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const LimbSlice = struct {\n    start: u32,\n    len: u32,\n\n    pub const empty: LimbSlice = .{\n        .start = std.math.maxInt(u32),\n        .len = 0,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "LimbSlice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Decl from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const Decl = struct {\n    name: String,\n    node_idx: std.zig.Ast.Node.Index,\n    /// this stores both the type and the value\n    index: InternPool.Index,\n    alignment: u16,\n    address_space: std.builtin.AddressSpace,\n    src_namespace: InternPool.NamespaceIndex,\n    is_pub: bool,\n    is_exported: bool,\n\n    pub const Index = enum(u32) {\n        _,\n\n        pub fn toOptional(i: Decl.Index) OptionalIndex {\n            return @enumFromInt(@intFromEnum(i));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Decl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Struct from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const Struct = struct {\n    fields: std.AutoArrayHashMapUnmanaged(String, Field),\n    owner_decl: Decl.OptionalIndex,\n    namespace: NamespaceIndex,\n    layout: std.builtin.Type.ContainerLayout = .auto,\n    backing_int_ty: InternPool.Index,\n    status: FieldStatus,\n\n    pub const Index = enum(u32) { _ }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Struct",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Field from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const Field = struct {\n        ty: InternPool.Index,\n        default_value: InternPool.Index = .none,\n        alignment: u16 = 0,\n        is_comptime: bool = false,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Field",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Enum from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const Enum = struct {\n    tag_type: InternPool.Index,\n    fields: std.AutoArrayHashMapUnmanaged(String, void),\n    values: std.AutoArrayHashMapUnmanaged(InternPool.Index, void),\n    namespace: NamespaceIndex,\n    tag_type_inferred: bool,\n\n    pub const Index = enum(u32) { _ }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Enum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Union from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const Union = struct {\n    tag_type: InternPool.Index,\n    fields: std.AutoArrayHashMapUnmanaged(String, Field),\n    namespace: NamespaceIndex,\n    layout: std.builtin.Type.ContainerLayout = .auto,\n    status: FieldStatus,\n\n    pub const Field = struct {\n        ty: InternPool.Index,\n        alignment: u16,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Union",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to KeyAdapter from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const KeyAdapter = struct {\n    ip: *const InternPool,\n    precomputed_hash: u32,\n\n    pub fn eql(ctx: @This(), a: Key, b_void: void, b_map_index: usize) bool {\n        _ = b_void;\n        return a.eqlNoLock(ctx.ip.indexToKeyNoLock(@enumFromInt(b_map_index)), ctx.ip);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "KeyAdapter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Pair from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const Pair = struct {\n        actual: Index, // type\n        wanted: Index, // type\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Pair",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to PairAndChild from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const PairAndChild = struct {\n        child: *InMemoryCoercionResult,\n        actual: Index, // type\n        wanted: Index, // type\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "PairAndChild",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Param from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const Param = struct {\n        child: *InMemoryCoercionResult,\n        actual: Index, // type\n        wanted: Index, // type\n        index: u64,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Param",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ComptimeParam from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const ComptimeParam = struct {\n        index: u64,\n        wanted: bool,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "ComptimeParam",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Sentinel from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const Sentinel = struct {\n        // Index.none indicates no sentinel\n        actual: Index, // value\n        wanted: Index, // value\n        ty: Index,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Sentinel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to IntMismatch from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const IntMismatch = struct {\n        actual_signedness: std.builtin.Signedness,\n        wanted_signedness: std.builtin.Signedness,\n        actual_bits: u16,\n        wanted_bits: u16,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "IntMismatch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to IntPair from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const IntPair = struct {\n        actual: u64,\n        wanted: u64,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "IntPair",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Size from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const Size = struct {\n        actual: std.builtin.Type.Pointer.Size,\n        wanted: std.builtin.Type.Pointer.Size,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Qualifiers from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const Qualifiers = struct {\n        actual_const: bool,\n        wanted_const: bool,\n        actual_volatile: bool,\n        wanted_volatile: bool,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "Qualifiers",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to AddressSpace from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const AddressSpace = struct {\n        actual: std.builtin.AddressSpace,\n        wanted: std.builtin.AddressSpace,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "AddressSpace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to CC from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const CC = struct {\n        actual: std.builtin.CallingConvention.Tag,\n        wanted: std.builtin.CallingConvention.Tag,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "CC",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to BitRange from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const BitRange = struct {\n        actual_host: u16,\n        wanted_host: u16,\n        actual_offset: u16,\n        wanted_offset: u16,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "BitRange",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FormatContext from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const FormatContext = struct {\n    index: Index,\n    options: FormatOptions = .{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "FormatContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FormatOptions from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const FormatOptions = struct {\n    debug: bool = false,\n    // TODO: truncate structs, unions, enums\n    truncate_container: bool = false,\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "FormatOptions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FormatId from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const FormatId = struct {\n    ip: *InternPool,\n    string: String,\n\n    fn render(ctx: FormatId, writer: *std.Io.Writer) std.Io.Writer.Error!void {\n        const locked_string = ctx.ip.string_pool.stringToSliceLock(ctx.string);\n        defer locked_string.release(&ctx.ip.string_pool);\n        try writer.print(\"{f}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "FormatId",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to funcs from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const funcs = struct {\n        fn do(\n            intern_pool: *InternPool,\n            wait_group: *std.Thread.WaitGroup,\n            allocator: std.mem.Allocator,\n            count: usize,\n        ) void {\n            defer wait_group.finish();\n            // insert float_32_value from 0 to count + random work\n            for (0..count) |i| {\n                _ = intern_pool.get(allocator, .{ .float_32_value = @floatFromInt(i) }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "struct",
      "name": "funcs",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to empty from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const empty: Slice = .{\n            .start = std.math.maxInt(u32),\n            .len = 0,\n        };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "const",
      "name": "empty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to empty from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const empty: StringSlice = .{\n        .start = std.math.maxInt(u32),\n        .len = 0,\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "const",
      "name": "empty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to empty from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "pub const empty: LimbSlice = .{\n        .start = std.math.maxInt(u32),\n        .len = 0,\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "const",
      "name": "empty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to adapter from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const adapter: KeyAdapter = .{\n        .ip = ip,\n        .precomputed_hash = key.hash32(ip),\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "const",
      "name": "adapter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to adapter from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const adapter: KeyAdapter = .{\n        .ip = ip,\n        .precomputed_hash = key.hash32(ip),\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "const",
      "name": "adapter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to start from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const start: u32 = @intCast(ip.extra.items.len);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "const",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to start from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const start: u32 = @intCast(ip.extra.items.len);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "const",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to start from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const start: u32 = @intCast(ip.limbs.items.len);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "const",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to result from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const result: u32 = @intCast(ip.extra.items.len);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "const",
      "name": "result",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to err_set_ty from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const err_set_ty: Index = Index.none;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "const",
      "name": "err_set_ty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to candidate_key from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const candidate_key: Key = ip.indexToKey(candidate);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "const",
      "name": "candidate_key",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to size from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const size: usize = 100;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "const",
      "name": "size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to index from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const index: Index = @enumFromInt(index_start + i);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "const",
      "name": "index",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to value from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/InternPool.zig",
    "response": "const value: usize = @intFromFloat(key.float_32_value);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/InternPool.zig",
      "type": "const",
      "name": "value",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dotCompletions from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/completions.zig",
    "response": "pub fn dotCompletions(\n    arena: std.mem.Allocator,\n    completions: *std.ArrayList(types.CompletionItem),\n    ip: *InternPool,\n    index: InternPool.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/completions.zig",
      "type": "function",
      "name": "dotCompletions",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to formatFieldDetail from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/completions.zig",
    "response": "fn formatFieldDetail(ctx: FormatFieldDetail, writer: *std.Io.Writer) std.Io.Writer.Error!void {\n    const field = ctx.item;\n    if (field.is_comptime) {\n        try writer.writeAll(\"comptime \");\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/completions.zig",
      "type": "function",
      "name": "formatFieldDetail",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmtFieldDetail from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/completions.zig",
    "response": "pub fn fmtFieldDetail(ip: *InternPool, field: InternPool.Struct.Field) std.fmt.Alt(FormatFieldDetail, formatFieldDetail) {\n    return .{ .data = .{ .ip = ip, .item = field }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/completions.zig",
      "type": "function",
      "name": "fmtFieldDetail",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to testCompletion from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/completions.zig",
    "response": "fn testCompletion(\n    ip: *InternPool,\n    index: InternPool.Index,\n    expected: []const types.CompletionItem,\n) !void {\n    const gpa = std.testing.allocator;\n    var arena_allocator: std.heap.ArenaAllocator = .init(gpa);\n    defer arena_allocator.deinit();\n\n    const arena = arena_allocator.allocator();\n    var completions: std.ArrayList(types.CompletionItem) = .empty;\n\n    try dotCompletions(arena, &completions, ip, index);\n\n    try std.testing.expectEqualDeep(expected, completions.items);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/completions.zig",
      "type": "function",
      "name": "testCompletion",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FormatFieldDetail from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/completions.zig",
    "response": "const FormatFieldDetail = struct {\n    ip: *InternPool,\n    item: InternPool.Struct.Field,\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/completions.zig",
      "type": "struct",
      "name": "FormatFieldDetail",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to val from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/completions.zig",
    "response": "const val: InternPool.Index = index;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/completions.zig",
      "type": "const",
      "name": "val",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ty from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/completions.zig",
    "response": "const ty: InternPool.Index = ip.typeOf(index);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/completions.zig",
      "type": "const",
      "name": "ty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmtDegibberish from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/degibberish.zig",
    "response": "pub fn fmtDegibberish(ip: *InternPool, ty: InternPool.Index) std.fmt.Alt(FormatDegibberishData, formatDegibberish) {\n    const data: FormatDegibberishData = .{ .ip = ip, .ty = ty }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/degibberish.zig",
      "type": "function",
      "name": "fmtDegibberish",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to formatDegibberish from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/degibberish.zig",
    "response": "fn formatDegibberish(data: FormatDegibberishData, writer: *std.Io.Writer) std.Io.Writer.Error!void {\n    const ip = data.ip;\n    var ty = data.ty;\n\n    while (ty != .none) {\n        switch (ip.indexToKey(ty)) {\n            .simple_type,\n            .int_type,\n            => try writer.print(\"{f}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/degibberish.zig",
      "type": "function",
      "name": "formatDegibberish",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FormatDegibberishData from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/degibberish.zig",
    "response": "const FormatDegibberishData = struct {\n    ip: *InternPool,\n    ty: InternPool.Index,\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/degibberish.zig",
      "type": "struct",
      "name": "FormatDegibberishData",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to data from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/degibberish.zig",
    "response": "const data: FormatDegibberishData = .{ .ip = ip, .ty = ty };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/degibberish.zig",
      "type": "const",
      "name": "data",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmt from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/error_msg.zig",
    "response": "pub fn fmt(self: ErrorMsg, ip: *InternPool) std.fmt.Alt(FormatContext, format) {\n        return .{ .data = .{ .error_msg = self, .ip = ip }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/error_msg.zig",
      "type": "function",
      "name": "fmt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to format from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/error_msg.zig",
    "response": "pub fn format(ctx: FormatContext, writer: *std.Io.Writer) std.Io.Writer.Error!void {\n        const ip = ctx.ip;\n        switch (ctx.error_msg) {\n            .expected_type => |info| try writer.print(\n                \"expected type '{f}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/error_msg.zig",
      "type": "function",
      "name": "format",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FormatContext from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/error_msg.zig",
    "response": "const FormatContext = struct {\n        error_msg: ErrorMsg,\n        ip: *InternPool,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/error_msg.zig",
      "type": "struct",
      "name": "FormatContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to AtType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "fn AtType(comptime SelfType: type) type {\n            if (@typeInfo(SelfType).pointer.is_const) {\n                return *const T;\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "AtType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn deinit(self: *Self, allocator: Allocator) void {\n            self.freeShelves(allocator, @as(ShelfIndex, @intCast(self.dynamic_segments.len)), 0);\n            allocator.free(self.dynamic_segments);\n            self.* = undefined;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to at from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn at(self: anytype, i: usize) AtType(@TypeOf(self)) {\n            assert(i < self.len);\n            return self.uncheckedAt(i);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "at",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to count from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn count(self: Self) usize {\n            return self.len;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to append from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn append(self: *Self, allocator: Allocator, item: T) Allocator.Error!void {\n            const new_item_ptr = try self.addOne(allocator);\n            new_item_ptr.* = item;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "append",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to appendSlice from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn appendSlice(self: *Self, allocator: Allocator, items: []const T) Allocator.Error!void {\n            for (items) |item| {\n                try self.append(allocator, item);\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "appendSlice",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to pop from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn pop(self: *Self) ?T {\n            if (self.len == 0) return null;\n\n            const index = self.len - 1;\n            const result = uncheckedAt(self, index).*;\n            self.len = index;\n            return result;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "pop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addOne from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn addOne(self: *Self, allocator: Allocator) Allocator.Error!*T {\n            const new_length = self.len + 1;\n            try self.growCapacity(allocator, new_length);\n            const result = uncheckedAt(self, self.len);\n            self.len = new_length;\n            return result;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "addOne",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to shrinkRetainingCapacity from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn shrinkRetainingCapacity(self: *Self, new_len: usize) void {\n            assert(new_len <= self.len);\n            self.len = new_len;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "shrinkRetainingCapacity",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to clearRetainingCapacity from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn clearRetainingCapacity(self: *Self) void {\n            self.len = 0;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "clearRetainingCapacity",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to clearAndFree from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn clearAndFree(self: *Self, allocator: Allocator) void {\n            self.setCapacity(allocator, 0) catch unreachable;\n            self.len = 0;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "clearAndFree",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to setCapacity from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn setCapacity(self: *Self, allocator: Allocator, new_capacity: usize) Allocator.Error!void {\n            if (prealloc_item_count != 0) {\n                if (new_capacity <= @as(usize, 1) << (prealloc_exp + @as(ShelfIndex, @intCast(self.dynamic_segments.len)))) {\n                    return self.shrinkCapacity(allocator, new_capacity);\n                }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "setCapacity",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to growCapacity from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn growCapacity(self: *Self, allocator: Allocator, new_capacity: usize) Allocator.Error!void {\n            const new_cap_shelf_count = shelfCount(new_capacity);\n            const old_shelf_count = @as(ShelfIndex, @intCast(self.dynamic_segments.len));\n            if (new_cap_shelf_count <= old_shelf_count) return;\n\n            const new_dynamic_segments = try allocator.alloc([*]T, new_cap_shelf_count);\n            errdefer allocator.free(new_dynamic_segments);\n\n            var i: ShelfIndex = 0;\n            while (i < old_shelf_count) : (i += 1) {\n                new_dynamic_segments[i] = self.dynamic_segments[i];\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "growCapacity",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to shrinkCapacity from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn shrinkCapacity(self: *Self, allocator: Allocator, new_capacity: usize) void {\n            if (new_capacity <= prealloc_item_count) {\n                const len = @as(ShelfIndex, @intCast(self.dynamic_segments.len));\n                self.freeShelves(allocator, len, 0);\n                allocator.free(self.dynamic_segments);\n                self.dynamic_segments = &[_][*]T{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "shrinkCapacity",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to shrink from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn shrink(self: *Self, new_len: usize) void {\n            assert(new_len <= self.len);\n            // TODO take advantage of the new realloc semantics\n            self.len = new_len;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "shrink",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeToSlice from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn writeToSlice(self: *Self, dest: []T, start: usize) void {\n            const end = start + dest.len;\n            assert(end <= self.len);\n\n            var i = start;\n            if (end <= prealloc_item_count) {\n                const src = self.prealloc_segment[i..end];\n                @memcpy(dest[i - start ..][0..src.len], src);\n                return;\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "writeToSlice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to uncheckedAt from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn uncheckedAt(self: anytype, index: usize) AtType(@TypeOf(self)) {\n            if (index < prealloc_item_count) {\n                return &self.prealloc_segment[index];\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "uncheckedAt",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to shelfCount from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "fn shelfCount(box_count: usize) ShelfIndex {\n            if (prealloc_item_count == 0) {\n                return log2_int_ceil(usize, box_count + 1);\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "shelfCount",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to shelfSize from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "fn shelfSize(shelf_index: ShelfIndex) usize {\n            if (prealloc_item_count == 0) {\n                return @as(usize, 1) << shelf_index;\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "shelfSize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to shelfIndex from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "fn shelfIndex(list_index: usize) ShelfIndex {\n            if (prealloc_item_count == 0) {\n                return std.math.log2_int(usize, list_index + 1);\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "shelfIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to boxIndex from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "fn boxIndex(list_index: usize, shelf_index: ShelfIndex) usize {\n            if (prealloc_item_count == 0) {\n                return (list_index + 1) - (@as(usize, 1) << shelf_index);\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "boxIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to freeShelves from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "fn freeShelves(self: *Self, allocator: Allocator, from_count: ShelfIndex, to_count: ShelfIndex) void {\n            var i = from_count;\n            while (i != to_count) {\n                i -= 1;\n                allocator.free(self.dynamic_segments[i][0..shelfSize(i)]);\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "freeShelves",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to BaseIterator from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "fn BaseIterator(comptime SelfType: type, comptime ElementPtr: type) type {\n            return struct {\n                list: SelfType,\n                index: usize,\n                box_index: usize,\n                shelf_index: ShelfIndex,\n                shelf_size: usize,\n\n                pub fn next(it: *@This()) ?ElementPtr {\n                    if (it.index >= it.list.len) return null;\n                    if (it.index < prealloc_item_count) {\n                        const ptr = &it.list.prealloc_segment[it.index];\n                        it.index += 1;\n                        if (it.index == prealloc_item_count) {\n                            it.box_index = 0;\n                            it.shelf_index = 0;\n                            it.shelf_size = prealloc_item_count * 2;\n                        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "BaseIterator",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to prev from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn prev(it: *@This()) ?ElementPtr {\n                    if (it.index == 0) return null;\n\n                    it.index -= 1;\n                    if (it.index < prealloc_item_count) return &it.list.prealloc_segment[it.index];\n\n                    if (it.box_index == 0) {\n                        it.shelf_index -= 1;\n                        it.shelf_size /= 2;\n                        it.box_index = it.shelf_size - 1;\n                    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "prev",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to peek from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn peek(it: *@This()) ?ElementPtr {\n                    if (it.index >= it.list.len)\n                        return null;\n                    if (it.index < prealloc_item_count)\n                        return &it.list.prealloc_segment[it.index];\n\n                    return &it.list.dynamic_segments[it.shelf_index][it.box_index];\n                }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "peek",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to set from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn set(it: *@This(), index: usize) void {\n                    it.index = index;\n                    if (index < prealloc_item_count) return;\n                    it.shelf_index = shelfIndex(index);\n                    it.box_index = boxIndex(index, it.shelf_index);\n                    it.shelf_size = shelfSize(it.shelf_index);\n                }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "set",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to iterator from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn iterator(self: *Self, start_index: usize) Iterator {\n            var it = Iterator{\n                .list = self,\n                .index = undefined,\n                .shelf_index = undefined,\n                .box_index = undefined,\n                .shelf_size = undefined,\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "iterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to constIterator from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "pub fn constIterator(self: *const Self, start_index: usize) ConstIterator {\n            var it = ConstIterator{\n                .list = self,\n                .index = undefined,\n                .shelf_index = undefined,\n                .box_index = undefined,\n                .shelf_size = undefined,\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "constIterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to log2_int_ceil from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "fn log2_int_ceil(comptime T: type, x: T) std.math.Log2Int(T) {\n    assert(x != 0);\n    const log2_val = std.math.log2_int(T, x);\n    if (@as(T, 1) << log2_val == x)\n        return log2_val;\n    return log2_val + 1;\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "function",
      "name": "log2_int_ceil",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to prealloc_exp from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/segmented_list.zig",
    "response": "const prealloc_exp: ShelfIndex = blk: {\n            // we don't use the prealloc_exp constant when prealloc_item_count is 0\n            // but lazy-init may still be triggered by other code so supply a value\n            if (prealloc_item_count == 0) {\n                break :blk 0;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/segmented_list.zig",
      "type": "const",
      "name": "prealloc_exp",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to StringPool from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "pub fn StringPool(comptime config: Config) type {\n    return struct {\n        const Pool = @This();\n\n        /// A unique number that identifier a interned string.\n        ///\n        /// Two interned string can be checked for equality simply by checking\n        /// if this identifier are equal if they both come from the same StringPool.\n        pub const String = enum(u32) {\n            _,\n\n            pub fn toOptional(self: String) OptionalString {\n                return @enumFromInt(@intFromEnum(self));\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "function",
      "name": "StringPool",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmt from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "pub fn fmt(self: String, pool: *Pool) std.fmt.Alt(FormatContext, print) {\n                return .{ .data = .{ .string = self, .pool = pool }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "function",
      "name": "fmt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to unwrap from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "pub fn unwrap(self: OptionalString) ?String {\n                if (self == .none) return null;\n                return @enumFromInt(@intFromEnum(self));\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "function",
      "name": "unwrap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getString from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "pub fn getString(pool: *Pool, str: []const u8) ?String {\n            assert(std.mem.indexOfScalar(u8, str, 0) == null);\n\n            // precompute the hash before acquiring the lock\n            const precomputed_key_hash = std.hash_map.hashString(str);\n\n            pool.mutex.lock();\n            defer pool.mutex.unlock();\n\n            const adapter: PrecomputedStringIndexAdapter = .{\n                .bytes = &pool.bytes,\n                .adapted_key = str,\n                .precomputed_key_hash = precomputed_key_hash,\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "function",
      "name": "getString",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getOrPutString from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "pub fn getOrPutString(pool: *Pool, allocator: Allocator, str: []const u8) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "function",
      "name": "getOrPutString",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stringToSliceAlloc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "pub fn stringToSliceAlloc(pool: *Pool, allocator: Allocator, index: String) Allocator.Error![]const u8 {\n            pool.mutex.lock();\n            defer pool.mutex.unlock();\n            const string_bytes: [*:0]u8 = @ptrCast(pool.bytes.items.ptr);\n            const start = @intFromEnum(index);\n            return try allocator.dupe(u8, std.mem.sliceTo(string_bytes + start, 0));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "function",
      "name": "stringToSliceAlloc",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to stringToSliceAllocZ from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "pub fn stringToSliceAllocZ(pool: *Pool, allocator: Allocator, index: String) Allocator.Error![:0]const u8 {\n            pool.mutex.lock();\n            defer pool.mutex.unlock();\n            const string_bytes: [*:0]u8 = @ptrCast(pool.bytes.items.ptr);\n            const start = @intFromEnum(index);\n            return try allocator.dupeZ(u8, std.mem.sliceTo(string_bytes + start, 0));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "function",
      "name": "stringToSliceAllocZ",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to release from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "pub fn release(locked_string: LockedString, pool: *Pool) void {\n                _ = locked_string;\n                pool.mutex.unlock();\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "function",
      "name": "release",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stringToSliceLock from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "pub fn stringToSliceLock(pool: *Pool, index: String) LockedString {\n            pool.mutex.lock();\n            return .{ .slice = pool.stringToSliceUnsafe(index) }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "function",
      "name": "stringToSliceLock",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stringToSliceUnsafe from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "pub fn stringToSliceUnsafe(pool: *Pool, index: String) [:0]const u8 {\n            assert(@intFromEnum(index) < pool.bytes.items.len);\n            const string_bytes: [*:0]u8 = @ptrCast(pool.bytes.items.ptr);\n            const start = @intFromEnum(index);\n            return std.mem.sliceTo(string_bytes + start, 0);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "function",
      "name": "stringToSliceUnsafe",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "pub fn deinit(pool: *Pool, allocator: Allocator) void {\n            pool.bytes.deinit(allocator);\n            pool.map.deinit(allocator);\n            if (builtin.mode == .Debug and !builtin.single_threaded and config.thread_safe) {\n                // detect deadlock when calling deinit while holding the lock\n                pool.mutex.lock();\n                pool.mutex.unlock();\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to print from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "fn print(ctx: FormatContext, writer: *std.Io.Writer) std.Io.Writer.Error!void {\n            const locked_string = ctx.pool.stringToSliceLock(ctx.string);\n            defer locked_string.release(ctx.pool);\n            try writer.writeAll(locked_string.slice);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "function",
      "name": "print",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "pub fn eql(self: @This(), a_slice: []const u8, b: u32) bool {\n        const b_slice = std.mem.sliceTo(@as([*:0]const u8, @ptrCast(self.bytes.items.ptr)) + b, 0);\n        return std.mem.eql(u8, a_slice, b_slice);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "pub fn hash(self: @This(), adapted_key: []const u8) u64 {\n        assert(std.mem.eql(u8, self.adapted_key, adapted_key));\n        return self.precomputed_key_hash;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "function",
      "name": "hash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Config from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "pub const Config = struct {\n    /// Whether the StringPool may be used simultaneously from multiple threads.\n    thread_safe: bool = !builtin.single_threaded,\n\n    /// What type of mutex you'd like to use, for thread safety.\n    /// when specified, the mutex type must have the same shape as `std.Thread.Mutex` and\n    /// `DummyMutex`, and have no required fields. Specifying this field causes\n    /// the `thread_safe` field to be ignored.\n    ///\n    /// when null (default):\n    /// * the mutex type defaults to `std.Thread.Mutex` when thread_safe is enabled.\n    /// * the mutex type defaults to `DummyMutex` otherwise.\n    MutexType: ?type = null,\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "struct",
      "name": "Config",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to LockedString from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "pub const LockedString = struct {\n            slice: [:0]const u8,\n\n            pub fn release(locked_string: LockedString, pool: *Pool) void {\n                _ = locked_string;\n                pool.mutex.unlock();\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "struct",
      "name": "LockedString",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to DummyMutex from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "const DummyMutex = struct {\n            pub fn lock(_: *@This()) void {}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "struct",
      "name": "DummyMutex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FormatContext from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "const FormatContext = struct {\n            string: String,\n            pool: *Pool,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "struct",
      "name": "FormatContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to PrecomputedStringIndexAdapter from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "const PrecomputedStringIndexAdapter = struct {\n    bytes: *const std.ArrayList(u8),\n    adapted_key: []const u8,\n    precomputed_key_hash: u64,\n\n    pub fn eql(self: @This(), a_slice: []const u8, b: u32) bool {\n        const b_slice = std.mem.sliceTo(@as([*:0]const u8, @ptrCast(self.bytes.items.ptr)) + b, 0);\n        return std.mem.eql(u8, a_slice, b_slice);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "struct",
      "name": "PrecomputedStringIndexAdapter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to adapter from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "const adapter: PrecomputedStringIndexAdapter = .{\n                .bytes = &pool.bytes,\n                .adapted_key = str,\n                .precomputed_key_hash = precomputed_key_hash,\n            };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "const",
      "name": "adapter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to adapter from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "const adapter: PrecomputedStringIndexAdapter = .{\n                .bytes = &pool.bytes,\n                .adapted_key = str,\n                .precomputed_key_hash = precomputed_key_hash,\n            };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "const",
      "name": "adapter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to string_bytes from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "const string_bytes: [*:0]u8 = @ptrCast(pool.bytes.items.ptr);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "const",
      "name": "string_bytes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to string_bytes from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "const string_bytes: [*:0]u8 = @ptrCast(pool.bytes.items.ptr);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "const",
      "name": "string_bytes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to string_bytes from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "const string_bytes: [*:0]u8 = @ptrCast(pool.bytes.items.ptr);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "const",
      "name": "string_bytes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to empty from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analyser/string_pool.zig",
    "response": "pub const empty: Pool = .{\n            .mutex = .{},\n            .bytes = .empty,\n            .map = .empty,\n        };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analyser/string_pool.zig",
      "type": "const",
      "name": "empty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn init(\n    gpa: std.mem.Allocator,\n    arena: std.mem.Allocator,\n    store: *DocumentStore,\n    ip: *InternPool,\n    root_handle: ?*DocumentStore.Handle,\n) Analyser {\n    return .{\n        .gpa = gpa,\n        .arena = arena,\n        .store = store,\n        .ip = ip,\n        .collect_callsite_references = true,\n        .resolve_number_literal_values = false,\n        .root_handle = root_handle,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn deinit(self: *Analyser) void {\n    self.resolved_callsites.deinit(self.gpa);\n    self.resolved_nodes.deinit(self.gpa);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to allocType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn allocType(analyser: *Analyser, ty: Type) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "allocType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getDocCommentsBeforeToken from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn getDocCommentsBeforeToken(allocator: std.mem.Allocator, tree: Ast, base: Ast.TokenIndex) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "getDocCommentsBeforeToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getDocComments from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn getDocComments(allocator: std.mem.Allocator, tree: Ast, node: Ast.Node.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "getDocComments",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getDocCommentTokenIndex from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn getDocCommentTokenIndex(tree: *const Ast, base_token: Ast.TokenIndex) ?Ast.TokenIndex {\n    var idx = base_token;\n    if (idx == 0) return null;\n    idx -|= 1;\n    if (tree.tokenTag(idx) == .keyword_threadlocal and idx > 0) idx -|= 1;\n    if (tree.tokenTag(idx) == .string_literal and idx > 1 and tree.tokenTag(idx -| 1) == .keyword_extern) idx -|= 1;\n    if (tree.tokenTag(idx) == .keyword_extern and idx > 0) idx -|= 1;\n    if (tree.tokenTag(idx) == .keyword_export and idx > 0) idx -|= 1;\n    if (tree.tokenTag(idx) == .keyword_inline and idx > 0) idx -|= 1;\n    if (tree.tokenTag(idx) == .identifier and idx > 0) idx -|= 1;\n    if (tree.tokenTag(idx) == .keyword_pub and idx > 0) idx -|= 1;\n\n    // Find first doc comment token\n    if (!(tree.tokenTag(idx) == .doc_comment))\n        return null;\n    return while (tree.tokenTag(idx) == .doc_comment) {\n        if (idx == 0) break 0;\n        idx -|= 1;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "getDocCommentTokenIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to collectDocComments from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn collectDocComments(allocator: std.mem.Allocator, tree: Ast, doc_comments: Ast.TokenIndex, container_doc: bool) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "collectDocComments",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getFunctionSignature from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn getFunctionSignature(tree: Ast, func: Ast.full.FnProto) []const u8 {\n    const first_token = func.ast.fn_token;\n    const last_token = if (func.ast.return_type.unwrap()) |return_type| ast.lastToken(tree, return_type) else first_token;\n    return offsets.tokensToSlice(tree, first_token, last_token);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "getFunctionSignature",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to formatSnippetPlaceholder from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn formatSnippetPlaceholder(data: []const u8, writer: *std.Io.Writer) std.Io.Writer.Error!void {\n    var split_it = std.mem.splitScalar(u8, data, '}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "formatSnippetPlaceholder",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmtSnippetPlaceholder from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn fmtSnippetPlaceholder(bytes: []const u8) std.fmt.Alt([]const u8, formatSnippetPlaceholder) {\n    return .{ .data = bytes }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "fmtSnippetPlaceholder",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stringifyParameter from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn stringifyParameter(analyser: *Analyser, options: FormatParameterOptions) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "stringifyParameter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rawStringifyParameter from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn rawStringifyParameter(\n    analyser: *Analyser,\n    writer: *std.Io.Writer,\n    options: FormatParameterOptions,\n) error{ OutOfMemory, WriteFailed }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "rawStringifyParameter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stringifyFunction from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn stringifyFunction(analyser: *Analyser, options: FormatFunctionOptions) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "stringifyFunction",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rawStringifyFunction from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn rawStringifyFunction(\n    analyser: *Analyser,\n    writer: *std.Io.Writer,\n    options: FormatFunctionOptions,\n) error{ OutOfMemory, WriteFailed }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "rawStringifyFunction",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isInstanceCall from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isInstanceCall(\n    analyser: *Analyser,\n    call_handle: *DocumentStore.Handle,\n    call: Ast.full.Call,\n    func_ty: Type,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isInstanceCall",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hasSelfParam from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn hasSelfParam(analyser: *Analyser, func_ty: Type) !bool {\n    std.debug.assert(func_ty.isFunc());\n    const container = func_ty.data.function.container_type.*;\n    if (container.is_type_val) return false;\n    const in_container = try container.typeOf(analyser);\n    if (in_container.isNamespace()) return false;\n    return Analyser.firstParamIs(func_ty, in_container);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "hasSelfParam",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to firstParamIs from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn firstParamIs(\n    func_type: Type,\n    expected_type: Type,\n) bool {\n    std.debug.assert(expected_type.is_type_val);\n    std.debug.assert(func_type.isFunc());\n    const func_info = func_type.data.function;\n    if (func_info.parameters.len == 0) return false;\n    const resolved_type = func_info.parameters[0].type;\n    if (!resolved_type.is_type_val) return false;\n    if (resolved_type.data == .anytype_parameter) return true;\n\n    const deref_type = switch (resolved_type.data) {\n        .pointer => |info| switch (info.size) {\n            .one => info.elem_ty.*,\n            .many, .slice, .c => return false,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "firstParamIs",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getVariableSignature from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn getVariableSignature(\n    arena: std.mem.Allocator,\n    tree: Ast,\n    var_decl: Ast.full.VarDecl,\n    include_name: bool,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "getVariableSignature",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to trimCommonIndentation from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn trimCommonIndentation(allocator: std.mem.Allocator, str: []const u8, preserved_indentation_amount: usize) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "trimCommonIndentation",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getContainerFieldSignature from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn getContainerFieldSignature(tree: Ast, field: Ast.full.ContainerField) ?[]const u8 {\n    const type_expr = field.ast.type_expr.unwrap() orelse return null;\n\n    const end_node = if (field.ast.value_expr.unwrap()) |value_expr|\n        value_expr\n    else if (field.ast.align_expr.unwrap()) |align_expr|\n        align_expr\n    else\n        type_expr;\n\n    const first_token = tree.firstToken(type_expr);\n    const last_token = ast.lastToken(tree, end_node);\n    return offsets.tokensToSlice(tree, first_token, last_token);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "getContainerFieldSignature",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isMetaType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isMetaType(tree: Ast, node: Ast.Node.Index) bool {\n    if (tree.nodeTag(node) == .identifier) {\n        return std.mem.eql(u8, tree.tokenSlice(tree.nodeMainToken(node)), \"type\");\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isMetaType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isTypeFunction from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isTypeFunction(tree: Ast, func: Ast.full.FnProto) bool {\n    const return_type = func.ast.return_type.unwrap() orelse return false;\n    return isMetaType(tree, return_type);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isTypeFunction",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isCamelCase from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isCamelCase(name: []const u8) bool {\n    return !std.ascii.isUpper(name[0]) and !isSnakeCase(name);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isCamelCase",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isPascalCase from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isPascalCase(name: []const u8) bool {\n    return std.ascii.isUpper(name[0]) and !isSnakeCase(name);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isPascalCase",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isSnakeCase from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isSnakeCase(name: []const u8) bool {\n    return std.mem.indexOf(u8, name, \"_\") != null;\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isSnakeCase",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to identifierLocFromIndex from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn identifierLocFromIndex(tree: Ast, source_index: usize) ?offsets.Loc {\n    _, const loc = identifierTokenAndLocFromIndex(tree, source_index) orelse return null;\n    return loc;\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "identifierLocFromIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to identifierTokenAndLocFromIndex from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn identifierTokenAndLocFromIndex(tree: Ast, source_index: usize) ?struct { Ast.TokenIndex, offsets.Loc }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "identifierTokenAndLocFromIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveVarDeclAlias from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveVarDeclAlias(analyser: *Analyser, options: ResolveOptions) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveVarDeclAlias",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveVarDeclAliasInternal from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveVarDeclAliasInternal(analyser: *Analyser, options: ResolveOptions, node_trail: *NodeSet) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveVarDeclAliasInternal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveFieldAccess from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveFieldAccess(analyser: *Analyser, lhs: Type, field_name: []const u8) !?Type {\n    const binding = try analyser.resolveFieldAccessBinding(.{ .type = lhs, .is_const = false }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveFieldAccess",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveFieldAccessBinding from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveFieldAccessBinding(analyser: *Analyser, lhs_binding: Binding, field_name: []const u8) !?Binding {\n    const lhs = lhs_binding.type;\n\n    if (try analyser.resolveUnionTagAccess(lhs, field_name)) |t|\n        return .{ .type = t, .is_const = true }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveFieldAccessBinding",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveGenericType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveGenericType(analyser: *Analyser, ty: Type, bound_params: TokenToTypeMap) !Type {\n    var visiting: Type.Data.GenericSet = .empty;\n    defer visiting.deinit(analyser.gpa);\n    return analyser.resolveGenericTypeInternal(ty, bound_params, &visiting);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveGenericType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveGenericTypeInternal from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveGenericTypeInternal(\n    analyser: *Analyser,\n    ty: Type,\n    bound_params: TokenToTypeMap,\n    visiting: *Type.Data.GenericSet,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveGenericTypeInternal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findReturnStatementInternal from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn findReturnStatementInternal(tree: Ast, body: Ast.Node.Index, already_found: *bool) ?Ast.Node.Index {\n    var result: ?Ast.Node.Index = null;\n\n    var buffer: [2]Ast.Node.Index = undefined;\n    const statements = tree.blockStatements(&buffer, body) orelse return null;\n\n    for (statements) |child_idx| {\n        if (tree.nodeTag(child_idx) == .@\"return\") {\n            if (already_found.*) return null;\n            already_found.* = true;\n            result = child_idx;\n            continue;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "findReturnStatementInternal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findReturnStatement from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn findReturnStatement(tree: Ast, body: Ast.Node.Index) ?Ast.Node.Index {\n    var already_found = false;\n    return findReturnStatementInternal(tree, body, &already_found);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "findReturnStatement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveReturnType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveReturnType(analyser: *Analyser, func_type_param: Type) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveReturnType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveReturnValueOfFuncNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveReturnValueOfFuncNode(\n    analyser: *Analyser,\n    handle: *DocumentStore.Handle,\n    func_node: Ast.Node.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveReturnValueOfFuncNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveOptionalUnwrap from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveOptionalUnwrap(analyser: *Analyser, optional: Type) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveOptionalUnwrap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveOrelseType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveOrelseType(analyser: *Analyser, lhs: Type, rhs: Type) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveOrelseType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveAddressOf from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveAddressOf(analyser: *Analyser, is_const: bool, ty: Type) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveAddressOf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveUnwrapErrorUnionType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveUnwrapErrorUnionType(analyser: *Analyser, ty: Type, side: ErrorUnionSide) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveUnwrapErrorUnionType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveUnionTag from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveUnionTag(analyser: *Analyser, ty: Type) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveUnionTag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveUnionTagAccess from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveUnionTagAccess(analyser: *Analyser, ty: Type, symbol: []const u8) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveUnionTagAccess",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveFuncProtoOfCallable from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveFuncProtoOfCallable(analyser: *Analyser, ty: Type) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveFuncProtoOfCallable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveDerefType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveDerefType(analyser: *Analyser, pointer: Type) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveDerefType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveDerefBinding from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveDerefBinding(analyser: *Analyser, pointer: Type) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveDerefBinding",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromSlice from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn fromSlice(\n        analyser: *Analyser,\n        handle: *DocumentStore.Handle,\n        slice: Ast.full.Slice,\n    ) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "fromSlice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveBracketAccessType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveBracketAccessType(analyser: *Analyser, lhs: Type, rhs: BracketAccess) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveBracketAccessType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to bracketAccessTypeFromIPIndex from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn bracketAccessTypeFromIPIndex(analyser: *Analyser, ip_index: InternPool.Index) !Type {\n    std.debug.assert(analyser.ip.typeOf(ip_index) == .type_type);\n    return switch (analyser.ip.indexToKey(ip_index)) {\n        .vector_type => |info| .{\n            .data = .{\n                .array = .{\n                    .elem_count = info.len,\n                    .sentinel = .none,\n                    .elem_ty = try analyser.allocType(try analyser.bracketAccessTypeFromIPIndex(info.child)),\n                }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "bracketAccessTypeFromIPIndex",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveBracketAccessTypeFromBinding from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveBracketAccessTypeFromBinding(analyser: *Analyser, lhs_binding: Binding, rhs: BracketAccess) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveBracketAccessTypeFromBinding",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolvePropertyType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolvePropertyType(analyser: *Analyser, ty: Type, name: []const u8) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolvePropertyType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to allDigits from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn allDigits(str: []const u8) bool {\n    for (str) |c| {\n        if (!std.ascii.isDigit(c)) return false;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "allDigits",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveOptionalIPValue from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveOptionalIPValue(\n    analyser: *Analyser,\n    optional_node: Ast.Node.OptionalIndex,\n    handle: *DocumentStore.Handle,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveOptionalIPValue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveInternPoolValue from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveInternPoolValue(analyser: *Analyser, options: ResolveOptions) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveInternPoolValue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveIntegerLiteral from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveIntegerLiteral(analyser: *Analyser, comptime T: type, options: ResolveOptions) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveIntegerLiteral",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to extractArrayData from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn extractArrayData(data: *Type.Data) ?*Type.Data {\n    return switch (data.*) {\n        .array => data,\n        .pointer => |*p| switch (p.elem_ty.data) {\n            .array => &p.elem_ty.data,\n            else => null,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "extractArrayData",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolvePrimitive from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolvePrimitive(analyser: *Analyser, identifier_name: []const u8) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolvePrimitive",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveStringLiteral from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveStringLiteral(analyser: *Analyser, options: ResolveOptions) !?[]const u8 {\n    var node_with_handle = options.node_handle;\n    if (try analyser.resolveVarDeclAlias(options)) |decl_with_handle| {\n        if (decl_with_handle.decl == .ast_node) {\n            node_with_handle = .{\n                .node = decl_with_handle.decl.ast_node,\n                .handle = decl_with_handle.handle,\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveStringLiteral",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveErrorSetIPIndex from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveErrorSetIPIndex(analyser: *Analyser, options: ResolveOptions) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveErrorSetIPIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolvePeerTypes from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolvePeerTypes(analyser: *Analyser, a: Type, b: Type) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolvePeerTypes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolvePeerTypesIP from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolvePeerTypesIP(analyser: *Analyser, a: InternPool.Index, b: InternPool.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolvePeerTypesIP",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolvePeerErrorSets from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolvePeerErrorSets(analyser: *Analyser, a: Type, b: Type) !?Type {\n    if (a.data != .ip_index) return null;\n    if (b.data != .ip_index) return null;\n    if (a.data.ip_index.type != .type_type) return null;\n    if (b.data.ip_index.type != .type_type) return null;\n    const a_index = a.data.ip_index.index orelse return null;\n    const b_index = b.data.ip_index.index orelse return null;\n    if (analyser.ip.zigTypeTag(a_index) != .error_set) return null;\n    if (analyser.ip.zigTypeTag(b_index) != .error_set) return null;\n    const resolved_index = try analyser.ip.errorSetMerge(analyser.gpa, a_index, b_index);\n    return Type.fromIP(analyser, .type_type, resolved_index);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolvePeerErrorSets",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolvePeerTypesInternal from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolvePeerTypesInternal(analyser: *Analyser, a: Type, b: Type) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolvePeerTypesInternal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveCallsiteReferences from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveCallsiteReferences(analyser: *Analyser, decl_handle: DeclWithHandle) !?Type {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    const pay = switch (decl_handle.decl) {\n        .function_parameter => |pay| pay,\n        else => return null,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveCallsiteReferences",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveFunctionTypeFromCall from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveFunctionTypeFromCall(\n    analyser: *Analyser,\n    handle: *DocumentStore.Handle,\n    call: Ast.full.Call,\n    func_ty: Type,\n) !Type {\n    if (!func_ty.isGenericType()) {\n        return func_ty;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveFunctionTypeFromCall",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn deinit(context: *FindBreaks) void {\n        context.break_operands.deinit(context.allocator);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findBreakOperands from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn findBreakOperands(context: *FindBreaks, tree: Ast, node: Ast.Node.Index) Error!void {\n        std.debug.assert(node != .root);\n\n        const allow_unlabeled = context.allow_unlabeled;\n\n        switch (tree.nodeTag(node)) {\n            .@\"break\" => {\n                const opt_label_token, const operand = tree.nodeData(node).opt_token_and_opt_node;\n                if (allow_unlabeled and opt_label_token == .none) {\n                    try context.break_operands.append(context.allocator, operand.unwrap() orelse return);\n                }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "findBreakOperands",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveTypeOfNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveTypeOfNode(analyser: *Analyser, options: ResolveOptions) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveTypeOfNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveTypeOfNodeInternal from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveTypeOfNodeInternal(analyser: *Analyser, options: ResolveOptions) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveTypeOfNodeInternal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveBindingOfNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveBindingOfNode(analyser: *Analyser, options: ResolveOptions) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveBindingOfNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveBindingOfNodeInternal from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveBindingOfNodeInternal(analyser: *Analyser, options: ResolveOptions) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveBindingOfNodeInternal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveTypeOfNodeUncached from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveTypeOfNodeUncached(analyser: *Analyser, options: ResolveOptions) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveTypeOfNodeUncached",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveBindingOfNodeUncached from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveBindingOfNodeUncached(analyser: *Analyser, options: ResolveOptions) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveBindingOfNodeUncached",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to of from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn of(node: Ast.Node.Index, handle: *DocumentStore.Handle) ResolveOptions {\n        return .{\n            .node_handle = .of(node, handle),\n            .container_type = null,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "of",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to foo from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn foo() Foo`\n        function: Function,\n\n        /// - `@compileError(\"\")`\n        compile_error: NodeWithHandle,\n\n        /// `T` in `fn Foo(comptime T: type) type`\n        type_parameter: TokenWithHandle,\n\n        /// `anytype` in `fn foo(bar: anytype) @TypeOf(bar)`\n        anytype_parameter: struct {\n            token_handle: TokenWithHandle,\n            type_from_callsite_references: ?*Type, // TODO: come up with a shorter name...\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "foo",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to root from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn root(handle: *DocumentStore.Handle) Container {\n                return .{\n                    .scope_handle = .{ .handle = handle, .scope = .root }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "root",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hashWithHasher from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn hashWithHasher(data: Data, hasher: anytype) void {\n            hasher.update(&.{@intFromEnum(data)}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "hashWithHasher",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn eql(a: Data, b: Data) bool {\n            if (@intFromEnum(a) != @intFromEnum(b)) return false;\n\n            switch (a) {\n                .pointer => |a_type| {\n                    const b_type = b.pointer;\n                    if (a_type.size != b_type.size) return false;\n                    if (a_type.sentinel != b_type.sentinel) return false;\n                    if (!a_type.elem_ty.eql(b_type.elem_ty.*)) return false;\n                }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isGeneric from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn isGeneric(data: Data) bool {\n            return switch (data) {\n                .type_parameter => true,\n                .anytype_parameter => true,\n                .pointer => |info| info.elem_ty.data.isGeneric(),\n                .array => |info| info.elem_ty.data.isGeneric(),\n                .tuple => |types| {\n                    for (types) |t| {\n                        if (t.data.isGeneric()) {\n                            return true;\n                        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isGeneric",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn hash(ctx: GenericContext, data: Data) u64 {\n                var hasher: std.hash.Wyhash = .init(0);\n                data.hashWithHasher(&hasher);\n                for (ctx.bound_params.keys(), ctx.bound_params.values()) |token_handle, ty| {\n                    token_handle.hashWithHasher(&hasher);\n                    ty.hashWithHasher(&hasher);\n                }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "hash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn eql(ctx: GenericContext, a: Data, b: Data) bool {\n                _ = ctx;\n                return a.eql(b);\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveGeneric from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn resolveGeneric(\n            data: Data,\n            analyser: *Analyser,\n            bound_params: TokenToTypeMap,\n            visiting: *GenericSet,\n        ) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveGeneric",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash32 from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn hash32(self: Type) u32 {\n        return @truncate(self.hash64());\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "hash32",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash64 from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn hash64(self: Type) u64 {\n        var hasher: std.hash.Wyhash = .init(0);\n        self.hashWithHasher(&hasher);\n        return hasher.final();\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "hash64",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hashWithHasher from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn hashWithHasher(self: Type, hasher: anytype) void {\n        hasher.update(&.{@intFromBool(self.is_type_val)}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "hashWithHasher",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn eql(a: Type, b: Type) bool {\n        if (a.is_type_val != b.is_type_val) return false;\n        if (!a.data.eql(b.data)) return false;\n        return true;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ArrayMap from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn ArrayMap(comptime V: type) type {\n        return std.ArrayHashMapUnmanaged(Type, V, ArrayMapContext, true);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "ArrayMap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn hash(self: ArrayMapContext, ty: Type) u32 {\n            _ = self;\n            return ty.hash32();\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "hash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn eql(self: ArrayMapContext, a: Type, b: Type, b_index: usize) bool {\n            _ = self;\n            _ = b_index;\n            return a.eql(b);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromIP from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn fromIP(analyser: *Analyser, ty: InternPool.Index, index: ?InternPool.Index) Type {\n        std.debug.assert(analyser.ip.isType(ty));\n        if (index) |idx| std.debug.assert(analyser.ip.typeOf(idx) == ty);\n        return .{\n            .data = .{ .ip_index = .{ .type = ty, .index = index }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "fromIP",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fromEither from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn fromEither(analyser: *Analyser, entries: []const TypeWithDescriptor) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "fromEither",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn hash(self: @This(), item: Type.Data.EitherEntry) u32 {\n                _ = self;\n                const ty: Type = .{ .data = item.type_data, .is_type_val = true }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "hash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn eql(self: @This(), a: Type.Data.EitherEntry, b: Type.Data.EitherEntry, b_index: usize) bool {\n                _ = b_index;\n                _ = self;\n                const a_ty: Type = .{ .data = a.type_data, .is_type_val = true }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getAllTypesWithHandles from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn getAllTypesWithHandles(ty: Type, analyser: *Analyser) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "getAllTypesWithHandles",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isConditional from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn isConditional(ty: Type) bool {\n        return switch (ty.data) {\n            .either => true,\n            .anytype_parameter => true,\n            .optional => |child_ty| child_ty.isConditional(),\n            .pointer => |info| info.elem_ty.isConditional(),\n            .array => |info| info.elem_ty.isConditional(),\n            .tuple => |types| {\n                for (types) |t|\n                    if (t.isConditional()) return true;\n                return false;\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isConditional",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getAllTypesWithHandlesArraySet from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn getAllTypesWithHandlesArraySet(ty: Type, analyser: *Analyser, all_types: *ArraySet) !bool {\n        if (all_types.count() >= analyser.max_conditional_combos) {\n            return true;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "getAllTypesWithHandlesArraySet",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn init(\n            arena: std.mem.Allocator,\n            possible_types: *const ArrayMap([]const Type),\n        ) !ComboIterator {\n            var current_combo: ArrayMap(Type) = .empty;\n            try current_combo.entries.resize(arena, possible_types.count());\n            @memcpy(current_combo.keys(), possible_types.keys());\n            try current_combo.reIndex(arena);\n\n            var total_combos: usize = 1;\n            for (possible_types.values()) |types| {\n                total_combos *= types.len;\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn next(iter: *ComboIterator) ?*const ArrayMap(Type) {\n            if (iter.counter == iter.total_combos) return null;\n            var x = iter.counter;\n            for (iter.current_combo.values(), iter.possible_types.values()) |*t, types| {\n                t.* = types[x % types.len];\n                x /= types.len;\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to instanceTypeVal from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn instanceTypeVal(self: Type, analyser: *Analyser) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "instanceTypeVal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to typeOf from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn typeOf(self: Type, analyser: *Analyser) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "typeOf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isRoot from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn isRoot(self: Type) bool {\n        switch (self.data) {\n            .container => |info| return info.scope_handle.scope == Scope.Index.root,\n            else => return false,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isRoot",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isGenericType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isGenericType(self: Type) bool {\n        return self.data.isGeneric();\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isGenericType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getContainerKind from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn getContainerKind(self: Type) ?std.zig.Token.Tag {\n        const scope_handle = switch (self.data) {\n            .container => |info| info.scope_handle,\n            else => return null,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "getContainerKind",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isContainerKind from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn isContainerKind(self: Type, container_kind_tok: std.zig.Token.Tag) bool {\n        return self.getContainerKind() == container_kind_tok;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isContainerKind",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isStructType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isStructType(self: Type) bool {\n        return self.data == .tuple or self.isContainerKind(.keyword_struct) or self.isRoot();\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isStructType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isNamespace from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isNamespace(self: Type) bool {\n        const scope_handle = switch (self.data) {\n            .tuple => |fields| return fields.len == 0,\n            .container => |info| info.scope_handle,\n            else => return false,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isNamespace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isEnumType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isEnumType(self: Type) bool {\n        return self.isContainerKind(.keyword_enum);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isEnumType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isUnionType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isUnionType(self: Type) bool {\n        return self.isContainerKind(.keyword_union);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isUnionType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isOpaqueType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isOpaqueType(self: Type) bool {\n        return self.isContainerKind(.keyword_opaque);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isOpaqueType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isTaggedUnion from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isTaggedUnion(self: Type) bool {\n        return switch (self.data) {\n            .container => |info| ast.isTaggedUnion(info.scope_handle.handle.tree, info.scope_handle.toNode()),\n            else => false,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isTaggedUnion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isMetaType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isMetaType(self: Type) bool {\n        if (!self.is_type_val) return false;\n        switch (self.data) {\n            .ip_index => |payload| return payload.index == .type_type,\n            else => return false,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isMetaType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isErrorSetType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isErrorSetType(self: Type, analyser: *Analyser) bool {\n        if (!self.is_type_val) return false;\n        switch (self.data) {\n            .ip_index => |payload| {\n                const ip_index = payload.index orelse return false;\n                return analyser.ip.zigTypeTag(ip_index) == .error_set;\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isErrorSetType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isEnumLiteral from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isEnumLiteral(self: Type) bool {\n        switch (self.data) {\n            .ip_index => |payload| return payload.type == .enum_literal_type,\n            else => return false,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isEnumLiteral",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveDeclLiteralResultType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveDeclLiteralResultType(ty: Type) Type {\n        var result_type = ty;\n        while (true) {\n            result_type = switch (result_type.data) {\n                .optional => |child_ty| child_ty.*,\n                .error_union => |info| info.payload.*,\n                .pointer => |child_ty| child_ty.elem_ty.*,\n                else => return result_type,\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveDeclLiteralResultType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isTypeFunc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isTypeFunc(self: Type) bool {\n        return switch (self.data) {\n            .function => |info| info.return_value.is_type_val,\n            else => false,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isTypeFunc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isGenericFunc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isGenericFunc(self: Type) bool {\n        return switch (self.data) {\n            .function => |info| {\n                for (info.parameters) |param| {\n                    if (param.type.data == .anytype_parameter or param.modifier == .comptime_param) {\n                        return true;\n                    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isGenericFunc",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to isFunc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isFunc(self: Type) bool {\n        return switch (self.data) {\n            .function => true,\n            else => false,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isFunc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isNoreturnType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isNoreturnType(self: Type) bool {\n        if (!self.is_type_val) return false;\n        return switch (self.data) {\n            .compile_error => true,\n            .ip_index => |payload| payload.index == .noreturn_type,\n            else => false,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isNoreturnType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to typeDefinitionToken from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn typeDefinitionToken(self: Type) !?TokenWithHandle {\n        return switch (self.data) {\n            .container => |info| .{\n                .token = info.scope_handle.handle.tree.firstToken(info.scope_handle.toNode()),\n                .handle = info.scope_handle.handle,\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "typeDefinitionToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to docComments from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn docComments(self: Type, allocator: std.mem.Allocator) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "docComments",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lookupSymbol from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn lookupSymbol(\n        self: Type,\n        analyser: *Analyser,\n        symbol: []const u8,\n    ) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "lookupSymbol",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stringifyTypeOf from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn stringifyTypeOf(ty: Type, analyser: *Analyser, options: FormatOptions) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "stringifyTypeOf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stringifyTypeVal from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn stringifyTypeVal(ty: Type, analyser: *Analyser, options: FormatOptions) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "stringifyTypeVal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeString from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn writeString(str: []const u8, writer: *std.Io.Writer) std.Io.Writer.Error!void {\n        try writer.writeAll(str);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "writeString",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to rawStringify from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn rawStringify(\n        ty: Type,\n        writer: *std.Io.Writer,\n        analyser: *Analyser,\n        options: FormatOptions,\n    ) error{ OutOfMemory, WriteFailed }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "rawStringify",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn toNode(scope_handle: ScopeWithHandle) Ast.Node.Index {\n        if (scope_handle.scope == Scope.Index.root) return .root;\n        var doc_scope = scope_handle.handle.getDocumentScopeCached();\n        return doc_scope.getScopeAstNode(scope_handle.scope).?;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "toNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hashWithHasher from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn hashWithHasher(scope_handle: ScopeWithHandle, hasher: anytype) void {\n        hasher.update(scope_handle.handle.uri);\n        std.hash.autoHash(hasher, scope_handle.scope);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "hashWithHasher",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn eql(a: ScopeWithHandle, b: ScopeWithHandle) bool {\n        if (a.scope != b.scope) return false;\n        if (!std.mem.eql(u8, a.handle.uri, b.handle.uri)) return false;\n        return true;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to instanceStdBuiltinType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn instanceStdBuiltinType(analyser: *Analyser, type_name: []const u8) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "instanceStdBuiltinType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to collectImports from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn collectImports(allocator: std.mem.Allocator, tree: Ast) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "collectImports",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to collectCImportNodes from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn collectCImportNodes(allocator: std.mem.Allocator, tree: Ast) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "collectCImportNodes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn hash(self: Context, item: NodeWithUri) u64 {\n            _ = self;\n            var hasher: std.hash.Wyhash = .init(0);\n            std.hash.autoHash(&hasher, item.node);\n            hasher.update(item.uri);\n            return hasher.final();\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "hash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn eql(self: Context, a: NodeWithUri, b: NodeWithUri) bool {\n            _ = self;\n            if (a.node != b.node) return false;\n            return std.mem.eql(u8, a.uri, b.uri);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to of from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn of(node: Ast.Node.Index, handle: *DocumentStore.Handle) NodeWithHandle {\n        return .{ .node = node, .handle = handle }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "of",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn eql(a: NodeWithHandle, b: NodeWithHandle) bool {\n        if (a.node != b.node) return false;\n        return std.mem.eql(u8, a.handle.uri, b.handle.uri);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getFieldAccessType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn getFieldAccessType(\n    analyser: *Analyser,\n    handle: *DocumentStore.Handle,\n    source_index: usize,\n    loc: offsets.Loc,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "getFieldAccessType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to loc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn loc(self: PositionContext, tree: *const Ast) ?offsets.Loc {\n        return switch (self) {\n            .builtin,\n            .import_string_literal,\n            .cinclude_string_literal,\n            .embedfile_string_literal,\n            .string_literal,\n            .field_access,\n            .var_access,\n            .label_access,\n            .label_decl,\n            .enum_literal,\n            .number_literal,\n            .char_literal,\n            .parens_expr,\n            => |l| return l,\n            .keyword => |token_index| return offsets.tokenToLoc(tree.*, token_index),\n            .global_error_set,\n            .comment,\n            .other,\n            .empty,\n            => return null,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "loc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stringLiteralContentLoc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn stringLiteralContentLoc(self: PositionContext, source: []const u8) offsets.Loc {\n        var location = switch (self) {\n            .import_string_literal,\n            .cinclude_string_literal,\n            .embedfile_string_literal,\n            .string_literal,\n            => |l| l,\n            else => unreachable,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "stringLiteralContentLoc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to peek from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn peek(allocator: std.mem.Allocator, arr: *std.ArrayList(StackState)) !*StackState {\n    if (arr.items.len == 0) {\n        try arr.append(allocator, .{ .ctx = .empty, .stack_id = .global }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "peek",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to tokenLocAppend from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn tokenLocAppend(prev: offsets.Loc, token: std.zig.Token) offsets.Loc {\n    return .{\n        .start = prev.start,\n        .end = token.loc.end,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "tokenLocAppend",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isSymbolChar from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isSymbolChar(char: u8) bool {\n    return std.ascii.isAlphanumeric(char) or char == '_';\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isSymbolChar",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getPositionContext from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn getPositionContext(\n    allocator: std.mem.Allocator,\n    tree: Ast,\n    source_index: usize,\n    /// Should we look beyond the `source_index`? `false` for completions, `true` otherwise (hover, goto, etc.)\n    lookahead: bool,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "getPositionContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hashWithHasher from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn hashWithHasher(token_handle: TokenWithHandle, hasher: anytype) void {\n        std.hash.autoHash(hasher, token_handle.token);\n        hasher.update(token_handle.handle.uri);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "hashWithHasher",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn eql(a: TokenWithHandle, b: TokenWithHandle) bool {\n        if (a.token != b.token) return false;\n        if (!std.mem.eql(u8, a.handle.uri, b.handle.uri)) return false;\n        return true;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn hash(self: Context, token_handle: TokenWithHandle) u32 {\n            _ = self;\n            var hasher: std.hash.Wyhash = .init(0);\n            token_handle.hashWithHasher(&hasher);\n            return @truncate(hasher.final());\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "hash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn eql(self: Context, a: TokenWithHandle, b: TokenWithHandle, b_index: usize) bool {\n            _ = self;\n            _ = b_index;\n            return a.eql(b);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn eql(a: DeclWithHandle, b: DeclWithHandle) bool {\n        return a.decl.eql(b.decl) and std.mem.eql(u8, a.handle.uri, b.handle.uri);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nameToken from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn nameToken(self: DeclWithHandle) Ast.TokenIndex {\n        return self.decl.nameToken(self.handle.tree);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "nameToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to definitionToken from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn definitionToken(self: DeclWithHandle, analyser: *Analyser, resolve_alias: bool) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "definitionToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to typeDeclarationNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn typeDeclarationNode(self: DeclWithHandle) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "typeDeclarationNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isConst from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isConst(self: DeclWithHandle) bool {\n        const tree = self.handle.tree;\n        return switch (self.decl) {\n            .ast_node => |node| switch (tree.nodeTag(node)) {\n                .global_var_decl,\n                .local_var_decl,\n                .aligned_var_decl,\n                .simple_var_decl,\n                => {\n                    const mut_token = tree.fullVarDecl(node).?.ast.mut_token;\n                    switch (tree.tokenTag(mut_token)) {\n                        .keyword_var => return false,\n                        .keyword_const => return true,\n                        else => unreachable,\n                    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isConst",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isCaptureByRef from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isCaptureByRef(self: DeclWithHandle) bool {\n        const tree = self.handle.tree;\n        return switch (self.decl) {\n            .ast_node,\n            .function_parameter,\n            .error_union_error,\n            .assign_destructure,\n            .label,\n            .error_token,\n            .switch_inline_tag_payload,\n            => false,\n            inline .optional_payload,\n            .for_loop_payload,\n            .error_union_payload,\n            => |payload| tree.tokenTag(payload.identifier - 1) == .asterisk,\n            .switch_payload => |payload| tree.tokenTag(payload.getCase(tree).payload_token.?) == .asterisk,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isCaptureByRef",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to docComments from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn docComments(self: DeclWithHandle, allocator: std.mem.Allocator) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "docComments",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isPublic from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isPublic(self: DeclWithHandle) bool {\n        const tree = self.handle.tree;\n        var buf: [1]Ast.Node.Index = undefined;\n        return switch (self.decl) {\n            .ast_node => |node| switch (tree.nodeTag(node)) {\n                .global_var_decl,\n                .local_var_decl,\n                .simple_var_decl,\n                .aligned_var_decl,\n                => tree.fullVarDecl(node).?.visib_token != null,\n                .fn_proto,\n                .fn_proto_multi,\n                .fn_proto_one,\n                .fn_proto_simple,\n                .fn_decl,\n                => tree.fullFnProto(&buf, node).?.visib_token != null,\n                .container_field,\n                .container_field_init,\n                .container_field_align,\n                => true,\n                else => unreachable,\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isPublic",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isStatic from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn isStatic(self: DeclWithHandle) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "isStatic",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveType(self: DeclWithHandle, analyser: *Analyser) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to collectDeclarationsOfContainer from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn collectDeclarationsOfContainer(\n    analyser: *Analyser,\n    /// A container type (i.e. `struct`, `union`, `enum`, `opaque`)\n    container_type: Type,\n    original_handle: *DocumentStore.Handle,\n    /// Whether or not the container type is a instance of its type.\n    /// ```zig\n    /// const NotInstance = struct{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "collectDeclarationsOfContainer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to collectAllSymbolsAtSourceIndex from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn collectAllSymbolsAtSourceIndex(\n    analyser: *Analyser,\n    /// a handle to a Document\n    handle: *DocumentStore.Handle,\n    /// a byte-index into `handle.tree.source`\n    source_index: usize,\n    /// allocated with `analyser.arena`\n    decl_collection: *std.ArrayList(DeclWithHandle),\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "collectAllSymbolsAtSourceIndex",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn next(self: *EnclosingScopeIterator) Scope.OptionalIndex {\n        const current_scope = self.current_scope.unwrap() orelse return .none;\n        const scopes = self.document_scope.getScopeChildScopesConst(current_scope);\n        const scope_locs = self.document_scope.scopes.items(.loc);\n        const result = self.current_scope;\n\n        const Context = struct {\n            scope_locs: []const DocumentScope.Scope.SmallLoc,\n            source_index: usize,\n\n            fn compare(ctx: @This(), scope_index: Scope.Index) std.math.Order {\n                const child_scope = ctx.scope_locs[@intFromEnum(scope_index)];\n                if (ctx.source_index < child_scope.start) return .lt;\n                if (child_scope.end < ctx.source_index) return .gt;\n                return .eq;\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to iterateEnclosingScopes from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "fn iterateEnclosingScopes(document_scope: *const DocumentScope, source_index: usize) EnclosingScopeIterator {\n    return .{\n        .document_scope = document_scope,\n        .current_scope = .root,\n        .source_index = source_index,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "iterateEnclosingScopes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to iterateLabels from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn iterateLabels(handle: *DocumentStore.Handle, source_index: usize, comptime callback: anytype, context: anytype) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "iterateLabels",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to innermostScopeAtIndex from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn innermostScopeAtIndex(\n    document_scope: DocumentScope,\n    source_index: usize,\n) Scope.Index {\n    return innermostScopeAtIndexWithTag(document_scope, source_index, .initFull()).unwrap().?;\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "innermostScopeAtIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to innermostScopeAtIndexWithTag from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn innermostScopeAtIndexWithTag(\n    document_scope: DocumentScope,\n    source_index: usize,\n    tag_filter: std.EnumSet(Scope.Tag),\n) Scope.OptionalIndex {\n    var scope_iterator = iterateEnclosingScopes(&document_scope, source_index);\n    var scope_index: Scope.OptionalIndex = .none;\n    while (scope_iterator.next().unwrap()) |inner_scope| {\n        const scope_tag = document_scope.getScopeTag(inner_scope);\n        if (!tag_filter.contains(scope_tag)) continue;\n        scope_index = inner_scope.toOptional();\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "innermostScopeAtIndexWithTag",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to innermostContainer from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn innermostContainer(analyser: *Analyser, handle: *DocumentStore.Handle, source_index: usize) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "innermostContainer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lookupLabel from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn lookupLabel(\n    handle: *DocumentStore.Handle,\n    symbol: []const u8,\n    source_index: usize,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "lookupLabel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lookupSymbolGlobal from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn lookupSymbolGlobal(\n    _: *Analyser,\n    handle: *DocumentStore.Handle,\n    symbol: []const u8,\n    source_index: usize,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "lookupSymbolGlobal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lookupSymbolContainer from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn lookupSymbolContainer(\n    container_type: Type,\n    symbol: []const u8,\n    kind: DocumentScope.DeclarationLookup.Kind,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "lookupSymbolContainer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lookupSymbolFieldInit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn lookupSymbolFieldInit(\n    analyser: *Analyser,\n    handle: *DocumentStore.Handle,\n    field_name: []const u8,\n    node: Ast.Node.Index,\n    ancestors: []const Ast.Node.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "lookupSymbolFieldInit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveExpressionType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveExpressionType(\n    analyser: *Analyser,\n    handle: *DocumentStore.Handle,\n    node: Ast.Node.Index,\n    ancestors: []const Ast.Node.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveExpressionType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveExpressionTypeFromAncestors from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveExpressionTypeFromAncestors(\n    analyser: *Analyser,\n    handle: *DocumentStore.Handle,\n    node: Ast.Node.Index,\n    ancestors: []const Ast.Node.Index,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveExpressionTypeFromAncestors",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getSymbolEnumLiteral from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn getSymbolEnumLiteral(\n    analyser: *Analyser,\n    handle: *DocumentStore.Handle,\n    source_index: usize,\n    name: []const u8,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "getSymbolEnumLiteral",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveStructInitType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn resolveStructInitType(\n    analyser: *Analyser,\n    handle: *DocumentStore.Handle,\n    source_index: usize,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "resolveStructInitType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getSymbolFieldAccesses from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn getSymbolFieldAccesses(\n    analyser: *Analyser,\n    arena: std.mem.Allocator,\n    handle: *DocumentStore.Handle,\n    source_index: usize,\n    held_loc: offsets.Loc,\n    name: []const u8,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "getSymbolFieldAccesses",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getSymbolFieldAccessesArrayList from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn getSymbolFieldAccessesArrayList(\n    analyser: *Analyser,\n    arena: std.mem.Allocator,\n    handle: *DocumentStore.Handle,\n    source_index: usize,\n    held_loc: offsets.Loc,\n    name: []const u8,\n    decls_with_handles: *std.ArrayList(DeclWithHandle),\n    property_types: *std.ArrayList(Type),\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "getSymbolFieldAccessesArrayList",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getSymbolFieldAccessesHighlight from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn getSymbolFieldAccessesHighlight(\n    analyser: *Analyser,\n    arena: std.mem.Allocator,\n    handle: *DocumentStore.Handle,\n    source_index: usize,\n    loc: offsets.Loc,\n    decls_with_handles: *std.ArrayList(DeclWithHandle),\n    property_types: *std.ArrayList(Type),\n) !?offsets.Loc {\n    const name_loc, const highlight_loc = blk: {\n        const name_token, const name_loc = Analyser.identifierTokenAndLocFromIndex(handle.tree, source_index) orelse {\n            const token = offsets.sourceIndexToTokenIndex(handle.tree, source_index).pickPreferred(&.{ .question_mark, .period_asterisk }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "getSymbolFieldAccessesHighlight",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to of from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn of(\n        str: []const u8,\n        handle: *DocumentStore.Handle,\n        token: Ast.TokenIndex,\n    ) ReferencedType {\n        return .{ .str = str, .handle = handle, .token = token }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "of",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn hash(self: SetContext, item: ReferencedType) u32 {\n            _ = self;\n            var hasher: std.hash.Wyhash = .init(0);\n            hasher.update(item.str);\n            hasher.update(item.handle.uri);\n            hasher.update(&std.mem.toBytes(item.token));\n            return @truncate(hasher.final());\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "hash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub fn eql(self: SetContext, a: ReferencedType, b: ReferencedType, b_index: usize) bool {\n            _ = self;\n            _ = b_index;\n            return std.mem.eql(u8, a.str, b.str) and\n                std.mem.eql(u8, a.handle.uri, b.handle.uri) and\n                a.token == b.token;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FormatParameterOptions from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const FormatParameterOptions = struct {\n    referenced: ?*ReferencedType.Set = null,\n    info: Type.Data.Parameter,\n    index: usize,\n\n    include_modifier: bool,\n    include_name: bool,\n    include_type: bool,\n    snippet_placeholders: bool,\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "FormatParameterOptions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FormatFunctionOptions from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const FormatFunctionOptions = struct {\n    referenced: ?*ReferencedType.Set = null,\n    info: Type.Data.Function,\n\n    include_fn_keyword: bool,\n    /// only included if available\n    include_name: bool,\n    override_name: ?[]const u8 = null,\n    skip_first_param: bool = false,\n    parameters: union(enum) {\n        collapse,\n        show: struct {\n            include_modifiers: bool,\n            include_names: bool,\n            include_types: bool,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "FormatFunctionOptions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FindBreaks from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const FindBreaks = struct {\n    const Error = error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "FindBreaks",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ResolveOptions from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const ResolveOptions = struct {\n    node_handle: NodeWithHandle,\n    container_type: ?Type,\n\n    pub fn of(node: Ast.Node.Index, handle: *DocumentStore.Handle) ResolveOptions {\n        return .{\n            .node_handle = .of(node, handle),\n            .container_type = null,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "ResolveOptions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Binding from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const Binding = struct {\n    type: Type,\n    is_const: bool,\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "Binding",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Type from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const Type = struct {\n    data: Data,\n    /// If true, the type `type`, the attached data is the value of the type value.\n    /// ```zig\n    /// const foo = u32; // is_type_val == true\n    /// const bar = @as(u32, ...); // is_type_val == false\n    /// ```\n    /// if `data == .ip_index` then this field is equivalent to `data.ip_index.type == .type_type`\n    is_type_val: bool,\n\n    pub const Data = union(enum) {\n        /// - `*const T`\n        /// - `[*]T`\n        /// - `[]const T`\n        /// - `[*c]T`\n        pointer: struct {\n            size: std.builtin.Type.Pointer.Size,\n            /// `.none` means no sentinel\n            sentinel: InternPool.Index,\n            is_const: bool,\n            elem_ty: *Type,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "Type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Container from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const Container = struct {\n            scope_handle: ScopeWithHandle,\n            bound_params: TokenToTypeMap,\n\n            pub fn root(handle: *DocumentStore.Handle) Container {\n                return .{\n                    .scope_handle = .{ .handle = handle, .scope = .root }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "Container",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Function from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const Function = struct {\n            fn_token: Ast.TokenIndex,\n            handle: *DocumentStore.Handle,\n\n            container_type: *Type,\n            doc_comments: ?[]const u8,\n            name: ?[]const u8,\n            parameters: []Parameter,\n            has_varargs: bool,\n            return_value: *Type,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "Function",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Parameter from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const Parameter = struct {\n            doc_comments: ?[]const u8,\n            modifier: ?Modifier,\n            name: ?[]const u8,\n            name_token: ?Ast.TokenIndex,\n            type: Type,\n\n            pub const Modifier = enum {\n                comptime_param,\n                noalias_param,\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "Parameter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to EitherEntry from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const EitherEntry = struct {\n            /// the `is_type_val` property is inherited from the containing `Type`\n            type_data: Data,\n            descriptor: []const u8,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "EitherEntry",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to GenericContext from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const GenericContext = struct {\n            bound_params: TokenToTypeMap,\n\n            pub fn hash(ctx: GenericContext, data: Data) u64 {\n                var hasher: std.hash.Wyhash = .init(0);\n                data.hashWithHasher(&hasher);\n                for (ctx.bound_params.keys(), ctx.bound_params.values()) |token_handle, ty| {\n                    token_handle.hashWithHasher(&hasher);\n                    ty.hashWithHasher(&hasher);\n                }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "GenericContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ArrayMapContext from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const ArrayMapContext = struct {\n        pub fn hash(self: ArrayMapContext, ty: Type) u32 {\n            _ = self;\n            return ty.hash32();\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "ArrayMapContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to TypeWithDescriptor from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const TypeWithDescriptor = struct {\n        type: Type,\n        descriptor: []const u8,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "TypeWithDescriptor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to DeduplicatorContext from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const DeduplicatorContext = struct {\n            pub fn hash(self: @This(), item: Type.Data.EitherEntry) u32 {\n                _ = self;\n                const ty: Type = .{ .data = item.type_data, .is_type_val = true }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "DeduplicatorContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ComboIterator from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const ComboIterator = struct {\n        possible_types: *const ArrayMap([]const Type),\n        current_combo: ArrayMap(Type),\n        total_combos: usize,\n        counter: usize,\n\n        fn init(\n            arena: std.mem.Allocator,\n            possible_types: *const ArrayMap([]const Type),\n        ) !ComboIterator {\n            var current_combo: ArrayMap(Type) = .empty;\n            try current_combo.entries.resize(arena, possible_types.count());\n            @memcpy(current_combo.keys(), possible_types.keys());\n            try current_combo.reIndex(arena);\n\n            var total_combos: usize = 1;\n            for (possible_types.values()) |types| {\n                total_combos *= types.len;\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "ComboIterator",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FormatOptions from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const FormatOptions = struct {\n        referenced: ?*ReferencedType.Set = null,\n        truncate_container_decls: bool,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "FormatOptions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ScopeWithHandle from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const ScopeWithHandle = struct {\n    handle: *DocumentStore.Handle,\n    scope: Scope.Index,\n\n    pub fn toNode(scope_handle: ScopeWithHandle) Ast.Node.Index {\n        if (scope_handle.scope == Scope.Index.root) return .root;\n        var doc_scope = scope_handle.handle.getDocumentScopeCached();\n        return doc_scope.getScopeAstNode(scope_handle.scope).?;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "ScopeWithHandle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to NodeWithUri from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const NodeWithUri = struct {\n    node: Ast.Node.Index,\n    uri: []const u8,\n\n    const Context = struct {\n        pub fn hash(self: Context, item: NodeWithUri) u64 {\n            _ = self;\n            var hasher: std.hash.Wyhash = .init(0);\n            std.hash.autoHash(&hasher, item.node);\n            hasher.update(item.uri);\n            return hasher.final();\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "NodeWithUri",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to NodeWithHandle from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const NodeWithHandle = struct {\n    node: Ast.Node.Index,\n    handle: *DocumentStore.Handle,\n\n    pub fn of(node: Ast.Node.Index, handle: *DocumentStore.Handle) NodeWithHandle {\n        return .{ .node = node, .handle = handle }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "NodeWithHandle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to StackState from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const StackState = struct {\n    ctx: PositionContext,\n    stack_id: StackId,\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "StackState",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to TokenWithHandle from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const TokenWithHandle = struct {\n    token: Ast.TokenIndex,\n    handle: *DocumentStore.Handle,\n\n    pub fn hashWithHasher(token_handle: TokenWithHandle, hasher: anytype) void {\n        std.hash.autoHash(hasher, token_handle.token);\n        hasher.update(token_handle.handle.uri);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "TokenWithHandle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Context from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const Context = struct {\n        pub fn hash(self: Context, token_handle: TokenWithHandle) u32 {\n            _ = self;\n            var hasher: std.hash.Wyhash = .init(0);\n            token_handle.hashWithHasher(&hasher);\n            return @truncate(hasher.final());\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "Context",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to DeclWithHandle from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const DeclWithHandle = struct {\n    decl: Declaration,\n    handle: *DocumentStore.Handle,\n    container_type: ?Type = null,\n\n    pub fn eql(a: DeclWithHandle, b: DeclWithHandle) bool {\n        return a.decl.eql(b.decl) and std.mem.eql(u8, a.handle.uri, b.handle.uri);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "DeclWithHandle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to EnclosingScopeIterator from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const EnclosingScopeIterator = struct {\n    document_scope: *const DocumentScope,\n    current_scope: Scope.OptionalIndex,\n    source_index: usize,\n\n    pub fn next(self: *EnclosingScopeIterator) Scope.OptionalIndex {\n        const current_scope = self.current_scope.unwrap() orelse return .none;\n        const scopes = self.document_scope.getScopeChildScopesConst(current_scope);\n        const scope_locs = self.document_scope.scopes.items(.loc);\n        const result = self.current_scope;\n\n        const Context = struct {\n            scope_locs: []const DocumentScope.Scope.SmallLoc,\n            source_index: usize,\n\n            fn compare(ctx: @This(), scope_index: Scope.Index) std.math.Order {\n                const child_scope = ctx.scope_locs[@intFromEnum(scope_index)];\n                if (ctx.source_index < child_scope.start) return .lt;\n                if (child_scope.end < ctx.source_index) return .gt;\n                return .eq;\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "EnclosingScopeIterator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ReferencedType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "pub const ReferencedType = struct {\n    str: []const u8,\n    handle: *DocumentStore.Handle,\n    token: Ast.TokenIndex,\n\n    pub fn of(\n        str: []const u8,\n        handle: *DocumentStore.Handle,\n        token: Ast.TokenIndex,\n    ) ReferencedType {\n        return .{ .str = str, .handle = handle, .token = token }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "ReferencedType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to SetContext from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const SetContext = struct {\n        pub fn hash(self: SetContext, item: ReferencedType) u32 {\n            _ = self;\n            var hasher: std.hash.Wyhash = .init(0);\n            hasher.update(item.str);\n            hasher.update(item.handle.uri);\n            hasher.update(&std.mem.toBytes(item.token));\n            return @truncate(hasher.final());\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "struct",
      "name": "SetContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to expected_loc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const expected_loc: offsets.Loc = .{ .start = 1, .end = 5 };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "expected_loc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to expected_loc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const expected_loc: offsets.Loc = .{ .start = 8, .end = 15 };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "expected_loc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to expected_loc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const expected_loc: offsets.Loc = .{ .start = 19, .end = 26 };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "expected_loc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to expected_loc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const expected_loc: offsets.Loc = .{ .start = 43, .end = 46 };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "expected_loc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to node_with_uri from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const node_with_uri: NodeWithUri = .{\n        .node = node_handle.node,\n        .uri = node_handle.handle.uri,\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "node_with_uri",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to binding from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const binding: Binding = .{ .type = instance.?, .is_const = is_const };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "binding",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to signedness from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const signedness: std.builtin.Signedness = switch (identifier_name[0]) {\n        'i' => .signed,\n        'u' => .unsigned,\n        else => return null,\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "signedness",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to func_decl from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const func_decl: Declaration = .{ .ast_node = pay.func };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "func_decl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to node_with_uri from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const node_with_uri: NodeWithUri = .{\n        .node = node_handle.node,\n        .uri = node_handle.handle.uri,\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "node_with_uri",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to identifier_token from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const identifier_token: Ast.TokenIndex = @intCast(tok_i);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "identifier_token",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cast_map from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const cast_map: std.StaticStringMap(usize) = .initComptime(.{\n                .{ \"@as\", 0 },\n                .{ \"@atomicLoad\", 0 },\n                .{ \"@atomicRmw\", 0 },\n                .{ \"@cVaArg\", 1 },\n                .{ \"@extern\", 0 },\n                .{ \"@mulAdd\", 0 },\n                .{ \"@unionInit\", 0 },\n            });",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "cast_map",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to float_map from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const float_map: std.StaticStringMap(void) = .initComptime(.{\n                .{\"@sqrt\"},\n                .{\"@sin\"},\n                .{\"@cos\"},\n                .{\"@tan\"},\n                .{\"@exp\"},\n                .{\"@exp2\"},\n                .{\"@log\"},\n                .{\"@log2\"},\n                .{\"@log10\"},\n                .{\"@floor\"},\n                .{\"@ceil\"},\n                .{\"@trunc\"},\n                .{\"@round\"},\n            });",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "float_map",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to param_type from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const param_type: Type = param_type: {\n                    if (param.type_expr) |type_expr| blk: {\n                        const ty = try analyser.resolveTypeOfNode(.of(type_expr, handle)) orelse {\n                            break :blk;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "param_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to info from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const info: Type.Data.Function = .{\n                .handle = handle,\n                .fn_token = fn_proto.ast.fn_token,\n                .container_type = try analyser.allocType(container_type),\n                .doc_comments = doc_comments,\n                .name = name,\n                .parameters = parameters.items,\n                .has_varargs = has_varargs,\n                .return_value = try analyser.allocType(return_value),\n            };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "info",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to ty from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const ty: InternPool.Index = switch (result) {\n                .int,\n                .big_int,\n                => .comptime_int_type,\n                .float => .comptime_float_type,\n                .failure => return null,\n            };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "ty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to value from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const value: ?InternPool.Index = switch (result) {\n                .float => blk: {\n                    break :blk try analyser.ip.get(\n                        analyser.gpa,\n                        .{ .float_comptime_value = std.fmt.parseFloat(f128, bytes) catch break :blk null },\n                    );",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "value",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to prefix_length from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const prefix_length: usize = if (base != .decimal) 2 else 0;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "prefix_length",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to kind from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const kind: BracketAccess = try .fromSlice(analyser, handle, slice);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "kind",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ctx from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const ctx: GenericContext = .{ .bound_params = bound_params };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "ctx",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ty from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const ty: Type = .{ .data = item.type_data, .is_type_val = true };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "ty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to a_ty from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const a_ty: Type = .{ .data = a.type_data, .is_type_val = true };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "a_ty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to b_ty from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const b_ty: Type = .{ .data = b.type_data, .is_type_val = true };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "b_ty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to entry_ty from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const entry_ty: Type = .{ .data = entry.type_data, .is_type_val = ty.is_type_val };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "entry_ty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to old_type from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const old_type: Type = .{ .data = old.type_data, .is_type_val = self.is_type_val };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "old_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to old_type from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const old_type: Type = .{ .data = old.type_data, .is_type_val = self.is_type_val };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "old_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to entry_ty from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const entry_ty: Type = .{ .data = entry.type_data, .is_type_val = self.is_type_val };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "entry_ty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to builtin_root_struct_type from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const builtin_root_struct_type: Type = .{\n        .data = .{ .container = .root(builtin_handle) },\n        .is_type_val = true,\n    };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "builtin_root_struct_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to node from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const node: Ast.Node.Index = @enumFromInt(i);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "node",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to stack_id from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const stack_id: StackId = switch (curr_ctx.ctx) {\n                    .keyword => |token_index| switch (tree.tokenTag(token_index)) {\n                        .keyword_for,\n                        .keyword_if,\n                        .keyword_while,\n                        => .global,\n                        else => .paren,\n                    },\n                    else => .paren,\n                };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "stack_id",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to switch_expr_type from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const switch_expr_type: Type = (try analyser.resolveTypeOfNodeInternal(.of(cond, self.handle))) orelse return null;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "switch_expr_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ty from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const ty: Type = .{ .data = entry.type_data, .is_type_val = container_type.is_type_val };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "ty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to decl_with_handle from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const decl_with_handle: DeclWithHandle = .{ .decl = decl, .handle = handle, .container_type = container_type };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "decl_with_handle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to token_handle from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const token_handle: TokenWithHandle = .{ .token = param_name_token, .handle = handle };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "token_handle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ty from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const ty: Type = .{ .data = .{ .type_parameter = token_handle }, .is_type_val = true };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "ty",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to break_label_maybe from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/analysis.zig",
    "response": "const break_label_maybe: ?[]const u8 = if (opt_target.unwrap()) |target|\n                tree.tokenSlice(target)\n            else\n                null;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/analysis.zig",
      "type": "const",
      "name": "break_label_maybe",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fullPtrTypeComponents from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "fn fullPtrTypeComponents(tree: Ast, info: full.PtrType.Components) full.PtrType {\n    const size: std.builtin.Type.Pointer.Size = switch (tree.tokenTag(info.main_token)) {\n        .asterisk,\n        .asterisk_asterisk,\n        => switch (tree.tokenTag(info.main_token + 1)) {\n            .r_bracket, .colon => .many,\n            .identifier => if (info.main_token != 0 and tree.tokenTag(info.main_token - 1) == .l_bracket) .c else .one,\n            else => .one,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "fullPtrTypeComponents",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ptrTypeSimple from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn ptrTypeSimple(tree: Ast, node: Node.Index) full.PtrType {\n    std.debug.assert(tree.nodeTag(node) == .ptr_type);\n    const extra_index, const child_type = tree.nodeData(node).extra_and_node;\n    const extra = tree.extraData(extra_index, Node.PtrType);\n    return fullPtrTypeComponents(tree, .{\n        .main_token = tree.nodeMainToken(node),\n        .align_node = extra.align_node,\n        .addrspace_node = extra.addrspace_node,\n        .sentinel = extra.sentinel,\n        .bit_range_start = .none,\n        .bit_range_end = .none,\n        .child_type = child_type,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "ptrTypeSimple",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ptrTypeSentinel from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn ptrTypeSentinel(tree: Ast, node: Node.Index) full.PtrType {\n    std.debug.assert(tree.nodeTag(node) == .ptr_type_sentinel);\n    const sentinel, const child_type = tree.nodeData(node).opt_node_and_node;\n    return fullPtrTypeComponents(tree, .{\n        .main_token = tree.nodeMainToken(node),\n        .align_node = .none,\n        .addrspace_node = .none,\n        .sentinel = sentinel,\n        .bit_range_start = .none,\n        .bit_range_end = .none,\n        .child_type = child_type,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "ptrTypeSentinel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ptrTypeAligned from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn ptrTypeAligned(tree: Ast, node: Node.Index) full.PtrType {\n    std.debug.assert(tree.nodeTag(node) == .ptr_type_aligned);\n    const align_node, const child_type = tree.nodeData(node).opt_node_and_node;\n    return fullPtrTypeComponents(tree, .{\n        .main_token = tree.nodeMainToken(node),\n        .align_node = align_node,\n        .addrspace_node = .none,\n        .sentinel = .none,\n        .bit_range_start = .none,\n        .bit_range_end = .none,\n        .child_type = child_type,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "ptrTypeAligned",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ptrTypeBitRange from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn ptrTypeBitRange(tree: Ast, node: Node.Index) full.PtrType {\n    std.debug.assert(tree.nodeTag(node) == .ptr_type_bit_range);\n    const extra_index, const child_type = tree.nodeData(node).extra_and_node;\n    const extra = tree.extraData(extra_index, Node.PtrTypeBitRange);\n    return fullPtrTypeComponents(tree, .{\n        .main_token = tree.nodeMainToken(node),\n        .align_node = extra.align_node.toOptional(),\n        .addrspace_node = extra.addrspace_node,\n        .sentinel = extra.sentinel,\n        .bit_range_start = extra.bit_range_start.toOptional(),\n        .bit_range_end = extra.bit_range_end.toOptional(),\n        .child_type = child_type,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "ptrTypeBitRange",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to legacyAsmComponents from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "fn legacyAsmComponents(tree: Ast, info: full.AsmLegacy.Components) full.AsmLegacy {\n    var result: full.AsmLegacy = .{\n        .ast = info,\n        .volatile_token = null,\n        .inputs = &.{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "legacyAsmComponents",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fullAsmComponents from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "fn fullAsmComponents(tree: Ast, info: full.Asm.Components) full.Asm {\n    var result: full.Asm = .{\n        .ast = info,\n        .volatile_token = null,\n        .inputs = &.{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "fullAsmComponents",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to asmLegacy from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn asmLegacy(tree: Ast, node: Node.Index) full.AsmLegacy {\n    const template, const extra_index = tree.nodeData(node).node_and_extra;\n    const extra = tree.extraData(extra_index, Node.AsmLegacy);\n    const items = tree.extraDataSlice(.{ .start = extra.items_start, .end = extra.items_end }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "asmLegacy",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to asmSimple from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn asmSimple(tree: Ast, node: Node.Index) full.Asm {\n    const template, const rparen = tree.nodeData(node).node_and_token;\n    return fullAsmComponents(tree, .{\n        .asm_token = tree.nodeMainToken(node),\n        .template = template,\n        .items = &.{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "asmSimple",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to asmFull from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn asmFull(tree: Ast, node: Node.Index) full.Asm {\n    const template, const extra_index = tree.nodeData(node).node_and_extra;\n    const extra = tree.extraData(extra_index, Node.Asm);\n    const items = tree.extraDataSlice(.{ .start = extra.items_start, .end = extra.items_end }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "asmFull",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fullIfComponents from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "fn fullIfComponents(tree: Ast, info: full.If.Components) full.If {\n    var result: full.If = .{\n        .ast = info,\n        .payload_token = null,\n        .error_token = null,\n        .else_token = 0,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "fullIfComponents",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ifFull from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn ifFull(tree: Ast, node: Node.Index) full.If {\n    std.debug.assert(tree.nodeTag(node) == .@\"if\");\n    const cond_expr, const extra_index = tree.nodeData(node).node_and_extra;\n    const extra = tree.extraData(extra_index, Node.If);\n    return fullIfComponents(tree, .{\n        .cond_expr = cond_expr,\n        .then_expr = extra.then_expr,\n        .else_expr = extra.else_expr.toOptional(),\n        .if_token = tree.nodeMainToken(node),\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "ifFull",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ifSimple from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn ifSimple(tree: Ast, node: Node.Index) full.If {\n    std.debug.assert(tree.nodeTag(node) == .if_simple);\n    const cond_expr, const then_expr = tree.nodeData(node).node_and_node;\n    return fullIfComponents(tree, .{\n        .cond_expr = cond_expr,\n        .then_expr = then_expr,\n        .else_expr = .none,\n        .if_token = tree.nodeMainToken(node),\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "ifSimple",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fullWhileComponents from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "fn fullWhileComponents(tree: Ast, info: full.While.Components) full.While {\n    var result: full.While = .{\n        .ast = info,\n        .inline_token = null,\n        .label_token = null,\n        .payload_token = null,\n        .else_token = 0,\n        .error_token = null,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "fullWhileComponents",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fullForComponents from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "fn fullForComponents(tree: Ast, info: full.For.Components) full.For {\n    var result: full.For = .{\n        .ast = info,\n        .inline_token = null,\n        .label_token = null,\n        .payload_token = undefined,\n        .else_token = 0,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "fullForComponents",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to whileSimple from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn whileSimple(tree: Ast, node: Node.Index) full.While {\n    const cond_expr, const then_expr = tree.nodeData(node).node_and_node;\n    return fullWhileComponents(tree, .{\n        .while_token = tree.nodeMainToken(node),\n        .cond_expr = cond_expr,\n        .cont_expr = .none,\n        .then_expr = then_expr,\n        .else_expr = .none,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "whileSimple",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to whileCont from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn whileCont(tree: Ast, node: Node.Index) full.While {\n    const cond_expr, const extra_index = tree.nodeData(node).node_and_extra;\n    const extra = tree.extraData(extra_index, Node.WhileCont);\n    return fullWhileComponents(tree, .{\n        .while_token = tree.nodeMainToken(node),\n        .cond_expr = cond_expr,\n        .cont_expr = extra.cont_expr.toOptional(),\n        .then_expr = extra.then_expr,\n        .else_expr = .none,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "whileCont",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to whileFull from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn whileFull(tree: Ast, node: Node.Index) full.While {\n    const cond_expr, const extra_index = tree.nodeData(node).node_and_extra;\n    const extra = tree.extraData(extra_index, Node.While);\n    return fullWhileComponents(tree, .{\n        .while_token = tree.nodeMainToken(node),\n        .cond_expr = cond_expr,\n        .cont_expr = extra.cont_expr,\n        .then_expr = extra.then_expr,\n        .else_expr = extra.else_expr.toOptional(),\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "whileFull",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forSimple from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn forSimple(tree: Ast, node: Node.Index) full.For {\n    const data = &tree.nodes.items(.data)[@intFromEnum(node)].node_and_node;\n    return fullForComponents(tree, .{\n        .for_token = tree.nodeMainToken(node),\n        .inputs = (&data[0])[0..1],\n        .then_expr = data[1],\n        .else_expr = .none,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "forSimple",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forFull from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn forFull(tree: Ast, node: Node.Index) full.For {\n    const extra_index, const extra = tree.nodeData(node).@\"for\";\n    const inputs = tree.extraDataSliceWithLen(extra_index, extra.inputs, Node.Index);\n    const then_expr: Node.Index = @enumFromInt(tree.extra_data[@intFromEnum(extra_index) + extra.inputs]);\n    const else_expr: Node.OptionalIndex = if (extra.has_else) @enumFromInt(tree.extra_data[@intFromEnum(extra_index) + extra.inputs + 1]) else .none;\n    return fullForComponents(tree, .{\n        .for_token = tree.nodeMainToken(node),\n        .inputs = inputs,\n        .then_expr = then_expr,\n        .else_expr = else_expr,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "forFull",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fullPtrType from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn fullPtrType(tree: Ast, node: Node.Index) ?full.PtrType {\n    return switch (tree.nodeTag(node)) {\n        .ptr_type_aligned => ptrTypeAligned(tree, node),\n        .ptr_type_sentinel => ptrTypeSentinel(tree, node),\n        .ptr_type => ptrTypeSimple(tree, node),\n        .ptr_type_bit_range => ptrTypeBitRange(tree, node),\n        else => null,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "fullPtrType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fullIf from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn fullIf(tree: Ast, node: Node.Index) ?full.If {\n    return switch (tree.nodeTag(node)) {\n        .if_simple => ifSimple(tree, node),\n        .@\"if\" => ifFull(tree, node),\n        else => null,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "fullIf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fullWhile from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn fullWhile(tree: Ast, node: Node.Index) ?full.While {\n    return switch (tree.nodeTag(node)) {\n        .while_simple => whileSimple(tree, node),\n        .while_cont => whileCont(tree, node),\n        .@\"while\" => whileFull(tree, node),\n        else => null,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "fullWhile",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fullFor from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn fullFor(tree: Ast, node: Node.Index) ?full.For {\n    return switch (tree.nodeTag(node)) {\n        .for_simple => forSimple(tree, node),\n        .@\"for\" => forFull(tree, node),\n        else => null,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "fullFor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fullAsm from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn fullAsm(tree: Ast, node: Node.Index) ?full.Asm {\n    return switch (tree.nodeTag(node)) {\n        .asm_simple => asmSimple(tree, node),\n        .@\"asm\" => asmFull(tree, node),\n        else => null,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "fullAsm",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findMatchingRBrace from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "fn findMatchingRBrace(tree: Ast, start: Ast.TokenIndex) ?Ast.TokenIndex {\n    return if (std.mem.indexOfScalarPos(std.zig.Token.Tag, tree.tokens.items(.tag), start, .r_brace)) |index| @intCast(index) else null;\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "findMatchingRBrace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to testDeclNameAndToken from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn testDeclNameAndToken(tree: Ast, test_decl_node: Ast.Node.Index) ?struct { Ast.TokenIndex, []const u8 }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "testDeclNameAndToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to identifierTokenFromIdentifierNode from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn identifierTokenFromIdentifierNode(tree: Ast, node: Ast.Node.Index) ?Ast.TokenIndex {\n    const main_token = tree.nodeMainToken(node);\n    if (tree.tokenTag(main_token) != .identifier) return null;\n    return main_token;\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "identifierTokenFromIdentifierNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hasInferredError from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn hasInferredError(tree: Ast, fn_proto: Ast.full.FnProto) bool {\n    const return_type = fn_proto.ast.return_type.unwrap() orelse return false;\n    return tree.tokenTag(tree.firstToken(return_type) - 1) == .bang;\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "hasInferredError",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to paramFirstToken from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn paramFirstToken(tree: Ast, param: Ast.full.FnProto.Param, include_doc_comment: bool) Ast.TokenIndex {\n    return (if (include_doc_comment) param.first_doc_comment else null) orelse\n        param.comptime_noalias orelse\n        param.name_token orelse\n        tree.firstToken(param.type_expr.?);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "paramFirstToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to paramLastToken from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn paramLastToken(tree: Ast, param: Ast.full.FnProto.Param) Ast.TokenIndex {\n    return param.anytype_ellipsis3 orelse lastToken(tree, param.type_expr.?);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "paramLastToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to paramLoc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn paramLoc(tree: Ast, param: Ast.full.FnProto.Param, include_doc_comment: bool) offsets.Loc {\n    const first_token = paramFirstToken(tree, param, include_doc_comment);\n    const last_token = paramLastToken(tree, param);\n    return offsets.tokensToLoc(tree, first_token, last_token);\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "paramLoc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to paramSlice from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn paramSlice(tree: Ast, param: Ast.full.FnProto.Param, include_doc_comment: bool) []const u8 {\n    return offsets.locToSlice(tree.source, paramLoc(tree, param, include_doc_comment));\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "paramSlice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isTaggedUnion from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn isTaggedUnion(tree: Ast, node: Ast.Node.Index) bool {\n    if (tree.tokenTag(tree.nodeMainToken(node)) != .keyword_union)\n        return false;\n\n    var buf: [2]Ast.Node.Index = undefined;\n    const decl = tree.fullContainerDecl(&buf, node) orelse\n        return false;\n\n    return decl.ast.enum_token != null or decl.ast.arg != .none;\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "isTaggedUnion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isContainer from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn isContainer(tree: Ast, node: Ast.Node.Index) bool {\n    return switch (tree.nodeTag(node)) {\n        .container_decl,\n        .container_decl_trailing,\n        .container_decl_arg,\n        .container_decl_arg_trailing,\n        .container_decl_two,\n        .container_decl_two_trailing,\n        .tagged_union,\n        .tagged_union_trailing,\n        .tagged_union_two,\n        .tagged_union_two_trailing,\n        .tagged_union_enum_tag,\n        .tagged_union_enum_tag_trailing,\n        .root,\n        .error_set_decl,\n        => true,\n        else => false,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "isContainer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isBuiltinCall from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn isBuiltinCall(tree: Ast, node: Ast.Node.Index) bool {\n    return switch (tree.nodeTag(node)) {\n        .builtin_call,\n        .builtin_call_comma,\n        .builtin_call_two,\n        .builtin_call_two_comma,\n        => true,\n        else => false,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "isBuiltinCall",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to blockLabel from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn blockLabel(tree: Ast, node: Ast.Node.Index) ?Ast.TokenIndex {\n    const main_token = tree.nodeMainToken(node);\n\n    if (main_token < 2) return null;\n    if (tree.tokenTag(main_token - 1) != .colon) return null;\n    if (tree.tokenTag(main_token - 2) != .identifier) return null;\n    return main_token - 2;\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "blockLabel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to errorSetFieldCount from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn errorSetFieldCount(tree: Ast, node: Ast.Node.Index) usize {\n    std.debug.assert(tree.nodeTag(node) == .error_set_decl);\n    var count: usize = 0;\n    const lbrace, const rbrace = tree.nodeData(node).token_and_token;\n    for (lbrace + 1..rbrace) |tok_i| {\n        count += @intFromBool(tree.tokenTag(@intCast(tok_i)) == .identifier);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "errorSetFieldCount",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nextFnParam from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn nextFnParam(it: *Ast.full.FnProto.Iterator) ?Ast.full.FnProto.Param {\n    while (true) {\n        var first_doc_comment: ?Ast.TokenIndex = null;\n        var comptime_noalias: ?Ast.TokenIndex = null;\n        var name_token: ?Ast.TokenIndex = null;\n        if (!it.tok_flag) {\n            if (it.param_i >= it.fn_proto.ast.params.len) {\n                return null;\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "nextFnParam",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to iterateChildren from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn iterateChildren(\n    tree: Ast,\n    node: Ast.Node.Index,\n    context: anytype,\n    comptime Error: type,\n    comptime callback: fn (@TypeOf(context), Ast, Ast.Node.Index) Error!void,\n) Error!void {\n    const ctx = struct {\n        fn inner(ctx: *const anyopaque, t: Ast, n: Ast.Node.Index) anyerror!void {\n            return callback(@as(*const @TypeOf(context), @ptrCast(@alignCast(ctx))).*, t, n);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "iterateChildren",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to nextAge from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn nextAge(age: u32) u32 {\n        \\\\  return age + 1;\n        \\\\}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "nextAge",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "fn callback(self: @This(), ast: Ast, child_node: Ast.Node.Index) !void {\n            try self.accumulator.append(self.ally, ast.nodeTag(child_node));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nextAge from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn nextAge(age: u32) u32`\n        .block_two_semicolon, // i.e., `return { return age + 1; }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "nextAge",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to iterateChildrenTypeErased from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "fn iterateChildrenTypeErased(\n    tree: Ast,\n    node: Ast.Node.Index,\n    context: *const anyopaque,\n    callback: *const fn (*const anyopaque, Ast, Ast.Node.Index) anyerror!void,\n) anyerror!void {\n    switch (tree.nodeTag(node)) {\n        .bool_not,\n        .negation,\n        .bit_not,\n        .negation_wrap,\n        .address_of,\n        .@\"try\",\n        .optional_type,\n        .deref,\n        .@\"suspend\",\n        .@\"resume\",\n        .@\"comptime\",\n        .@\"nosuspend\",\n        .@\"defer\",\n        => {\n            try callback(context, tree, tree.nodeData(node).node);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "iterateChildrenTypeErased",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to iterateChildrenRecursive from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn iterateChildrenRecursive(\n    tree: Ast,\n    node: Ast.Node.Index,\n    context: anytype,\n    comptime Error: type,\n    comptime callback: fn (@TypeOf(context), Ast, Ast.Node.Index) Error!void,\n) Error!void {\n    const RecursiveContext = struct {\n        fn recursive_callback(ctx: *const anyopaque, ast: Ast, child_node: Ast.Node.Index) anyerror!void {\n            std.debug.assert(child_node != .root);\n            try callback(@as(*const @TypeOf(context), @ptrCast(@alignCast(ctx))).*, ast, child_node);\n            try iterateChildrenTypeErased(ast, child_node, ctx, recursive_callback);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "iterateChildrenRecursive",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to nodeChildrenAlloc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn nodeChildrenAlloc(allocator: std.mem.Allocator, tree: Ast, node: Ast.Node.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "nodeChildrenAlloc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "fn callback(self: @This(), ast: Ast, child_node: Ast.Node.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nodeChildrenRecursiveAlloc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn nodeChildrenRecursiveAlloc(allocator: std.mem.Allocator, tree: Ast, node: Ast.Node.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "nodeChildrenRecursiveAlloc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "fn callback(self: @This(), ast: Ast, child_node: Ast.Node.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nodesOverlappingIndex from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn nodesOverlappingIndex(allocator: std.mem.Allocator, tree: Ast, index: usize) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "nodesOverlappingIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to append from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn append(self: *@This(), ast: Ast, node: Ast.Node.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "append",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nodesOverlappingIndexIncludingParseErrors from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn nodesOverlappingIndexIncludingParseErrors(allocator: std.mem.Allocator, tree: Ast, source_index: usize) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "nodesOverlappingIndexIncludingParseErrors",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lessThan from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "fn lessThan(_: void, lhs: @This(), rhs: @This()) bool {\n            return rhs.loc.start < lhs.loc.start and lhs.loc.end < rhs.loc.end;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "lessThan",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nodesAtLoc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn nodesAtLoc(allocator: std.mem.Allocator, tree: Ast, loc: offsets.Loc) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "nodesAtLoc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to append from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn append(self: *@This(), ast: Ast, node: Ast.Node.Index) !void {\n            std.debug.assert(node != .root);\n            try self.nodes.append(self.allocator, node);\n            try self.locs.append(self.allocator, offsets.nodeToLoc(ast, node));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "append",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to smallestEnclosingSubrange from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn smallestEnclosingSubrange(children: []const offsets.Loc, loc: offsets.Loc) ?struct {\n    start: usize,\n    len: usize,\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "smallestEnclosingSubrange",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to indexOfBreakTarget from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "pub fn indexOfBreakTarget(\n    tree: Ast,\n    nodes: []const Ast.Node.Index,\n    break_label_maybe: ?[]const u8,\n) ?usize {\n    for (nodes, 0..) |node, index| {\n        if (fullFor(tree, node)) |for_node| {\n            const break_label = break_label_maybe orelse return index;\n            const for_label = tree.tokenSlice(for_node.label_token orelse continue);\n            if (std.mem.eql(u8, break_label, for_label)) return index;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "function",
      "name": "indexOfBreakTarget",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ctx from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "const ctx = struct {\n        fn inner(ctx: *const anyopaque, t: Ast, n: Ast.Node.Index) anyerror!void {\n            return callback(@as(*const @TypeOf(context), @ptrCast(@alignCast(ctx))).*, t, n);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "struct",
      "name": "ctx",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Context from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "const Context = struct {\n        accumulator: *std.ArrayList(Ast.Node.Tag),\n        ally: std.mem.Allocator,\n\n        fn callback(self: @This(), ast: Ast, child_node: Ast.Node.Index) !void {\n            try self.accumulator.append(self.ally, ast.nodeTag(child_node));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "struct",
      "name": "Context",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to RecursiveContext from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "const RecursiveContext = struct {\n        fn recursive_callback(ctx: *const anyopaque, ast: Ast, child_node: Ast.Node.Index) anyerror!void {\n            std.debug.assert(child_node != .root);\n            try callback(@as(*const @TypeOf(context), @ptrCast(@alignCast(ctx))).*, ast, child_node);\n            try iterateChildrenTypeErased(ast, child_node, ctx, recursive_callback);\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "struct",
      "name": "RecursiveContext",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Context from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "const Context = struct {\n        allocator: std.mem.Allocator,\n        children: *std.ArrayList(Ast.Node.Index),\n        fn callback(self: @This(), ast: Ast, child_node: Ast.Node.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "struct",
      "name": "Context",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to namespace from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "const namespace = struct { field_a: u32 }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "struct",
      "name": "namespace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Context from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "const Context = struct {\n        allocator: std.mem.Allocator,\n        children: *std.ArrayList(Ast.Node.Index),\n        fn callback(self: @This(), ast: Ast, child_node: Ast.Node.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "struct",
      "name": "Context",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to namespace from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "const namespace = struct { field_a: u32 }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "struct",
      "name": "namespace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Context from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "const Context = struct {\n        index: usize,\n        allocator: std.mem.Allocator,\n        nodes: std.ArrayList(Ast.Node.Index) = .empty,\n\n        pub fn append(self: *@This(), ast: Ast, node: Ast.Node.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "struct",
      "name": "Context",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to NodeLoc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "const NodeLoc = struct {\n        node: Ast.Node.Index,\n        loc: offsets.Loc,\n\n        fn lessThan(_: void, lhs: @This(), rhs: @This()) bool {\n            return rhs.loc.start < lhs.loc.start and lhs.loc.end < rhs.loc.end;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "struct",
      "name": "NodeLoc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Context from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "const Context = struct {\n        allocator: std.mem.Allocator,\n        nodes: std.ArrayList(Ast.Node.Index) = .empty,\n        locs: std.ArrayList(offsets.Loc) = .empty,\n\n        pub fn append(self: *@This(), ast: Ast, node: Ast.Node.Index) !void {\n            std.debug.assert(node != .root);\n            try self.nodes.append(self.allocator, node);\n            try self.locs.append(self.allocator, offsets.nodeToLoc(ast, node));\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "struct",
      "name": "Context",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to outputs_end from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "const outputs_end: usize = for (info.items, 0..) |item, i| {\n        switch (tree.nodeTag(item)) {\n            .asm_output => continue,\n            else => break i,\n        }\n    } else info.items.len;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "const",
      "name": "outputs_end",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to outputs_end from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "const outputs_end: usize = for (info.items, 0..) |item, i| {\n        switch (tree.nodeTag(item)) {\n            .asm_output => continue,\n            else => break i,\n        }\n    } else info.items.len;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "const",
      "name": "outputs_end",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to then_expr from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "const then_expr: Node.Index = @enumFromInt(tree.extra_data[@intFromEnum(extra_index) + extra.inputs]);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "const",
      "name": "then_expr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to else_expr from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "const else_expr: Node.OptionalIndex = if (extra.has_else) @enumFromInt(tree.extra_data[@intFromEnum(extra_index) + extra.inputs + 1]) else .none;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "const",
      "name": "else_expr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to node from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "const node: Ast.Node.Index = @enumFromInt(i);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "const",
      "name": "node",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to start from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/ast.zig",
    "response": "const start: usize = while (i < children.len) : (i += 1) {\n        const child_loc = children[i];",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/ast.zig",
      "type": "const",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "pub fn init(allocator: std.mem.Allocator) Manager {\n        return .{\n            .allocator = allocator,\n            .zig_exe = null,\n            .zig_lib_dir = null,\n            .global_cache_dir = null,\n            .build_runner_supported = .no_dont_error,\n            .config = .{}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "pub fn deinit(manager: *Manager) void {\n        const allocator = manager.allocator;\n        switch (builtin.os.tag) {\n            .wasi => {\n                if (manager.impl.cached_wasi_preopens) |wasi_preopens| {\n                    for (wasi_preopens.names[3..]) |name| allocator.free(name);\n                    allocator.free(wasi_preopens.names);\n                }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to setConfiguration from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "pub fn setConfiguration(\n        manager: *Manager,\n        tag: Tag,\n        config: *const UnresolvedConfig,\n    ) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "function",
      "name": "setConfiguration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to setConfiguration2 from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "pub fn setConfiguration2(\n        manager: *Manager,\n        tag: Tag,\n        config: *const Config,\n    ) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "function",
      "name": "setConfiguration2",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "pub fn deinit(result: *ResolveConfigurationResult, allocator: std.mem.Allocator) void {\n            for (result.messages) |msg| allocator.free(msg);\n            allocator.free(result.messages);\n            result.* = undefined;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveConfiguration from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "pub fn resolveConfiguration(\n        manager: *Manager,\n        result_allocator: std.mem.Allocator,\n    ) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "function",
      "name": "resolveConfiguration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to validateConfiguration from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "fn validateConfiguration(\n        config: *Config,\n        allocator: std.mem.Allocator,\n        messages: *std.ArrayList([]const u8),\n    ) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "function",
      "name": "validateConfiguration",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to free from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "fn free(comptime T: type, value: T, allocator: std.mem.Allocator) void {\n        const val = switch (@typeInfo(T)) {\n            .optional => if (value) |val| val else return,\n            else => value,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "function",
      "name": "free",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to dupe from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "fn dupe(comptime T: type, value: T, allocator: std.mem.Allocator) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "function",
      "name": "dupe",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "fn eql(comptime T: type, a: T, b: T) bool {\n        const a_val, const b_val = switch (@typeInfo(T)) {\n            .optional => blk: {\n                if (a == null and b == null) return true;\n                if ((a == null) != (b == null)) return false;\n                break :blk .{ a.?, b.? }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getZigEnv from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "pub fn getZigEnv(\n    allocator: std.mem.Allocator,\n    result_arena: std.mem.Allocator,\n    zig_exe_path: []const u8,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "function",
      "name": "getZigEnv",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findZig from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "pub fn findZig(allocator: std.mem.Allocator) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "function",
      "name": "findZig",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Manager from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "pub const Manager = struct {\n    allocator: std.mem.Allocator,\n    config: Config,\n    zig_exe: ?struct {\n        /// Same as `Manager.config.zig_exe_path.?`\n        path: []const u8,\n        version: std.SemanticVersion,\n        env: Env,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "struct",
      "name": "Manager",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ResolveConfigurationResult from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "pub const ResolveConfigurationResult = struct {\n        did_change: DidConfigChange,\n        messages: [][]const u8,\n\n        pub fn deinit(result: *ResolveConfigurationResult, allocator: std.mem.Allocator) void {\n            for (result.messages) |msg| allocator.free(msg);\n            allocator.free(result.messages);\n            result.* = undefined;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "struct",
      "name": "ResolveConfigurationResult",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to option from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "pub const option = struct {\n    fn free(comptime T: type, value: T, allocator: std.mem.Allocator) void {\n        const val = switch (@typeInfo(T)) {\n            .optional => if (value) |val| val else return,\n            else => value,\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "struct",
      "name": "option",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Env from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "pub const Env = struct {\n    zig_exe: []const u8,\n    lib_dir: ?[]const u8,\n    std_dir: []const u8,\n    global_cache_dir: []const u8,\n    version: []const u8,\n    target: ?[]const u8 = null,\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "struct",
      "name": "Env",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FileConfigInfo from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "pub const FileConfigInfo = struct {\n    name: []const u8,\n    kind: enum { file, directory }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "struct",
      "name": "FileConfigInfo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to zig_lib_dir from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "const zig_lib_dir: std.fs.Dir = switch (builtin.target.os.tag) {\n                // TODO The `zig_lib_path` could be a subdirectory of a preopen directory\n                .wasi => .{ .fd = wasi_preopens.find(zig_lib_path) orelse {\n                    log.warn(\"failed to resolve '{s}' WASI preopen\", .{zig_lib_path});",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "const",
      "name": "zig_lib_dir",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to global_cache_dir from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "const global_cache_dir: std.fs.Dir = switch (builtin.target.os.tag) {\n                // TODO The `global_cache_path` could be a subdirectory of a preopen directory\n                .wasi => .{ .fd = wasi_preopens.find(global_cache_path) orelse {\n                    log.warn(\"failed to resolve '{s}' WASI preopen\", .{global_cache_path});",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "const",
      "name": "global_cache_dir",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to file_system_config_options from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/configuration.zig",
    "response": "pub const file_system_config_options: []const FileConfigInfo = &.{\n    .{ .name = \"zig_exe_path\", .kind = .file, .is_accessible = true },\n    .{ .name = \"builtin_path\", .kind = .file, .is_accessible = true },\n    .{ .name = \"build_runner_path\", .kind = .file, .is_accessible = true },\n    .{ .name = \"zig_lib_path\", .kind = .directory, .is_accessible = true },\n    .{ .name = \"global_cache_path\", .kind = .directory, .is_accessible = false },\n};",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/configuration.zig",
      "type": "const",
      "name": "file_system_config_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to edits from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/diff.zig",
    "response": "pub fn edits(\n    allocator: std.mem.Allocator,\n    before: []const u8,\n    after: []const u8,\n    encoding: offsets.Encoding,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/diff.zig",
      "type": "function",
      "name": "edits",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applyContentChanges from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/diff.zig",
    "response": "pub fn applyContentChanges(\n    allocator: std.mem.Allocator,\n    text: []const u8,\n    content_changes: []const types.TextDocumentContentChangeEvent,\n    encoding: offsets.Encoding,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/diff.zig",
      "type": "function",
      "name": "applyContentChanges",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to textEditLessThan from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/diff.zig",
    "response": "fn textEditLessThan(_: void, lhs: types.TextEdit, rhs: types.TextEdit) bool {\n    return offsets.orderPosition(lhs.range.start, rhs.range.start) == .lt or offsets.orderPosition(lhs.range.end, rhs.range.end) == .lt;\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/diff.zig",
      "type": "function",
      "name": "textEditLessThan",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to applyTextEdits from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/diff.zig",
    "response": "pub fn applyTextEdits(\n    allocator: std.mem.Allocator,\n    text: []const u8,\n    text_edits: []const types.TextEdit,\n    encoding: offsets.Encoding,\n) ![]const u8 {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    const text_edits_sortable = try allocator.dupe(types.TextEdit, text_edits);\n    defer allocator.free(text_edits_sortable);\n\n    std.mem.sort(types.TextEdit, text_edits_sortable, {}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/diff.zig",
      "type": "function",
      "name": "applyTextEdits",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to dmp from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/diff.zig",
    "response": "const dmp: DiffMatchPatch = .{\n    .diff_timeout = 250,\n};",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/diff.zig",
      "type": "const",
      "name": "dmp",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateCodeAction from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn generateCodeAction(\n        builder: *Builder,\n        error_bundle: std.zig.ErrorBundle,\n    ) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "generateCodeAction",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wantKind from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn wantKind(builder: *Builder, kind: std.meta.Tag(types.CodeActionKind)) bool {\n        const only_kinds = builder.only_kinds orelse return true;\n        return only_kinds.contains(kind);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "wantKind",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateCodeActionsInRange from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn generateCodeActionsInRange(\n        builder: *Builder,\n        range: types.Range,\n    ) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "generateCodeActionsInRange",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to createTextEditLoc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn createTextEditLoc(self: *Builder, loc: offsets.Loc, new_text: []const u8) types.TextEdit {\n        const range = offsets.locToRange(self.handle.tree.source, loc, self.offset_encoding);\n        return .{ .range = range, .newText = new_text }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "createTextEditLoc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to createTextEditPos from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn createTextEditPos(self: *Builder, index: usize, new_text: []const u8) types.TextEdit {\n        const position = offsets.indexToPosition(self.handle.tree.source, index, self.offset_encoding);\n        return .{ .range = .{ .start = position, .end = position }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "createTextEditPos",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to createWorkspaceEdit from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn createWorkspaceEdit(self: *Builder, edits: []const types.TextEdit) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "createWorkspaceEdit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateStringLiteralCodeActions from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn generateStringLiteralCodeActions(\n    builder: *Builder,\n    token: Ast.TokenIndex,\n) !void {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    if (!builder.wantKind(.refactor)) return;\n\n    const tree = builder.handle.tree;\n    switch (tree.tokenTag(token -| 1)) {\n        // Not covered by position context\n        .keyword_test, .keyword_extern => return,\n        else => {}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "generateStringLiteralCodeActions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateMultilineStringCodeActions from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn generateMultilineStringCodeActions(\n    builder: *Builder,\n    token: Ast.TokenIndex,\n) !void {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    if (!builder.wantKind(.refactor)) return;\n\n    const tree = builder.handle.tree;\n    std.debug.assert(.multiline_string_literal_line == tree.tokenTag(token));\n    // Collect (exclusive) token range of the literal (one token per literal line)\n    const start = if (std.mem.lastIndexOfNone(Token.Tag, tree.tokens.items(.tag)[0..(token + 1)], &.{.multiline_string_literal_line}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "generateMultilineStringCodeActions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to collectAutoDiscardDiagnostics from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn collectAutoDiscardDiagnostics(\n    analyser: *Analyser,\n    handle: *DocumentStore.Handle,\n    arena: std.mem.Allocator,\n    diagnostics: *std.ArrayList(types.Diagnostic),\n    offset_encoding: offsets.Encoding,\n) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "collectAutoDiscardDiagnostics",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to handleNonCamelcaseFunction from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn handleNonCamelcaseFunction(builder: *Builder, loc: offsets.Loc) !void {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    if (!builder.wantKind(.quickfix)) return;\n\n    const identifier_name = offsets.locToSlice(builder.handle.tree.source, loc);\n\n    if (std.mem.allEqual(u8, identifier_name, '_')) return;\n\n    const new_text = try createCamelcaseText(builder.arena, identifier_name);\n\n    try builder.actions.append(builder.arena, .{\n        .title = \"make function name camelCase\",\n        .kind = .quickfix,\n        .isPreferred = true,\n        .edit = try builder.createWorkspaceEdit(&.{builder.createTextEditLoc(loc, new_text)}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "handleNonCamelcaseFunction",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to handleUnusedFunctionParameter from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn handleUnusedFunctionParameter(builder: *Builder, loc: offsets.Loc) !void {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    if (!builder.wantKind(.@\"source.fixAll\") and !builder.wantKind(.quickfix)) return;\n\n    const tree = builder.handle.tree;\n    const identifier_token = offsets.sourceIndexToTokenIndex(tree, loc.start).pickTokenTag(.identifier, &tree) orelse return;\n    const identifier_name = offsets.identifierTokenToNameSlice(tree, identifier_token);\n    const identifier_full_name = offsets.tokenToSlice(tree, identifier_token);\n\n    const decl = (try builder.analyser.lookupSymbolGlobal(\n        builder.handle,\n        identifier_name,\n        loc.start,\n    )) orelse return;\n\n    const payload = switch (decl.decl) {\n        .function_parameter => |pay| pay,\n        else => return,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "handleUnusedFunctionParameter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to handleUnusedVariableOrConstant from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn handleUnusedVariableOrConstant(builder: *Builder, loc: offsets.Loc) !void {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    if (!builder.wantKind(.@\"source.fixAll\") and !builder.wantKind(.quickfix)) return;\n\n    const tree = builder.handle.tree;\n    const identifier_token = offsets.sourceIndexToTokenIndex(tree, loc.start).pickTokenTag(.identifier, &tree) orelse return;\n    const identifier_name = offsets.identifierTokenToNameSlice(tree, identifier_token);\n    const identifier_full_name = offsets.tokenToSlice(tree, identifier_token);\n\n    const decl = (try builder.analyser.lookupSymbolGlobal(\n        builder.handle,\n        identifier_name,\n        loc.start,\n    )) orelse return;\n\n    const node = switch (decl.decl) {\n        .ast_node => |node| node,\n        .assign_destructure => |payload| payload.node,\n        else => return,\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "handleUnusedVariableOrConstant",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to handleUnusedCapture from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn handleUnusedCapture(\n    builder: *Builder,\n    loc: offsets.Loc,\n    remove_capture_actions: *std.AutoHashMapUnmanaged(types.Range, void),\n) !void {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    if (!builder.wantKind(.@\"source.fixAll\") and !builder.wantKind(.quickfix)) return;\n\n    const tree = builder.handle.tree;\n    const identifier_token = offsets.sourceIndexToTokenIndex(tree, loc.start).pickTokenTag(.identifier, &tree) orelse return;\n    const identifier_name = offsets.identifierTokenToNameSlice(tree, identifier_token);\n    const identifier_full_name = offsets.tokenToSlice(tree, identifier_token);\n\n    // Zig can report incorrect \"unused capture\" errors\n    // https://github.com/ziglang/zig/pull/22209\n    if (std.mem.eql(u8, identifier_name, \"_\")) return;\n\n    if (builder.wantKind(.quickfix)) {\n        const capture_loc = getCaptureLoc(tree.source, loc) orelse return;\n\n        const remove_cap_loc = builder.createTextEditLoc(capture_loc, \"\");\n\n        try builder.actions.append(builder.arena, .{\n            .title = \"discard capture name\",\n            .kind = .quickfix,\n            .isPreferred = false,\n            .edit = try builder.createWorkspaceEdit(&.{builder.createTextEditLoc(loc, \"_\")}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "handleUnusedCapture",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to handlePointlessDiscard from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn handlePointlessDiscard(builder: *Builder, loc: offsets.Loc) !void {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    if (!builder.wantKind(.@\"source.fixAll\") and !builder.wantKind(.quickfix)) return;\n\n    const edit_loc = getDiscardLoc(builder.handle.tree, loc) orelse return;\n\n    if (builder.wantKind(.@\"source.fixAll\")) {\n        try builder.fixall_text_edits.append(builder.arena, builder.createTextEditLoc(edit_loc, \"\"));\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "handlePointlessDiscard",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to handleVariableNeverMutated from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn handleVariableNeverMutated(builder: *Builder, loc: offsets.Loc) !void {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    if (!builder.wantKind(.quickfix)) return;\n\n    const tree = builder.handle.tree;\n    const identifier_token = offsets.sourceIndexToTokenIndex(tree, loc.start).pickTokenTag(.identifier, &tree) orelse return;\n    if (identifier_token == 0) return;\n    const var_token = identifier_token - 1;\n    if (tree.tokenTag(var_token) != .keyword_var) return;\n\n    try builder.actions.append(builder.arena, .{\n        .title = \"use 'const'\",\n        .kind = .quickfix,\n        .isPreferred = true,\n        .edit = try builder.createWorkspaceEdit(&.{\n            builder.createTextEditLoc(offsets.tokenToLoc(tree, var_token), \"const\"),\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "handleVariableNeverMutated",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to analyzeImportPlacement from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn analyzeImportPlacement(tree: Ast, imports: []const ImportDecl) ImportPlacement {\n    const root_decls = tree.rootDecls();\n\n    if (root_decls.len == 0 or imports.len == 0) return .top;\n\n    const first_import = imports[0].var_decl;\n    const last_import = imports[imports.len - 1].var_decl;\n\n    const first_decl = root_decls[0];\n    const last_decl = root_decls[root_decls.len - 1];\n\n    const starts_with_import = first_decl == first_import;\n    const ends_with_import = last_decl == last_import;\n\n    if (starts_with_import and ends_with_import) {\n        // If there are only imports, choose \"top\" to avoid unnecessary newlines.\n        // Otherwise, having an import at the bottom is a strong signal that that is the preferred style.\n        const has_gaps = root_decls.len != imports.len;\n\n        return if (has_gaps) .bottom else .top;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "analyzeImportPlacement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to handleUnorganizedImport from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn handleUnorganizedImport(builder: *Builder) !void {\n    const tracy_zone = tracy.trace(@src());\n    defer tracy_zone.end();\n\n    if (!builder.wantKind(.@\"source.organizeImports\")) return;\n\n    const tree = builder.handle.tree;\n    if (tree.errors.len != 0) return;\n\n    const imports = try getImportsDecls(builder, builder.arena);\n\n    if (imports.len == 0) return;\n\n    // The optimization is disabled because it does not detect the case where imports and other decls are mixed\n    // if (std.sort.isSorted(ImportDecl, imports.items, tree, ImportDecl.lessThan)) return;\n\n    const placement = analyzeImportPlacement(tree, imports);\n\n    const sorted_imports = try builder.arena.dupe(ImportDecl, imports);\n    std.mem.sort(ImportDecl, sorted_imports, tree, ImportDecl.lessThan);\n\n    var edits: std.ArrayList(types.TextEdit) = .empty;\n\n    // add sorted imports\n    {\n        var new_text: std.ArrayList(u8) = .empty;\n\n        if (placement == .bottom) {\n            try new_text.append(builder.arena, '\\n');\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "handleUnorganizedImport",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn hash(ctx: @This(), ast_node: Ast.Node.Index) u32 {\n            _ = ctx;\n            const hash_fn = std.array_hash_map.getAutoHashFn(Ast.Node.Index, void);\n            return hash_fn({}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "hash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn eql(ctx: @This(), a: Ast.Node.Index, b: ImportDecl, b_index: usize) bool {\n            _ = ctx;\n            _ = b_index;\n            return a == b.var_decl;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lessThan from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn lessThan(context: Ast, lhs: ImportDecl, rhs: ImportDecl) bool {\n        const lhs_kind = lhs.getKind();\n        const rhs_kind = rhs.getKind();\n        if (lhs_kind != rhs_kind) return @intFromEnum(lhs_kind) < @intFromEnum(rhs_kind);\n\n        if (sort_public_decls_first) {\n            const node_tokens = context.nodes.items(.main_token);\n            const is_lhs_pub = node_tokens[lhs.var_decl] > 0 and context.tokenTag(node_tokens[lhs.var_decl] - 1) == .keyword_pub;\n            const is_rhs_pub = node_tokens[rhs.var_decl] > 0 and context.tokenTag(node_tokens[rhs.var_decl] - 1) == .keyword_pub;\n            if (is_lhs_pub != is_rhs_pub) return is_lhs_pub;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "lessThan",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isParent from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn isParent(self: ImportDecl, child: ImportDecl) bool {\n        const parent_name = child.parent_name orelse return false;\n        const parent_value = child.parent_value orelse return false;\n        return std.mem.eql(u8, self.name, parent_name) and std.mem.eql(u8, self.value, parent_value);\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "isParent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getKind from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn getKind(self: ImportDecl) Kind {\n        const name = self.getSortValue()[1 .. self.getSortValue().len - 1];\n\n        if (std.mem.endsWith(u8, name, \".zig\")) return .file;\n\n        if (std.mem.eql(u8, name, \"std\")) return .std;\n        if (std.mem.eql(u8, name, \"builtin\")) return .builtin;\n        if (std.mem.eql(u8, name, \"root\")) return .builtin;\n        if (std.mem.eql(u8, name, \"build_options\")) return .build_options;\n\n        return .package;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "getKind",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getSortSlice from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn getSortSlice(self: ImportDecl) []const u8 {\n        switch (self.getKind()) {\n            .file => {\n                if (std.mem.indexOfScalar(u8, self.getSortValue(), '/') != null) {\n                    return self.getSortValue()[1 .. self.getSortValue().len - 1];\n                }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "getSortSlice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getSortName from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn getSortName(self: ImportDecl) []const u8 {\n        return self.parent_name orelse self.name;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "getSortName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getSortValue from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn getSortValue(self: ImportDecl) []const u8 {\n        return self.parent_value orelse self.value;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "getSortValue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addSeperator from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn addSeperator(lhs: ImportDecl, rhs: ImportDecl) bool {\n        const lhs_kind = @intFromEnum(lhs.getKind());\n        const rhs_kind = @intFromEnum(rhs.getKind());\n        if (rhs_kind <= @intFromEnum(Kind.build_options)) return false;\n        return lhs_kind != rhs_kind;\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "addSeperator",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getSourceStartIndex from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn getSourceStartIndex(self: ImportDecl, tree: Ast) usize {\n        return tree.tokenStart(self.first_comment_token orelse tree.firstToken(self.var_decl));\n    }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "getSourceStartIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getSourceEndIndex from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn getSourceEndIndex(self: ImportDecl, tree: Ast, include_line_break: bool) usize {\n        var last_token = ast.lastToken(tree, self.var_decl);\n        if (last_token + 1 < tree.tokens.len - 1 and tree.tokenTag(last_token + 1) == .semicolon) {\n            last_token += 1;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "getSourceEndIndex",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getLoc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn getLoc(self: ImportDecl, tree: Ast, include_line_break: bool) offsets.Loc {\n        return .{\n            .start = self.getSourceStartIndex(tree),\n            .end = self.getSourceEndIndex(tree, include_line_break),\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "getLoc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getImportsDecls from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub fn getImportsDecls(builder: *Builder, allocator: std.mem.Allocator) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "getImportsDecls",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to detectIndentation from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn detectIndentation(source: []const u8) []const u8 {\n    // Essentially I'm looking for the first indentation in the file.\n    var i: usize = 0;\n    const len = source.len - 1; // I need 1 look-ahead\n    while (i < len) : (i += 1) {\n        if (source[i] != '\\n') continue;\n        i += 1;\n        if (source[i] == '\\t') return \"\\t\";\n        var space_count: usize = 0;\n        while (i < source.len and source[i] == ' ') : (i += 1) {\n            space_count += 1;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "detectIndentation",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to createCamelcaseText from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn createCamelcaseText(allocator: std.mem.Allocator, identifier: []const u8) ![]const u8 {\n    // skip initial & ending underscores\n    const trimmed_identifier = std.mem.trim(u8, identifier, \"_\");\n\n    const num_separators = std.mem.count(u8, trimmed_identifier, \"_\");\n\n    const new_text_len = trimmed_identifier.len - num_separators;\n    var new_text: std.ArrayList(u8) = try .initCapacity(allocator, new_text_len);\n    errdefer new_text.deinit(allocator);\n\n    var idx: usize = 0;\n    while (idx < trimmed_identifier.len) {\n        const ch = trimmed_identifier[idx];\n        if (ch == '_') {\n            // the trimmed identifier is guaranteed to not have underscores at the end,\n            // so it can be assumed that ptr dereferences are safe until an alnum char is found\n            while (trimmed_identifier[idx] == '_') : (idx += 1) {}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "createCamelcaseText",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to createDiscardText from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn createDiscardText(\n    builder: *Builder,\n    identifier_name: []const u8,\n    insert_token: Ast.TokenIndex,\n    add_block_indentation: bool,\n    add_suffix_newline: bool,\n) !struct {\n    /// insert index\n    usize,\n    /// new text\n    []const u8,\n}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "createDiscardText",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getParamRemovalRange from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn getParamRemovalRange(tree: Ast, param: Ast.full.FnProto.Param) offsets.Loc {\n    var loc = ast.paramLoc(tree, param, true);\n\n    var trim_end = false;\n    while (loc.start != 0) : (loc.start -= 1) {\n        switch (tree.source[loc.start - 1]) {\n            ' ', '\\n' => continue,\n            ',' => {\n                loc.start -= 1;\n                break;\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "getParamRemovalRange",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parse from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn parse(diagnostic_message: []const u8) ?DiagnosticKind {\n        const msg = diagnostic_message;\n\n        if (std.mem.startsWith(u8, msg, \"unused \")) {\n            return .{\n                .unused = parseEnum(IdCat, msg[\"unused \".len..]) orelse return null,\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "parse",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseEnum from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn parseEnum(comptime T: type, message: []const u8) ?T {\n        inline for (std.meta.fields(T)) |field| {\n            if (std.mem.startsWith(u8, message, field.name)) {\n                // is there a better way to achieve this?\n                return @as(T, @enumFromInt(field.value));\n            }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "parseEnum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getDiscardLoc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn getDiscardLoc(tree: Ast, loc: offsets.Loc) ?offsets.Loc {\n    const identifier_token = offsets.sourceIndexToTokenIndex(tree, loc.start).pickTokenTag(.identifier, &tree) orelse return null;\n\n    // check if the identifier is followed by a semicolon\n    const semicolon_token = identifier_token + 1;\n    if (semicolon_token >= tree.tokens.len) return null;\n    if (tree.tokenTag(semicolon_token) != .semicolon) return null;\n\n    // check if the identifier is precede by a equal sign and then an underscore\n    if (identifier_token < 2) return null;\n    const equal_token = identifier_token - 1;\n    const underscore_token = identifier_token - 2;\n    if (tree.tokenTag(equal_token) != .equal) return null;\n    if (tree.tokenTag(underscore_token) != .identifier or !std.mem.eql(u8, offsets.tokenToSlice(tree, underscore_token), \"_\")) return null;\n\n    // check if the colon is followed by the autofix comment\n    const colon_end_index = tree.tokenStart(semicolon_token) + 1;\n    const autofix_comment_start = std.mem.indexOfNonePos(u8, tree.source, colon_end_index, \" \") orelse return null;\n    if (!std.mem.startsWith(u8, tree.source[autofix_comment_start..], \"//\")) return null;\n    const autofix_str_start = std.mem.indexOfNonePos(u8, tree.source, autofix_comment_start + \"//\".len, \" \") orelse return null;\n    if (!std.mem.startsWith(u8, tree.source[autofix_str_start..], \"autofix\")) return null;\n    const autofix_comment_end = std.mem.indexOfNonePos(u8, tree.source, autofix_str_start + \"autofix\".len, \" \") orelse autofix_str_start + \"autofix\".len;\n\n    // move backwards until we find a newline\n    const start_position = found: {\n        var i = tree.tokenStart(underscore_token);\n        while (i > 0) : (i -= 1) {\n            switch (tree.source[i - 1]) {\n                ' ', '\\t' => {}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "getDiscardLoc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getCaptureLoc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "fn getCaptureLoc(text: []const u8, loc: offsets.Loc) ?offsets.Loc {\n    const start_pipe_position = blk: {\n        var i = loc.start;\n        while (true) : (i -= 1) {\n            if (text[i] == '|') break;\n            if (i == 0) return null;\n        }",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "function",
      "name": "getCaptureLoc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Builder from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub const Builder = struct {\n    arena: std.mem.Allocator,\n    analyser: *Analyser,\n    handle: *DocumentStore.Handle,\n    offset_encoding: offsets.Encoding,\n    only_kinds: ?std.EnumSet(std.meta.Tag(types.CodeActionKind)),\n\n    actions: std.ArrayList(types.CodeAction) = .empty,\n    fixall_text_edits: std.ArrayList(types.TextEdit) = .empty,\n\n    pub fn generateCodeAction(\n        builder: *Builder,\n        error_bundle: std.zig.ErrorBundle,\n    ) error{OutOfMemory}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "struct",
      "name": "Builder",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ImportDecl from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub const ImportDecl = struct {\n    var_decl: Ast.Node.Index,\n    first_comment_token: ?Ast.TokenIndex,\n    name: []const u8,\n    value: []const u8,\n\n    /// Strings for sorting second order imports (e.g. `const ascii = std.ascii`)\n    parent_name: ?[]const u8 = null,\n    parent_value: ?[]const u8 = null,\n\n    pub const AstNodeAdapter = struct {\n        pub fn hash(ctx: @This(), ast_node: Ast.Node.Index) u32 {\n            _ = ctx;\n            const hash_fn = std.array_hash_map.getAutoHashFn(Ast.Node.Index, void);\n            return hash_fn({}",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "struct",
      "name": "ImportDecl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to loc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "const loc: offsets.Loc = .{\n                .start = src_loc.span_start,\n                .end = src_loc.span_end,\n            };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "const",
      "name": "loc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to remove_loc from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "const remove_loc: offsets.Loc = .{ .start = first_token_start, .end = last_token_end };",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "const",
      "name": "remove_loc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to supported_code_actions from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub const supported_code_actions: []const types.CodeActionKind = &.{\n    .quickfix,\n    .refactor,\n    .source,\n    .@\"source.organizeImports\",\n    .@\"source.fixAll\",\n};",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "const",
      "name": "supported_code_actions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to first_token from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "const first_token: Ast.TokenIndex = @intCast(std.mem.indexOfPos(\n            Token.Tag,\n            tree.tokens.items(.tag),\n            i,\n            &.{ .identifier, .equal, .identifier, .semicolon },\n        ) orelse break);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "const",
      "name": "first_token",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to capture_end from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "const capture_end: Ast.TokenIndex = @intCast(std.mem.indexOfScalarPos(\n        Token.Tag,\n        tree.tokens.items(.tag),\n        identifier_token,\n        .pipe,\n    ) orelse return);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "const",
      "name": "capture_end",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to range from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "const range: offsets.Range = switch (placement) {\n            .top => blk: {\n                // Current behavior: insert at top after doc comments\n                const first_token = std.mem.indexOfNone(Token.Tag, tree.tokens.items(.tag), &.{.container_doc_comment}) orelse tree.tokens.len;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "const",
      "name": "range",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to sort_case_sensitive from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub const sort_case_sensitive: bool = false;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "const",
      "name": "sort_case_sensitive",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to sort_public_decls_first from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "pub const sort_public_decls_first: bool = false;",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "const",
      "name": "sort_public_decls_first",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to import from zigtools/zls",
    "context": "Repository: zigtools/zls (4263 ⭐)\nFile: src/features/code_actions.zig",
    "response": "const import: ImportDecl = found_decl: while (true) {\n                const token = tree.nodeMainToken(current_node);",
    "metadata": {
      "repo": "zigtools/zls",
      "stars": 4263,
      "file": "src/features/code_actions.zig",
      "type": "const",
      "name": "import",
      "difficulty": "easy"
    }
  }
]