[
  {
    "instruction": "Write a Zig function similar to build from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: build.zig",
    "response": "pub fn build(b: *std.Build) !void {\n    const target = b.standardTargetOptions(.{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "build.zig",
      "type": "function",
      "name": "build",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildBenchmarks from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: build.zig",
    "response": "fn buildBenchmarks(\n    b: *std.Build,\n    target: std.Build.ResolvedTarget,\n) ![]const *Step.Compile {\n    const alloc = b.allocator;\n    var steps: std.ArrayList(*Step.Compile) = .empty;\n    defer steps.deinit(alloc);\n\n    var dir = try std.fs.cwd().openDir(try b.build_root.join(\n        b.allocator,\n        &.{ \"src\", \"bench\" }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "build.zig",
      "type": "function",
      "name": "buildBenchmarks",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildExamples from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: build.zig",
    "response": "fn buildExamples(\n    b: *std.Build,\n    target: std.Build.ResolvedTarget,\n    optimize: std.builtin.OptimizeMode,\n    c_lib_: ?*Step.Compile,\n) ![]const *Step.Compile {\n    const alloc = b.allocator;\n    var steps: std.ArrayList(*Step.Compile) = .empty;\n    defer steps.deinit(alloc);\n\n    var dir = try std.fs.cwd().openDir(try b.build_root.join(\n        b.allocator,\n        &.{\"examples\"}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "build.zig",
      "type": "function",
      "name": "buildExamples",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to manPages from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: build.zig",
    "response": "fn manPages(b: *std.Build) ![]const *Step {\n    const alloc = b.allocator;\n    var steps: std.ArrayList(*Step) = .empty;\n    defer steps.deinit(alloc);\n\n    var dir = try std.fs.cwd().openDir(try b.build_root.join(\n        b.allocator,\n        &.{\"docs\"}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "build.zig",
      "type": "function",
      "name": "manPages",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to static_lib from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: build.zig",
    "response": "const static_lib: ?*Step.Compile = lib: {\n        if (target.result.os.tag == .wasi) break :lib null;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "build.zig",
      "type": "const",
      "name": "static_lib",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to dynamic_lib from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: build.zig",
    "response": "const dynamic_lib: ?*Step.Compile = lib: {\n        // We require native so we can link to libxml2\n        if (!target.query.isNative()) break :lib null;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "build.zig",
      "type": "const",
      "name": "dynamic_lib",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to test_exe from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: build.zig",
    "response": "const test_exe: *Step.Compile = test_exe: {\n        const test_filter = b.option(\n            []const u8,\n            \"test-filter\",\n            \"Filter for test\",\n        );",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "build.zig",
      "type": "const",
      "name": "test_exe",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to exe from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: build.zig",
    "response": "const exe: *Step.Compile = if (is_zig) exe: {\n            const exe = b.addExecutable(.{\n                .name = name,\n                .root_module = b.createModule(.{\n                    .root_source_file = b.path(b.fmt(\n                        \"examples/{s}\",\n                        .{entry.name},\n                    )),\n                    .target = target,\n                    .optimize = optimize,\n                }),\n            });",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "build.zig",
      "type": "const",
      "name": "exe",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: examples/_basic.zig",
    "response": "pub fn main() !void {\n    // Initialize the loop state. Notice we can use a stack-allocated\n    // value here. We can even pass around the loop by value! The loop\n    // will contain all of our \"completions\" (watches).\n    var loop = try xev.Loop.init(.{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "examples/_basic.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to timerCallback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: examples/_basic.zig",
    "response": "fn timerCallback(\n    _: ?*void,\n    _: *xev.Loop,\n    _: *xev.Completion,\n    result: xev.Timer.RunError!void,\n) xev.CallbackAction {\n    _ = result catch unreachable;\n    return .disarm;\n}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "examples/_basic.zig",
      "type": "function",
      "name": "timerCallback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "pub fn init(config: Config) ThreadPool {\n    return .{\n        .stack_size = @max(1, config.stack_size),\n        .max_threads = if (config.max_threads > 0)\n            config.max_threads\n        else\n            @intCast(std.Thread.getCpuCount() catch 1),\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "pub fn deinit(self: *ThreadPool) void {\n    self.join();\n    self.* = undefined;\n}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to from from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "pub fn from(task: *Task) Batch {\n        return Batch{\n            .len = 1,\n            .head = task,\n            .tail = task,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "from",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to push from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "pub fn push(self: *Batch, batch: Batch) void {\n        if (batch.len == 0) return;\n        if (self.len == 0) {\n            self.* = batch;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "push",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to schedule from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "pub fn schedule(self: *ThreadPool, batch: Batch) void {\n    // Sanity check\n    if (batch.len == 0) {\n        return;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "schedule",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to notify from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn notify(self: *ThreadPool, is_waking: bool) void {\n    // Fast path to check the Sync state to avoid calling into notifySlow().\n    // If we're waking, then we need to update the state regardless\n    if (!is_waking) {\n        const sync: Sync = @bitCast(self.sync.load(.monotonic));\n        if (sync.notified) {\n            return;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "notify",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to notifySlow from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn notifySlow(self: *ThreadPool, is_waking: bool) void {\n    var sync: Sync = @bitCast(self.sync.load(.monotonic));\n    while (sync.state != .shutdown) {\n        const can_wake = is_waking or (sync.state == .pending);\n        if (is_waking) {\n            assert(sync.state == .waking);\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "notifySlow",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wait from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn wait(self: *ThreadPool, _is_waking: bool) error{Shutdown}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "wait",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to shutdown from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn shutdown(self: *ThreadPool) void {\n    var sync: Sync = @bitCast(self.sync.load(.monotonic));\n    while (sync.state != .shutdown) {\n        var new_sync = sync;\n        new_sync.notified = true;\n        new_sync.state = .shutdown;\n        new_sync.idle = 0;\n\n        // Full barrier to synchronize with both wait() and notify()\n        sync = @bitCast(self.sync.cmpxchgWeak(\n            @bitCast(sync),\n            @bitCast(new_sync),\n            .acq_rel,\n            .monotonic,\n        ) orelse {\n            // Wake up any threads sleeping on the idle_event.\n            // TODO: I/O polling notification here.\n            if (sync.idle > 0) self.idle_event.shutdown();\n            if (sync.spawned == 0) self.join_event.notify();\n            return;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "shutdown",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to register from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn register(noalias self: *ThreadPool, noalias thread: *Thread) void {\n    // Push the thread onto the threads stack in a lock-free manner.\n    var threads = self.threads.load(.monotonic);\n    while (true) {\n        thread.next = threads;\n        threads = self.threads.cmpxchgWeak(\n            threads,\n            thread,\n            .release,\n            .monotonic,\n        ) orelse break;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "register",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to unregister from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn unregister(noalias self: *ThreadPool, noalias maybe_thread: ?*Thread) void {\n    // Un-spawn one thread, either due to a failed OS thread spawning or the thread is exitting.\n    const one_spawned: u32 = @bitCast(Sync{ .spawned = 1 }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "unregister",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to join from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn join(self: *ThreadPool) void {\n    // Wait for the thread pool to be shutdown() then for all threads to enter a joinable state\n    self.join_event.wait();\n    const sync: Sync = @bitCast(self.sync.load(.monotonic));\n\n    assert(sync.state == .shutdown);\n    assert(sync.spawned == 0);\n\n    // If there are threads, start off the chain sending it the shutdown signal.\n    // The thread receives the shutdown signal and sends it to the next thread, and the next..\n    const thread = self.threads.load(.acquire) orelse return;\n    thread.join_event.notify();\n}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "join",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn run(thread_pool: *ThreadPool) void {\n        var self = Thread{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "run",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pop from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn pop(noalias self: *Thread, noalias thread_pool: *ThreadPool) ?Node.Buffer.Stole {\n        // Check our local buffer first\n        if (self.run_buffer.pop()) |node| {\n            return Node.Buffer.Stole{\n                .node = node,\n                .pushed = false,\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "pop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wait from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn wait(self: *Event) void {\n        var acquire_with: u32 = EMPTY;\n        var state = self.state.load(.monotonic);\n\n        while (true) {\n            // If we're shutdown then exit early.\n            // Acquire barrier to ensure operations before the shutdown() are seen after the wait().\n            // Shutdown is rare so it's better to have an Acquire barrier here instead of on CAS failure + load which are common.\n            if (state == SHUTDOWN) {\n                _ = self.state.load(.acquire);\n                return;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "wait",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to notify from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn notify(self: *Event) void {\n        return self.wake(NOTIFIED, 1);\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "notify",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to shutdown from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn shutdown(self: *Event) void {\n        return self.wake(SHUTDOWN, std.math.maxInt(u32));\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "shutdown",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wake from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn wake(self: *Event, release_with: u32, wake_threads: u32) void {\n        // Update the Event to notifty it with the new `release_with` state (either NOTIFIED or SHUTDOWN).\n        // Release barrier to ensure any operations before this are this to happen before the wait() in the other threads.\n        const state = self.state.swap(release_with, .release);\n\n        // Only wake threads sleeping in futex if the state is WAITING.\n        // Avoids unnecessary wake ups.\n        if (state == WAITING) {\n            std.Thread.Futex.wake(&self.state, wake_threads);\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "wake",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to push from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn push(noalias self: *Queue, list: List) void {\n            var stack = self.stack.load(.monotonic);\n            while (true) {\n                // Attach the list to the stack (pt. 1)\n                list.tail.next = @ptrFromInt(stack & PTR_MASK);\n\n                // Update the stack with the list (pt. 2).\n                // Don't change the HAS_CACHE and IS_CONSUMING bits of the consumer.\n                var new_stack = @intFromPtr(list.head);\n                assert(new_stack & ~PTR_MASK == 0);\n                new_stack |= (stack & ~PTR_MASK);\n\n                // Push to the stack with a release barrier for the consumer to see the proper list links.\n                stack = self.stack.cmpxchgWeak(\n                    stack,\n                    new_stack,\n                    .release,\n                    .monotonic,\n                ) orelse break;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "push",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tryAcquireConsumer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn tryAcquireConsumer(self: *Queue) error{ Empty, Contended }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "tryAcquireConsumer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to releaseConsumer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn releaseConsumer(noalias self: *Queue, noalias consumer: ?*Node) void {\n            // Stop consuming and remove the HAS_CACHE bit as well if the consumer's cache is empty.\n            // When HAS_CACHE bit is zeroed, the next consumer will acquire the pushed stack nodes.\n            var remove = IS_CONSUMING;\n            if (consumer == null)\n                remove |= HAS_CACHE;\n\n            // Release the consumer with a release barrier to ensure cache/node accesses\n            // happen before the consumer was released and before the next consumer starts using the cache.\n            self.cache = consumer;\n            const stack = self.stack.fetchSub(remove, .release);\n            assert(stack & remove != 0);\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "releaseConsumer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pop from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn pop(noalias self: *Queue, noalias consumer_ref: *?*Node) ?*Node {\n            // Check the consumer cache (fast path)\n            if (consumer_ref.*) |node| {\n                consumer_ref.* = node.next;\n                return node;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "pop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to push from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn push(noalias self: *Buffer, noalias list: *List) error{Overflow}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "push",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pop from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn pop(self: *Buffer) ?*Node {\n            var head = self.head.load(.monotonic);\n            const tail = self.tail.raw; // we're the only thread that can change this\n\n            while (true) {\n                // Quick sanity check and return null when not empty\n                const size = tail -% head;\n                assert(size <= capacity);\n                if (size == 0) {\n                    return null;\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "pop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to consume from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn consume(noalias self: *Buffer, noalias queue: *Queue) ?Stole {\n            var consumer = queue.tryAcquireConsumer() catch return null;\n            defer queue.releaseConsumer(consumer);\n\n            const head = self.head.load(.monotonic);\n            const tail = self.tail.raw; // we're the only thread that can change this\n\n            const size = tail -% head;\n            assert(size <= capacity);\n            assert(size == 0); // we should only be consuming if our array is empty\n\n            // Pop nodes from the queue and push them to our array.\n            // Atomic stores to the array as steal() threads may be atomically reading from it.\n            var pushed: Index = 0;\n            while (pushed < capacity) : (pushed += 1) {\n                const node = queue.pop(&consumer) orelse break;\n                self.array[(tail +% pushed) % capacity].store(node, .unordered);\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "consume",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to steal from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "fn steal(noalias self: *Buffer, noalias buffer: *Buffer) ?Stole {\n            const head = self.head.load(.monotonic);\n            const tail = self.tail.raw; // we're the only thread that can change this\n\n            const size = tail -% head;\n            assert(size <= capacity);\n            assert(size == 0); // we should only be stealing if our array is empty\n\n            while (true) : (std.atomic.spinLoopHint()) {\n                const buffer_head = buffer.head.load(.acquire);\n                const buffer_tail = buffer.tail.load(.acquire);\n\n                // Overly large size indicates the the tail was updated a lot after the head was loaded.\n                // Reload both and try again.\n                const buffer_size = buffer_tail -% buffer_head;\n                if (buffer_size > capacity) {\n                    continue;\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "function",
      "name": "steal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Config from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "pub const Config = struct {\n    stack_size: u32 = (std.Thread.SpawnConfig{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "struct",
      "name": "Config",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Task from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "pub const Task = struct {\n    node: Node = .{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "struct",
      "name": "Task",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Batch from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "pub const Batch = struct {\n    len: usize = 0,\n    head: ?*Task = null,\n    tail: ?*Task = null,\n\n    /// Create a batch from a single task.\n    pub fn from(task: *Task) Batch {\n        return Batch{\n            .len = 1,\n            .head = task,\n            .tail = task,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "struct",
      "name": "Batch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Thread from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "const Thread = struct {\n    next: ?*Thread = null,\n    target: ?*Thread = null,\n    join_event: Event = .{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "struct",
      "name": "Thread",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Event from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "const Event = struct {\n    state: Atomic(u32) = Atomic(u32).init(EMPTY),\n\n    const EMPTY = 0;\n    const WAITING = 1;\n    const NOTIFIED = 2;\n    const SHUTDOWN = 3;\n\n    /// Wait for and consume a notification\n    /// or wait for the event to be shutdown entirely\n    noinline fn wait(self: *Event) void {\n        var acquire_with: u32 = EMPTY;\n        var state = self.state.load(.monotonic);\n\n        while (true) {\n            // If we're shutdown then exit early.\n            // Acquire barrier to ensure operations before the shutdown() are seen after the wait().\n            // Shutdown is rare so it's better to have an Acquire barrier here instead of on CAS failure + load which are common.\n            if (state == SHUTDOWN) {\n                _ = self.state.load(.acquire);\n                return;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "struct",
      "name": "Event",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Node from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "const Node = struct {\n    next: ?*Node = null,\n\n    /// A linked list of Nodes\n    const List = struct {\n        head: *Node,\n        tail: *Node,\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "struct",
      "name": "Node",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Queue from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "const Queue = struct {\n        stack: Atomic(usize) = Atomic(usize).init(0),\n        cache: ?*Node = null,\n\n        const HAS_CACHE: usize = 0b01;\n        const IS_CONSUMING: usize = 0b10;\n        const PTR_MASK: usize = ~(HAS_CACHE | IS_CONSUMING);\n\n        comptime {\n            assert(@alignOf(Node) >= ((IS_CONSUMING | HAS_CACHE) + 1));\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "struct",
      "name": "Queue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Buffer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "const Buffer = struct {\n        head: Atomic(Index) = Atomic(Index).init(0),\n        tail: Atomic(Index) = Atomic(Index).init(0),\n        array: [capacity]Atomic(*Node) = undefined,\n\n        const Index = u32;\n        const capacity = 256; // Appears to be a pretty good trade-off in space vs contended throughput\n        comptime {\n            assert(std.math.maxInt(Index) >= capacity);\n            assert(std.math.isPowerOfTwo(capacity));\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "struct",
      "name": "Buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Stole from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "const Stole = struct {\n            node: *Node,\n            pushed: bool,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "struct",
      "name": "Stole",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to sync from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "const sync: Sync = @bitCast(self.sync.load(.monotonic));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "const",
      "name": "sync",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to one_spawned from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "const one_spawned: u32 = @bitCast(Sync{ .spawned = 1 });",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "const",
      "name": "one_spawned",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to sync from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "const sync: Sync = @bitCast(self.sync.fetchSub(one_spawned, .release));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "const",
      "name": "sync",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to sync from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "const sync: Sync = @bitCast(self.sync.load(.monotonic));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "const",
      "name": "sync",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to task from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "const task: *Task = @fieldParentPtr(\"node\", result.node);",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "const",
      "name": "task",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to HAS_CACHE from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "const HAS_CACHE: usize = 0b01;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "const",
      "name": "HAS_CACHE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to IS_CONSUMING from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "const IS_CONSUMING: usize = 0b10;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "const",
      "name": "IS_CONSUMING",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to PTR_MASK from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "const PTR_MASK: usize = ~(HAS_CACHE | IS_CONSUMING);",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "const",
      "name": "PTR_MASK",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to node from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/ThreadPool.zig",
    "response": "const node: *Node = @ptrFromInt(stack & PTR_MASK);",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/ThreadPool.zig",
      "type": "const",
      "name": "node",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to c from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/api.zig",
    "response": "const c: Self.Completion = .{};",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/api.zig",
      "type": "const",
      "name": "c",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to default from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend.zig",
    "response": "pub fn default() Backend {\n        return switch (builtin.os.tag) {\n            .linux => .io_uring,\n            .ios, .macos => .kqueue,\n            .freebsd => .kqueue,\n            .wasi => .wasi_poll,\n            .windows => .iocp,\n            else => {\n                @compileLog(builtin.os);\n                @compileError(\"no default backend for this target\");\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend.zig",
      "type": "function",
      "name": "default",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to candidates from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend.zig",
    "response": "pub fn candidates() []const Backend {\n        return switch (builtin.os.tag) {\n            .linux => &.{ .io_uring, .epoll }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend.zig",
      "type": "function",
      "name": "candidates",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to Api from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend.zig",
    "response": "pub fn Api(comptime self: Backend) type {\n        return switch (self) {\n            .io_uring => @import(\"main.zig\").IO_Uring,\n            .epoll => @import(\"main.zig\").Epoll,\n            .kqueue => @import(\"main.zig\").Kqueue,\n            .wasi_poll => @import(\"main.zig\").WasiPoll,\n            .iocp => @import(\"main.zig\").IOCP,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend.zig",
      "type": "function",
      "name": "Api",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to available from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "pub fn available() bool {\n    return builtin.os.tag == .linux;\n}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "available",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "pub fn init(options: Options) !Loop {\n        var eventfd = try Async.init();\n        errdefer eventfd.deinit();\n\n        var res: Loop = .{\n            .fd = try posix.epoll_create1(std.os.linux.EPOLL.CLOEXEC),\n            .eventfd = eventfd,\n            .thread_pool = options.thread_pool,\n            .thread_pool_completions = undefined,\n            .cached_now = undefined,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "pub fn deinit(self: *Loop) void {\n        posix.close(self.fd);\n        self.eventfd.deinit();\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "pub fn run(self: *Loop, mode: RunMode) !void {\n        switch (mode) {\n            .no_wait => try self.tick(0),\n            .once => try self.tick(1),\n            .until_done => while (!self.done()) try self.tick(1),\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "run",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to done from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn done(self: *Loop) bool {\n        return self.flags.stopped or (self.active == 0 and\n            self.submissions.empty());\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "done",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stop from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "pub fn stop(self: *Loop) void {\n        self.flags.stopped = true;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "stop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stopped from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "pub fn stopped(self: *Loop) bool {\n        return self.flags.stopped;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "stopped",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to add from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "pub fn add(self: *Loop, completion: *Completion) void {\n        switch (completion.flags.state) {\n            // Already adding, forget about it.\n            .adding => return,\n\n            // If it is dead we're good. If we're deleting we'll ignore it\n            // while we're processing.\n            .dead,\n            .deleting,\n            => {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "add",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to delete from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "pub fn delete(self: *Loop, completion: *Completion) void {\n        switch (completion.flags.state) {\n            // Already deleted\n            .deleting => return,\n\n            // If we're active then we will stop it and remove from epoll.\n            // If we're adding then we'll ignore it when adding.\n            .dead, .active, .adding => {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "delete",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to now from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "pub fn now(self: *Loop) i64 {\n        // If anything overflows we just return the max value.\n        const max = std.math.maxInt(i64);\n\n        // Calculate all the values, being careful about overflows in order\n        // to just return the maximum value.\n        const sec = std.math.mul(isize, self.cached_now.sec, std.time.ms_per_s) catch return max;\n        const nsec = @divFloor(self.cached_now.nsec, std.time.ns_per_ms);\n        return std.math.lossyCast(i64, sec +| nsec);\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "now",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to update_now from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "pub fn update_now(self: *Loop) void {\n        if (posix.clock_gettime(posix.CLOCK.MONOTONIC)) |new_time| {\n            self.cached_now = new_time;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "update_now",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to timer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "pub fn timer(\n        self: *Loop,\n        c: *Completion,\n        next_ms: u64,\n        userdata: ?*anyopaque,\n        comptime cb: Callback,\n    ) void {\n        c.* = .{\n            .op = .{\n                .timer = .{\n                    .next = self.timer_next(next_ms),\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "timer",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to timer_reset from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "pub fn timer_reset(\n        self: *Loop,\n        c: *Completion,\n        c_cancel: *Completion,\n        next_ms: u64,\n        userdata: ?*anyopaque,\n        comptime cb: Callback,\n    ) void {\n        switch (c.flags.state) {\n            .dead, .deleting => {\n                self.timer(c, next_ms, userdata, cb);\n                return;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "timer_reset",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to timer_next from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn timer_next(self: *Loop, next_ms: u64) posix.timespec {\n        // Get the timestamp of the absolute time that we'll execute this timer.\n        // There are lots of failure scenarios here in math. If we see any\n        // of them we just use the maximum value.\n        const max: posix.timespec = .{\n            .sec = std.math.maxInt(isize),\n            .nsec = std.math.maxInt(isize),\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "timer_next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tick from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "pub fn tick(self: *Loop, wait: u32) !void {\n        // If we're stopped then the loop is fully over.\n        if (self.flags.stopped) return;\n\n        // We can't nest runs.\n        if (self.flags.in_run) return error.NestedRunsNotAllowed;\n        self.flags.in_run = true;\n        defer self.flags.in_run = false;\n\n        // Initialize\n        if (!self.flags.init) {\n            self.flags.init = true;\n\n            if (self.thread_pool != null) {\n                self.thread_pool_completions.init();\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "tick",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to thread_schedule from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn thread_schedule(self: *Loop, c: *Completion) !void {\n        const pool = self.thread_pool orelse return error.ThreadPoolRequired;\n\n        // Setup our completion state so that thread_perform can do stuff\n        c.task_loop = self;\n        c.task_completions = &self.thread_pool_completions;\n        c.task = .{ .callback = Loop.thread_perform }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "thread_schedule",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to thread_perform from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn thread_perform(t: *ThreadPool.Task) void {\n        const c: *Completion = @fieldParentPtr(\"task\", t);\n\n        // Do our task\n        c.task_result = c.perform();\n\n        // Add to our completion queue\n        c.task_completions.push(c);\n\n        // Wake up our main loop\n        c.task_loop.wakeup() catch {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "thread_perform",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wakeup from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn wakeup(self: *Loop) !void {\n        try self.eventfd.notify();\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "wakeup",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to start from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn start(self: *Loop, completion: *Completion) void {\n        const res_: ?Result = switch (completion.op) {\n            .noop => {\n                completion.flags.state = .dead;\n                return;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stop_completion from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn stop_completion(self: *Loop, completion: *Completion) void {\n        // Delete. This should never fail.\n        const maybe_fd = if (completion.flags.dup) completion.flags.dup_fd else completion.fd();\n        if (maybe_fd) |fd| {\n            posix.epoll_ctl(\n                self.fd,\n                linux.EPOLL.CTL_DEL,\n                fd,\n                null,\n            ) catch unreachable;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "stop_completion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to state from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "pub fn state(self: Completion) CompletionState {\n        return switch (self.flags.state) {\n            .dead => .dead,\n            .adding, .deleting, .active => .active,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "state",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to perform from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn perform(self: *Completion) Result {\n        return switch (self.op) {\n            // This should never happen because we always do these synchronously\n            // or in another location.\n            .cancel,\n            .noop,\n            .shutdown,\n            .timer,\n            => unreachable,\n\n            .accept => |*op| .{\n                .accept = if (posix.accept(\n                    op.socket,\n                    &op.addr,\n                    &op.addr_size,\n                    op.flags,\n                )) |v|\n                    v\n                else |_|\n                    error.Unknown,\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "perform",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fd_maybe_dup from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn fd_maybe_dup(self: *Completion) error{DupFailed}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "fd_maybe_dup",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fd from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn fd(self: *Completion) ?posix.fd_t {\n        return switch (self.op) {\n            .accept => |v| v.socket,\n            .connect => |v| v.socket,\n            .poll => |v| v.fd,\n            .read => |v| v.fd,\n            .pread => |v| v.fd,\n            .recv => |v| v.fd,\n            .write => |v| v.fd,\n            .pwrite => |v| v.fd,\n            .send => |v| v.fd,\n            .sendmsg => |v| v.fd,\n            .recvmsg => |v| v.fd,\n            .close => |v| v.fd,\n            .shutdown => |v| v.socket,\n\n            .cancel,\n            .timer,\n            => null,\n\n            .noop => unreachable,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "fd",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to less from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn less(_: void, a: *const Timer, b: *const Timer) bool {\n            return a.ns() < b.ns();\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "less",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ns from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn ns(self: *const Timer) u64 {\n            assert(self.next.sec >= 0);\n            assert(self.next.nsec >= 0);\n\n            const max = std.math.maxInt(u64);\n            const s_ns = std.math.mul(\n                u64,\n                @as(u64, @intCast(self.next.sec)),\n                std.time.ns_per_s,\n            ) catch return max;\n            return std.math.add(u64, s_ns, @as(u64, @intCast(self.next.nsec))) catch\n                return max;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "ns",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, _: *Completion, r: Result) CallbackAction {\n            _ = l;\n            _ = r;\n            const b = @as(*bool, @ptrCast(ud.?));\n            b.* = true;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            _ = r;\n            const b = @as(*bool, @ptrCast(ud.?));\n            b.* = true;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            _ = r;\n            const b = @as(*bool, @ptrCast(ud.?));\n            b.* = true;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            const v = @as(*?TimerTrigger, @ptrCast(ud.?));\n            v.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            const v = @as(*?TimerTrigger, @ptrCast(ud.?));\n            v.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            const v = @as(*?TimerTrigger, @ptrCast(ud.?));\n            v.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = r.read catch unreachable;\n                _ = c;\n                _ = l;\n                const b = @as(*bool, @ptrCast(ud.?));\n                b.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                const conn = @as(*os.socket_t, @ptrCast(@alignCast(ud.?)));\n                conn.* = r.accept catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.connect catch unreachable;\n                const b = @as(*bool, @ptrCast(ud.?));\n                b.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.send catch unreachable;\n                _ = ud;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                const ptr = @as(*usize, @ptrCast(@alignCast(ud.?)));\n                ptr.* = r.recv catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.shutdown catch unreachable;\n                const ptr = @as(*bool, @ptrCast(@alignCast(ud.?)));\n                ptr.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                const ptr = @as(*?bool, @ptrCast(@alignCast(ud.?)));\n                ptr.* = if (r.recv) |_| false else |err| switch (err) {\n                    error.EOF => true,\n                    else => false,\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.close catch unreachable;\n                const ptr = @as(*os.socket_t, @ptrCast(@alignCast(ud.?)));\n                ptr.* = 0;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.close catch unreachable;\n                const ptr = @as(*os.socket_t, @ptrCast(@alignCast(ud.?)));\n                ptr.* = 0;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            const ptr = @as(*?TimerTrigger, @ptrCast(@alignCast(ud.?)));\n            ptr.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.cancel catch unreachable;\n                const ptr = @as(*bool, @ptrCast(@alignCast(ud.?)));\n                ptr.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            const ptr = @as(*?TimerTrigger, @ptrCast(@alignCast(ud.?)));\n            ptr.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.cancel catch unreachable;\n                const ptr = @as(*bool, @ptrCast(@alignCast(ud.?)));\n                ptr.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Loop from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "pub const Loop = struct {\n    const TimerHeap = heap.Intrusive(Operation.Timer, void, Operation.Timer.less);\n    const TaskCompletionQueue = queue_mpsc.Intrusive(Completion);\n\n    fd: posix.fd_t,\n\n    /// The eventfd that this epoll queue always has a filter for. Writing\n    /// an empty message to this eventfd can be used to wake up the loop\n    /// at any time. Waking up the loop via this eventfd won't trigger any\n    /// particular completion, it just forces tick to cycle.\n    eventfd: Async,\n\n    /// The number of active completions. This DOES NOT include completions that\n    /// are queued in the submissions queue.\n    active: usize = 0,\n\n    /// Our queue of submissions that we want to enqueue on the next tick.\n    submissions: queue.Intrusive(Completion) = .{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "struct",
      "name": "Loop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Completion from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "pub const Completion = struct {\n    /// Operation to execute. This is only safe to read BEFORE the completion\n    /// is queued. After being queued (with \"add\"), the operation may change.\n    op: Operation = .{ .noop = {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "struct",
      "name": "Completion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Timer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "const Timer = struct {\n        /// The absolute time to fire this timer next.\n        next: std.os.linux.timespec,\n\n        /// Only used internally. If this is non-null and timer is\n        /// CANCELLED, then the timer is rearmed automatically with this\n        /// as the next time. The callback will not be called on the\n        /// cancellation.\n        reset: ?std.os.linux.timespec = null,\n\n        /// Internal heap fields.\n        heap: heap.IntrusiveField(Timer) = .{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "struct",
      "name": "Timer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to max from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "const max: posix.timespec = .{\n            .sec = std.math.maxInt(isize),\n            .nsec = std.math.maxInt(isize),\n        };",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "const",
      "name": "max",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to now_timer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "const now_timer: Operation.Timer = .{ .next = self.cached_now };",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "const",
      "name": "now_timer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to timeout from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "const timeout: i32 = if (wait_rem == 0) 0 else timeout: {\n                // If we have a timer, we want to set the timeout to our next\n                // timer value. If we have no timer, we wait forever.\n                const t = self.timers.peek() orelse break :timeout -1;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "const",
      "name": "timeout",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to c from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "const c: *Completion = @ptrFromInt(@as(usize, @intCast(ev.data.ptr)));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "const",
      "name": "c",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to c from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "const c: *Completion = @fieldParentPtr(\"task\", t);",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "const",
      "name": "c",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to res_ from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "const res_: ?Result = switch (completion.op) {\n            .noop => {\n                completion.flags.state = .dead;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "const",
      "name": "res_",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cb from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "const cb: Callback = (struct {\n        fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "const",
      "name": "cb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cb from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "const cb: Callback = (struct {\n        fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "const",
      "name": "cb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cb from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/epoll.zig",
    "response": "const cb: Callback = (struct {\n        fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/epoll.zig",
      "type": "const",
      "name": "cb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to available from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "pub fn available() bool {\n    if (comptime builtin.os.tag != .linux) return false;\n\n    // Perform a harmless syscall to determine if we have io_uring support.\n    // We should really only be checking for a subset of possible errors\n    // to determine if io_uring is available but there isn't really a strong\n    // course of action for any other error so we just mark it as unavailable.\n    //\n    // Also, this is a bit expensive -- we could get away with a single\n    // io_uring_register syscall to check for availability but that involves\n    // manually handling errors vs. the tried and true Zig stdlib here.\n    var ring = linux.IoUring.init(256, 0) catch return false;\n    ring.deinit();\n\n    return true;\n}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "available",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "pub fn init(options: looppkg.Options) !Loop {\n        const entries = std.math.cast(u13, options.entries) orelse\n            return error.TooManyEntries;\n\n        var result: Loop = .{\n            // TODO(mitchellh): add an init_advanced function or something\n            // for people using the io_uring API directly to be able to set\n            // the flags for this.\n            .ring = try linux.IoUring.init(entries, 0),\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "pub fn deinit(self: *Loop) void {\n        self.ring.deinit();\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "pub fn run(self: *Loop, mode: looppkg.RunMode) !void {\n        switch (mode) {\n            .no_wait => try self.tick_(.no_wait),\n            .once => try self.tick_(.once),\n            .until_done => try self.tick_(.until_done),\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "run",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stop from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "pub fn stop(self: *Loop) void {\n        self.flags.stopped = true;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "stop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stopped from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "pub fn stopped(self: *Loop) bool {\n        return self.flags.stopped;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "stopped",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to now from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "pub fn now(self: *Loop) i64 {\n        if (self.flags.now_outdated) self.update_now();\n\n        // If anything overflows we just return the max value.\n        const max = std.math.maxInt(i64);\n\n        // Calculate all the values, being careful about overflows in order\n        // to just return the maximum value.\n        const sec = std.math.mul(isize, self.cached_now.sec, std.time.ms_per_s) catch return max;\n        const nsec = @divFloor(self.cached_now.nsec, std.time.ns_per_ms);\n        return std.math.lossyCast(i64, sec +| nsec);\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "now",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to update_now from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "pub fn update_now(self: *Loop) void {\n        if (posix.clock_gettime(posix.CLOCK.MONOTONIC)) |new_time| {\n            self.cached_now = new_time;\n            self.flags.now_outdated = false;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "update_now",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tick_ from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn tick_(self: *Loop, comptime mode: looppkg.RunMode) !void {\n        // We can't nest runs.\n        if (self.flags.in_run) return error.NestedRunsNotAllowed;\n        self.flags.in_run = true;\n        defer self.flags.in_run = false;\n\n        // The total number of events we're waiting for.\n        const wait = switch (mode) {\n            // until_done is one because we need to wait for at least one\n            // (if we have any).\n            .until_done => 1,\n            .once => 1,\n            .no_wait => 0,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "tick_",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to submit from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "pub fn submit(self: *Loop) SubmitError!void {\n        _ = try self.ring.submit();\n\n        // If we have any submissions that failed to submit, we try to\n        // send those now. We have to make a copy so that any failures are\n        // resubmitted without an infinite loop.\n        var queued = self.submissions;\n        self.submissions = .{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "submit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to timer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "pub fn timer(\n        self: *Loop,\n        c: *Completion,\n        next_ms: u64,\n        userdata: ?*anyopaque,\n        comptime cb: Callback,\n    ) void {\n        c.* = .{\n            .op = .{\n                .timer = .{\n                    .next = self.timer_next(next_ms),\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "timer",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to timer_reset from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "pub fn timer_reset(\n        self: *Loop,\n        c: *Completion,\n        c_cancel: *Completion,\n        next_ms: u64,\n        userdata: ?*anyopaque,\n        comptime cb: Callback,\n    ) void {\n        if (c.state() == .dead) {\n            self.timer(c, next_ms, userdata, cb);\n            return;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "timer_reset",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to timer_next from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn timer_next(self: *Loop, next_ms: u64) linux.kernel_timespec {\n        // Get the timestamp of the absolute time that we'll execute this timer.\n        // There are lots of failure scenarios here in math. If we see any\n        // of them we just use the maximum value.\n        const max: linux.kernel_timespec = .{\n            .sec = std.math.maxInt(isize),\n            .nsec = std.math.maxInt(isize),\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "timer_next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to add from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "pub fn add(self: *Loop, completion: *Completion) void {\n        self.add_(completion, false);\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "add",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to add_ from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn add_(\n        self: *Loop,\n        completion: *Completion,\n        try_submit: bool,\n    ) void {\n        // The completion at this point is active no matter what because\n        // it is going to be queued.\n        completion.flags.state = .active;\n\n        const sqe = self.ring.get_sqe() catch |err| switch (err) {\n            error.SubmissionQueueFull => retry: {\n                // If the queue is full and we're in try_submit mode then we\n                // attempt to submit. This is used during submission flushing.\n                if (try_submit) {\n                    if (self.submit()) {\n                        // Submission succeeded but we may still fail (unlikely)\n                        // to get an SQE...\n                        if (self.ring.get_sqe()) |sqe| {\n                            break :retry sqe;\n                        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "add_",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to cancel from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "pub fn cancel(\n        self: *Loop,\n        c: *Completion,\n        c_cancel: *Completion,\n        comptime Userdata: type,\n        userdata: ?*Userdata,\n        comptime cb: *const fn (\n            ud: ?*Userdata,\n            l: *Loop,\n            c: *Completion,\n            r: CancelError!void,\n        ) CallbackAction,\n    ) void {\n        c_cancel.* = .{\n            .op = .{\n                .cancel = .{\n                    .c = c,\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "cancel",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(\n                    ud: ?*anyopaque,\n                    l_inner: *Loop,\n                    c_inner: *Completion,\n                    r: Result,\n                ) CallbackAction {\n                    return @call(.always_inline, cb, .{\n                        @as(?*Userdata, if (Userdata == void) null else @ptrCast(@alignCast(ud))),\n                        l_inner,\n                        c_inner,\n                        if (r.cancel) |_| {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to state from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "pub fn state(self: Completion) CompletionState {\n        return switch (self.flags.state) {\n            .dead => .dead,\n            .active => .active,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "state",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to invoke from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn invoke(self: *Completion, loop: *Loop, res: i32) CallbackAction {\n        const result: Result = switch (self.op) {\n            .noop => unreachable,\n\n            .accept => .{\n                .accept = if (res >= 0)\n                    @intCast(res)\n                else switch (@as(posix.E, @enumFromInt(-res))) {\n                    .CANCELED => error.Canceled,\n                    .AGAIN => error.Again,\n                    else => |errno| posix.unexpectedErrno(errno),\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "invoke",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to readResult from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn readResult(self: *Completion, comptime op: OperationType, res: i32) ReadError!usize {\n        if (res > 0) {\n            return @intCast(res);\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "readResult",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, _: *Completion, r: Result) CallbackAction {\n            _ = l;\n            _ = r;\n            const b = @as(*bool, @ptrCast(ud.?));\n            b.* = true;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = c;\n                _ = r;\n                _ = l;\n                const b = @as(*bool, @ptrCast(ud.?));\n                b.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, _: *Completion, r: Result) CallbackAction {\n            _ = l;\n            _ = r;\n            const b = @as(*bool, @ptrCast(ud.?));\n            b.* = true;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, _: *Completion, r: Result) CallbackAction {\n            _ = l;\n            _ = r;\n            const b = @as(*bool, @ptrCast(ud.?));\n            b.* = true;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            const v = @as(*?TimerTrigger, @ptrCast(ud.?));\n            v.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, _: *Completion, r: Result) CallbackAction {\n            _ = l;\n            _ = r;\n            const b = @as(*bool, @ptrCast(ud.?));\n            b.* = true;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, _: *Completion, r: Result) CallbackAction {\n            _ = l;\n            const b = @as(*?TimerTrigger, @ptrCast(ud.?));\n            b.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, c: *Completion, r: Result) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = ud;\n                _ = r.timer_remove catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, c: *Completion, r: Result) CallbackAction {\n                _ = l;\n                _ = c;\n                const conn = @as(*os.socket_t, @ptrCast(@alignCast(ud.?)));\n                conn.* = r.accept catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, c: *Completion, r: Result) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.connect catch unreachable;\n                const b = @as(*bool, @ptrCast(ud.?));\n                b.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, c: *Completion, r: Result) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.send catch unreachable;\n                _ = ud;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, c: *Completion, r: Result) CallbackAction {\n                _ = l;\n                _ = c;\n                const ptr = @as(*usize, @ptrCast(@alignCast(ud.?)));\n                ptr.* = r.recv catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, c: *Completion, r: Result) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.shutdown catch unreachable;\n                const ptr = @as(*bool, @ptrCast(@alignCast(ud.?)));\n                ptr.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, c: *Completion, r: Result) CallbackAction {\n                _ = l;\n                _ = c;\n                const ptr = @as(*?bool, @ptrCast(@alignCast(ud.?)));\n                ptr.* = if (r.recv) |_| false else |err| switch (err) {\n                    error.EOF => true,\n                    else => false,\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, c: *Completion, r: Result) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.close catch unreachable;\n                const ptr = @as(*os.socket_t, @ptrCast(@alignCast(ud.?)));\n                ptr.* = 0;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, c: *Completion, r: Result) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.close catch unreachable;\n                const ptr = @as(*os.socket_t, @ptrCast(@alignCast(ud.?)));\n                ptr.* = 0;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, c: *Completion, r: Result) CallbackAction {\n                _ = ud;\n                _ = l;\n                _ = c;\n                _ = r.sendmsg catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, c: *Completion, r: Result) CallbackAction {\n                _ = l;\n                _ = c;\n                const ptr = @as(*usize, @ptrCast(@alignCast(ud.?)));\n                ptr.* = r.recvmsg catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, c: *Completion, r: Result) CallbackAction {\n                const ptr = @as(*Result, @ptrCast(@alignCast(ud)));\n                ptr.* = r;\n                _ = c;\n                _ = l;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "fn callback(ud: ?*void, l: *Loop, c: *Completion, r: CancelError!void) CallbackAction {\n                r catch unreachable;\n                _ = c;\n                _ = l;\n                _ = ud;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Loop from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "pub const Loop = struct {\n    ring: linux.IoUring,\n\n    /// The number of active completions. This DOES NOT include completions that\n    /// are queued in the submissions queue.\n    active: usize = 0,\n\n    /// Our queue of submissions that failed to enqueue.\n    submissions: queue.Intrusive(Completion) = .{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "struct",
      "name": "Loop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Completion from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "pub const Completion = struct {\n    /// Operation to execute. This is only safe to read BEFORE the completion\n    /// is queued. After being queued (with \"add\"), the operation may change.\n    op: Operation = .{ .noop = {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "struct",
      "name": "Completion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to max from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "const max: linux.kernel_timespec = .{\n            .sec = std.math.maxInt(isize),\n            .nsec = std.math.maxInt(isize),\n        };",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "const",
      "name": "max",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cb from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/io_uring.zig",
    "response": "const cb: Callback = (struct {\n        fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/io_uring.zig",
      "type": "const",
      "name": "cb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to available from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn available() bool {\n    return switch (builtin.os.tag) {\n        .windows => true,\n        else => false,\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "available",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn init(options: Options) !Loop {\n        _ = options;\n\n        // Get the duration of the QueryPerformanceCounter.\n        // We should check if the division is lossless, but it returns 10_000_000 on my machine so\n        // we'll handle that later.\n        const qpc_duration = 1_000_000_000 / windows.QueryPerformanceFrequency();\n\n        // This creates a new Completion Port\n        const handle = try windows.CreateIoCompletionPort(windows.INVALID_HANDLE_VALUE, null, 0, 1);\n        var res: Loop = .{\n            .iocp_handle = handle,\n            .qpc_duration = qpc_duration,\n            .cached_now = undefined,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn deinit(self: *Loop) void {\n        windows.CloseHandle(self.iocp_handle);\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stop from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn stop(self: *Loop) void {\n        self.flags.stopped = true;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "stop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stopped from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn stopped(self: *Loop) bool {\n        return self.flags.stopped;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "stopped",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to add from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn add(self: *Loop, completion: *Completion) void {\n        // If the completion is a cancel operation, we start it immediately as it will be put in the\n        // cancellations queue.\n        if (completion.op == .cancel) {\n            self.start_completion(completion);\n            return;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "add",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to submit from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn submit(self: *Loop) !void {\n        // Submit all the submissions. We copy the submission queue so that any resubmits don't\n        // cause an infinite loop.\n        var queued = self.submissions;\n        self.submissions = .{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "submit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to process_cancellations from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn process_cancellations(self: *Loop) void {\n        while (self.cancellations.pop()) |c| {\n            const target = c.op.cancel.c;\n            var cancel_result: CancelError!void = {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "process_cancellations",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn run(self: *Loop, mode: RunMode) !void {\n        switch (mode) {\n            .no_wait => try self.tick(0),\n            .once => try self.tick(1),\n            .until_done => while (!self.done()) try self.tick(1),\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "run",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tick from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn tick(self: *Loop, wait: u32) !void {\n        // If we're stopped then the loop is fully over.\n        if (self.flags.stopped) return;\n\n        // We can't nest runs.\n        if (self.flags.in_run) return error.NestedRunsNotAllowed;\n        self.flags.in_run = true;\n        defer self.flags.in_run = false;\n\n        // The list of entry that will be filled with a call to GetQueuedCompletionStatusEx.\n        var entries: [128]windows.OVERLAPPED_ENTRY = undefined;\n\n        var wait_rem = @as(usize, @intCast(wait));\n\n        // Handle all of our cancellations first because we may be able to stop submissions from\n        // even happening if its still queued. Plus, cancellations sometimes add more to the\n        // submission queue.\n        self.process_cancellations();\n\n        // Submit pending completions.\n        try self.submit();\n\n        // Loop condition is inspired from the kqueue backend. See its documentation for details.\n        while (true) {\n            // If we're stopped then the loop is fully over.\n            if (self.flags.stopped) return;\n\n            // We must update our time no matter what.\n            self.update_now();\n\n            const should_continue = (self.active > 0 and (wait == 0 or wait_rem > 0)) or !self.completions.empty();\n            if (!should_continue) break;\n\n            // Run our expired timers.\n            const now_timer: Timer = .{ .next = self.cached_now }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "tick",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to now from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn now(self: *Loop) i64 {\n        return @as(i64, @intCast(self.cached_now));\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "now",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to update_now from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn update_now(self: *Loop) void {\n        // Compute the current timestamp in ms by multiplying the QueryPerfomanceCounter value in\n        // ticks by the duration of a tick.\n        self.cached_now = windows.QueryPerformanceCounter() * self.qpc_duration;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "update_now",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to timer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn timer(\n        self: *Loop,\n        c: *Completion,\n        next_ms: u64,\n        userdata: ?*anyopaque,\n        comptime cb: Callback,\n    ) void {\n        c.* = .{\n            .op = .{\n                .timer = .{\n                    .next = self.timer_next(next_ms),\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "timer",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to timer_reset from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn timer_reset(\n        self: *Loop,\n        c: *Completion,\n        c_cancel: *Completion,\n        next_ms: u64,\n        userdata: ?*anyopaque,\n        comptime cb: Callback,\n    ) void {\n        switch (c.flags.state) {\n            .dead => {\n                self.timer(c, next_ms, userdata, cb);\n                return;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "timer_reset",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to timer_next from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn timer_next(self: *Loop, next_ms: u64) u64 {\n        return self.cached_now + next_ms * std.time.ns_per_ms;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "timer_next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to done from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn done(self: *Loop) bool {\n        return self.flags.stopped or (self.active == 0 and\n            self.submissions.empty() and\n            self.completions.empty());\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "done",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to start_completion from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn start_completion(self: *Loop, completion: *Completion) void {\n        const StartAction = union(enum) {\n            // We successfully submitted the operation.\n            submitted: void,\n\n            // We are a timer.\n            timer: void,\n\n            // We are a cancellation.\n            cancel: void,\n\n            // We are an async wait\n            async_wait: void,\n\n            // We have a result code from making a system call now.\n            result: Result,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "start_completion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stop_completion from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn stop_completion(self: *Loop, completion: *Completion, cancel_result: ?*CancelError!void) void {\n        if (completion.flags.state == .active and completion.result != null) return;\n\n        // Inspect other operations. WARNING: the state can be anything here so per op be sure to\n        // check the state flag.\n        switch (completion.op) {\n            .timer => |*v| {\n                if (completion.flags.state == .active) {\n                    // Remove from the heap so it never fires...\n                    self.timers.remove(v);\n\n                    // If we have reset AND we got cancellation result, that means that we were\n                    // canceled so that we can update our expiration time.\n                    if (v.reset) |r| {\n                        v.next = r;\n                        v.reset = null;\n                        completion.flags.state = .dead;\n                        self.active -= 1;\n                        self.add(completion);\n                        return;\n                    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "stop_completion",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to async_notify from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn async_notify(self: *Loop, completion: *Completion) void {\n        // The completion must be in a waiting state.\n        assert(completion.op == .async_wait);\n\n        // The completion has been wakeup, this is used to see which completion in the async queue\n        // needs to be removed.\n        completion.op.async_wait.wakeup.store(true, .seq_cst);\n\n        // NOTE: This call can fail but errors are not documented, so we log the error here.\n        windows.PostQueuedCompletionStatus(self.iocp_handle, 0, 0, null) catch |err| {\n            log.warn(\"unexpected async_notify error={}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "async_notify",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to associate_fd from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn associate_fd(self: Loop, fd: windows.HANDLE) !void {\n        if (fd == windows.INVALID_HANDLE_VALUE or self.iocp_handle == windows.INVALID_HANDLE_VALUE) return error.InvalidParameter;\n        // We ignore the error here because multiple call to CreateIoCompletionPort with a HANDLE\n        // already registered triggers a INVALID_PARAMETER error and we have no way to see the cause\n        // of it.\n        _ = windows.kernel32.CreateIoCompletionPort(fd, self.iocp_handle, 0, 0);\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "associate_fd",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to asSocket from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn asSocket(h: windows.HANDLE) windows.ws2_32.SOCKET {\n    return @as(windows.ws2_32.SOCKET, @ptrCast(h));\n}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "asSocket",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to state from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn state(self: Completion) CompletionState {\n        return switch (self.flags.state) {\n            .dead => .dead,\n            .adding, .active => .active,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "state",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to handle from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn handle(self: Completion) ?windows.HANDLE {\n        return switch (self.op) {\n            inline .accept => |*v| v.socket,\n            inline .read, .pread, .write, .pwrite, .recv, .send, .recvfrom, .sendto => |*v| v.fd,\n            else => null,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "handle",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to perform from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn perform(self: *Completion) Result {\n        return switch (self.op) {\n            .noop, .close, .connect, .shutdown, .timer, .cancel => {\n                std.log.warn(\"perform op={s}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "perform",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reset from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub fn reset(self: *Completion) void {\n        self.overlapped = .{\n            .Internal = 0,\n            .InternalHigh = 0,\n            .DUMMYUNIONNAME = .{ .Pointer = null }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "reset",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to less from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn less(_: void, a: *const Timer, b: *const Timer) bool {\n        return a.next < b.next;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "less",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, _: *Completion, r: Result) CallbackAction {\n            _ = l;\n            _ = r;\n            const b = @as(*bool, @ptrCast(ud.?));\n            b.* = true;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            _ = r;\n            const b = @as(*bool, @ptrCast(ud.?));\n            b.* = true;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            _ = r;\n            const b = @as(*bool, @ptrCast(ud.?));\n            b.* = true;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            const v = @as(*?TimerTrigger, @ptrCast(ud.?));\n            v.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            const v = @as(*?TimerTrigger, @ptrCast(ud.?));\n            v.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            const v = @as(*?TimerTrigger, @ptrCast(ud.?));\n            v.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            const ptr: *?TimerTrigger = @ptrCast(@alignCast(ud.?));\n            ptr.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.cancel catch unreachable;\n                const ptr: *bool = @ptrCast(@alignCast(ud.?));\n                ptr.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            const ptr: *?TimerTrigger = @ptrCast(@alignCast(ud.?));\n            ptr.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.cancel catch unreachable;\n                const ptr: *bool = @ptrCast(@alignCast(ud.?));\n                ptr.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = ud;\n                _ = l;\n                _ = c;\n                _ = r.write catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                const ptr: *usize = @ptrCast(@alignCast(ud.?));\n                ptr.* = r.read catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = ud;\n                _ = l;\n                _ = c;\n                _ = r.pwrite catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                const ptr: *usize = @ptrCast(@alignCast(ud.?));\n                ptr.* = r.pread catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                const conn: *Result = @ptrCast(@alignCast(ud.?));\n                conn.* = r;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.connect catch unreachable;\n                const b = @as(*bool, @ptrCast(ud.?));\n                b.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.send catch unreachable;\n                _ = ud;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                const ptr: *usize = @ptrCast(@alignCast(ud.?));\n                ptr.* = r.recv catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.shutdown catch unreachable;\n                const ptr: *bool = @ptrCast(@alignCast(ud.?));\n                ptr.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                const ptr: *?bool = @ptrCast(@alignCast(ud.?));\n                ptr.* = if (r.recv) |_| false else |err| switch (err) {\n                    error.EOF => true,\n                    else => false,\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.close catch unreachable;\n                const ptr: *bool = @ptrCast(@alignCast(ud.?));\n                ptr.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.close catch unreachable;\n                const ptr: *bool = @ptrCast(@alignCast(ud.?));\n                ptr.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                const ptr: *Result = @ptrCast(@alignCast(ud.?));\n                ptr.* = r;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = r.cancel catch unreachable;\n                _ = ud;\n                _ = l;\n                _ = c;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                const conn: *Result = @ptrCast(@alignCast(ud.?));\n                conn.* = r;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = r.cancel catch unreachable;\n                _ = ud;\n                _ = l;\n                _ = c;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Loop from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub const Loop = struct {\n    const TimerHeap = heap.Intrusive(Timer, void, Timer.less);\n\n    /// The handle to the IO completion port.\n    iocp_handle: windows.HANDLE = windows.INVALID_HANDLE_VALUE,\n\n    /// The number of active completions. This DOES NOT include completions that are queued in the\n    /// submissions queue.\n    active: usize = 0,\n\n    /// Our queue of submissions that we want to enqueue on the next tick.\n    /// These are NOT started.\n    submissions: queue.Intrusive(Completion) = .{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "struct",
      "name": "Loop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Completion from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub const Completion = struct {\n    /// Operation to execute.\n    op: Operation = .{ .noop = {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "struct",
      "name": "Completion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Timer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "pub const Timer = struct {\n    /// The absolute time to fire this timer next.\n    next: u64,\n\n    /// Only used internally. If this is non-null and timer is\n    /// CANCELLED, then the timer is rearmed automatically with this\n    /// as the next time. The callback will not be called on the\n    /// cancellation.\n    reset: ?u64 = null,\n\n    /// Internal heap field.\n    heap: heap.IntrusiveField(Timer) = .{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "struct",
      "name": "Timer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to now_timer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const now_timer: Timer = .{ .next = self.cached_now };",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "now_timer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to timeout from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const timeout: ?windows.DWORD = timeout: {\n                // If we have a timer, we want to set the timeout to our next timer value. If we\n                // have no timer, we wait forever.\n                const t = self.timers.peek() orelse break :timeout null;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "timeout",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to count from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const count: u32 = windows.GetQueuedCompletionStatusEx(self.iocp_handle, &entries, timeout, false) catch |err| switch (err) {\n                // A timeout means that nothing was completed.\n                error.Timeout => 0,\n\n                else => return err,\n            };",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to completion from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const completion: *Completion = if (entry.lpCompletionKey == 0) completion: {\n                    // We retrieve the Completion from the OVERLAPPED pointer as we know it's a part of\n                    // the Completion struct.\n                    const overlapped_ptr: ?*windows.OVERLAPPED = @as(?*windows.OVERLAPPED, @ptrCast(entry.lpOverlapped));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "completion",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to completion from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const completion: *Completion = @ptrFromInt(entry.lpCompletionKey);",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "completion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to action from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const action: StartAction = switch (completion.op) {\n            .noop => {\n                completion.flags.state = .dead;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "action",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to buffer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const buffer: []u8 = if (v.buffer == .slice) v.buffer.slice else &v.buffer.array;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to buffer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const buffer: []u8 = if (v.buffer == .slice) v.buffer.slice else &v.buffer.array;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to buffer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const buffer: []const u8 = if (v.buffer == .slice) v.buffer.slice else v.buffer.array.array[0..v.buffer.array.len];",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to buffer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const buffer: []const u8 = if (v.buffer == .slice) v.buffer.slice else v.buffer.array.array[0..v.buffer.array.len];",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to buffer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const buffer: []const u8 = if (v.buffer == .slice) v.buffer.slice else v.buffer.array.array[0..v.buffer.array.len];",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to buffer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const buffer: []u8 = if (v.buffer == .slice) v.buffer.slice else &v.buffer.array;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to buffer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const buffer: []const u8 = if (v.buffer == .slice) v.buffer.slice else v.buffer.array.array[0..v.buffer.array.len];",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to buffer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const buffer: []u8 = if (v.buffer == .slice) v.buffer.slice else &v.buffer.array;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "buffer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to r from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const r: Result = .{\n                        .accept = switch (err) {\n                            windows.ws2_32.WinsockError.WSA_OPERATION_ABORTED => error.Canceled,\n                            else => windows.unexpectedWSAError(err),\n                        },\n                    };",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "r",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cb from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const cb: Callback = (struct {\n        fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "cb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cb from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const cb: Callback = (struct {\n        fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "cb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cb from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const cb: Callback = (struct {\n        fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "cb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const ptr: *?TimerTrigger = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const ptr: *bool = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const ptr: *?TimerTrigger = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const ptr: *bool = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const ptr: *usize = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const ptr: *usize = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to conn from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const conn: *Result = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "conn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const ptr: *usize = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const ptr: *bool = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const ptr: *?bool = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const ptr: *bool = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const ptr: *bool = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const ptr: *Result = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to conn from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/iocp.zig",
    "response": "const conn: *Result = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/iocp.zig",
      "type": "const",
      "name": "conn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to available from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "pub fn available() bool {\n    return switch (builtin.os.tag) {\n        // macOS uses kqueue\n        .ios, .macos => true,\n\n        // BSDs use kqueue, but we only test on FreeBSD for now.\n        // kqueue isn't exactly the same here as it is on Apple platforms.\n        .freebsd => true,\n\n        // Technically other BSDs support kqueue but our implementation\n        // below hard requires mach ports currently. That's not a fundamental\n        // requirement but until someone makes this implementation work\n        // on other BSDs we'll just say it isn't available.\n        else => false,\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "available",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "pub fn init(options: Options) !Loop {\n        // This creates a new kqueue fd\n        const fd = try posix.kqueue();\n        errdefer posix.close(fd);\n\n        const wakeup_state: Wakeup = try .init();\n        errdefer wakeup_state.deinit();\n\n        var res: Loop = .{\n            .kqueue_fd = fd,\n            .wakeup_state = wakeup_state,\n            .thread_pool = options.thread_pool,\n            .thread_pool_completions = undefined,\n            .cached_now = undefined,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "pub fn deinit(self: *Loop) void {\n        posix.close(self.kqueue_fd);\n        self.wakeup_state.deinit();\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stop from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "pub fn stop(self: *Loop) void {\n        self.flags.stopped = true;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "stop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stopped from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "pub fn stopped(self: *Loop) bool {\n        return self.flags.stopped;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "stopped",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to add from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "pub fn add(self: *Loop, completion: *Completion) void {\n        // If this is a cancellation, we special case it and add it to\n        // a separate queue so we can handle them first.\n        if (completion.op == .cancel) {\n            assert(!self.start(completion, undefined));\n            return;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "add",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to submit from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "pub fn submit(self: *Loop) !void {\n        // We try to submit as many events at once as we can.\n        var events: [256]Kevent = undefined;\n        var events_len: usize = 0;\n\n        // Submit all the submissions. We copy the submission queue so that\n        // any resubmits don't cause an infinite loop.\n        var queued = self.submissions;\n        self.submissions = .{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "submit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to process_cancellations from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn process_cancellations(self: *Loop) void {\n        while (self.cancellations.pop()) |c| {\n            const target = c.op.cancel.c;\n            switch (target.flags.state) {\n                // If the target is dead already we do nothing.\n                .dead => {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "process_cancellations",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "pub fn run(self: *Loop, mode: RunMode) !void {\n        switch (mode) {\n            .no_wait => try self.tick(0),\n            .once => try self.tick(1),\n            .until_done => while (!self.done()) try self.tick(1),\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "run",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tick from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "pub fn tick(self: *Loop, wait: u32) !void {\n        // If we're stopped then the loop is fully over.\n        if (self.flags.stopped) return;\n\n        // We can't nest runs.\n        if (self.flags.in_run) return error.NestedRunsNotAllowed;\n        self.flags.in_run = true;\n        defer self.flags.in_run = false;\n\n        // Initialize\n        if (!self.flags.init) {\n            self.flags.init = true;\n\n            if (self.thread_pool != null) {\n                self.thread_pool_completions.init();\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "tick",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to now from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "pub fn now(self: *Loop) i64 {\n        // If anything overflows we just return the max value.\n        const max = std.math.maxInt(i64);\n\n        // Calculate all the values, being careful about overflows in order\n        // to just return the maximum value.\n        const sec = std.math.mul(isize, self.cached_now.sec, std.time.ms_per_s) catch return max;\n        const nsec = @divFloor(self.cached_now.nsec, std.time.ns_per_ms);\n        return std.math.lossyCast(i64, sec +| nsec);\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "now",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to update_now from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "pub fn update_now(self: *Loop) void {\n        if (posix.clock_gettime(posix.CLOCK.MONOTONIC)) |new_time| {\n            self.cached_now = new_time;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "update_now",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to timer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "pub fn timer(\n        self: *Loop,\n        c: *Completion,\n        next_ms: u64,\n        userdata: ?*anyopaque,\n        comptime cb: Callback,\n    ) void {\n        c.* = .{\n            .op = .{\n                .timer = .{\n                    .next = self.timer_next(next_ms),\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "timer",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to timer_reset from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "pub fn timer_reset(\n        self: *Loop,\n        c: *Completion,\n        c_cancel: *Completion,\n        next_ms: u64,\n        userdata: ?*anyopaque,\n        comptime cb: Callback,\n    ) void {\n        switch (c.flags.state) {\n            .dead, .deleting => {\n                self.timer(c, next_ms, userdata, cb);\n                return;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "timer_reset",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to timer_next from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn timer_next(self: Loop, next_ms: u64) posix.timespec {\n        // Get the timestamp of the absolute time that we'll execute this timer.\n        // There are lots of failure scenarios here in math. If we see any\n        // of them we just use the maximum value.\n        const max: posix.timespec = .{\n            .sec = std.math.maxInt(isize),\n            .nsec = std.math.maxInt(isize),\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "timer_next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to done from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn done(self: *Loop) bool {\n        return self.flags.stopped or (self.active == 0 and\n            self.submissions.empty() and\n            self.completions.empty());\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "done",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to start from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn start(self: *Loop, c: *Completion, ev: *Kevent) bool {\n        const StartAction = union(enum) {\n            /// We have set the kevent out parameter\n            kevent: void,\n\n            // We are a timer,\n            timer: void,\n\n            // We are a cancellation\n            cancel: void,\n\n            // We want to run on the threadpool\n            threadpool: void,\n\n            /// We have a result code from making a system call now.\n            result: i32,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stop_completion from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn stop_completion(self: *Loop, c: *Completion) void {\n        if (c.flags.state == .active) {\n            // If there is a result already, then we're already in the\n            // completion queue and we can be done. Items in the completion\n            // queue can NOT be in the kqueue too.\n            if (c.result != null) return;\n\n            // If this completion has a kevent associated with it, then\n            // we must remove the kevent. We remove the kevent by adding it\n            // to the submission queue (because its the same syscall) but\n            // setting the state to deleting.\n            if (c.kevent() != null) {\n                self.active -= 1;\n                c.flags.state = .deleting;\n                self.submissions.push(c);\n                return;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "stop_completion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to thread_perform from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn thread_perform(t: *ThreadPool.Task) void {\n        const c: *Completion = @fieldParentPtr(\"task\", t);\n\n        // Do our task\n        c.result = c.perform(null);\n\n        // Add to our completion queue\n        c.task_loop.thread_pool_completions.push(c);\n\n        if (comptime builtin.target.os.tag == .macos) {\n            // Wake up our main loop\n            c.task_loop.wakeup() catch {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "thread_perform",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to wakeup from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn wakeup(self: *Loop) !void {\n        try self.wakeup_state.wakeup();\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "wakeup",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to state from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "pub fn state(self: Completion) CompletionState {\n        return switch (self.flags.state) {\n            .dead => .dead,\n            .adding, .deleting, .active => .active,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "state",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to kevent from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn kevent(self: *Completion) ?Kevent {\n        return switch (self.op) {\n            .noop => unreachable,\n\n            .cancel,\n            .close,\n            .timer,\n            .shutdown,\n            => null,\n\n            .accept => |v| kevent_init(.{\n                .ident = @intCast(v.socket),\n                .filter = std.c.EVFILT.READ,\n                .flags = std.c.EV.ADD | std.c.EV.ENABLE,\n                .fflags = 0,\n                .data = 0,\n                .udata = @intFromPtr(self),\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "kevent",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to perform from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn perform(self: *Completion, ev_: ?*const Kevent) Result {\n        return switch (self.op) {\n            .cancel,\n            .noop,\n            .timer,\n            .shutdown,\n            => {\n                log.warn(\"perform op={s}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "perform",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to syscall_result from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn syscall_result(c: *Completion, r: i32) Result {\n        const errno: posix.E = if (r >= 0) .SUCCESS else @enumFromInt(-r);\n        return switch (c.op) {\n            .noop => unreachable,\n\n            .accept => .{\n                .accept = switch (errno) {\n                    .SUCCESS => r,\n                    .CANCELED => error.Canceled,\n                    else => |err| posix.unexpectedErrno(err),\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "syscall_result",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn init() !Self {\n        const mach_port = try Async.init();\n        errdefer mach_port.deinit();\n        return .{ .mach_port = mach_port }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn deinit(self: *Self) void {\n        self.mach_port.deinit();\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to setup from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn setup(self: *Self, kqueue_fd: posix.fd_t) !void {\n        const events = [_]Kevent{.{\n            .ident = @as(usize, @intCast(self.mach_port.port)),\n            .filter = std.c.EVFILT.MACHPORT,\n            .flags = std.c.EV.ADD | std.c.EV.ENABLE,\n            .fflags = darwin.MACH_RCV_MSG,\n            .data = 0,\n            .udata = 0,\n            .ext = .{\n                @intFromPtr(&self.mach_port_buffer),\n                self.mach_port_buffer.len,\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "setup",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to wakeup from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn wakeup(self: *Self) !void {\n        try self.mach_port.notify();\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "wakeup",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn deinit(self: *Self) void {\n        _ = self;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to setup from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn setup(self: *Self, kqueue_fd: posix.fd_t) !void {\n        _ = self;\n        _ = kqueue_fd;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "setup",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wakeup from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn wakeup(self: *Self) !void {\n        _ = self;\n        @panic(\"wakeup not implemented on this platform\");\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "wakeup",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to less from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn less(_: void, a: *const Timer, b: *const Timer) bool {\n        return a.ns() < b.ns();\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "less",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ns from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn ns(self: *const Timer) u64 {\n        assert(self.next.sec >= 0);\n        assert(self.next.nsec >= 0);\n\n        const max = std.math.maxInt(u64);\n        const s_ns = std.math.mul(\n            u64,\n            @as(u64, @intCast(self.next.sec)),\n            std.time.ns_per_s,\n        ) catch return max;\n        return std.math.add(u64, s_ns, @as(u64, @intCast(self.next.nsec))) catch\n            return max;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "ns",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to kevent_syscall from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn kevent_syscall(\n    kq: i32,\n    changelist: []const Kevent,\n    eventlist: []Kevent,\n    timeout: ?*const posix.timespec,\n) posix.KEventError!usize {\n    // Normaly Kevent? Just use the normal posix.kevent call.\n    if (Kevent == posix.Kevent) return try posix.kevent(\n        kq,\n        changelist,\n        eventlist,\n        timeout,\n    );\n\n    // Otherwise, we have to call the kevent64 variant.\n    while (true) {\n        const rc = posix.system.kevent64(\n            kq,\n            changelist.ptr,\n            std.math.cast(c_int, changelist.len) orelse return error.Overflow,\n            eventlist.ptr,\n            std.math.cast(c_int, eventlist.len) orelse return error.Overflow,\n            0,\n            timeout,\n        );\n        switch (posix.errno(rc)) {\n            .SUCCESS => return @intCast(rc),\n            .ACCES => return error.AccessDenied,\n            .FAULT => unreachable,\n            .BADF => unreachable, // Always a race condition.\n            .INTR => continue,\n            .INVAL => unreachable,\n            .NOENT => return error.EventNotFound,\n            .NOMEM => return error.SystemResources,\n            .SRCH => return error.ProcessNotFound,\n            else => unreachable,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "kevent_syscall",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to kevent_init from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn kevent_init(ev: posix.Kevent) Kevent {\n    if (Kevent == posix.Kevent) return ev;\n\n    return .{\n        .ident = ev.ident,\n        .filter = ev.filter,\n        .flags = ev.flags,\n        .fflags = ev.fflags,\n        .data = ev.data,\n        .udata = ev.udata,\n        .ext = .{ 0, 0 }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "kevent_init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(ud: ?*anyopaque, l: *Loop, _: *Completion, r: Result) CallbackAction {\n            _ = l;\n            _ = r;\n            const b: *bool = @ptrCast(ud.?);\n            b.* = true;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            _ = r;\n            const b: *bool = @ptrCast(ud.?);\n            b.* = true;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            _ = r;\n            const b: *bool = @ptrCast(ud.?);\n            b.* = true;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            const v: *?TimerTrigger = @ptrCast(ud.?);\n            v.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            const v: *?TimerTrigger = @ptrCast(ud.?);\n            v.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            const v: *?TimerTrigger = @ptrCast(ud.?);\n            v.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            const ptr: *?TimerTrigger = @ptrCast(@alignCast(ud.?));\n            ptr.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.cancel catch unreachable;\n                const ptr: *bool = @ptrCast(@alignCast(ud.?));\n                ptr.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;\n            const ptr: *?TimerTrigger = @ptrCast(@alignCast(ud.?));\n            ptr.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.cancel catch unreachable;\n                const ptr: *bool = @ptrCast(@alignCast(ud.?));\n                ptr.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                const conn = @as(*posix.socket_t, @ptrCast(@alignCast(ud.?)));\n                conn.* = r.accept catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.connect catch unreachable;\n                const b = @as(*bool, @ptrCast(ud.?));\n                b.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.send catch unreachable;\n                _ = ud;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                const ptr = @as(*usize, @ptrCast(@alignCast(ud.?)));\n                ptr.* = r.recv catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.shutdown catch unreachable;\n                const ptr = @as(*bool, @ptrCast(@alignCast(ud.?)));\n                ptr.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                const ptr = @as(*?bool, @ptrCast(@alignCast(ud.?)));\n                ptr.* = if (r.recv) |_| false else |err| switch (err) {\n                    error.EOF => true,\n                    else => false,\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.close catch unreachable;\n                const ptr = @as(*posix.socket_t, @ptrCast(@alignCast(ud.?)));\n                ptr.* = 0;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.close catch unreachable;\n                const ptr = @as(*posix.socket_t, @ptrCast(@alignCast(ud.?)));\n                ptr.* = 0;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = ud;\n                _ = l;\n                _ = c;\n                _ = r.write catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                const ptr = @as(*usize, @ptrCast(@alignCast(ud.?)));\n                ptr.* = r.read catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.machport catch unreachable;\n                const b = @as(*bool, @ptrCast(ud.?));\n                b.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                _: *Loop,\n                _: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = ud;\n                _ = r.accept catch |err| switch (err) {\n                    error.Canceled => {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                _: *Loop,\n                _: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = r.cancel catch unreachable;\n                const ptr = @as(*?bool, @ptrCast(@alignCast(ud.?)));\n                ptr.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *Loop,\n                c: *Completion,\n                r: Result,\n            ) CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.close catch unreachable;\n                const ptr = @as(*posix.socket_t, @ptrCast(@alignCast(ud.?)));\n                ptr.* = 0;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Loop from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "pub const Loop = struct {\n    const TimerHeap = heap.Intrusive(Timer, void, Timer.less);\n    const TaskCompletionQueue = queue_mpsc.Intrusive(Completion);\n\n    /// The fd of the kqueue.\n    kqueue_fd: posix.fd_t,\n\n    /// The wakeup mechanism (mach ports on Apple, eventfd on BSD).\n    wakeup_state: Wakeup,\n\n    /// The number of active completions. This DOES NOT include completions that\n    /// are queued in the submissions queue.\n    active: usize = 0,\n\n    /// Our queue of submissions that we want to enqueue on the next tick.\n    /// These are NOT started, they are NOT submitted to kqueue. They are\n    /// pending.\n    submissions: queue.Intrusive(Completion) = .{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "struct",
      "name": "Loop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Completion from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "pub const Completion = struct {\n    /// Operation to execute.\n    op: Operation = .{ .noop = {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "struct",
      "name": "Completion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Timer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const Timer = struct {\n    /// The absolute time to fire this timer next.\n    next: posix.timespec,\n\n    /// Only used internally. If this is non-null and timer is\n    /// CANCELLED, then the timer is rearmed automatically with this\n    /// as the next time. The callback will not be called on the\n    /// cancellation.\n    reset: ?posix.timespec = null,\n\n    /// Internal heap fields.\n    heap: heap.IntrusiveField(Timer) = .{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "struct",
      "name": "Timer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to wakeup_state from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const wakeup_state: Wakeup = try .init();",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "wakeup_state",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to c from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const c: *Completion = @ptrFromInt(@as(usize, @intCast(ev.udata)));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "c",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to now_timer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const now_timer: Timer = .{ .next = self.cached_now };",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "now_timer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to disarm_ev from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const disarm_ev: ?Kevent = ev: {\n                    // If we're not active then we were never part of the kqueue.\n                    // If we are part of a threadpool we also never were part\n                    // of the kqueue.\n                    if (c.flags.state != .active or\n                        c.flags.threadpool) break :ev null;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "disarm_ev",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to timeout from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const timeout: ?posix.timespec = timeout: {\n                if (wait_rem == 0) break :timeout std.mem.zeroes(posix.timespec);",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "timeout",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to c from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const c: *Completion = @ptrFromInt(@as(usize, @intCast(ev.udata)));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "c",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to max from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const max: posix.timespec = .{\n            .sec = std.math.maxInt(isize),\n            .nsec = std.math.maxInt(isize),\n        };",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "max",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to action from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const action: StartAction = if (c.flags.threadpool) .{\n            .threadpool = {},\n        } else switch (c.op) {\n            .noop => {\n                c.flags.state = .dead;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "action",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to c from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const c: *Completion = @fieldParentPtr(\"task\", t);",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "c",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slice from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const slice: []u8 = switch (v.buffer) {\n                    .slice => |slice| slice,\n                    .array => |*arr| arr,\n                };",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "slice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to n_ from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const n_: ReadError!usize = switch (op.buffer) {\n                    .slice => |v| if (v.len == 0) empty: {\n                        const ev = ev_ orelse\n                            break :res .{ .read = error.MissingKevent };",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "n_",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to n_ from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const n_: ReadError!usize = switch (op.buffer) {\n                    .slice => |v| if (v.len == 0) empty: {\n                        const ev = ev_ orelse\n                            break :res .{ .read = error.MissingKevent };",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "n_",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to n_ from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const n_: ReadError!usize = switch (op.buffer) {\n                    .slice => |v| if (v.len == 0) empty: {\n                        const ev = ev_ orelse\n                            break :res .{ .read = error.MissingKevent };",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "n_",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to n_ from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const n_: ReadError!usize = switch (op.buffer) {\n                    .slice => |v| if (v.len == 0) empty: {\n                        const ev = ev_ orelse\n                            break :res .{ .read = error.MissingKevent };",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "n_",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to data from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const data: u32 = @intCast(ev.data);",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "data",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to errno from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const errno: posix.E = if (r >= 0) .SUCCESS else @enumFromInt(-r);",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "errno",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to b from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const b: *bool = @ptrCast(ud.?);",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "b",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to b from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const b: *bool = @ptrCast(ud.?);",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "b",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to b from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const b: *bool = @ptrCast(ud.?);",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "b",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cb from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const cb: Callback = (struct {\n        fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "cb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to v from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const v: *?TimerTrigger = @ptrCast(ud.?);",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "v",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cb from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const cb: Callback = (struct {\n        fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "cb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to v from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const v: *?TimerTrigger = @ptrCast(ud.?);",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "v",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cb from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const cb: Callback = (struct {\n        fn callback(\n            ud: ?*anyopaque,\n            l: *Loop,\n            _: *Completion,\n            r: Result,\n        ) CallbackAction {\n            _ = l;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "cb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to v from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const v: *?TimerTrigger = @ptrCast(ud.?);",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "v",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const ptr: *?TimerTrigger = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const ptr: *bool = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const ptr: *?TimerTrigger = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to ptr from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/kqueue.zig",
    "response": "const ptr: *bool = @ptrCast(@alignCast(ud.?));",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/kqueue.zig",
      "type": "const",
      "name": "ptr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to available from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub fn available() bool {\n    return builtin.os.tag == .wasi;\n}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "available",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub fn init(options: xev.Options) !Loop {\n        _ = options;\n        return .{ .cached_now = try get_now() }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub fn deinit(self: *Loop) void {\n        _ = self;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub fn run(self: *Loop, mode: xev.RunMode) !void {\n        switch (mode) {\n            .no_wait => try self.tick(0),\n            .once => try self.tick(1),\n            .until_done => while (!self.done()) try self.tick(1),\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "run",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stop from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub fn stop(self: *Loop) void {\n        self.flags.stopped = true;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "stop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stopped from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub fn stopped(self: *Loop) bool {\n        return self.flags.stopped;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "stopped",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to add from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub fn add(self: *Loop, c: *Completion) void {\n        c.flags.state = .adding;\n        self.submissions.push(c);\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "add",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to done from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn done(self: *Loop) bool {\n        return self.flags.stopped or (self.active == 0 and\n            self.submissions.empty());\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "done",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to async_notify from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub fn async_notify(self: *Loop, c: *Completion) void {\n        assert(c.op == .async_wait);\n\n        if (threaded) {\n            self.wakeup.store(true, .SeqCst);\n            c.op.async_wait.wakeup.store(true, .SeqCst);\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "async_notify",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tick from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub fn tick(self: *Loop, wait: u32) !void {\n        // If we're stopped then the loop is fully over.\n        if (self.flags.stopped) return;\n\n        // We can't nest runs.\n        if (self.flags.in_run) return error.NestedRunsNotAllowed;\n        self.flags.in_run = true;\n        defer self.flags.in_run = false;\n\n        // Submit all the submissions. We copy the submission queue so that\n        // any resubmits don't cause an infinite loop.\n        var queued = self.submissions;\n        self.submissions = .{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "tick",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to start from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn start(self: *Loop, completion: *Completion) void {\n        const res_: ?Result = switch (completion.op) {\n            .noop => {\n                completion.flags.state = .dead;\n                return;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to stop_completion from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn stop_completion(self: *Loop, c: *Completion) void {\n        // We may modify the state below so we need to know now if this\n        // completion was active.\n        const active = c.flags.state == .active;\n\n        const rearm: bool = switch (c.op) {\n            .timer => |*v| timer: {\n                assert(v.c == c);\n\n                // Timers needs to be removed from the timer heap only if\n                // it has been inserted.\n                if (c.flags.state == .active) {\n                    self.timers.remove(v);\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "stop_completion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to timer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub fn timer(\n        self: *Loop,\n        c: *Completion,\n        next_ms: u64,\n        userdata: ?*anyopaque,\n        comptime cb: xev.Callback,\n    ) void {\n        c.* = .{\n            .op = .{\n                .timer = .{\n                    .next = timer_next(next_ms),\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "timer",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to timer_reset from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub fn timer_reset(\n        self: *Loop,\n        c: *Completion,\n        c_cancel: *Completion,\n        next_ms: u64,\n        userdata: ?*anyopaque,\n        comptime cb: xev.Callback,\n    ) void {\n        switch (c.flags.state) {\n            .dead, .deleting => {\n                self.timer(c, next_ms, userdata, cb);\n                return;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "timer_reset",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to now from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub fn now(self: *Loop) i64 {\n        return std.math.lossyCast(i64, @divFloor(self.cached_now, std.time.ns_per_ms));\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "now",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to update_now from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub fn update_now(self: *Loop) void {\n        if (get_now()) |t| self.cached_now = t else |_| {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "update_now",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to timer_next from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn timer_next(next_ms: u64) wasi.timestamp_t {\n        // Get the absolute time we'll execute this timer next.\n        var now_ts: wasi.timestamp_t = undefined;\n        switch (wasi.clock_time_get(@as(u32, @bitCast(posix.CLOCK.MONOTONIC)), 1, &now_ts)) {\n            .SUCCESS => {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "timer_next",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get_now from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn get_now() !wasi.timestamp_t {\n        var ts: wasi.timestamp_t = undefined;\n        return switch (wasi.clock_time_get(posix.CLOCK.MONOTONIC, 1, &ts)) {\n            .SUCCESS => ts,\n            .INVAL => error.UnsupportedClock,\n            else => |err| posix.unexpectedErrno(err),\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "get_now",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to state from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub fn state(self: Completion) xev.CompletionState {\n        return switch (self.flags.state) {\n            .dead => .dead,\n            .adding, .deleting, .active => .active,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "state",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to subscription from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn subscription(self: *Completion) wasi.subscription_t {\n        return switch (self.op) {\n            .read => |v| .{\n                .userdata = @intFromPtr(self),\n                .u = .{\n                    .tag = wasi.EVENTTYPE_FD_READ,\n                    .u = .{\n                        .fd_read = .{\n                            .fd = v.fd,\n                        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "subscription",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to perform from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn perform(self: *Completion) Result {\n        return switch (self.op) {\n            // This should never happen because we always do these synchronously\n            // or in another location.\n            .close,\n            .async_wait,\n            .noop,\n            .shutdown,\n            .cancel,\n            .timer,\n            => unreachable,\n\n            .accept => |*op| res: {\n                var out_fd: posix.fd_t = undefined;\n                break :res .{\n                    .accept = switch (wasi.sock_accept(op.socket, 0, &out_fd)) {\n                        .SUCCESS => out_fd,\n                        else => |err| posix.unexpectedErrno(err),\n                    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "perform",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to less from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn less(_: void, a: *const Timer, b: *const Timer) bool {\n        return a.next < b.next;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "less",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to get from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub fn get(self: *Batch, c: *Completion) Error!*wasi.subscription_t {\n        if (self.len >= self.array.len) return error.BatchFull;\n        c.batch_idx = self.len;\n        self.len += 1;\n        return &self.array[c.batch_idx];\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "get",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to put from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub fn put(self: *Batch, c: *Completion) void {\n        assert(c.batch_idx > 0);\n        assert(self.len > 1);\n\n        const old_idx = c.batch_idx;\n        c.batch_idx = 0;\n        self.len -= 1;\n\n        // If we're empty then we don't worry about swapping.\n        if (self.len == 0) return;\n\n        // We're not empty so swap the value we just removed with the\n        // last one so our empty slot is always at the end.\n        self.array[old_idx] = self.array[self.len];\n        const swapped = @as(*Completion, @ptrFromInt(@as(usize, @intCast(self.array[old_idx].userdata))));\n        swapped.batch_idx = old_idx;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "put",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *xev.Loop,\n            _: *xev.Completion,\n            r: xev.Result,\n        ) xev.CallbackAction {\n            _ = l;\n            _ = r;\n            const b = @as(*bool, @ptrCast(ud.?));\n            b.* = true;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *xev.Loop,\n            _: *xev.Completion,\n            r: xev.Result,\n        ) xev.CallbackAction {\n            _ = l;\n            _ = r;\n            const b = @as(*bool, @ptrCast(ud.?));\n            b.* = true;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *xev.Loop,\n            _: *xev.Completion,\n            r: xev.Result,\n        ) xev.CallbackAction {\n            _ = l;\n            const v = @as(*?TimerTrigger, @ptrCast(ud.?));\n            v.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *xev.Loop,\n            _: *xev.Completion,\n            r: xev.Result,\n        ) xev.CallbackAction {\n            _ = l;\n            const v = @as(*?TimerTrigger, @ptrCast(ud.?));\n            v.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *xev.Loop,\n            _: *xev.Completion,\n            r: xev.Result,\n        ) xev.CallbackAction {\n            _ = l;\n            const v = @as(*?TimerTrigger, @ptrCast(ud.?));\n            v.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *xev.Loop,\n            _: *xev.Completion,\n            r: xev.Result,\n        ) xev.CallbackAction {\n            _ = l;\n            const ptr = @as(*?TimerTrigger, @ptrCast(@alignCast(ud.?)));\n            ptr.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *xev.Loop,\n                c: *xev.Completion,\n                r: xev.Result,\n            ) xev.CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.cancel catch unreachable;\n                const ptr = @as(*bool, @ptrCast(@alignCast(ud.?)));\n                ptr.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn callback(\n            ud: ?*anyopaque,\n            l: *xev.Loop,\n            _: *xev.Completion,\n            r: xev.Result,\n        ) xev.CallbackAction {\n            _ = l;\n            const ptr = @as(*?TimerTrigger, @ptrCast(@alignCast(ud.?)));\n            ptr.* = r.timer catch unreachable;\n            return .disarm;\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *xev.Loop,\n                c: *xev.Completion,\n                r: xev.Result,\n            ) xev.CallbackAction {\n                _ = l;\n                _ = c;\n                _ = r.cancel catch unreachable;\n                const ptr = @as(*bool, @ptrCast(@alignCast(ud.?)));\n                ptr.* = true;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *xev.Loop,\n                c: *xev.Completion,\n                r: xev.Result,\n            ) xev.CallbackAction {\n                _ = l;\n                _ = c;\n                const ptr = @as(*?usize, @ptrCast(@alignCast(ud.?)));\n                ptr.* = r.read catch |err| switch (err) {\n                    error.EOF => 0,\n                    else => unreachable,\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *xev.Loop,\n                c: *xev.Completion,\n                r: xev.Result,\n            ) xev.CallbackAction {\n                _ = l;\n                _ = c;\n                const ptr = @as(*?usize, @ptrCast(@alignCast(ud.?)));\n                ptr.* = r.write catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to callback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "fn callback(\n                ud: ?*anyopaque,\n                l: *xev.Loop,\n                c: *xev.Completion,\n                r: xev.Result,\n            ) xev.CallbackAction {\n                _ = ud;\n                _ = l;\n                _ = c;\n                _ = r.close catch unreachable;\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "function",
      "name": "callback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Loop from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub const Loop = struct {\n    pub const threaded = std.Target.wasm.featureSetHas(builtin.cpu.features, .atomics);\n    const TimerHeap = heap.Intrusive(Timer, void, Timer.less);\n    const WakeupType = if (threaded) std.atomic.Atomic(bool) else bool;\n    const wakeup_init = if (threaded) .{ .value = false }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "struct",
      "name": "Loop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Completion from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "pub const Completion = struct {\n    /// Operation to execute. This is only safe to read BEFORE the completion\n    /// is queued. After being queued (with \"add\"), the operation may change.\n    op: Operation = .{ .noop = {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "struct",
      "name": "Completion",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Timer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "const Timer = struct {\n    /// The absolute time to fire this timer next.\n    next: wasi.timestamp_t,\n\n    /// Only used internally. If this is non-null and timer is\n    /// CANCELLED, then the timer is rearmed automatically with this\n    /// as the next time. The callback will not be called on the\n    /// cancellation.\n    reset: ?wasi.timestamp_t = null,\n\n    /// Internal heap fields.\n    heap: heap.IntrusiveField(Timer) = .{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "struct",
      "name": "Timer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Batch from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "const Batch = struct {\n    pub const capacity = 1024;\n\n    /// The array of subscriptions. Sub zero is ALWAYS our loop timeout\n    /// so the actual capacity of this for user completions is (len - 1).\n    array: [capacity]wasi.subscription_t = undefined,\n\n    /// The length of the used slots in the array including our reserved slot.\n    len: usize = 1,\n\n    pub const Error = error{BatchFull}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "struct",
      "name": "Batch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to now_timer from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "const now_timer: Timer = .{ .next = self.cached_now };",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "const",
      "name": "now_timer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to res_ from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "const res_: ?Result = switch (completion.op) {\n            .noop => {\n                completion.flags.state = .dead;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "const",
      "name": "res_",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to how from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "const how: wasi.sdflags_t = switch (v.how) {\n                    .both => wasi.SHUT.WR | wasi.SHUT.RD,\n                    .recv => wasi.SHUT.RD,\n                    .send => wasi.SHUT.WR,\n                };",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "const",
      "name": "how",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to rearm from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "const rearm: bool = switch (c.op) {\n            .timer => |*v| timer: {\n                assert(v.c == c);",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "const",
      "name": "rearm",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cb from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "const cb: xev.Callback = (struct {\n        fn callback(\n            ud: ?*anyopaque,\n            l: *xev.Loop,\n            _: *xev.Completion,\n            r: xev.Result,\n        ) xev.CallbackAction {\n            _ = l;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "const",
      "name": "cb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cb from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "const cb: xev.Callback = (struct {\n        fn callback(\n            ud: ?*anyopaque,\n            l: *xev.Loop,\n            _: *xev.Completion,\n            r: xev.Result,\n        ) xev.CallbackAction {\n            _ = l;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "const",
      "name": "cb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to cb from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "const cb: xev.Callback = (struct {\n        fn callback(\n            ud: ?*anyopaque,\n            l: *xev.Loop,\n            _: *xev.Completion,\n            r: xev.Result,\n        ) xev.CallbackAction {\n            _ = l;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "const",
      "name": "cb",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to base from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "const base: w.rights_t = w.RIGHT.FD_WRITE |\n            w.RIGHT.FD_READ |\n            w.RIGHT.FD_DATASYNC |\n            w.RIGHT.FD_SEEK |\n            w.RIGHT.FD_TELL |\n            w.RIGHT.FD_FDSTAT_SET_FLAGS |\n            w.RIGHT.FD_SYNC |\n            w.RIGHT.FD_ALLOCATE |\n            w.RIGHT.FD_ADVISE |\n            w.RIGHT.FD_FILESTAT_SET_TIMES |\n            w.RIGHT.FD_FILESTAT_SET_SIZE |\n            w.RIGHT.FD_FILESTAT_GET |\n            w.RIGHT.POLL_FD_READWRITE;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "const",
      "name": "base",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to fdflags from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/backend/wasi_poll.zig",
    "response": "const fdflags: w.fdflags_t = w.FDFLAG.SYNC | w.FDFLAG.RSYNC | w.FDFLAG.DSYNC;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/backend/wasi_poll.zig",
      "type": "const",
      "name": "fdflags",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async1.zig",
    "response": "pub fn run(comptime thread_count: comptime_int) !void {\n    if (comptime xev.dynamic) try xev.detect();\n    var loop = try xev.Loop.init(.{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async1.zig",
      "type": "function",
      "name": "run",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to mainAsyncCallback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async1.zig",
    "response": "fn mainAsyncCallback(\n    ud: ?*Thread,\n    _: *xev.Loop,\n    _: *xev.Completion,\n    r: xev.Async.WaitError!void,\n) xev.CallbackAction {\n    _ = r catch unreachable;\n\n    const self = ud.?;\n    self.worker_async.notify() catch unreachable;\n    self.main_sent += 1;\n    self.main_seen += 1;\n\n    return if (self.main_sent >= NUM_PINGS) .disarm else .rearm;\n}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async1.zig",
      "type": "function",
      "name": "mainAsyncCallback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async1.zig",
    "response": "pub fn init() !Thread {\n        return .{\n            .loop = try xev.Loop.init(.{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async1.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to threadMain from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async1.zig",
    "response": "pub fn threadMain(self: *Thread) !void {\n        // Kick us off\n        try self.main_async.notify();\n\n        // Start our waiter\n        var c: xev.Completion = undefined;\n        self.worker_async.wait(&self.loop, &c, Thread, self, asyncCallback);\n\n        // Run\n        try self.loop.run(.until_done);\n        if (self.worker_sent < NUM_PINGS) @panic(\"FAIL\");\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async1.zig",
      "type": "function",
      "name": "threadMain",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to asyncCallback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async1.zig",
    "response": "fn asyncCallback(\n        ud: ?*Thread,\n        _: *xev.Loop,\n        _: *xev.Completion,\n        r: xev.Async.WaitError!void,\n    ) xev.CallbackAction {\n        _ = r catch unreachable;\n        const self = ud.?;\n        self.main_async.notify() catch unreachable;\n        self.worker_sent += 1;\n        self.worker_seen += 1;\n        return if (self.worker_sent >= NUM_PINGS) .disarm else .rearm;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async1.zig",
      "type": "function",
      "name": "asyncCallback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Thread from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async1.zig",
    "response": "const Thread = struct {\n    loop: xev.Loop,\n    worker_async: xev.Async,\n    main_async: xev.Async,\n    worker_sent: usize = 0,\n    worker_seen: usize = 0,\n    main_sent: usize = 0,\n    main_seen: usize = 0,\n\n    pub fn init() !Thread {\n        return .{\n            .loop = try xev.Loop.init(.{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async1.zig",
      "type": "struct",
      "name": "Thread",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to std_options from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async1.zig",
    "response": "pub const std_options: std.Options = .{\n    .log_level = .info,\n};",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async1.zig",
      "type": "const",
      "name": "std_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to std_options from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async2.zig",
    "response": "pub const std_options: std.Options = .{\n    .log_level = .info,\n};",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async2.zig",
      "type": "const",
      "name": "std_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to std_options from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async4.zig",
    "response": "pub const std_options: std.Options = .{\n    .log_level = .info,\n};",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async4.zig",
      "type": "const",
      "name": "std_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to std_options from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async8.zig",
    "response": "pub const std_options: std.Options = .{\n    .log_level = .info,\n};",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async8.zig",
      "type": "const",
      "name": "std_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to run from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async_pummel_1.zig",
    "response": "pub fn run(comptime thread_count: comptime_int) !void {\n    var thread_pool = xev.ThreadPool.init(.{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async_pummel_1.zig",
      "type": "function",
      "name": "run",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to asyncCallback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async_pummel_1.zig",
    "response": "fn asyncCallback(\n    _: ?*void,\n    _: *xev.Loop,\n    _: *xev.Completion,\n    r: xev.Async.WaitError!void,\n) xev.CallbackAction {\n    _ = r catch unreachable;\n\n    callbacks += 1;\n    if (callbacks < NUM_PINGS) return .rearm;\n\n    // We're done\n    state = .stop;\n    while (state != .stopped) std.Thread.sleep(0);\n    return .disarm;\n}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async_pummel_1.zig",
      "type": "function",
      "name": "asyncCallback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to threadMain from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async_pummel_1.zig",
    "response": "fn threadMain() !void {\n    while (state == .running) try notifier.notify();\n    state = .stopped;\n}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async_pummel_1.zig",
      "type": "function",
      "name": "threadMain",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to std_options from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async_pummel_1.zig",
    "response": "pub const std_options: std.Options = .{\n    .log_level = .info,\n};",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async_pummel_1.zig",
      "type": "const",
      "name": "std_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to userdata from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async_pummel_1.zig",
    "response": "const userdata: ?*void = null;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async_pummel_1.zig",
      "type": "const",
      "name": "userdata",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to std_options from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async_pummel_2.zig",
    "response": "pub const std_options: std.Options = .{\n    .log_level = .info,\n};",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async_pummel_2.zig",
      "type": "const",
      "name": "std_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to std_options from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async_pummel_4.zig",
    "response": "pub const std_options: std.Options = .{\n    .log_level = .info,\n};",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async_pummel_4.zig",
      "type": "const",
      "name": "std_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to std_options from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/async_pummel_8.zig",
    "response": "pub const std_options: std.Options = .{\n    .log_level = .info,\n};",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/async_pummel_8.zig",
      "type": "const",
      "name": "std_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/million-timers.zig",
    "response": "pub fn main() !void {\n    var thread_pool = xev.ThreadPool.init(.{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/million-timers.zig",
      "type": "function",
      "name": "main",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to timerCallback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/million-timers.zig",
    "response": "fn timerCallback(\n    _: ?*void,\n    _: *xev.Loop,\n    _: *xev.Completion,\n    result: xev.Timer.RunError!void,\n) xev.CallbackAction {\n    _ = result catch unreachable;\n    timer_callback_count += 1;\n    return .disarm;\n}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/million-timers.zig",
      "type": "function",
      "name": "timerCallback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to NUM_TIMERS from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/million-timers.zig",
    "response": "pub const NUM_TIMERS: usize = 10 * 1000 * 1000;",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/million-timers.zig",
      "type": "const",
      "name": "NUM_TIMERS",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to std_options from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/million-timers.zig",
    "response": "pub const std_options: std.Options = .{\n    .log_level = .info,\n};",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/million-timers.zig",
      "type": "const",
      "name": "std_options",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "pub fn main() !void {\n    var thread_pool = xev.ThreadPool.init(.{}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "main",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "pub fn init(alloc: Allocator, loop: *xev.Loop) !Client {\n        return .{\n            .loop = loop,\n            .completion_pool = CompletionPool.init(alloc),\n            .read_buf = undefined,\n            .pongs = 0,\n            .state = 0,\n            .stop = false,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "pub fn deinit(self: *Client) void {\n        self.completion_pool.deinit();\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to start from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "pub fn start(self: *Client) !void {\n        const addr = try std.net.Address.parseIp4(\"127.0.0.1\", 3131);\n        const socket = try xev.TCP.init(addr);\n\n        const c = try self.completion_pool.create();\n        socket.connect(self.loop, c, addr, Client, self, connectCallback);\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to connectCallback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "fn connectCallback(\n        self_: ?*Client,\n        l: *xev.Loop,\n        c: *xev.Completion,\n        socket: xev.TCP,\n        r: xev.ConnectError!void,\n    ) xev.CallbackAction {\n        _ = r catch unreachable;\n\n        const self = self_.?;\n\n        // Send message\n        socket.write(l, c, .{ .slice = PING[0..PING.len] }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "connectCallback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeCallback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "fn writeCallback(\n        self_: ?*Client,\n        l: *xev.Loop,\n        c: *xev.Completion,\n        s: xev.TCP,\n        b: xev.WriteBuffer,\n        r: xev.WriteError!usize,\n    ) xev.CallbackAction {\n        _ = r catch unreachable;\n        _ = l;\n        _ = s;\n        _ = b;\n\n        // Put back the completion.\n        self_.?.completion_pool.destroy(c);\n        return .disarm;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "writeCallback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to readCallback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "fn readCallback(\n        self_: ?*Client,\n        l: *xev.Loop,\n        c: *xev.Completion,\n        socket: xev.TCP,\n        buf: xev.ReadBuffer,\n        r: xev.ReadError!usize,\n    ) xev.CallbackAction {\n        const self = self_.?;\n        const n = r catch unreachable;\n        const data = buf.slice[0..n];\n\n        // Count the number of pings in our message\n        var i: usize = 0;\n        while (i < n) : (i += 1) {\n            assert(data[i] == PING[self.state]);\n            self.state = (self.state + 1) % (PING.len);\n            if (self.state == 0) {\n                self.pongs += 1;\n\n                // If we're done then exit\n                if (self.pongs > 500_000) {\n                    socket.shutdown(l, c, Client, self, shutdownCallback);\n                    return .disarm;\n                }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "readCallback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to shutdownCallback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "fn shutdownCallback(\n        self_: ?*Client,\n        l: *xev.Loop,\n        c: *xev.Completion,\n        socket: xev.TCP,\n        r: xev.ShutdownError!void,\n    ) xev.CallbackAction {\n        _ = r catch {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "shutdownCallback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to closeCallback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "fn closeCallback(\n        self_: ?*Client,\n        l: *xev.Loop,\n        c: *xev.Completion,\n        socket: xev.TCP,\n        r: xev.CloseError!void,\n    ) xev.CallbackAction {\n        _ = l;\n        _ = socket;\n        _ = r catch unreachable;\n\n        const self = self_.?;\n        self.stop = true;\n        self.completion_pool.destroy(c);\n        return .disarm;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "closeCallback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "pub fn init(alloc: Allocator, loop: *xev.Loop) !Server {\n        return .{\n            .loop = loop,\n            .buffer_pool = BufferPool.init(alloc),\n            .completion_pool = CompletionPool.init(alloc),\n            .socket_pool = TCPPool.init(alloc),\n            .stop = false,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "pub fn deinit(self: *Server) void {\n        self.buffer_pool.deinit();\n        self.completion_pool.deinit();\n        self.socket_pool.deinit();\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to start from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "pub fn start(self: *Server) !void {\n        const addr = try std.net.Address.parseIp4(\"127.0.0.1\", 3131);\n        var socket = try xev.TCP.init(addr);\n\n        const c = try self.completion_pool.create();\n        try socket.bind(addr);\n        try socket.listen(std.os.linux.SOMAXCONN);\n        socket.accept(self.loop, c, Server, self, acceptCallback);\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to threadMain from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "pub fn threadMain(self: *Server) !void {\n        try self.loop.run(.until_done);\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "threadMain",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to destroyBuf from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "fn destroyBuf(self: *Server, buf: []const u8) void {\n        self.buffer_pool.destroy(\n            @alignCast(\n                @as(*[4096]u8, @ptrFromInt(@intFromPtr(buf.ptr))),\n            ),\n        );\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "destroyBuf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to acceptCallback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "fn acceptCallback(\n        self_: ?*Server,\n        l: *xev.Loop,\n        c: *xev.Completion,\n        r: xev.AcceptError!xev.TCP,\n    ) xev.CallbackAction {\n        const self = self_.?;\n\n        // Create our socket\n        const socket = self.socket_pool.create() catch unreachable;\n        socket.* = r catch unreachable;\n\n        // Start reading -- we can reuse c here because its done.\n        const buf = self.buffer_pool.create() catch unreachable;\n        socket.read(l, c, .{ .slice = buf }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "acceptCallback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to readCallback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "fn readCallback(\n        self_: ?*Server,\n        loop: *xev.Loop,\n        c: *xev.Completion,\n        socket: xev.TCP,\n        buf: xev.ReadBuffer,\n        r: xev.ReadError!usize,\n    ) xev.CallbackAction {\n        const self = self_.?;\n        const n = r catch |err| switch (err) {\n            error.EOF => {\n                self.destroyBuf(buf.slice);\n                socket.shutdown(loop, c, Server, self, shutdownCallback);\n                return .disarm;\n            }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "readCallback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to writeCallback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "fn writeCallback(\n        self_: ?*Server,\n        l: *xev.Loop,\n        c: *xev.Completion,\n        s: xev.TCP,\n        buf: xev.WriteBuffer,\n        r: xev.WriteError!usize,\n    ) xev.CallbackAction {\n        _ = l;\n        _ = s;\n        _ = r catch unreachable;\n\n        // We do nothing for write, just put back objects into the pool.\n        const self = self_.?;\n        self.completion_pool.destroy(c);\n        self.buffer_pool.destroy(\n            @alignCast(\n                @as(*[4096]u8, @ptrFromInt(@intFromPtr(buf.slice.ptr))),\n            ),\n        );\n        return .disarm;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "writeCallback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to shutdownCallback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "fn shutdownCallback(\n        self_: ?*Server,\n        l: *xev.Loop,\n        c: *xev.Completion,\n        s: xev.TCP,\n        r: xev.ShutdownError!void,\n    ) xev.CallbackAction {\n        _ = r catch {}",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "shutdownCallback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to closeCallback from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "fn closeCallback(\n        self_: ?*Server,\n        l: *xev.Loop,\n        c: *xev.Completion,\n        socket: xev.TCP,\n        r: xev.CloseError!void,\n    ) xev.CallbackAction {\n        _ = l;\n        _ = r catch unreachable;\n        _ = socket;\n\n        const self = self_.?;\n        self.stop = true;\n        self.completion_pool.destroy(c);\n        return .disarm;\n    }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "function",
      "name": "closeCallback",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Client from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "const Client = struct {\n    loop: *xev.Loop,\n    completion_pool: CompletionPool,\n    read_buf: [1024]u8,\n    pongs: u64,\n    state: usize = 0,\n    stop: bool = false,\n\n    pub const PING = \"PING\\n\";\n\n    pub fn init(alloc: Allocator, loop: *xev.Loop) !Client {\n        return .{\n            .loop = loop,\n            .completion_pool = CompletionPool.init(alloc),\n            .read_buf = undefined,\n            .pongs = 0,\n            .state = 0,\n            .stop = false,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "struct",
      "name": "Client",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Server from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "const Server = struct {\n    loop: *xev.Loop,\n    buffer_pool: BufferPool,\n    completion_pool: CompletionPool,\n    socket_pool: TCPPool,\n    stop: bool,\n\n    pub fn init(alloc: Allocator, loop: *xev.Loop) !Server {\n        return .{\n            .loop = loop,\n            .buffer_pool = BufferPool.init(alloc),\n            .completion_pool = CompletionPool.init(alloc),\n            .socket_pool = TCPPool.init(alloc),\n            .stop = false,\n        }",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "struct",
      "name": "Server",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to std_options from mitchellh/libxev",
    "context": "Repository: mitchellh/libxev (3095 ⭐)\nFile: src/bench/ping-pongs.zig",
    "response": "pub const std_options: std.Options = .{\n    .log_level = .info,\n};",
    "metadata": {
      "repo": "mitchellh/libxev",
      "stars": 3095,
      "file": "src/bench/ping-pongs.zig",
      "type": "const",
      "name": "std_options",
      "difficulty": "easy"
    }
  }
]