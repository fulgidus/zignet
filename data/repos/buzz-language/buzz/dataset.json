[
  {
    "instruction": "Write a Zig function similar to step from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "pub fn step(self: @This(), b: *Build) *Build.Module {\n        var options = b.addOptions();\n        options.addOption(@TypeOf(self.version), \"version\", self.version);\n        options.addOption(@TypeOf(self.sha), \"sha\", self.sha);\n        options.addOption(@TypeOf(self.mimalloc), \"mimalloc\", self.mimalloc);\n        options.addOption(@TypeOf(self.cycle_limit), \"cycle_limit\", self.cycle_limit);\n        options.addOption(@TypeOf(self.recursive_call_limit), \"recursive_call_limit\", self.recursive_call_limit);\n        options.addOption(@TypeOf(self.stack_size), \"stack_size\", self.stack_size);\n\n        self.debug.step(options);\n        self.gc.step(options);\n        self.jit.step(options);\n\n        return options.createModule();\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "function",
      "name": "step",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to needLibC from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "pub fn needLibC(self: @This()) bool {\n        return !self.target.result.cpu.arch.isWasm();\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "function",
      "name": "needLibC",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to step from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "pub fn step(self: DebugOptions, options: *Build.Step.Options) void {\n            options.addOption(@TypeOf(self.debug), \"debug\", self.debug);\n            options.addOption(@TypeOf(self.stack), \"debug_stack\", self.stack);\n            options.addOption(@TypeOf(self.current_instruction), \"debug_current_instruction\", self.current_instruction);\n            options.addOption(@TypeOf(self.perf), \"show_perf\", self.perf);\n            options.addOption(@TypeOf(self.stop_on_report), \"stop_on_report\", self.stop_on_report);\n            options.addOption(@TypeOf(self.placeholders), \"debug_placeholders\", self.placeholders);\n            options.addOption(@TypeOf(self.type_registry), \"debug_type_registry\", self.type_registry);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "function",
      "name": "step",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to step from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "pub fn step(self: JITOptions, options: *Build.Step.Options) void {\n            options.addOption(@TypeOf(self.debug), \"jit_debug\", self.debug);\n            options.addOption(@TypeOf(self.always_on), \"jit_always_on\", self.always_on);\n            options.addOption(@TypeOf(self.hotspot_always_on), \"jit_hotspot_always_on\", self.hotspot_always_on);\n            options.addOption(@TypeOf(self.on), \"jit\", self.on);\n            options.addOption(@TypeOf(self.prof_threshold), \"jit_prof_threshold\", self.prof_threshold);\n            options.addOption(@TypeOf(self.hotspot_on), \"jit_hotspot_on\", self.hotspot_on);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "function",
      "name": "step",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to step from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "pub fn step(self: GCOptions, options: *Build.Step.Options) void {\n            options.addOption(@TypeOf(self.debug), \"gc_debug\", self.debug);\n            options.addOption(@TypeOf(self.debug_light), \"gc_debug_light\", self.debug_light);\n            options.addOption(@TypeOf(self.debug_access), \"gc_debug_access\", self.debug_access);\n            options.addOption(@TypeOf(self.on), \"gc\", self.on);\n            options.addOption(@TypeOf(self.initial_gc), \"initial_gc\", self.initial_gc);\n            options.addOption(@TypeOf(self.next_gc_ratio), \"next_gc_ratio\", self.next_gc_ratio);\n            options.addOption(@TypeOf(self.next_full_gc_ratio), \"next_full_gc_ratio\", self.next_full_gc_ratio);\n            options.addOption(@TypeOf(self.memory_limit), \"memory_limit\", self.memory_limit);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "function",
      "name": "step",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to build from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "pub fn build(b: *Build) !void {\n    var envMap = try std.process.getEnvMap(b.allocator);\n    defer envMap.deinit();\n\n    // Check minimum zig version\n    const current_zig = builtin.zig_version;\n    const min_zig = std.SemanticVersion.parse(\"0.15.1\") catch return;\n    if (current_zig.order(min_zig).compare(.lt)) {\n        @panic(b.fmt(\"Your Zig version v{f}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "function",
      "name": "build",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildPcre2 from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "pub fn buildPcre2(b: *Build, target: Build.ResolvedTarget, optimize: std.builtin.OptimizeMode) !*Build.Step.Compile {\n    const copyFiles = b.addWriteFiles();\n    _ = copyFiles.addCopyFile(\n        b.path(\"vendors/pcre2/src/config.h.generic\"),\n        \"vendors/pcre2/src/config.h\",\n    );\n    _ = copyFiles.addCopyFile(\n        b.path(\"vendors/pcre2/src/pcre2.h.generic\"),\n        \"vendors/pcre2/src/pcre2.h\",\n    );\n    _ = copyFiles.addCopyFile(\n        b.path(\"vendors/pcre2/src/pcre2_chartables.c.dist\"),\n        \"vendors/pcre2/src/pcre2_chartables.c\",\n    );\n\n    const flags: []const []const u8 = &.{\n        \"-std=c99\",\n        \"-DHAVE_CONFIG_H\",\n        \"-DPCRE2_CODE_UNIT_WIDTH=8\",\n        \"-DPCRE2_STATIC\",\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "function",
      "name": "buildPcre2",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildMimalloc from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "pub fn buildMimalloc(b: *Build, target: Build.ResolvedTarget, optimize: std.builtin.OptimizeMode) !*Build.Step.Compile {\n    const lib = b.addLibrary(\n        .{\n            .name = \"mimalloc\",\n            .linkage = .static,\n            .use_llvm = true,\n            .root_module = b.createModule(\n                .{\n                    .target = target,\n                    .optimize = optimize,\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "function",
      "name": "buildMimalloc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildLinenoise from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "pub fn buildLinenoise(b: *Build, target: Build.ResolvedTarget, optimize: std.builtin.OptimizeMode) !*Build.Step.Compile {\n    const lib = b.addLibrary(\n        .{\n            .name = \"linenoise\",\n            .linkage = .static,\n            .use_llvm = true,\n            .root_module = b.createModule(\n                .{\n                    .target = target,\n                    .optimize = optimize,\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "function",
      "name": "buildLinenoise",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildWasmReplDemo from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "pub fn buildWasmReplDemo(b: *Build, exe: *Build.Step.Compile) void {\n    const npm_install = b.addSystemCommand(\n        &.{ \"npm\", \"i\" }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "function",
      "name": "buildWasmReplDemo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildMir from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "pub fn buildMir(b: *Build, target: Build.ResolvedTarget, optimize: std.builtin.OptimizeMode) !*Build.Step.Compile {\n    const lib = b.addLibrary(\n        .{\n            .name = \"mir\",\n            .linkage = .static,\n            .use_llvm = true,\n            .root_module = b.createModule(\n                .{\n                    .target = target,\n                    .optimize = optimize,\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "function",
      "name": "buildMir",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to BuildOptions from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "const BuildOptions = struct {\n    version: std.SemanticVersion,\n    sha: []const u8,\n    mimalloc: bool,\n    debug: DebugOptions,\n    gc: GCOptions,\n    jit: JITOptions,\n    target: Build.ResolvedTarget,\n    cycle_limit: ?u128,\n    recursive_call_limit: ?u32,\n    stack_size: usize = 100_000,\n\n    pub fn step(self: @This(), b: *Build) *Build.Module {\n        var options = b.addOptions();\n        options.addOption(@TypeOf(self.version), \"version\", self.version);\n        options.addOption(@TypeOf(self.sha), \"sha\", self.sha);\n        options.addOption(@TypeOf(self.mimalloc), \"mimalloc\", self.mimalloc);\n        options.addOption(@TypeOf(self.cycle_limit), \"cycle_limit\", self.cycle_limit);\n        options.addOption(@TypeOf(self.recursive_call_limit), \"recursive_call_limit\", self.recursive_call_limit);\n        options.addOption(@TypeOf(self.stack_size), \"stack_size\", self.stack_size);\n\n        self.debug.step(options);\n        self.gc.step(options);\n        self.jit.step(options);\n\n        return options.createModule();\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "struct",
      "name": "BuildOptions",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to DebugOptions from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "const DebugOptions = struct {\n        debug: bool,\n        stack: bool,\n        current_instruction: bool,\n        perf: bool,\n        stop_on_report: bool,\n        placeholders: bool,\n        type_registry: bool,\n\n        pub fn step(self: DebugOptions, options: *Build.Step.Options) void {\n            options.addOption(@TypeOf(self.debug), \"debug\", self.debug);\n            options.addOption(@TypeOf(self.stack), \"debug_stack\", self.stack);\n            options.addOption(@TypeOf(self.current_instruction), \"debug_current_instruction\", self.current_instruction);\n            options.addOption(@TypeOf(self.perf), \"show_perf\", self.perf);\n            options.addOption(@TypeOf(self.stop_on_report), \"stop_on_report\", self.stop_on_report);\n            options.addOption(@TypeOf(self.placeholders), \"debug_placeholders\", self.placeholders);\n            options.addOption(@TypeOf(self.type_registry), \"debug_type_registry\", self.type_registry);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "struct",
      "name": "DebugOptions",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to JITOptions from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "const JITOptions = struct {\n        on: bool,\n        always_on: bool,\n        hotspot_always_on: bool,\n        hotspot_on: bool,\n        debug: bool,\n        prof_threshold: f128 = 0.05,\n\n        pub fn step(self: JITOptions, options: *Build.Step.Options) void {\n            options.addOption(@TypeOf(self.debug), \"jit_debug\", self.debug);\n            options.addOption(@TypeOf(self.always_on), \"jit_always_on\", self.always_on);\n            options.addOption(@TypeOf(self.hotspot_always_on), \"jit_hotspot_always_on\", self.hotspot_always_on);\n            options.addOption(@TypeOf(self.on), \"jit\", self.on);\n            options.addOption(@TypeOf(self.prof_threshold), \"jit_prof_threshold\", self.prof_threshold);\n            options.addOption(@TypeOf(self.hotspot_on), \"jit_hotspot_on\", self.hotspot_on);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "struct",
      "name": "JITOptions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to GCOptions from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "const GCOptions = struct {\n        debug: bool,\n        debug_light: bool,\n        debug_access: bool,\n        on: bool,\n        initial_gc: usize,\n        next_gc_ratio: usize,\n        next_full_gc_ratio: usize,\n        memory_limit: ?usize,\n\n        pub fn step(self: GCOptions, options: *Build.Step.Options) void {\n            options.addOption(@TypeOf(self.debug), \"gc_debug\", self.debug);\n            options.addOption(@TypeOf(self.debug_light), \"gc_debug_light\", self.debug_light);\n            options.addOption(@TypeOf(self.debug_access), \"gc_debug_access\", self.debug_access);\n            options.addOption(@TypeOf(self.on), \"gc\", self.on);\n            options.addOption(@TypeOf(self.initial_gc), \"initial_gc\", self.initial_gc);\n            options.addOption(@TypeOf(self.next_gc_ratio), \"next_gc_ratio\", self.next_gc_ratio);\n            options.addOption(@TypeOf(self.next_full_gc_ratio), \"next_full_gc_ratio\", self.next_full_gc_ratio);\n            options.addOption(@TypeOf(self.memory_limit), \"memory_limit\", self.memory_limit);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "struct",
      "name": "GCOptions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Lib from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "const Lib = struct {\n            path: ?[]const u8 = null,\n            name: []const u8,\n            wasm_compatible: bool = true,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "struct",
      "name": "Lib",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to flags from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: build.zig",
    "response": "const flags: []const []const u8 = &.{\n        \"-std=c99\",\n        \"-DHAVE_CONFIG_H\",\n        \"-DPCRE2_CODE_UNIT_WIDTH=8\",\n        \"-DPCRE2_STATIC\",\n    };",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "build.zig",
      "type": "const",
      "name": "flags",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to processNode from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "fn processNode(ctx: @TypeOf(ctx), allocator: std.mem.Allocator, ast: Ast.Slice, node: Node.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "processNode",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to walk from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub fn walk(self: Slice, allocator: std.mem.Allocator, ctx: anytype, root: Node.Index) !void {\n        const tags = self.nodes.items(.tag);\n        const components = self.nodes.items(.components);\n\n        // Hold previous node's leaves\n        var node_queue = std.ArrayList(Node.Index){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "walk",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to processNode from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub fn processNode(self: *UsesFiberContext, _: std.mem.Allocator, ast: Self.Slice, node: Self.Node.Index) (std.mem.Allocator.Error || std.fmt.BufPrintError)!bool {\n            switch (ast.nodes.items(.tag)[node]) {\n                .AsyncCall,\n                .Resolve,\n                .Resume,\n                .Yield,\n                => {\n                    self.result = true;\n                    return true;\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "processNode",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to usesFiber from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub fn usesFiber(self: Self.Slice, allocator: std.mem.Allocator, node: Node.Index) !bool {\n        var ctx = UsesFiberContext{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "usesFiber",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to processNode from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub fn processNode(self: *IsConstantContext, _: std.mem.Allocator, ast: Self.Slice, node: Self.Node.Index) (std.mem.Allocator.Error || std.fmt.BufPrintError)!bool {\n            switch (ast.nodes.items(.tag)[node]) {\n                .AnonymousObjectType,\n                .FiberType,\n                .FunctionType,\n                .GenericResolveType,\n                .GenericType,\n                .ListType,\n                .MapType,\n                .SimpleType,\n                .UserType,\n                .Boolean,\n                .Integer,\n                .Double,\n                .Pattern,\n                .Null,\n                .StringLiteral,\n                .TypeExpression,\n                .Void,\n                .Namespace,\n                => self.result = self.result == null or self.result.?,\n\n                .AsyncCall,\n                .Block,\n                .Break,\n                .Continue,\n                .Call,\n                .DoUntil,\n                .Enum,\n                .Export,\n                .For,\n                .ForEach,\n                .Function,\n                .FunDeclaration,\n                .Import,\n                .NamedVariable,\n                .ObjectDeclaration,\n                .ObjectInit,\n                .ProtocolDeclaration,\n                .Resolve,\n                .Resume,\n                .Return,\n                .Try,\n                .Throw,\n                .VarDeclaration,\n                .While,\n                .Yield,\n                .Zdef,\n                .BlockExpression,\n                .Out,\n                => {\n                    self.result = false;\n                    return true;\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "processNode",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to isConstant from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub fn isConstant(self: Self.Slice, allocator: std.mem.Allocator, node: Node.Index) !bool {\n        var ctx = IsConstantContext{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "isConstant",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to binaryValue from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "fn binaryValue(self: Self.Slice, node: Node.Index, gc: *GC) !?Value {\n        const components = self.nodes.items(.components)[node].Binary;\n\n        const left = try self.toValue(components.left, gc);\n        const left_integer = if (left.isInteger()) left.integer() else null;\n        const left_float = if (left.isDouble()) left.double() else null;\n        const right = try self.toValue(components.right, gc);\n        const right_integer = if (right.isInteger()) right.integer() else null;\n        const right_float = if (right.isDouble()) right.double() else null;\n\n        switch (components.operator) {\n            .Ampersand => return Value.fromInteger(left_integer.? & right_integer.?),\n            .Bor => return Value.fromInteger(left_integer.? | right_integer.?),\n            .Xor => return Value.fromInteger(left_integer.? ^ right_integer.?),\n            .ShiftLeft => {\n                const b = right_integer.?;\n\n                if (b < 0) {\n                    if (b * -1 > std.math.maxInt(u6)) {\n                        return Value.fromInteger(0);\n                    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "binaryValue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toValue from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub fn toValue(self: Self.Slice, node: Node.Index, gc: *GC) Error!Value {\n        const value = &self.nodes.items(.value)[node];\n\n        if (value.* == null and try self.isConstant(gc.allocator, node)) {\n            value.* = switch (self.nodes.items(.tag)[node]) {\n                .AnonymousObjectType,\n                .FiberType,\n                .FunctionType,\n                .GenericResolveType,\n                .GenericType,\n                .ListType,\n                .MapType,\n                .SimpleType,\n                .UserType,\n                => self.nodes.items(.type_def)[node].?.toValue(),\n                .StringLiteral => self.nodes.items(.components)[node].StringLiteral.literal.toValue(),\n                .TypeOfExpression => (try (try self.toValue(\n                    self.nodes.items(.components)[node].TypeOfExpression,\n                    gc,\n                )).typeOf(gc)).toValue(),\n                .TypeExpression => self.nodes.items(.type_def)[self.nodes.items(.components)[node].TypeExpression].?.toValue(),\n                .Pattern => self.nodes.items(.components)[node].Pattern.toValue(),\n                .Void => Value.Void,\n                .Null => Value.Null,\n                .Double => Value.fromDouble(self.nodes.items(.components)[node].Double),\n                .Integer => Value.fromInteger(self.nodes.items(.components)[node].Integer),\n                .Boolean => Value.fromBoolean(self.nodes.items(.components)[node].Boolean),\n                .As => try self.toValue(self.nodes.items(.components)[node].As.left, gc),\n                .Is => is: {\n                    const components = self.nodes.items(.components)[node].Is;\n                    break :is Value.fromBoolean(\n                        (try self.toValue(components.constant, gc))\n                            .is(try self.toValue(components.left, gc)),\n                    );\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "toValue",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub fn init(allocator: std.mem.Allocator) Self {\n    return .{\n        .allocator = allocator,\n        .tokens = TokenList{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub fn deinit(self: *Self, allocator: std.mem.Allocator) void {\n    self.tokens.deinit(allocator);\n    self.nodes.deinit(allocator);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to slice from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub fn slice(self: Self) Slice {\n    return .{\n        .tokens = self.tokens.slice(),\n        .nodes = self.nodes.slice(),\n        .root = self.root,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "slice",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to appendNode from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "fn appendNode(self: *Self, node: Node) !Node.Index {\n    try self.nodes.append(self.allocator, node);\n\n    return @intCast(self.nodes.len - 1);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "appendNode",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to appendToken from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "fn appendToken(self: *Self, token: Token) !TokenIndex {\n    // if (token.tag == .Semicolon and self.tokens.items(.tag)[self.tokens.len - 1] == .Semicolon) {\n    //     unreachable;\n    // }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "appendToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to swapNodes from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub fn swapNodes(self: *Self, from: Node.Index, to: Node.Index) void {\n    const from_node = self.nodes.get(from);\n    const to_node = self.nodes.get(to);\n\n    self.nodes.set(from, to_node);\n    self.nodes.set(to, from_node);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "swapNodes",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub fn deinit(self: *Node, allocator: std.mem.Allocator) void {\n        if (self.ends_scope) |ends_scope| {\n            allocator.free(ends_scope);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isHotspot from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub fn isHotspot(self: Tag) bool {\n            return switch (self) {\n                .While,\n                .For,\n                .ForEach,\n                => true,\n                else => false,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "isHotspot",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub fn deinit(self: Components, allocator: std.mem.Allocator) void {\n            switch (self) {\n                .AnonymousObjectType => allocator.free(self.AnonymousObjectType.fields),\n                .Block => allocator.free(self.Block),\n                .BlockExpression => allocator.free(self.BlockExpression),\n                .Call => allocator.free(self.Call.arguments),\n                .Enum => allocator.free(self.Enum.cases),\n                .Export => if (self.Export.name) |name| allocator.free(name) else void,\n                .For => {\n                    allocator.free(self.For.init_declarations);\n                    allocator.free(self.For.post_loop);\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nextId from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub fn nextId() usize {\n        Function.next_id += 1;\n\n        return Function.next_id;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "function",
      "name": "nextId",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Slice from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Slice = struct {\n    tokens: TokenList.Slice,\n    nodes: NodeList.Slice,\n    root: ?Node.Index,\n\n    /// Do a breadth first walk of the AST, calling a callback for each node that can stop the walking from going deeper by returning true\n    /// ctx should have:\n    /// - `fn processNode(ctx: @TypeOf(ctx), allocator: std.mem.Allocator, ast: Ast.Slice, node: Node.Index) error{OutOfMemory}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Slice",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to UsesFiberContext from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "const UsesFiberContext = struct {\n        result: bool = false,\n\n        pub fn processNode(self: *UsesFiberContext, _: std.mem.Allocator, ast: Self.Slice, node: Self.Node.Index) (std.mem.Allocator.Error || std.fmt.BufPrintError)!bool {\n            switch (ast.nodes.items(.tag)[node]) {\n                .AsyncCall,\n                .Resolve,\n                .Resume,\n                .Yield,\n                => {\n                    self.result = true;\n                    return true;\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "UsesFiberContext",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Node from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Node = struct {\n    tag: Tag,\n    /// First token of this node\n    location: TokenIndex,\n    /// Last token of this node\n    end_location: TokenIndex,\n    /// Docblock if any\n    docblock: ?TokenIndex = null,\n\n    /// If null, either its a statement or its a reference to something unknown that should ultimately raise a compile error\n    type_def: ?*obj.ObjTypeDef = null,\n    /// Wether optional jumps must be patch before generate this node bytecode\n    patch_opt_jumps: bool = false,\n    /// Does this node closes a scope\n    ends_scope: ?[]const Chunk.OpCode = null,\n\n    /// Data related to this node\n    components: Components,\n\n    /// To avoid generating a node const value multiple times\n    value: ?Value = null,\n\n    /// How many time it was visited at runtime (used to decide wether its a hotspot that needs to be compiled)\n    count: usize = 0,\n\n    /// Wether its blacklisted or already compiled\n    compilable: bool = true,\n\n    pub fn deinit(self: *Node, allocator: std.mem.Allocator) void {\n        if (self.ends_scope) |ends_scope| {\n            allocator.free(ends_scope);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Node",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to AnonymousObjectType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const AnonymousObjectType = struct {\n    fields: []const Field,\n\n    pub const Field = struct {\n        name: TokenIndex,\n        type: Node.Index,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "AnonymousObjectType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Binary from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Binary = struct {\n    left: Node.Index,\n    right: Node.Index,\n    operator: Token.Type,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Binary",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to BreakContinue from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const BreakContinue = struct {\n    label: ?TokenIndex,\n    destination: ?Node.Index,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "BreakContinue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Call from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Call = struct {\n    is_async: bool,\n    callee: Node.Index,\n    // We need this because in a dot.call, callee is dot and its type will be == to call return type\n    callee_type_def: *obj.ObjTypeDef,\n    arguments: []const Argument,\n    catch_default: ?Node.Index,\n    tail_call: bool = false,\n\n    pub const Argument = struct {\n        name: ?TokenIndex,\n        value: Node.Index,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Call",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Dot from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Dot = struct {\n    pub const MemberKind = enum {\n        Ref,\n        Value,\n        Call,\n        EnumCase,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Dot",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Enum from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Enum = struct {\n    name: TokenIndex,\n    case_type: ?Node.Index,\n    slot: Slot,\n    cases: []const Case,\n    values_omitted: bool,\n\n    pub const Case = struct {\n        name: TokenIndex,\n        docblock: ?TokenIndex,\n        value: ?Node.Index,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Enum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Export from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Export = struct {\n    name: ?[]const TokenIndex,\n    alias: ?TokenIndex,\n    declaration: ?Node.Index,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Export",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FiberType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const FiberType = struct {\n    return_type: Node.Index,\n    yield_type: Node.Index,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "FiberType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to For from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const For = struct {\n    init_declarations: []const Node.Index,\n    condition: Node.Index,\n    post_loop: []const Node.Index,\n    body: Node.Index,\n    label: ?TokenIndex,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "For",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ForEach from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const ForEach = struct {\n    iterable: Node.Index,\n    key: Node.Index,\n    value: Node.Index,\n    body: Node.Index,\n    key_omitted: bool,\n    label: ?TokenIndex,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "ForEach",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Function from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Function = struct {\n    var next_id: usize = 0;\n\n    pub fn nextId() usize {\n        Function.next_id += 1;\n\n        return Function.next_id;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Function",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Entry from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Entry = struct {\n        main_slot: ?usize = null,\n        push_cli_args: bool = false,\n        main_location: ?TokenIndex = null,\n        test_slots: []const usize,\n        test_locations: []const TokenIndex,\n        exported_count: usize = 0,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Entry",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FunctionType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const FunctionType = struct {\n    is_signature: bool,\n    name: ?TokenIndex,\n    return_type: ?Node.Index,\n    yield_type: ?Node.Index,\n    error_types: []const Node.Index,\n    arguments: []const Argument,\n    /// If the struct is use as the function signature, this is a list of nodes otherwise its a list of tokens\n    /// Since `TokenIndex` and `Node.Index` are actually the same type, we don't make this any more complicated\n    generic_types: []const TokenIndex,\n    lambda: bool,\n\n    pub const Argument = struct {\n        name: TokenIndex,\n        type: Node.Index,\n        default: ?Node.Index,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "FunctionType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to GenericResolve from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const GenericResolve = struct {\n    expression: Node.Index,\n    resolved_types: []const Node.Index,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "GenericResolve",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to FunDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const FunDeclaration = struct {\n    function: Node.Index,\n\n    slot: Slot,\n    slot_type: SlotType,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "FunDeclaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to If from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const If = struct {\n    condition: Node.Index,\n    unwrapped_identifier: ?TokenIndex,\n    casted_type: ?Node.Index,\n    body: Node.Index,\n    else_branch: ?Node.Index,\n    is_statement: bool,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "If",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Import from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Import = struct {\n    imported_symbols: []const TokenIndex,\n    prefix: ?[]const TokenIndex,\n    path: TokenIndex,\n    import: ?Parser.ScriptImport,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Import",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to IsAs from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const IsAs = struct {\n    left: Node.Index,\n    constant: Node.Index,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "IsAs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to List from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const List = struct {\n    explicit_item_type: ?Node.Index,\n    items: []const Node.Index,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "List",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Map from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Map = struct {\n    explicit_key_type: ?Node.Index,\n    explicit_value_type: ?Node.Index,\n\n    entries: []const Entry,\n\n    pub const Entry = struct {\n        key: Node.Index,\n        value: Node.Index,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Map",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to MapType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const MapType = struct {\n    key_type: Node.Index,\n    value_type: Node.Index,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "MapType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to NamedVariable from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const NamedVariable = struct {\n    name: []const TokenIndex,\n    definition: Node.Index,\n    value: ?Node.Index,\n    assign_token: ?TokenIndex,\n    slot: Slot,\n    slot_type: SlotType,\n    slot_final: bool,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "NamedVariable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ObjectDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const ObjectDeclaration = struct {\n    name: TokenIndex,\n    slot: Slot,\n    protocols: []const Node.Index,\n    generics: []const TokenIndex,\n    // List of either Function (methods) or VarDeclaration (properties)\n    members: []const Member,\n\n    pub const Member = struct {\n        name: TokenIndex,\n        docblock: ?TokenIndex,\n        method: bool,\n        method_or_default_value: ?Node.Index,\n        property_type: ?Node.Index,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "ObjectDeclaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ObjectInit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const ObjectInit = struct {\n    object: ?Node.Index, // Should be a NamedVariableNode or GenericResolve\n    properties: []const Property,\n\n    pub const Property = struct {\n        name: TokenIndex,\n        value: Node.Index,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "ObjectInit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ProtocolDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const ProtocolDeclaration = struct {\n    name: TokenIndex,\n    slot: Slot,\n    methods: []const Method,\n\n    pub const Method = struct {\n        docblock: ?TokenIndex,\n        method: Node.Index,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "ProtocolDeclaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Range from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Range = struct {\n    low: Node.Index,\n    high: Node.Index,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Range",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Return from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Return = struct {\n    value: ?Node.Index,\n    unconditional: bool,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Return",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to StringLiteral from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const StringLiteral = struct {\n    delimiter: u8,\n    literal: *obj.ObjString,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "StringLiteral",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Subscript from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Subscript = struct {\n    subscripted: Node.Index,\n    index: Node.Index,\n    value: ?Node.Index,\n    checked: bool,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Subscript",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Throw from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Throw = struct {\n    expression: Node.Index,\n    unconditional: bool,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Throw",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Try from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Try = struct {\n    body: Node.Index,\n    clauses: []const Clause,\n    unconditional_clause: ?Node.Index,\n\n    pub const Clause = struct {\n        identifier: TokenIndex,\n\n        type_def: Node.Index,\n        body: Node.Index,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Try",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Unary from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Unary = struct {\n    operator: Token.Type,\n    expression: Node.Index,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Unary",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Unwrap from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Unwrap = struct {\n    unwrapped: Node.Index,\n    original_type: *obj.ObjTypeDef,\n    start_opt_jumps: bool,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Unwrap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to UserType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const UserType = struct {\n    name: []const TokenIndex,\n    generic_resolve: ?Node.Index,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "UserType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to VarDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const VarDeclaration = struct {\n    name: TokenIndex,\n    value: ?Node.Index,\n    type: ?Node.Index,\n    final: bool,\n    omits_qualifier: bool,\n    slot: Slot,\n    slot_type: SlotType,\n    implicit: bool,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "VarDeclaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to WhileDoUntil from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const WhileDoUntil = struct {\n    condition: Node.Index,\n    body: Node.Index,\n    label: ?TokenIndex,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "WhileDoUntil",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Zdef from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "pub const Zdef = struct {\n    lib_name: TokenIndex,\n    source: TokenIndex,\n    elements: []ZdefElement,\n\n    pub const ZdefElement = struct {\n        fn_ptr: ?*anyopaque = null,\n        obj_native: ?*obj.ObjNative = null,\n        // TODO: On the stack, do we free it at some point?\n        zdef: *const FFI.Zdef,\n        slot: Slot,\n        // TODO: add TokenIndex which should wrap portion of the zdef string relative to this element\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "struct",
      "name": "Zdef",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to index from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "const index: usize = @intCast(key.integer());",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "const",
      "name": "index",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to index from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Ast.zig",
    "response": "const index: usize = @intCast(key.integer());",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Ast.zig",
      "type": "const",
      "name": "index",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hash from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Chunk.zig",
    "response": "pub fn hash(_: RegistryContext, key: Self) u64 {\n        return std.hash.Wyhash.hash(\n            0,\n            std.mem.sliceAsBytes(key.code.items),\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Chunk.zig",
      "type": "function",
      "name": "hash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Chunk.zig",
    "response": "pub fn eql(_: RegistryContext, a: Self, b: Self) bool {\n        return std.mem.eql(u32, a.code.items, b.code.items) and\n            std.mem.eql(Value, a.constants.items, b.constants.items);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Chunk.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to HashMap from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Chunk.zig",
    "response": "pub fn HashMap(V: type) type {\n    return std.HashMapUnmanaged(\n        Self,\n        V,\n        RegistryContext,\n        std.hash_map.default_max_load_percentage,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Chunk.zig",
      "type": "function",
      "name": "HashMap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Chunk.zig",
    "response": "pub fn init(allocator: std.mem.Allocator, ast: Ast.Slice) Self {\n    return Self{\n        .allocator = allocator,\n        .ast = ast,\n        .code = .{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Chunk.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Chunk.zig",
    "response": "pub fn deinit(self: *Self) void {\n    self.code.deinit(self.allocator);\n    self.constants.deinit(self.allocator);\n    self.lines.deinit(self.allocator);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Chunk.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to write from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Chunk.zig",
    "response": "pub fn write(self: *Self, code: u32, where: Ast.TokenIndex) !void {\n    try self.code.append(self.allocator, code);\n    try self.lines.append(self.allocator, where);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Chunk.zig",
      "type": "function",
      "name": "write",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to addConstant from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Chunk.zig",
    "response": "pub fn addConstant(self: *Self, vm: ?*VM, value: Value) !u24 {\n    if (vm) |uvm| uvm.push(value);\n    try self.constants.append(self.allocator, value);\n    if (vm) |uvm| _ = uvm.pop();\n\n    return @intCast(self.constants.items.len - 1);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Chunk.zig",
      "type": "function",
      "name": "addConstant",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to RegistryContext from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Chunk.zig",
    "response": "const RegistryContext = struct {\n    pub fn hash(_: RegistryContext, key: Self) u64 {\n        return std.hash.Wyhash.hash(\n            0,\n            std.mem.sliceAsBytes(key.code.items),\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Chunk.zig",
      "type": "struct",
      "name": "RegistryContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn deinit(self: *Frame, allocator: std.mem.Allocator) void {\n        self.constants.deinit(allocator);\n        if (self.try_should_handle) |*handle| {\n            handle.deinit(allocator);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn init(\n    gc: *GC,\n    parser: *Parser,\n    flavor: RunFlavor,\n    jit: ?*JIT,\n) Self {\n    return .{\n        .gc = gc,\n        .parser = parser,\n        .flavor = flavor,\n        .reporter = Reporter{\n            .allocator = gc.allocator,\n            .error_prefix = \"Compile\",\n            .collect = flavor == .Ast,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn deinit(self: *Self) void {\n    self.reporter.deinit();\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to currentCode from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn currentCode(self: *Self) usize {\n    return self.current.?.function.?.chunk.code.items.len;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "currentCode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generate from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn generate(self: *Self, ast: Ast.Slice) Error!?*obj.ObjFunction {\n    self.ast = ast;\n    self.reporter.last_error = null;\n    self.reporter.panic_mode = false;\n\n    const function = self.generateNode(self.ast.root.?, null);\n\n    return if (self.reporter.last_error != null) null else function;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generate",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to emit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn emit(self: *Self, location: Ast.TokenIndex, code: u32) !void {\n    try self.current.?.function.?.chunk.write(code, location);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "emit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to emitTwo from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn emitTwo(self: *Self, location: Ast.TokenIndex, a: u8, b: u24) !void {\n    try self.emit(location, (@as(u32, @intCast(a)) << 24) | @as(u32, @intCast(b)));\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "emitTwo",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to emitCodeArg from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn emitCodeArg(self: *Self, location: Ast.TokenIndex, code: Chunk.OpCode, arg: u24) !void {\n    try self.emit(\n        location,\n        (@as(u32, @intCast(@intFromEnum(code))) << 24) | @as(u32, @intCast(arg)),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "emitCodeArg",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to emitCodeArgs from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn emitCodeArgs(self: *Self, location: Ast.TokenIndex, code: Chunk.OpCode, a: u8, b: u16) !void {\n    try self.emit(\n        location,\n        (@as(u32, @intCast(@intFromEnum(code))) << 24) | (@as(u32, @intCast(a)) << 16) | (@as(u32, @intCast(b))),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "emitCodeArgs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to emitOpCode from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn emitOpCode(self: *Self, location: Ast.TokenIndex, code: Chunk.OpCode) !void {\n    try self.emit(location, @as(u32, @intCast(@intFromEnum(code))) << 24);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "emitOpCode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to emitLoop from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn emitLoop(self: *Self, location: Ast.TokenIndex, loop_start: usize) !void {\n    const offset: usize = self.currentCode() - loop_start + 1;\n    if (offset > std.math.maxInt(u24)) {\n        self.reportError(.loop_body_too_large, \"Loop body too large.\");\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "emitLoop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to emitJump from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn emitJump(self: *Self, location: Ast.TokenIndex, instruction: Chunk.OpCode) !usize {\n    try self.emitCodeArg(location, instruction, 0xffffff);\n\n    return self.currentCode() - 1;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "emitJump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to patchJumpOrLoop from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn patchJumpOrLoop(self: *Self, offset: usize, loop_start: ?usize) !void {\n    const original = self.current.?.function.?.chunk.code.items[offset];\n    const instruction: u8 = @intCast(original >> 24);\n    const code: Chunk.OpCode = @enumFromInt(instruction);\n\n    if (code == .OP_LOOP) { // Patching a continue statement\n        std.debug.assert(loop_start != null);\n        const loop_offset: usize = offset - loop_start.? + 1;\n        if (loop_offset > std.math.maxInt(u24)) {\n            self.reportError(.loop_body_too_large, \"Loop body too large.\");\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "patchJumpOrLoop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to patchBreaks from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn patchBreaks(self: *Self, breaks: *Breaks, previous_breaks: ?*Breaks, loop_node: Ast.Node.Index, loop_start: usize) !void {\n    for (breaks.items) |brk| {\n        if (brk.label_node == null or brk.label_node.? == loop_node) {\n            try self.patchJumpOrLoop(brk.ip, loop_start);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "patchBreaks",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to patchJump from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn patchJump(self: *Self, offset: usize) void {\n    std.debug.assert(offset < self.currentCode());\n\n    const jump = self.currentCode() - offset - 1;\n\n    if (jump > std.math.maxInt(u24)) {\n        self.reportError(.jump_too_large, \"Jump too large.\");\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "patchJump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to patchTryOrJit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn patchTryOrJit(self: *Self, offset: usize) void {\n    std.debug.assert(offset < self.currentCode());\n\n    const jump = self.currentCode();\n\n    if (jump > std.math.maxInt(u24)) {\n        self.reportError(\n            .block_too_large,\n            \"Try block too large.\",\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "patchTryOrJit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to emitReturn from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn emitReturn(self: *Self, location: Ast.TokenIndex) !void {\n    try self.OP_VOID(location);\n    try self.OP_RETURN(location);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "emitReturn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to emitConstant from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn emitConstant(self: *Self, location: Ast.TokenIndex, value: Value) !void {\n    try self.emitCodeArg(location, .OP_CONSTANT, try self.makeConstant(value));\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "emitConstant",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to makeConstant from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn makeConstant(self: *Self, value: Value) !u24 {\n    if (self.current.?.constants.get(value)) |idx| {\n        return idx;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "makeConstant",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to identifierConstant from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn identifierConstant(self: *Self, name: []const u8) !u24 {\n    return try self.makeConstant(\n        (try self.gc.copyString(name)).toValue(),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "identifierConstant",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reportError from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn reportError(self: *Self, error_type: Reporter.Error, comptime message: []const u8) void {\n    @branchHint(.cold);\n\n    if (self.reporter.panic_mode) {\n        return;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "reportError",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to synchronize from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn synchronize(self: *Self, node: Ast.Node.Index) bool {\n    if (self.reporter.panic_mode) {\n        switch (self.ast.nodes.items(.tag)[node]) {\n            .ObjectDeclaration,\n            .Enum,\n            .FunDeclaration,\n            .If,\n            .While,\n            .DoUntil,\n            .For,\n            .ForEach,\n            .Return,\n            .VarDeclaration,\n            .Throw,\n            .Break,\n            .Continue,\n            .Export,\n            .Import,\n            => {\n                self.reporter.panic_mode = false;\n                return false;\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "synchronize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to patchOptJumps from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn patchOptJumps(self: *Self, node: Ast.Node.Index) !void {\n    const location = self.ast.nodes.items(.location)[node];\n\n    if (self.ast.nodes.items(.patch_opt_jumps)[node]) {\n        std.debug.assert(self.opt_jumps.items.len > 0);\n\n        // Hope over OP_POP if actual value\n        const njump: usize = try self.emitJump(location, .OP_JUMP);\n\n        for (self.opt_jumps.items[self.opt_jumps.items.len - 1].items) |jump| {\n            self.patchJump(jump);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "patchOptJumps",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to endScope from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn endScope(self: *Self, node: Ast.Node.Index) Error!void {\n    const location = self.ast.nodes.items(.location)[node];\n\n    if (self.ast.nodes.items(.ends_scope)[node]) |closing| {\n        for (closing) |op| {\n            try self.emitOpCode(location, op);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "endScope",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateNode from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateNode(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    if (self.synchronize(node)) {\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateNode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nodeValue from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn nodeValue(self: *Self, node: Ast.Node.Index) Error!?Value {\n    const value = &self.ast.nodes.items(.value)[node];\n\n    if (value.* == null) {\n        if (self.ast.isConstant(node)) {\n            value.* = try self.ast.toValue(node, self.gc);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "nodeValue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateAs from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateAs(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const locations = self.ast.nodes.items(.location);\n    const node_location = locations[node];\n    const components = self.ast.nodes.items(.components)[node].As;\n\n    const constant = try self.ast.toValue(components.constant, self.gc);\n\n    std.debug.assert(constant.isObj() and constant.obj().obj_type == .Type);\n\n    if (obj.ObjTypeDef.cast(constant.obj()).?.def_type == .Placeholder) {\n        self.reporter.reportPlaceholder(\n            self.ast,\n            obj.ObjTypeDef.cast(constant.obj()).?.resolved_type.?.Placeholder,\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateAs",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateAsyncCall from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateAsyncCall(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const locations = self.ast.nodes.items(.location);\n    const type_defs = self.ast.nodes.items(.type_def);\n    const node_location = locations[node];\n    const type_def = type_defs[node].?;\n    const call_node = self.ast.nodes.items(.components)[node].AsyncCall;\n\n    // Push fiber type as constant (we only need it if the fiber is printed out)\n    // Should not interfere with local counts since OP_FIBER will consume it right away\n    try self.emitConstant(\n        node_location,\n        type_def.toValue(),\n    );\n\n    _ = try self.generateNode(call_node, breaks);\n\n    try self.patchOptJumps(node);\n    try self.endScope(node);\n\n    return null;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateAsyncCall",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateBinary from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateBinary(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const components = self.ast.nodes.items(.components)[node].Binary;\n\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const type_defs = self.ast.nodes.items(.type_def);\n    const left_type = type_defs[components.left].?;\n    const right_type = type_defs[components.right].?;\n\n    if (left_type.def_type == .Placeholder) {\n        self.reporter.reportPlaceholder(self.ast, left_type.resolved_type.?.Placeholder);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateBinary",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateBlock from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateBlock(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const tags = self.ast.nodes.items(.tag);\n\n    var seen_return = false;\n    for (self.ast.nodes.items(.components)[node].Block) |statement| {\n        if (seen_return) {\n            self.reporter.warnFmt(\n                .code_after_return,\n                self.ast.tokens.get(\n                    self.ast.nodes.items(.location)[statement],\n                ),\n                self.ast.tokens.get(\n                    self.ast.nodes.items(.end_location)[statement],\n                ),\n                \"Code after return statement will never be reached\",\n                .{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateBlock",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateBlockExpression from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateBlockExpression(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    for (self.ast.nodes.items(.components)[node].BlockExpression) |statement| {\n        _ = try self.generateNode(statement, breaks);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateBlockExpression",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateOut from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateOut(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    _ = try self.generateNode(self.ast.nodes.items(.components)[node].Out, breaks);\n\n    try self.patchOptJumps(node);\n    try self.endScope(node);\n\n    return null;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateOut",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateBoolean from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateBoolean(self: *Self, node: Ast.Node.Index, _: ?*Breaks) Error!?*obj.ObjFunction {\n    try self.emitOpCode(\n        self.ast.nodes.items(.location)[node],\n        if (self.ast.nodes.items(.components)[node].Boolean) .OP_TRUE else .OP_FALSE,\n    );\n\n    try self.patchOptJumps(node);\n    try self.endScope(node);\n\n    return null;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateBoolean",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateBreak from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateBreak(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    // Close scope(s), then jump\n    try self.endScope(node);\n    try breaks.?.append(\n        self.gc.allocator,\n        .{\n            .ip = try self.OP_JUMP(self.ast.nodes.items(.location)[node]),\n            .label_node = self.ast.nodes.items(.components)[node].Break.destination,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateBreak",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateContinue from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateContinue(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    // Close scope(s), then jump\n    try self.endScope(node);\n    try breaks.?.append(\n        self.gc.allocator,\n        .{\n            .ip = try self.emitJump(\n                self.ast.nodes.items(.location)[node],\n                .OP_LOOP,\n            ),\n            .label_node = self.ast.nodes.items(.components)[node].Continue.destination,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateContinue",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateCall from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateCall(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const type_defs = self.ast.nodes.items(.type_def);\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const node_components = self.ast.nodes.items(.components);\n    const lexemes = self.ast.tokens.items(.lexeme);\n\n    const components = node_components[node].Call;\n\n    const callee_type_def = type_defs[components.callee].?;\n    if (callee_type_def.def_type == .Placeholder) {\n        self.reporter.reportPlaceholder(self.ast, callee_type_def.resolved_type.?.Placeholder);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateCall",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateDot from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateDot(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const node_components = self.ast.nodes.items(.components);\n    const type_defs = self.ast.nodes.items(.type_def);\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const tags = self.ast.tokens.items(.tag);\n\n    const components = node_components[node].Dot;\n    const identifier_lexeme = self.ast.tokens.items(.lexeme)[components.identifier];\n\n    _ = try self.generateNode(components.callee, breaks);\n\n    const callee_type = type_defs[components.callee].?;\n\n    if (callee_type.def_type == .Placeholder) {\n        self.reporter.reportPlaceholder(self.ast, callee_type.resolved_type.?.Placeholder);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateDot",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateDoUntil from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateDoUntil(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const type_defs = self.ast.nodes.items(.type_def);\n    const node_components = self.ast.nodes.items(.components);\n    const components = node_components[node].DoUntil;\n\n    const loop_start = self.currentCode();\n\n    var lbreaks = Breaks{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateDoUntil",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateEnum from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateEnum(self: *Self, node: Ast.Node.Index, _: ?*Breaks) Error!?*obj.ObjFunction {\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const type_defs = self.ast.nodes.items(.type_def);\n    const node_components = self.ast.nodes.items(.components);\n    const components = node_components[node].Enum;\n\n    const enum_type = type_defs[node].?.resolved_type.?.Enum.enum_type;\n    if (enum_type.def_type == .Placeholder) {\n        self.reporter.reportPlaceholder(self.ast, enum_type.resolved_type.?.Placeholder);\n\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateEnum",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateExport from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateExport(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const components = self.ast.nodes.items(.components)[node].Export;\n\n    if (components.declaration) |decl| {\n        _ = try self.generateNode(decl, breaks);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateExport",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateExpression from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateExpression(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const components = self.ast.nodes.items(.components);\n    const expr = components[node].Expression;\n    const expr_node_type = self.ast.nodes.items(.tag)[expr];\n    const expr_type_def = self.ast.nodes.items(.type_def)[expr];\n\n    _ = try self.generateNode(expr, breaks);\n\n    try self.OP_POP(locations[node]);\n\n    const lone_expr = (expr_node_type != .NamedVariable or components[expr].NamedVariable.value == null) and\n        (expr_node_type != .Subscript or components[expr].Subscript.value == null) and\n        (expr_node_type != .Dot or components[expr].Dot.member_kind != .Value) and\n        expr_type_def != null and\n        expr_type_def.?.def_type != .Void;\n\n    if (self.flavor != .Repl and lone_expr and expr_type_def.?.def_type != .Placeholder) {\n        const type_def_str = expr_type_def.?.toStringAlloc(self.gc.allocator, false) catch unreachable;\n        defer self.gc.allocator.free(type_def_str);\n\n        self.reporter.warnFmt(\n            .discarded_value,\n            self.ast.tokens.get(locations[node]),\n            self.ast.tokens.get(end_locations[node]),\n            \"Discarded value of type `{s}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateExpression",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateFloat from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateFloat(self: *Self, node: Ast.Node.Index, _: ?*Breaks) Error!?*obj.ObjFunction {\n    try self.emitConstant(\n        self.ast.nodes.items(.location)[node],\n        try self.ast.toValue(node, self.gc),\n    );\n\n    try self.patchOptJumps(node);\n    try self.endScope(node);\n\n    return null;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateFloat",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateFor from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateFor(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const type_defs = self.ast.nodes.items(.type_def);\n    const node_components = self.ast.nodes.items(.components);\n\n    const components = node_components[node].For;\n    if (try self.ast.isConstant(self.gc.allocator, components.condition) and !(try self.ast.toValue(components.condition, self.gc)).boolean()) {\n        try self.patchOptJumps(node);\n\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateFor",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateForceUnwrap from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateForceUnwrap(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const components = self.ast.nodes.items(.components)[node].ForceUnwrap;\n\n    if (components.original_type.def_type == .Placeholder) {\n        self.reporter.reportPlaceholder(self.ast, components.original_type.resolved_type.?.Placeholder);\n\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateForceUnwrap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateForEach from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateForEach(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const node_components = self.ast.nodes.items(.components);\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const type_defs = self.ast.nodes.items(.type_def);\n    const components = node_components[node].ForEach;\n\n    // Type checking\n    const iterable_type_def = type_defs[components.iterable].?;\n    var key_type_def = type_defs[components.key].?;\n    const value_type_def = type_defs[components.value].?;\n    if (iterable_type_def.def_type == .Placeholder) {\n        self.reporter.reportPlaceholder(self.ast, iterable_type_def.resolved_type.?.Placeholder);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateForEach",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateFunction from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateFunction(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const node_components = self.ast.nodes.items(.components);\n    const type_defs = self.ast.nodes.items(.type_def);\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const components = node_components[node].Function;\n    const function_signature = if (components.function_signature) |fs|\n        node_components[fs].FunctionType\n    else\n        null;\n    const node_type_def = type_defs[node].?;\n    const function_type = node_type_def.resolved_type.?.Function.function_type;\n\n    // If function is a test block and we're not testing/checking/etc. don't waste time generating the node\n    if (self.flavor == .Run and function_type == .Test) {\n        try self.emitOpCode(locations[node], .OP_NULL);\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateFunction",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateFunDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateFunDeclaration(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const node_components = self.ast.nodes.items(.components);\n    const components = node_components[node].FunDeclaration;\n\n    _ = try self.generateNode(components.function, breaks);\n\n    if (components.slot_type == .Global) {\n        try self.OP_DEFINE_GLOBAL(\n            self.ast.nodes.items(.location)[node],\n            @intCast(components.slot),\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateFunDeclaration",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateGenericResolve from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateGenericResolve(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const type_def = self.ast.nodes.items(.type_def)[node].?;\n    const expr = self.ast.nodes.items(.components)[node].GenericResolve.expression;\n    const node_location = self.ast.nodes.items(.location)[node];\n    const node_end_location = self.ast.nodes.items(.end_location)[node];\n\n    switch (type_def.def_type) {\n        .Function => {\n            const function_type = type_def.resolved_type.?.Function;\n\n            if (function_type.generic_types.count() > 0 and\n                (function_type.resolved_generics == null or function_type.resolved_generics.?.len < function_type.generic_types.count()))\n            {\n                self.reporter.reportErrorFmt(\n                    .generic_type,\n                    self.ast.tokens.get(node_location),\n                    self.ast.tokens.get(node_end_location),\n                    \"Missing generic types. Expected {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateGenericResolve",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateGrouping from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateGrouping(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const components = self.ast.nodes.items(.components);\n    const expr = components[node].Grouping;\n\n    _ = try self.generateNode(expr, breaks);\n\n    try self.patchOptJumps(node);\n    try self.endScope(node);\n\n    return null;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateGrouping",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateIf from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateIf(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const type_defs = self.ast.nodes.items(.type_def);\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const node_components = self.ast.nodes.items(.components);\n    const components = node_components[node].If;\n    const location = locations[node];\n\n    // Type checking\n    if (type_defs[components.condition].?.def_type == .Placeholder) {\n        self.reporter.reportPlaceholder(self.ast, type_defs[components.condition].?.resolved_type.?.Placeholder);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateIf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateImport from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateImport(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const components = self.ast.nodes.items(.components)[node].Import;\n    const location = self.ast.nodes.items(.location)[node];\n\n    if (components.import) |import| {\n        try self.emitConstant(location, import.absolute_path.toValue());\n\n        _ = try self.generateNode(import.function, breaks);\n\n        // FIXME: avoid generating the same import function more than once!\n        try self.OP_IMPORT(location);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateImport",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateInteger from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateInteger(self: *Self, node: Ast.Node.Index, _: ?*Breaks) Error!?*obj.ObjFunction {\n    try self.emitConstant(\n        self.ast.nodes.items(.location)[node],\n        try self.ast.toValue(node, self.gc),\n    );\n\n    try self.patchOptJumps(node);\n    try self.endScope(node);\n\n    return null;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateInteger",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateIs from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateIs(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const components = self.ast.nodes.items(.components)[node].Is;\n    const location = self.ast.nodes.items(.location)[node];\n    const constant = try self.ast.toValue(components.constant, self.gc);\n\n    std.debug.assert(constant.isObj());\n    std.debug.assert(constant.obj().obj_type == .Type);\n\n    if (obj.ObjTypeDef.cast(constant.obj()).?.def_type == .Placeholder) {\n        self.reporter.reportPlaceholder(self.ast, obj.ObjTypeDef.cast(constant.obj()).?.resolved_type.?.Placeholder);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateIs",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateList from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateList(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const components = self.ast.nodes.items(.components)[node].List;\n    const type_defs = self.ast.nodes.items(.type_def);\n\n    const item_type = type_defs[node].?.resolved_type.?.List.item_type;\n\n    try self.OP_LIST(\n        locations[node],\n        type_defs[node].?.toValue(),\n    );\n\n    for (components.items) |item| {\n        if (item_type.def_type == .Placeholder) {\n            self.reporter.reportPlaceholder(self.ast, type_defs[item].?.resolved_type.?.Placeholder);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateList",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateMap from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateMap(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const components = self.ast.nodes.items(.components)[node].Map;\n    const type_defs = self.ast.nodes.items(.type_def);\n\n    const key_type = if (components.explicit_key_type) |kt|\n        type_defs[kt]\n    else\n        null;\n\n    const value_type = if (components.explicit_value_type) |vt|\n        type_defs[vt]\n    else\n        null;\n\n    try self.OP_MAP(\n        locations[node],\n        type_defs[node].?.toValue(),\n    );\n\n    for (components.entries) |entry| {\n        _ = try self.generateNode(entry.key, breaks);\n        _ = try self.generateNode(entry.value, breaks);\n\n        if (type_defs[entry.key].?.def_type == .Placeholder) {\n            self.reporter.reportPlaceholder(self.ast, type_defs[entry.key].?.resolved_type.?.Placeholder);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateMap",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateNamedVariable from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateNamedVariable(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const components = self.ast.nodes.items(.components)[node].NamedVariable;\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const type_defs = self.ast.nodes.items(.type_def);\n    const tags = self.ast.tokens.items(.tag);\n\n    var get_op: Chunk.OpCode = undefined;\n    var set_op: Chunk.OpCode = undefined;\n\n    switch (components.slot_type) {\n        .Local => {\n            get_op = .OP_GET_LOCAL;\n            set_op = .OP_SET_LOCAL;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateNamedVariable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateNull from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateNull(self: *Self, node: Ast.Node.Index, _: ?*Breaks) Error!?*obj.ObjFunction {\n    try self.OP_NULL(self.ast.nodes.items(.location)[node]);\n\n    try self.patchOptJumps(node);\n    try self.endScope(node);\n\n    return null;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateNull",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateObjectDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateObjectDeclaration(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const type_defs = self.ast.nodes.items(.type_def);\n    const lexemes = self.ast.tokens.items(.lexeme);\n    const components = self.ast.nodes.items(.components)[node].ObjectDeclaration;\n    const location = locations[node];\n\n    const object_type = type_defs[node].?;\n    const object_def = object_type.resolved_type.?.Object;\n\n    // Check object conforms to declared protocols\n    var protocol_it = object_def.conforms_to.iterator();\n    while (protocol_it.next()) |kv| {\n        const protocol_type_def = kv.key_ptr.*;\n\n        if (protocol_type_def.def_type == .Placeholder) {\n            self.reporter.reportPlaceholder(self.ast, protocol_type_def.resolved_type.?.Placeholder);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateObjectDeclaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateObjectInit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateObjectInit(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const type_defs = self.ast.nodes.items(.type_def);\n    const lexemes = self.ast.tokens.items(.lexeme);\n    const components = self.ast.nodes.items(.components)[node].ObjectInit;\n    const location = locations[node];\n    const node_type_def = type_defs[node].?;\n\n    if (components.object != null and type_defs[components.object.?].?.def_type == .Object) {\n        _ = try self.generateNode(components.object.?, breaks);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateObjectInit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generatePattern from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generatePattern(self: *Self, node: Ast.Node.Index, _: ?*Breaks) Error!?*obj.ObjFunction {\n    try self.emitConstant(\n        self.ast.nodes.items(.location)[node],\n        try self.ast.toValue(node, self.gc),\n    );\n\n    try self.patchOptJumps(node);\n    try self.endScope(node);\n\n    return null;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generatePattern",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateProtocolDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateProtocolDeclaration(self: *Self, node: Ast.Node.Index, _: ?*Breaks) Error!?*obj.ObjFunction {\n    const location = self.ast.nodes.items(.location)[node];\n    const components = self.ast.nodes.items(.components)[node].ProtocolDeclaration;\n    const type_def = self.ast.nodes.items(.type_def)[node].?;\n\n    try self.emitConstant(location, type_def.toValue());\n    try self.OP_DEFINE_GLOBAL(location, @intCast(components.slot));\n\n    try self.patchOptJumps(node);\n    try self.endScope(node);\n\n    return null;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateProtocolDeclaration",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateRange from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateRange(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const type_defs = self.ast.nodes.items(.type_def);\n    const components = self.ast.nodes.items(.components)[node].Range;\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n\n    // Type checking\n    if (type_defs[components.low].?.def_type == .Placeholder) {\n        self.reporter.reportPlaceholder(self.ast, type_defs[components.low].?.resolved_type.?.Placeholder);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateRange",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateResolve from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateResolve(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const fiber = self.ast.nodes.items(.components)[node].Resolve;\n    const fiber_type_def = self.ast.nodes.items(.type_def)[fiber].?;\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n\n    if (fiber_type_def.def_type == .Placeholder) {\n        self.reporter.reportPlaceholder(self.ast, fiber_type_def.resolved_type.?.Placeholder);\n\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateResolve",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateResume from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateResume(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const fiber = self.ast.nodes.items(.components)[node].Resume;\n    const fiber_type_def = self.ast.nodes.items(.type_def)[fiber].?;\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n\n    if (fiber_type_def.def_type == .Placeholder) {\n        self.reporter.reportPlaceholder(self.ast, fiber_type_def.resolved_type.?.Placeholder);\n\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateResume",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateReturn from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateReturn(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const components = self.ast.nodes.items(.components)[node].Return;\n    const type_defs = self.ast.nodes.items(.type_def);\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n\n    if (components.unconditional) {\n        self.current.?.return_emitted = true;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateReturn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateString from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateString(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const location = self.ast.nodes.items(.location)[node];\n    const type_defs = self.ast.nodes.items(.type_def);\n    const elements = self.ast.nodes.items(.components)[node].String;\n\n    if (elements.len == 0) {\n        // Push the empty string which is always the constant 0\n        try self.emitCodeArg(location, .OP_CONSTANT, 0);\n\n        try self.endScope(node);\n\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateString",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateStringLiteral from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateStringLiteral(self: *Self, node: Ast.Node.Index, _: ?*Breaks) Error!?*obj.ObjFunction {\n    try self.emitConstant(\n        self.ast.nodes.items(.location)[node],\n        self.ast.nodes.items(.components)[node].StringLiteral.literal.toValue(),\n    );\n\n    try self.patchOptJumps(node);\n    try self.endScope(node);\n\n    return null;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateStringLiteral",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateSubscript from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateSubscript(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const location = locations[node];\n    const type_defs = self.ast.nodes.items(.type_def);\n    const components = self.ast.nodes.items(.components)[node].Subscript;\n\n    _ = try self.generateNode(components.subscripted, breaks);\n\n    const subscripted_type_def = type_defs[components.subscripted].?;\n    const index_type_def = type_defs[components.index].?;\n    const value_type_def = if (components.value) |value| type_defs[value] else null;\n\n    if (subscripted_type_def.def_type == .Placeholder) {\n        self.reporter.reportPlaceholder(self.ast, subscripted_type_def.resolved_type.?.Placeholder);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateSubscript",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateTry from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateTry(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const components = self.ast.nodes.items(.components)[node].Try;\n    const type_defs = self.ast.nodes.items(.type_def);\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const location = locations[node];\n\n    self.current.?.try_should_handle = .{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateTry",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateThrow from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateThrow(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const components = self.ast.nodes.items(.components)[node].Throw;\n    const type_defs = self.ast.nodes.items(.type_def);\n    const location = self.ast.nodes.items(.location)[node];\n    const end_locations = self.ast.nodes.items(.end_location);\n\n    if (components.unconditional) {\n        self.current.?.return_emitted = true;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateThrow",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateTypeExpression from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateTypeExpression(self: *Self, node: Ast.Node.Index, _: ?*Breaks) Error!?*obj.ObjFunction {\n    const node_components = self.ast.nodes.items(.components);\n    const type_defs = self.ast.nodes.items(.type_def);\n\n    try self.emitConstant(\n        self.ast.nodes.items(.location)[node],\n        type_defs[node_components[node].TypeExpression].?.toValue(),\n    );\n\n    try self.patchOptJumps(node);\n    try self.endScope(node);\n\n    return null;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateTypeExpression",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateTypeOfExpression from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateTypeOfExpression(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    _ = try self.generateNode(self.ast.nodes.items(.components)[node].TypeOfExpression, breaks);\n\n    try self.OP_TYPEOF(self.ast.nodes.items(.location)[node]);\n\n    try self.patchOptJumps(node);\n    try self.endScope(node);\n\n    return null;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateTypeOfExpression",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateUnary from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateUnary(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const components = self.ast.nodes.items(.components)[node].Unary;\n    const location = self.ast.nodes.items(.location)[node];\n    const end_locations = self.ast.nodes.items(.end_location);\n    const expression_location = self.ast.nodes.items(.location)[components.expression];\n    const expression_type_def = self.ast.nodes.items(.type_def)[components.expression].?;\n\n    if (expression_type_def.def_type == .Placeholder) {\n        self.reporter.reportPlaceholder(self.ast, expression_type_def.resolved_type.?.Placeholder);\n\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateUnary",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateUnwrap from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateUnwrap(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const location = locations[node];\n    const components = self.ast.nodes.items(.components)[node].Unwrap;\n\n    if (components.original_type.def_type == .Placeholder) {\n        self.reporter.reportPlaceholder(self.ast, components.original_type.resolved_type.?.Placeholder);\n\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateUnwrap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateVarDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateVarDeclaration(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const components = self.ast.nodes.items(.components)[node].VarDeclaration;\n    const type_defs = self.ast.nodes.items(.type_def);\n    const type_def = type_defs[node].?;\n    const value_type_def = if (components.value) |value|\n        self.ast.nodes.items(.type_def)[value]\n    else\n        null;\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const location = locations[node];\n\n    if (components.value) |value| {\n        _ = try self.generateNode(value, breaks);\n\n        if (value_type_def.?.def_type == .Placeholder) {\n            self.reporter.reportPlaceholder(self.ast, value_type_def.?.resolved_type.?.Placeholder);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateVarDeclaration",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateVoid from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateVoid(self: *Self, node: Ast.Node.Index, _: ?*Breaks) Error!?*obj.ObjFunction {\n    try self.OP_VOID(self.ast.nodes.items(.location)[node]);\n\n    try self.patchOptJumps(node);\n    try self.endScope(node);\n\n    return null;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateVoid",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateWhile from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateWhile(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const components = self.ast.nodes.items(.components)[node].While;\n    const type_defs = self.ast.nodes.items(.type_def);\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const location = locations[node];\n    const condition_type_def = type_defs[components.condition].?;\n\n    // If condition constant and false, skip the node\n    if (try self.ast.isConstant(self.gc.allocator, components.condition) and !(try self.ast.toValue(components.condition, self.gc)).boolean()) {\n        try self.patchOptJumps(node);\n        try self.endScope(node);\n\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateWhile",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateYield from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateYield(self: *Self, node: Ast.Node.Index, breaks: ?*Breaks) Error!?*obj.ObjFunction {\n    const expression = self.ast.nodes.items(.components)[node].Yield;\n    const type_defs = self.ast.nodes.items(.type_def);\n    const type_def = type_defs[node];\n    const locations = self.ast.nodes.items(.location);\n    const end_locations = self.ast.nodes.items(.end_location);\n    const location = locations[node];\n\n    const current_function_typedef = type_defs[self.current.?.function_node].?.resolved_type.?.Function;\n    const current_function_type = current_function_typedef.function_type;\n    switch (current_function_type) {\n        .Script,\n        .ScriptEntryPoint,\n        .Repl,\n        .EntryPoint,\n        .Test,\n        .Extern,\n        => self.reporter.reportErrorAt(\n            .yield_not_allowed,\n            self.ast.tokens.get(location),\n            self.ast.tokens.get(end_locations[node]),\n            \"Can't yield here\",\n        ),\n        else => {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateYield",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateZdef from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn generateZdef(self: *Self, node: Ast.Node.Index, _: ?*Breaks) Error!?*obj.ObjFunction {\n    if (is_wasm) {\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "generateZdef",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to populateEmptyCollectionType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub fn populateEmptyCollectionType(self: *Self, value: Ast.Node.Index, target_type: *obj.ObjTypeDef) void {\n    const tags = self.ast.nodes.items(.tag);\n    const components = self.ast.nodes.items(.components);\n\n    // variable: [T] = [<any>] -> variable: [T] = [<T>];\n    if (target_type.def_type == .List and\n        tags[value] == .List and\n        components[value].List.explicit_item_type == null and\n        components[value].List.items.len == 0)\n    {\n        self.ast.nodes.items(.type_def)[value] = target_type;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "populateEmptyCollectionType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_SWAP from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_SWAP(self: *Self, location: Ast.TokenIndex, slotA: u8, slotB: u8) !void {\n    try self.emitCodeArgs(location, .OP_SWAP, slotA, slotB);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_SWAP",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_HOTSPOT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_HOTSPOT(self: *Self, location: Ast.TokenIndex) !usize {\n    return try self.emitJump(location, .OP_HOTSPOT);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_HOTSPOT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_NULL from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_NULL(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_NULL);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_NULL",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_VOID from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_VOID(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_VOID);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_VOID",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_TRUE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_TRUE(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_TRUE);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_TRUE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_FALSE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_FALSE(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_FALSE);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_FALSE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_POP from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_POP(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_POP);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_POP",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_EQUAL from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_EQUAL(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_EQUAL);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_EQUAL",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_IS from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_IS(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_IS);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_IS",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GREATER from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GREATER(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_GREATER);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GREATER",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_LESS from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_LESS(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_LESS);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_LESS",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_ADD_F from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_ADD_F(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_ADD_F);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_ADD_F",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_ADD_I from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_ADD_I(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_ADD_I);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_ADD_I",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_ADD_STRING from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_ADD_STRING(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_ADD_STRING);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_ADD_STRING",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_ADD_LIST from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_ADD_LIST(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_ADD_LIST);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_ADD_LIST",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_ADD_MAP from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_ADD_MAP(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_ADD_MAP);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_ADD_MAP",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_SUBTRACT_I from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_SUBTRACT_I(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_SUBTRACT_I);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_SUBTRACT_I",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_SUBTRACT_F from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_SUBTRACT_F(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_SUBTRACT_F);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_SUBTRACT_F",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_MULTIPLY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_MULTIPLY(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_MULTIPLY);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_MULTIPLY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_DIVIDE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_DIVIDE(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_DIVIDE);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_DIVIDE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_MULTIPLY_I from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_MULTIPLY_I(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_MULTIPLY_I);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_MULTIPLY_I",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_MULTIPLY_F from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_MULTIPLY_F(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_MULTIPLY_F);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_MULTIPLY_F",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_DIVIDE_I from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_DIVIDE_I(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_DIVIDE_I);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_DIVIDE_I",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_DIVIDE_F from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_DIVIDE_F(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_DIVIDE_F);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_DIVIDE_F",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_NOT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_NOT(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_NOT);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_NOT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_NEGATE_I from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_NEGATE_I(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_NEGATE_I);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_NEGATE_I",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_NEGATE_F from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_NEGATE_F(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_NEGATE_F);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_NEGATE_F",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_BAND from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_BAND(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_BAND);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_BAND",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_BOR from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_BOR(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_BOR);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_BOR",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_XOR from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_XOR(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_XOR);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_XOR",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_BNOT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_BNOT(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_BNOT);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_BNOT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_SHL from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_SHL(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_SHL);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_SHL",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_SHR from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_SHR(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_SHR);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_SHR",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_MOD_I from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_MOD_I(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_MOD_I);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_MOD_I",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_MOD_F from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_MOD_F(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_MOD_F);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_MOD_F",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_UNWRAP from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_UNWRAP(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_UNWRAP);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_UNWRAP",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_ENUM_CASE_VALUE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_ENUM_CASE_VALUE(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_GET_ENUM_CASE_VALUE);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_ENUM_CASE_VALUE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_SET_LIST_SUBSCRIPT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_SET_LIST_SUBSCRIPT(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_SET_LIST_SUBSCRIPT);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_SET_LIST_SUBSCRIPT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_SET_MAP_SUBSCRIPT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_SET_MAP_SUBSCRIPT(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_SET_MAP_SUBSCRIPT);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_SET_MAP_SUBSCRIPT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_THROW from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_THROW(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_THROW);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_THROW",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_IMPORT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_IMPORT(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_IMPORT);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_IMPORT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_TO_STRING from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_TO_STRING(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_TO_STRING);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_TO_STRING",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_INSTANCE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_INSTANCE(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_INSTANCE);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_INSTANCE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_FCONTAINER_INSTANCE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_FCONTAINER_INSTANCE(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_FCONTAINER_INSTANCE);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_FCONTAINER_INSTANCE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_STRING_FOREACH from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_STRING_FOREACH(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_STRING_FOREACH);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_STRING_FOREACH",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_LIST_FOREACH from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_LIST_FOREACH(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_LIST_FOREACH);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_LIST_FOREACH",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_ENUM_FOREACH from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_ENUM_FOREACH(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_ENUM_FOREACH);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_ENUM_FOREACH",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_MAP_FOREACH from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_MAP_FOREACH(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_MAP_FOREACH);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_MAP_FOREACH",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_FIBER_FOREACH from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_FIBER_FOREACH(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_FIBER_FOREACH);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_FIBER_FOREACH",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_RANGE_FOREACH from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_RANGE_FOREACH(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_RANGE_FOREACH);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_RANGE_FOREACH",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_RESUME from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_RESUME(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_RESUME);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_RESUME",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_YIELD from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_YIELD(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_YIELD);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_YIELD",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_RESOLVE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_RESOLVE(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_RESOLVE);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_RESOLVE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_TRY_END from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_TRY_END(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_TRY_END);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_TRY_END",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_ENUM_CASE_FROM_VALUE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_ENUM_CASE_FROM_VALUE(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_GET_ENUM_CASE_FROM_VALUE);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_ENUM_CASE_FROM_VALUE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_TYPEOF from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_TYPEOF(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_TYPEOF);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_TYPEOF",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_HOTSPOT_CALL from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_HOTSPOT_CALL(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_HOTSPOT_CALL);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_HOTSPOT_CALL",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_DEFINE_GLOBAL from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_DEFINE_GLOBAL(self: *Self, location: Ast.TokenIndex, slot: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_DEFINE_GLOBAL,\n        slot,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_DEFINE_GLOBAL",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_GLOBAL from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_GLOBAL(self: *Self, location: Ast.TokenIndex, slot: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_GLOBAL,\n        slot,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_GLOBAL",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_SET_GLOBAL from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_SET_GLOBAL(self: *Self, location: Ast.TokenIndex, slot: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_SET_GLOBAL,\n        slot,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_SET_GLOBAL",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_LOCAL from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_LOCAL(self: *Self, location: Ast.TokenIndex, slot: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_LOCAL,\n        slot,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_LOCAL",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_SET_LOCAL from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_SET_LOCAL(self: *Self, location: Ast.TokenIndex, slot: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_SET_LOCAL,\n        slot,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_SET_LOCAL",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_UPVALUE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_UPVALUE(self: *Self, location: Ast.TokenIndex, slot: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_UPVALUE,\n        slot,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_UPVALUE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_SET_UPVALUE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_SET_UPVALUE(self: *Self, location: Ast.TokenIndex, slot: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_SET_UPVALUE,\n        slot,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_SET_UPVALUE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_ENUM_CASE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_ENUM_CASE(self: *Self, location: Ast.TokenIndex, case: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_ENUM_CASE,\n        case,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_ENUM_CASE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_EXPORT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_EXPORT(self: *Self, location: Ast.TokenIndex, count: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_EXPORT,\n        count,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_EXPORT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_COPY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_COPY(self: *Self, location: Ast.TokenIndex, dist: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_COPY,\n        dist,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_COPY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_CLONE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_CLONE(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_CLONE);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_CLONE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_CLOSE_UPVALUE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_CLOSE_UPVALUE(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_CLOSE_UPVALUE);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_CLOSE_UPVALUE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_RETURN from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_RETURN(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_RETURN);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_RETURN",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_LIST_APPEND from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_LIST_APPEND(self: *Self, location: Ast.TokenIndex, count: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_LIST_APPEND,\n        count,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_LIST_APPEND",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_SET_MAP from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_SET_MAP(self: *Self, location: Ast.TokenIndex, slot: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_SET_MAP,\n        slot,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_SET_MAP",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_PROPERTY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_PROPERTY(self: *Self, location: Ast.TokenIndex, member_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_PROPERTY,\n        member_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_PROPERTY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_OBJECT_DEFAULT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_OBJECT_DEFAULT(self: *Self, location: Ast.TokenIndex, property_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_OBJECT_DEFAULT,\n        property_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_OBJECT_DEFAULT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_SET_OBJECT_PROPERTY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_SET_OBJECT_PROPERTY(self: *Self, location: Ast.TokenIndex, property_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_SET_OBJECT_PROPERTY,\n        property_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_SET_OBJECT_PROPERTY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_SET_INSTANCE_PROPERTY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_SET_INSTANCE_PROPERTY(self: *Self, location: Ast.TokenIndex, property_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_SET_INSTANCE_PROPERTY,\n        property_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_SET_INSTANCE_PROPERTY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_INSTANCE_PROPERTY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_INSTANCE_PROPERTY(self: *Self, location: Ast.TokenIndex, property_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_INSTANCE_PROPERTY,\n        property_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_INSTANCE_PROPERTY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_INSTANCE_METHOD from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_INSTANCE_METHOD(self: *Self, location: Ast.TokenIndex, property_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_INSTANCE_METHOD,\n        property_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_INSTANCE_METHOD",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_LIST_PROPERTY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_LIST_PROPERTY(self: *Self, location: Ast.TokenIndex, property_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_LIST_PROPERTY,\n        property_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_LIST_PROPERTY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_MAP_PROPERTY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_MAP_PROPERTY(self: *Self, location: Ast.TokenIndex, property_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_MAP_PROPERTY,\n        property_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_MAP_PROPERTY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_FIBER_PROPERTY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_FIBER_PROPERTY(self: *Self, location: Ast.TokenIndex, property_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_FIBER_PROPERTY,\n        property_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_FIBER_PROPERTY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_RANGE_PROPERTY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_RANGE_PROPERTY(self: *Self, location: Ast.TokenIndex, property_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_RANGE_PROPERTY,\n        property_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_RANGE_PROPERTY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_STRING_PROPERTY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_STRING_PROPERTY(self: *Self, location: Ast.TokenIndex, property_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_STRING_PROPERTY,\n        property_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_STRING_PROPERTY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_PATTERN_PROPERTY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_PATTERN_PROPERTY(self: *Self, location: Ast.TokenIndex, property_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_PATTERN_PROPERTY,\n        property_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_PATTERN_PROPERTY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_OBJECT_PROPERTY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_OBJECT_PROPERTY(self: *Self, location: Ast.TokenIndex, property_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_OBJECT_PROPERTY,\n        property_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_OBJECT_PROPERTY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_LIST_SUBSCRIPT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_LIST_SUBSCRIPT(self: *Self, location: Ast.TokenIndex, checked: bool) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_LIST_SUBSCRIPT,\n        if (checked) 1 else 0,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_LIST_SUBSCRIPT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_STRING_SUBSCRIPT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_STRING_SUBSCRIPT(self: *Self, location: Ast.TokenIndex, checked: bool) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_STRING_SUBSCRIPT,\n        if (checked) 1 else 0,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_STRING_SUBSCRIPT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_MAP_SUBSCRIPT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_MAP_SUBSCRIPT(self: *Self, location: Ast.TokenIndex, checked: bool) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_MAP_SUBSCRIPT,\n        if (checked) 1 else 0,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_MAP_SUBSCRIPT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_OBJECT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_OBJECT(self: *Self, location: Ast.TokenIndex, constant: Value) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_OBJECT,\n        try self.makeConstant(constant),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_OBJECT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_LIST from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_LIST(self: *Self, location: Ast.TokenIndex, constant: Value) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_LIST,\n        try self.makeConstant(constant),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_LIST",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_MAP from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_MAP(self: *Self, location: Ast.TokenIndex, constant: Value) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_MAP,\n        try self.makeConstant(constant),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_MAP",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_RANGE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_RANGE(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_RANGE);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_RANGE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_PROTOCOL_METHOD from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_PROTOCOL_METHOD(self: *Self, location: Ast.TokenIndex, identifier: []const u8) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_PROTOCOL_METHOD,\n        try self.identifierConstant(identifier),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_PROTOCOL_METHOD",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_GET_FCONTAINER_INSTANCE_PROPERTY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_GET_FCONTAINER_INSTANCE_PROPERTY(self: *Self, location: Ast.TokenIndex, field_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_GET_FCONTAINER_INSTANCE_PROPERTY,\n        field_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_GET_FCONTAINER_INSTANCE_PROPERTY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_SET_FCONTAINER_INSTANCE_PROPERTY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_SET_FCONTAINER_INSTANCE_PROPERTY(self: *Self, location: Ast.TokenIndex, field_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_SET_FCONTAINER_INSTANCE_PROPERTY,\n        field_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_SET_FCONTAINER_INSTANCE_PROPERTY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_CONSTANT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_CONSTANT(self: *Self, location: Ast.TokenIndex, constant: Value) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_CONSTANT,\n        try self.makeConstant(constant),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_CONSTANT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_JUMP from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_JUMP(self: *Self, location: Ast.TokenIndex) !usize {\n    return try self.emitJump(\n        location,\n        .OP_JUMP,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_JUMP",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_JUMP_IF_FALSE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_JUMP_IF_FALSE(self: *Self, location: Ast.TokenIndex) !usize {\n    return try self.emitJump(\n        location,\n        .OP_JUMP_IF_FALSE,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_JUMP_IF_FALSE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_JUMP_IF_NOT_NULL from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_JUMP_IF_NOT_NULL(self: *Self, location: Ast.TokenIndex) !usize {\n    return try self.emitJump(\n        location,\n        .OP_JUMP_IF_NOT_NULL,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_JUMP_IF_NOT_NULL",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_LOOP from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_LOOP(self: *Self, location: Ast.TokenIndex, loop_start: usize) !void {\n    const offset: usize = self.currentCode() - loop_start + 1;\n    if (offset > std.math.maxInt(u24)) {\n        self.reportError(.loop_body_too_large, \"Loop body too large.\");\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_LOOP",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_TRY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_TRY(self: *Self, location: Ast.TokenIndex) !usize {\n    return try self.emitJump(\n        location,\n        .OP_TRY,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_TRY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_CALL_INSTANCE_PROPERTY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_CALL_INSTANCE_PROPERTY(self: *Self, location: Ast.TokenIndex, field_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_CALL_INSTANCE_PROPERTY,\n        field_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_CALL_INSTANCE_PROPERTY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_TAIL_CALL_INSTANCE_PROPERTY from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_TAIL_CALL_INSTANCE_PROPERTY(self: *Self, location: Ast.TokenIndex, field_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_TAIL_CALL_INSTANCE_PROPERTY,\n        field_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_TAIL_CALL_INSTANCE_PROPERTY",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_INSTANCE_INVOKE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_INSTANCE_INVOKE(self: *Self, location: Ast.TokenIndex, field_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_INSTANCE_INVOKE,\n        field_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_INSTANCE_INVOKE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_INSTANCE_TAIL_INVOKE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_INSTANCE_TAIL_INVOKE(self: *Self, location: Ast.TokenIndex, field_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_INSTANCE_TAIL_INVOKE,\n        field_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_INSTANCE_TAIL_INVOKE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_STRING_INVOKE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_STRING_INVOKE(self: *Self, location: Ast.TokenIndex, field_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_STRING_INVOKE,\n        field_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_STRING_INVOKE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_PATTERN_INVOKE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_PATTERN_INVOKE(self: *Self, location: Ast.TokenIndex, field_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_PATTERN_INVOKE,\n        field_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_PATTERN_INVOKE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_FIBER_INVOKE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_FIBER_INVOKE(self: *Self, location: Ast.TokenIndex, field_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_FIBER_INVOKE,\n        field_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_FIBER_INVOKE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_LIST_INVOKE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_LIST_INVOKE(self: *Self, location: Ast.TokenIndex, field_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_LIST_INVOKE,\n        field_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_LIST_INVOKE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_MAP_INVOKE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_MAP_INVOKE(self: *Self, location: Ast.TokenIndex, field_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_MAP_INVOKE,\n        field_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_MAP_INVOKE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_RANGE_INVOKE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_RANGE_INVOKE(self: *Self, location: Ast.TokenIndex, field_idx: u24) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_RANGE_INVOKE,\n        field_idx,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_RANGE_INVOKE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_PROTOCOL_INVOKE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_PROTOCOL_INVOKE(self: *Self, location: Ast.TokenIndex, identifier: []const u8) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_PROTOCOL_INVOKE,\n        try self.identifierConstant(identifier),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_PROTOCOL_INVOKE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_PROTOCOL_TAIL_INVOKE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_PROTOCOL_TAIL_INVOKE(self: *Self, location: Ast.TokenIndex, identifier: []const u8) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_PROTOCOL_TAIL_INVOKE,\n        try self.identifierConstant(identifier),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_PROTOCOL_TAIL_INVOKE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_CALL from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_CALL(self: *Self, location: Ast.TokenIndex, arg_count: u8, catch_default: bool) !void {\n    try self.emitCodeArgs(\n        location,\n        .OP_CALL,\n        arg_count,\n        if (catch_default) 1 else 0,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_CALL",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_TAIL_CALL from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_TAIL_CALL(self: *Self, location: Ast.TokenIndex, arg_count: u24, catch_default: bool) !void {\n    try self.emitCodeArgs(\n        location,\n        .OP_TAIL_CALL,\n        arg_count,\n        if (catch_default) 1 else 0,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_TAIL_CALL",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_FIBER from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_FIBER(self: *Self, location: Ast.TokenIndex) !void {\n    try self.emitOpCode(location, .OP_FIBER);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_FIBER",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OP_CLOSURE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "fn OP_CLOSURE(self: *Self, location: Ast.TokenIndex, closure: Value) !void {\n    try self.emitCodeArg(\n        location,\n        .OP_CLOSURE,\n        try self.makeConstant(closure),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "function",
      "name": "OP_CLOSURE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Frame from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "pub const Frame = struct {\n    enclosing: ?*Frame = null,\n    function_node: Ast.Node.Index,\n    function: ?*obj.ObjFunction = null,\n    return_counts: bool = false,\n    return_emitted: bool = false,\n    // Keep track of constants to avoid adding the same more than once to the chunk\n    constants: std.AutoHashMapUnmanaged(Value, u24),\n\n    try_should_handle: ?std.AutoHashMapUnmanaged(*obj.ObjTypeDef, Ast.TokenIndex) = null,\n\n    pub fn deinit(self: *Frame, allocator: std.mem.Allocator) void {\n        self.constants.deinit(allocator);\n        if (self.try_should_handle) |*handle| {\n            handle.deinit(allocator);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "struct",
      "name": "Frame",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Break from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const Break = struct {\n    ip: usize, // The op code will tell us if this is a continue or a break statement\n    label_node: ?Ast.Node.Index = null,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "struct",
      "name": "Break",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to offset from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const offset: usize = self.currentCode() - loop_start + 1;",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "offset",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to instruction from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const instruction: u8 = @intCast(original >> 24);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "instruction",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to code from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const code: Chunk.OpCode = @enumFromInt(instruction);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "code",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to loop_offset from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const loop_offset: usize = offset - loop_start.? + 1;",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "loop_offset",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to instruction from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const instruction: u8 = @intCast(original >> 24);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "instruction",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to instruction from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const instruction: u8 = @intCast(original >> 24);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "instruction",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to njump from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const njump: usize = try self.emitJump(location, .OP_JUMP);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "njump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to end_jump from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const end_jump: usize = try self.OP_JUMP_IF_NOT_NULL(locations[node]);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "end_jump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to end_jump from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const end_jump: usize = try self.OP_JUMP_IF_FALSE(locations[node]);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "end_jump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to else_jump from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const else_jump: usize = try self.OP_JUMP_IF_FALSE(locations[node]);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "else_jump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to end_jump from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const end_jump: usize = try self.OP_JUMP(locations[node]);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "end_jump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to exit_jump from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const exit_jump: usize = try self.OP_JUMP_IF_FALSE(locations[node]);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "exit_jump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to expr_loop from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const expr_loop: usize = self.currentCode();",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "expr_loop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to loop_start from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const loop_start: usize = self.currentCode();",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "loop_start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to exit_jump from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const exit_jump: usize = try self.OP_JUMP_IF_FALSE(locations[node]);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "exit_jump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to else_jump from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const else_jump: usize = try self.OP_JUMP_IF_FALSE(location);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "else_jump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to out_jump from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const out_jump: usize = try self.emitJump(location, .OP_JUMP);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "out_jump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to next_clause_jump from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const next_clause_jump: usize = try self.OP_JUMP_IF_FALSE(location);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "next_clause_jump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to loop_start from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const loop_start: usize = self.currentCode();",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "loop_start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to offset from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Codegen.zig",
    "response": "const offset: usize = self.currentCode() - loop_start + 1;",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Codegen.zig",
      "type": "const",
      "name": "offset",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/FFI.zig",
    "response": "pub fn init(gc: *GC) Self {\n    return .{\n        .gc = gc,\n        .reporter = .{\n            .allocator = gc.allocator,\n            .error_prefix = \"FFI\",\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/FFI.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/FFI.zig",
    "response": "pub fn deinit(self: *Self) void {\n    self.type_expr_cache.deinit(self.gc.allocator);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/FFI.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseTypeExpr from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/FFI.zig",
    "response": "pub fn parseTypeExpr(self: *Self, ztype: []const u8) !?*Zdef {\n    if (self.type_expr_cache.get(ztype)) |zdef| {\n        return zdef;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/FFI.zig",
      "type": "function",
      "name": "parseTypeExpr",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parse from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/FFI.zig",
    "response": "pub fn parse(self: *Self, parser: ?*Parser, source: Ast.TokenIndex, type_expr: ?[]const u8) !?[]*Zdef {\n    // TODO: maybe an Arena allocator for those kinds of things that can live for the whole process lifetime\n    const duped = self.gc.allocator.dupeZ(\n        u8,\n        type_expr orelse parser.?.ast.tokens.items(.literal)[source].String,\n    ) catch @panic(\"Out of memory\");\n    // defer self.gc.allocator.free(duped);\n\n    self.state = .{\n        .script = if (parser) |uparser|\n            try std.mem.replaceOwned(u8, self.gc.allocator, uparser.script_name, \"/\", \".\")\n        else\n            \"zdef\",\n        .type_expr = type_expr,\n        .source = source,\n        .parser = parser,\n        .buzz_ast = if (parser) |p|\n            p.ast.slice()\n        else\n            null,\n        .ast = Ast.parse(\n            self.gc.allocator,\n            duped,\n            .zig,\n        ) catch @panic(\"Could not parse zdef\"),\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/FFI.zig",
      "type": "function",
      "name": "parse",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getZdef from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/FFI.zig",
    "response": "fn getZdef(self: *Self, decl_index: Ast.Node.Index) !?*Zdef {\n    const decl_tag = self.state.?.ast.nodeTag(decl_index);\n    const decl_data = self.state.?.ast.nodeData(decl_index);\n    const ast = self.state.?.ast;\n\n    return switch (decl_tag) {\n        .fn_proto_simple,\n        .fn_proto_multi,\n        .fn_proto_one,\n        .fn_proto,\n        => try self.fnProto(decl_tag, decl_index),\n\n        .identifier => try self.identifier(decl_index),\n\n        .ptr_type_aligned,\n        .ptr_type_sentinel,\n        .ptr_type,\n        => try self.ptrType(decl_tag, decl_index),\n\n        .simple_var_decl => var_decl: {\n            // Allow simple type if we're parsing type expr, or struct type\n            if (self.state.?.type_expr != null) {\n                break :var_decl try self.getZdef(ast.simpleVarDecl(decl_index).ast.type_node.unwrap().?);\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/FFI.zig",
      "type": "function",
      "name": "getZdef",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to containerDecl from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/FFI.zig",
    "response": "fn containerDecl(self: *Self, name: []const u8, decl_index: Ast.Node.Index) anyerror!*Zdef {\n    const container_node_tag = self.state.?.ast.nodeTag(decl_index);\n\n    var buf: [2]Ast.Node.Index = undefined;\n    const container = switch (container_node_tag) {\n        .container_decl => self.state.?.ast.containerDecl(decl_index),\n        .container_decl_trailing => self.state.?.ast.containerDecl(decl_index),\n        .container_decl_two => self.state.?.ast.containerDeclTwo(&buf, decl_index),\n        .container_decl_two_trailing => self.state.?.ast.containerDeclTwo(&buf, decl_index),\n        .container_decl_arg => self.state.?.ast.containerDeclArg(decl_index),\n        .container_decl_arg_trailing => self.state.?.ast.containerDecl(decl_index),\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/FFI.zig",
      "type": "function",
      "name": "containerDecl",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to unionContainer from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/FFI.zig",
    "response": "fn unionContainer(self: *Self, name: []const u8, container: Ast.full.ContainerDecl) anyerror!*Zdef {\n    var fields = std.ArrayList(ZigType.UnionField).empty;\n    var get_set_fields = std.StringArrayHashMapUnmanaged(o.ObjForeignContainer.ContainerDef.Field).empty;\n    var buzz_fields = std.StringArrayHashMapUnmanaged(*o.ObjTypeDef).empty;\n    var decls = std.ArrayList(ZigType.Declaration).empty;\n    var next_field: ?*Zdef = null;\n    for (container.ast.members, 0..) |member, idx| {\n        const member_zdef = next_field orelse try self.getZdef(member);\n\n        next_field = if (idx < container.ast.members.len - 1)\n            try self.getZdef(container.ast.members[idx + 1])\n        else\n            null;\n\n        try fields.append(\n            self.gc.allocator,\n            ZigType.UnionField{\n                .name = member_zdef.?.name,\n                .type = &member_zdef.?.zig_type,\n                .alignment = member_zdef.?.zig_type.alignment(),\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/FFI.zig",
      "type": "function",
      "name": "unionContainer",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to structContainer from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/FFI.zig",
    "response": "fn structContainer(self: *Self, name: []const u8, container: Ast.full.ContainerDecl) anyerror!*Zdef {\n    var fields = std.ArrayList(ZigType.StructField).empty;\n    var get_set_fields = std.StringArrayHashMapUnmanaged(o.ObjForeignContainer.ContainerDef.Field).empty;\n    var buzz_fields = std.StringArrayHashMapUnmanaged(*o.ObjTypeDef).empty;\n    var decls = std.ArrayList(ZigType.Declaration).empty;\n    var offset: usize = 0;\n    var next_field: ?*Zdef = null;\n    for (container.ast.members, 0..) |member, idx| {\n        const member_zdef = next_field orelse try self.getZdef(member);\n\n        next_field = if (idx < container.ast.members.len - 1)\n            try self.getZdef(container.ast.members[idx + 1])\n        else\n            null;\n\n        try fields.append(\n            self.gc.allocator,\n            ZigType.StructField{\n                .name = member_zdef.?.name,\n                .type = &member_zdef.?.zig_type,\n                .default_value = null,\n                .is_comptime = false,\n                .alignment = member_zdef.?.zig_type.alignment(),\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/FFI.zig",
      "type": "function",
      "name": "structContainer",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to containerField from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/FFI.zig",
    "response": "fn containerField(self: *Self, decl_index: Ast.Node.Index) anyerror!*Zdef {\n    const container_field = self.state.?.ast.containerFieldInit(decl_index);\n\n    var zdef = (try self.getZdef(container_field.ast.type_expr.unwrap().?)).?;\n    zdef.name = self.state.?.ast.tokenSlice(self.state.?.ast.nodeMainToken(decl_index));\n\n    return zdef;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/FFI.zig",
      "type": "function",
      "name": "containerField",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to identifier from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/FFI.zig",
    "response": "fn identifier(self: *Self, decl_index: Ast.Node.Index) anyerror!*Zdef {\n    const id = self.state.?.ast.tokenSlice(self.state.?.ast.nodeMainToken(decl_index));\n\n    var type_def = if (basic_types.get(id)) |basic_type|\n        basic_type\n    else\n        null;\n    var zig_type = if (zig_basic_types.get(id)) |zig_basic_type|\n        zig_basic_type\n    else\n        null;\n\n    if ((type_def == null or zig_type == null) and self.state.?.parser != null) {\n        // FIXME: should this account for the current namespace?\n        const global_idx = glb: {\n            for (self.state.?.parser.?.globals.items, 0..) |global, idx| {\n                if (std.mem.eql(\n                    u8,\n                    id,\n                    self.state.?.parser.?.ast.tokens.items(.lexeme)[global.name[global.name.len - 1]],\n                )) {\n                    break :glb idx;\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/FFI.zig",
      "type": "function",
      "name": "identifier",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ptrType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/FFI.zig",
    "response": "fn ptrType(self: *Self, tag: Ast.Node.Tag, decl_index: Ast.Node.Index) anyerror!*Zdef {\n    const ptr_type = switch (tag) {\n        .ptr_type_aligned => self.state.?.ast.ptrTypeAligned(decl_index),\n        .ptr_type_sentinel => self.state.?.ast.ptrTypeSentinel(decl_index),\n        .ptr_type => self.state.?.ast.ptrType(decl_index),\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/FFI.zig",
      "type": "function",
      "name": "ptrType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fnProto from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/FFI.zig",
    "response": "fn fnProto(self: *Self, tag: Ast.Node.Tag, decl_index: Ast.Node.Index) anyerror!*Zdef {\n    var buffer = [1]Ast.Node.Index{undefined}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/FFI.zig",
      "type": "function",
      "name": "fnProto",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reportZigError from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/FFI.zig",
    "response": "fn reportZigError(self: *Self, err: Ast.Error) void {\n    var message = std.ArrayList(u8).empty;\n    defer message.deinit(self.gc.allocator);\n\n    message.writer(self.gc.allocator).print(\"zdef could not be parsed: {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/FFI.zig",
      "type": "function",
      "name": "reportZigError",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Zdef from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/FFI.zig",
    "response": "pub const Zdef = struct {\n    name: []const u8,\n    type_def: *o.ObjTypeDef,\n    zig_type: ZigType,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/FFI.zig",
      "type": "struct",
      "name": "Zdef",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to State from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/FFI.zig",
    "response": "pub const State = struct {\n    script: []const u8,\n    source: Ast.TokenIndex,\n    ast: Ast,\n    buzz_ast: ?BuzzAst.Slice = null,\n    parser: ?*Parser,\n    type_expr: ?[]const u8 = null,\n    structs: std.StringHashMapUnmanaged(*Zdef) = .empty,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/FFI.zig",
      "type": "struct",
      "name": "State",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to zig_type from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/FFI.zig",
    "response": "const zig_type: {s};\", .{ztype}) catch @panic(\"Out of memory\");\n\n    const zdef = try self.parse(\n        null,\n        0,\n        full.items,\n    );",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/FFI.zig",
      "type": "const",
      "name": "zig_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn init(allocator: std.mem.Allocator) !GC {\n    const self = GC{\n        .allocator = allocator,\n        .type_registry = undefined,\n        .debugger = if (BuildOptions.gc_debug_access) Debugger.init(allocator) else null,\n\n        .objfiber_members = try allocator.alloc(?*o.ObjNative, o.ObjFiber.members.len),\n        .objfiber_memberDefs = try allocator.alloc(?*o.ObjTypeDef, o.ObjFiber.members.len),\n        .objpattern_members = try allocator.alloc(?*o.ObjNative, o.ObjPattern.members.len),\n        .objpattern_memberDefs = try allocator.alloc(?*o.ObjTypeDef, o.ObjPattern.members.len),\n        .objstring_members = try allocator.alloc(?*o.ObjNative, o.ObjString.members.len),\n        .objstring_memberDefs = try allocator.alloc(?*o.ObjTypeDef, o.ObjString.members.len),\n        .objrange_members = try allocator.alloc(?*o.ObjNative, o.ObjRange.members.len),\n        .objrange_memberDefs = try allocator.alloc(?*o.ObjTypeDef, o.ObjRange.members.len),\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to registerVM from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn registerVM(self: *GC, vm: *v.VM) !void {\n    try self.active_vms.put(\n        self.allocator,\n        vm,\n        {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "registerVM",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to unregisterVM from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn unregisterVM(self: *GC, vm: *v.VM) void {\n    const removed = self.active_vms.remove(vm);\n\n    std.debug.assert(removed);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "unregisterVM",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn deinit(self: *GC) void {\n    self.gray_stack.deinit(self.allocator);\n    self.strings.deinit(self.allocator);\n    self.active_vms.deinit(self.allocator);\n    if (BuildOptions.gc_debug_access) {\n        self.debugger.?.deinit();\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to allocate from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn allocate(self: *GC, comptime T: type) !*T {\n    var timer = if (!is_wasm) std.time.Timer.start() catch unreachable else {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "allocate",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to allocateMany from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn allocateMany(self: *GC, comptime T: type, count: usize) ![]T {\n    var timer = if (!is_wasm)\n        std.time.Timer.start() catch unreachable\n    else {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "allocateMany",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to allocateObject from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn allocateObject(self: *GC, data: anytype) !*@TypeOf(data) {\n    const T = @TypeOf(data);\n\n    const obj: *T = try self.allocate(T);\n    obj.* = data;\n\n    const object = obj.toObj();\n\n    // Add new object at start of vm.objects linked list\n    try self.addObject(object);\n\n    if (BuildOptions.gc_debug_access) {\n        self.debugger.?.allocated(\n            object,\n            self.where,\n            switch (T) {\n                o.ObjString => .String,\n                o.ObjTypeDef => .Type,\n                o.ObjUpValue => .UpValue,\n                o.ObjClosure => .Closure,\n                o.ObjFunction => .Function,\n                o.ObjObjectInstance => .ObjectInstance,\n                o.ObjObject => .Object,\n                o.ObjList => .List,\n                o.ObjMap => .Map,\n                o.ObjEnum => .Enum,\n                o.ObjEnumInstance => .EnumInstance,\n                o.ObjBoundMethod => .Bound,\n                o.ObjNative => .Native,\n                o.ObjUserData => .UserData,\n                o.ObjPattern => .Pattern,\n                o.ObjFiber => .Fiber,\n                o.ObjForeignContainer => .ForeignContainer,\n                o.ObjRange => .Range,\n                else => @panic(\"Unknown object type being allocated\"),\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "allocateObject",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to addObject from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "fn addObject(self: *GC, obj: *o.Obj) !void {\n    self.objects.prepend(&obj.node);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "addObject",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to allocateString from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn allocateString(self: *GC, chars: []const u8) !*o.ObjString {\n    const string: *o.ObjString = try allocateObject(\n        self,\n        o.ObjString{ .string = chars }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "allocateString",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to copyString from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn copyString(self: *GC, chars: []const u8) !*o.ObjString {\n    if (self.strings.get(chars)) |interned| {\n        return interned;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "copyString",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to free from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "fn free(self: *GC, comptime T: type, pointer: *T) void {\n    var timer = if (!is_wasm) std.time.Timer.start() catch unreachable else {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "free",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to freeMany from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "fn freeMany(self: *GC, comptime T: type, pointer: []const T) void {\n    var timer = if (!is_wasm) std.time.Timer.start() catch unreachable else {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "freeMany",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to markObjDirty from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn markObjDirty(self: *GC, obj: *o.Obj) !void {\n    if (!obj.dirty and self.obj_collected != obj) {\n        obj.dirty = true;\n\n        // A dirty obj is: an old object with reference to potential young objects that will need to be marked\n        // Since old object are ignored when tracing references, this will force tracing for it\n        try self.gray_stack.append(self.allocator, obj);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "markObjDirty",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to markObj from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn markObj(self: *GC, obj: *o.Obj) !void {\n    if (obj.marked or self.obj_collected == obj) {\n        if (BuildOptions.gc_debug) {\n            std.log.info(\n                \"{*}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "markObj",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to blackenObject from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "fn blackenObject(self: *GC, obj: *o.Obj) !void {\n    if (BuildOptions.gc_debug) {\n        std.log.info(\n            \"blackening @{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "blackenObject",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to freeObj from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "fn freeObj(self: *GC, obj: *o.Obj) (std.mem.Allocator.Error || std.fmt.BufPrintError)!void {\n    if (BuildOptions.gc_debug) {\n        std.log.info(\n            \">> freeing {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "freeObj",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to markValue from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn markValue(self: *GC, value: Value) !void {\n    if (value.isObj()) {\n        try self.markObj(value.obj());\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "markValue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to markFiber from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn markFiber(self: *GC, fiber: *v.Fiber) !void {\n    var current_fiber: ?*v.Fiber = fiber;\n    while (current_fiber) |ufiber| {\n        try self.markObj(@constCast(ufiber.type_def.toObj()));\n        // Mark main fiber\n        if (BuildOptions.gc_debug) {\n            std.log.info(\"MARKING STACK OF FIBER @{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "markFiber",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to markMethods from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "fn markMethods(self: *GC) !void {\n    if (BuildOptions.gc_debug) {\n        std.log.info(\"MARKING BASIC TYPES METHOD\", .{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "markMethods",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to markRoots from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "fn markRoots(self: *GC, vm: *v.VM) !void {\n    // FIXME: We should not need this, but we don't know how to prevent collection before the VM actually starts making reference to them\n    try self.type_registry.mark();\n\n    try self.markMethods();\n\n    // Mark special strings we always need\n    if (self.strings.get(\"$\")) |dollar| {\n        try self.markObj(dollar.toObj());\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "markRoots",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to traceReference from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "fn traceReference(self: *GC) !void {\n    if (BuildOptions.gc_debug) {\n        std.log.info(\"TRACING REFERENCE\", .{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "traceReference",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sweep from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "fn sweep(self: *GC, mode: Mode) !void {\n    const swept: usize = self.bytes_allocated;\n\n    var obj_count: usize = 0;\n    var obj_node = self.objects.first;\n    var count: usize = 0;\n    while (obj_node) |node| : (count += 1) {\n        const obj: *o.Obj = @fieldParentPtr(\"node\", node);\n        const marked = obj.marked;\n        if (marked) {\n            if (BuildOptions.gc_debug and mode == .Full) {\n                std.log.info(\n                    \"UNMARKING @{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "sweep",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to collectGarbage from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn collectGarbage(self: *GC) !void {\n    var timer = if (!is_wasm) std.time.Timer.start() catch unreachable else {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "collectGarbage",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn init(allocator: std.mem.Allocator) Self {\n        return .{\n            .allocator = allocator,\n            .tracker = std.AutoHashMapUnmanaged(*o.Obj, Ptr){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "init",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn deinit(self: *Self) void {\n        self.tracker.deinit(self.allocator);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to allocated from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn allocated(self: *Self, ptr: *o.Obj, at: ?Token, what: o.ObjType) void {\n        std.debug.assert(self.tracker.get(ptr) == null);\n        self.tracker.put(\n            self.allocator,\n            ptr,\n            Ptr{\n                .what = what,\n                .allocated_at = at,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "allocated",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to collected from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn collected(self: *Self, ptr: *o.Obj, at: Token) void {\n        if (self.tracker.getPtr(ptr)) |tracked| {\n            if (tracked.collected_at) |collected_at| {\n                self.reporter.reportWithOrigin(\n                    .gc,\n                    at,\n                    at,\n                    collected_at,\n                    collected_at,\n                    \"Trying to collected already collected {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "collected",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to accessed from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub fn accessed(self: *Self, ptr: *o.Obj, at: ?Token) void {\n        if (self.invoking_collector) return;\n\n        if (self.tracker.getPtr(ptr)) |tracked| {\n            if (tracked.collected_at) |collected_at| {\n                var items = std.ArrayList(Reporter.ReportItem).empty;\n                defer items.deinit(self.allocator);\n\n                var message = std.ArrayList(u8).empty;\n                defer message.deinit(self.allocator);\n\n                message.writer(self.allocator).print(\n                    \"Access to already collected {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "function",
      "name": "accessed",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Debugger from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "pub const Debugger = struct {\n    const Self = @This();\n\n    pub const Ptr = struct {\n        what: o.ObjType,\n        allocated_at: ?Token,\n        collected_at: ?Token = null,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "struct",
      "name": "Debugger",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to obj from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "const obj: *T = try self.allocate(T);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "const",
      "name": "obj",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to string from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "const string: *o.ObjString = try allocateObject(\n        self,\n        o.ObjString{ .string = chars },\n    );",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "const",
      "name": "string",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to copy from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "const copy: []u8 = try self.allocateMany(u8, chars.len);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "const",
      "name": "copy",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to n from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "const n: usize = (@sizeOf(T) * pointer.len);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "const",
      "name": "n",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to swept from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "const swept: usize = self.bytes_allocated;",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "const",
      "name": "swept",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to obj from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "const obj: *o.Obj = @fieldParentPtr(\"node\", node);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "const",
      "name": "obj",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to unreached from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "const unreached: *o.Obj = obj;",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "const",
      "name": "unreached",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to mode from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/GC.zig",
    "response": "const mode: Mode = if (self.bytes_allocated > self.next_full_gc and self.last_gc != null) .Full else .Young;",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/GC.zig",
      "type": "const",
      "name": "mode",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "pub fn deinit(self: *OptJump, allocator: std.mem.Allocator) void {\n        self.current_insn.deinit(allocator);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "pub fn deinit(self: *GenState, allocator: std.mem.Allocator) void {\n        self.prototypes.deinit(allocator);\n        self.registers.deinit(allocator);\n        if (self.try_should_handle) |*try_should_handle| {\n            try_should_handle.deinit(allocator);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "pub fn init(vm: *VM) Self {\n    return .{\n        .vm = vm,\n        .ctx = m.MIR_init(),\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "pub fn deinit(self: *Self, allocator: std.mem.Allocator) void {\n    self.compiled_nodes.deinit(allocator);\n    self.blacklisted_nodes.deinit(allocator);\n    // std.debug.assert(self.functions_queue.count() == 0);\n    self.functions_queue.deinit(allocator);\n    // std.debug.assert(self.objclosures_queue.count() == 0);\n    self.objclosures_queue.deinit(allocator);\n    self.modules.deinit(allocator);\n    self.required_ext_api.deinit(allocator);\n    self.compiled_functions_bodies.deinit(allocator);\n    m.MIR_finish(self.ctx);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reset from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn reset(self: *Self, allocator: std.mem.Allocator) void {\n    self.functions_queue.clearAndFree(allocator);\n    self.objclosures_queue.clearAndFree(allocator);\n    self.required_ext_api.clearAndFree(allocator);\n    self.modules.clearAndFree(allocator);\n\n    self.state.?.deinit(allocator);\n    self.state = null;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "reset",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to compileFunction from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "pub fn compileFunction(self: *Self, ast: Ast.Slice, closure: *o.ObjClosure) Error!void {\n    const function = closure.function;\n\n    // Did we already compile a function with the same body?\n    if (self.compiled_functions_bodies.get(function.chunk)) |compiled| {\n        function.native = compiled.native;\n        function.native_raw = compiled.native_raw;\n\n        if (BuildOptions.jit_debug) {\n            io.print(\"Reusing previous compilation\\n\", .{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "compileFunction",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to compileHotSpot from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "pub fn compileHotSpot(self: *Self, ast: Ast.Slice, closure: *o.ObjClosure, hotspot_node: Ast.Node.Index) Error!*anyopaque {\n    if (try ast.usesFiber(\n        self.vm.gc.allocator,\n        hotspot_node,\n    )) {\n        if (BuildOptions.jit_debug) {\n            io.print(\n                \"Not compiling node {s}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "compileHotSpot",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildCollateralFunctions from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildCollateralFunctions(self: *Self, ast: Ast.Slice) Error!void {\n    var it = self.functions_queue.iterator();\n    while (it.next()) |kv| {\n        const node = kv.key_ptr.*;\n\n        if (kv.value_ptr.* == null) {\n            // Does it have an associated closure?\n            var it2 = self.objclosures_queue.iterator();\n            var sub_closure: ?*o.ObjClosure = null;\n            while (it2.next()) |kv2| {\n                if (kv2.key_ptr.*.function.node == node) {\n                    sub_closure = kv2.key_ptr.*;\n                    break;\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildCollateralFunctions",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildFunction from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildFunction(self: *Self, ast: Ast.Slice, closure: ?*o.ObjClosure, ast_node: Ast.Node.Index) Error!void {\n    self.state = .{\n        .ast = ast,\n        .module = undefined,\n        .ast_node = ast_node,\n        .closure = closure orelse self.state.?.closure,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildFunction",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to closeScope from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn closeScope(self: *Self, node: Ast.Node.Index) !void {\n    if (self.state.?.ast.nodes.items(.ends_scope)[node]) |closing| {\n        for (closing) |op| {\n            if (op == .OP_CLOSE_UPVALUE) {\n                try self.buildCloseUpValues();\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "closeScope",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildCloseUpValues from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildCloseUpValues(self: *Self) !void {\n    const ctx_reg = self.state.?.ctx_reg.?;\n    const stack_top_ptr_base = try self.REG(\"stack_top_ptr_base\", m.MIR_T_I64);\n    const stack_top_base = try self.REG(\"stack_top_base\", m.MIR_T_I64);\n    const index = try self.REG(\"index\", m.MIR_T_I64);\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, index),\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    // *[*]Value\n    const stack_top_ptr = m.MIR_new_mem_op(\n        self.ctx,\n        m.MIR_T_P,\n        @offsetOf(o.NativeCtx, \"stack_top\"),\n        ctx_reg,\n        index,\n        1,\n    );\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, stack_top_ptr_base),\n        stack_top_ptr,\n    );\n\n    // [*]Value\n    const stack_top = m.MIR_new_mem_op(\n        self.ctx,\n        m.MIR_T_P,\n        0,\n        stack_top_ptr_base,\n        index,\n        1,\n    );\n\n    // Store value on stack top\n    self.SUB(\n        m.MIR_new_reg_op(self.ctx, stack_top_base),\n        stack_top,\n        m.MIR_new_uint_op(self.ctx, @sizeOf(u64)),\n    );\n\n    try self.buildExternApiCall(\n        .bz_closeUpValues,\n        null,\n        &[_]m.MIR_op_t{\n            m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n            m.MIR_new_reg_op(self.ctx, stack_top_base),\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildCloseUpValues",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildStackPtr from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildStackPtr(self: *Self, distance: usize) !m.MIR_op_t {\n    const ctx_reg = self.state.?.ctx_reg.?;\n    const stack_top_ptr_base = try self.REG(\"stack_top_ptr_base\", m.MIR_T_I64);\n    const stack_top_base = try self.REG(\"stack_top_base\", m.MIR_T_I64);\n    const index = try self.REG(\"index\", m.MIR_T_I64);\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, index),\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    // *[*]Value\n    const stack_top_ptr = m.MIR_new_mem_op(\n        self.ctx,\n        m.MIR_T_P,\n        @offsetOf(o.NativeCtx, \"stack_top\"),\n        ctx_reg,\n        index,\n        1,\n    );\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, stack_top_ptr_base),\n        stack_top_ptr,\n    );\n\n    // [*]Value\n    const stack_top = m.MIR_new_mem_op(\n        self.ctx,\n        m.MIR_T_P,\n        0,\n        stack_top_ptr_base,\n        index,\n        1,\n    );\n\n    // Store value on stack top\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, stack_top_base),\n        stack_top,\n    );\n\n    const ptr = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"ptr\", m.MIR_T_I64),\n    );\n\n    self.SUB(\n        ptr,\n        stack_top,\n        m.MIR_new_uint_op(self.ctx, (1 + distance) * @sizeOf(u64)),\n    );\n\n    return ptr;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildStackPtr",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildPush from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildPush(self: *Self, value: m.MIR_op_t) !void {\n    const ctx_reg = self.state.?.ctx_reg.?;\n    const stack_top_ptr_base = try self.REG(\"stack_top_ptr_base\", m.MIR_T_I64);\n    const stack_top_base = try self.REG(\"stack_top_base\", m.MIR_T_I64);\n    const index = try self.REG(\"index\", m.MIR_T_I64);\n\n    // Avoid intertwining the push and its value expression\n    const value_reg = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"value\", m.MIR_T_I64),\n    );\n    self.MOV(value_reg, value);\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, index),\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    // *[*]Value\n    const stack_top_ptr = m.MIR_new_mem_op(\n        self.ctx,\n        m.MIR_T_P,\n        @offsetOf(o.NativeCtx, \"stack_top\"),\n        ctx_reg,\n        index,\n        1,\n    );\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, stack_top_ptr_base),\n        stack_top_ptr,\n    );\n\n    // [*]Value\n    const stack_top = m.MIR_new_mem_op(\n        self.ctx,\n        m.MIR_T_P,\n        0,\n        stack_top_ptr_base,\n        index,\n        1,\n    );\n\n    // Store value on stack top\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, stack_top_base),\n        stack_top,\n    );\n\n    const top = m.MIR_new_mem_op(\n        self.ctx,\n        m.MIR_T_P,\n        0,\n        stack_top_base,\n        index,\n        1,\n    );\n\n    self.MOV(\n        top,\n        value_reg,\n    );\n\n    // Increment stack top\n    self.ADD(\n        stack_top,\n        m.MIR_new_reg_op(self.ctx, stack_top_base),\n        m.MIR_new_uint_op(self.ctx, @sizeOf(u64)),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildPush",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildPop from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildPop(self: *Self, dest: ?m.MIR_op_t) !void {\n    const ctx_reg = self.state.?.ctx_reg.?;\n    const stack_top_ptr_base = try self.REG(\"stack_top_ptr_base\", m.MIR_T_I64);\n    const stack_top_base = try self.REG(\"stack_top_base\", m.MIR_T_I64);\n    const index = try self.REG(\"index\", m.MIR_T_I64);\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, index),\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    // *[*]Value\n    const stack_top_ptr = m.MIR_new_mem_op(\n        self.ctx,\n        m.MIR_T_P,\n        @offsetOf(o.NativeCtx, \"stack_top\"),\n        ctx_reg,\n        index,\n        1,\n    );\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, stack_top_ptr_base),\n        stack_top_ptr,\n    );\n\n    // [*]Value\n    const stack_top = m.MIR_new_mem_op(\n        self.ctx,\n        m.MIR_T_P,\n        0,\n        stack_top_ptr_base,\n        index,\n        1,\n    );\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, stack_top_base),\n        stack_top,\n    );\n\n    // Decrement stack top\n    self.SUB(\n        stack_top,\n        m.MIR_new_reg_op(self.ctx, stack_top_base),\n        m.MIR_new_uint_op(self.ctx, @sizeOf(u64)),\n    );\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, stack_top_base),\n        stack_top,\n    );\n\n    // Store new top in result reg\n    if (dest) |into| {\n        const top = m.MIR_new_mem_op(\n            self.ctx,\n            m.MIR_T_P,\n            0,\n            stack_top_base,\n            index,\n            1,\n        );\n\n        self.MOV(\n            into,\n            top,\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildPop",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildPeek from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildPeek(self: *Self, distance: u32, dest: m.MIR_op_t) !void {\n    const ctx_reg = self.state.?.ctx_reg.?;\n    const stack_top_ptr_base = try self.REG(\"stack_top_ptr_base\", m.MIR_T_I64);\n    const stack_top_base = try self.REG(\"stack_top_base\", m.MIR_T_I64);\n    const index = try self.REG(\"index\", m.MIR_T_I64);\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, index),\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    // *[*]Value\n    const stack_top_ptr = m.MIR_new_mem_op(\n        self.ctx,\n        m.MIR_T_P,\n        @offsetOf(o.NativeCtx, \"stack_top\"),\n        ctx_reg,\n        index,\n        1,\n    );\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, stack_top_ptr_base),\n        stack_top_ptr,\n    );\n\n    // [*]Value\n    const stack_top = m.MIR_new_mem_op(\n        self.ctx,\n        m.MIR_T_P,\n        0,\n        stack_top_ptr_base,\n        index,\n        1,\n    );\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, stack_top_base),\n        stack_top,\n    );\n\n    const top = m.MIR_new_mem_op(\n        self.ctx,\n        m.MIR_T_P,\n        (-1 - @as(i32, @intCast(distance))) * @sizeOf(u64),\n        stack_top_base,\n        index,\n        1,\n    );\n\n    self.MOV(dest, top);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildPeek",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildGetLocal from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildGetLocal(self: *Self, slot: usize) !m.MIR_op_t {\n    const ctx_reg = self.state.?.ctx_reg.?;\n    const index = try self.REG(\"index\", m.MIR_T_I64);\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, index),\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    const base = try self.REG(\"base\", m.MIR_T_I64);\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, base),\n        m.MIR_new_mem_op(\n            self.ctx,\n            m.MIR_T_U64,\n            @offsetOf(o.NativeCtx, \"base\"),\n            ctx_reg,\n            index,\n            @sizeOf(u64),\n        ),\n    );\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, index),\n        m.MIR_new_uint_op(self.ctx, slot),\n    );\n\n    // Avoid intertwining the get local and its value expression\n    const value_reg = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"value\", m.MIR_T_I64),\n    );\n    self.MOV(\n        value_reg,\n        m.MIR_new_mem_op(\n            self.ctx,\n            m.MIR_T_U64,\n            0,\n            base,\n            index,\n            @sizeOf(u64),\n        ),\n    );\n\n    return value_reg;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildGetLocal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildSetLocal from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildSetLocal(self: *Self, slot: usize, value: m.MIR_op_t) !void {\n    const ctx_reg = self.state.?.ctx_reg.?;\n    const index = try self.REG(\"index\", m.MIR_T_I64);\n    const base = try self.REG(\"base\", m.MIR_T_I64);\n\n    // Avoid intertwining the set local and its value expression\n    const value_reg = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"value\", m.MIR_T_I64),\n    );\n    self.MOV(value_reg, value);\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, index),\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, base),\n        m.MIR_new_mem_op(\n            self.ctx,\n            m.MIR_T_U64,\n            @offsetOf(o.NativeCtx, \"base\"),\n            ctx_reg,\n            index,\n            0,\n        ),\n    );\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, index),\n        m.MIR_new_uint_op(self.ctx, slot),\n    );\n\n    const local = m.MIR_new_mem_op(\n        self.ctx,\n        m.MIR_T_U64,\n        0,\n        base,\n        index,\n        @sizeOf(u64),\n    );\n\n    self.MOV(local, value_reg);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildSetLocal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildGetGlobal from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildGetGlobal(self: *Self, slot: usize) !m.MIR_op_t {\n    const ctx_reg = self.state.?.ctx_reg.?;\n    const index = try self.REG(\"index\", m.MIR_T_I64);\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, index),\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    const globals = try self.REG(\"globals\", m.MIR_T_I64);\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, globals),\n        m.MIR_new_mem_op(\n            self.ctx,\n            m.MIR_T_P,\n            @offsetOf(o.NativeCtx, \"globals\"),\n            ctx_reg,\n            index,\n            @sizeOf(u64),\n        ),\n    );\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, index),\n        m.MIR_new_uint_op(self.ctx, slot),\n    );\n\n    return m.MIR_new_mem_op(\n        self.ctx,\n        m.MIR_T_U64,\n        0,\n        globals,\n        index,\n        @sizeOf(u64),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildGetGlobal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildSetGlobal from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildSetGlobal(self: *Self, slot: usize, value: m.MIR_op_t) !void {\n    const ctx_reg = self.state.?.ctx_reg.?;\n    const index = try self.REG(\"index\", m.MIR_T_I64);\n    const globals = try self.REG(\"globals\", m.MIR_T_I64);\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, index),\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, globals),\n        m.MIR_new_mem_op(\n            self.ctx,\n            m.MIR_T_U64,\n            @offsetOf(o.NativeCtx, \"globals\"),\n            ctx_reg,\n            index,\n            0,\n        ),\n    );\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, index),\n        m.MIR_new_uint_op(self.ctx, slot),\n    );\n\n    const global = m.MIR_new_mem_op(\n        self.ctx,\n        m.MIR_T_U64,\n        0,\n        globals,\n        index,\n        @sizeOf(u64),\n    );\n\n    self.MOV(global, value);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildSetGlobal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueToBoolean from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueToBoolean(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) void {\n    self.EQ(\n        dest,\n        value,\n        m.MIR_new_uint_op(self.ctx, Value.TrueMask),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueToBoolean",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueFromBoolean from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueFromBoolean(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) void {\n    const true_label = m.MIR_new_label(self.ctx);\n    const out_label = m.MIR_new_label(self.ctx);\n\n    self.BEQ(\n        m.MIR_new_label_op(self.ctx, true_label),\n        value,\n        m.MIR_new_uint_op(self.ctx, 1),\n    );\n\n    self.MOV(\n        dest,\n        m.MIR_new_uint_op(self.ctx, Value.False.val),\n    );\n\n    self.JMP(out_label);\n\n    self.append(true_label);\n\n    self.MOV(\n        dest,\n        m.MIR_new_uint_op(self.ctx, Value.True.val),\n    );\n\n    self.append(out_label);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueFromBoolean",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueToInteger from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueToInteger(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    const inter = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\n            \"inter\",\n            m.MIR_T_I64,\n        ),\n    );\n\n    // Extract i48\n    self.AND(\n        inter,\n        value,\n        m.MIR_new_uint_op(self.ctx, 0xffffffffffff),\n    );\n\n    const is_neg = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\n            \"is_neg\",\n            m.MIR_T_I64,\n        ),\n    );\n\n    const out_label = m.MIR_new_label(self.ctx);\n    self.AND(\n        is_neg,\n        inter,\n        m.MIR_new_uint_op(self.ctx, 1 << 47),\n    );\n\n    // If 48th bit is 1, means the i48 is negative\n    self.BEQ(\n        m.MIR_new_label_op(self.ctx, out_label),\n        is_neg,\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    // Extend sign by filling upper bits with 1s\n    self.OR(\n        inter,\n        inter,\n        m.MIR_new_uint_op(self.ctx, @bitCast(~@as(i64, 0xFFFFFFFFFFFF))),\n    );\n\n    self.append(out_label);\n\n    self.MOV(dest, inter);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueToInteger",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueFromInteger from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueFromInteger(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) void {\n    // Get rid of upper bits\n    self.AND(\n        dest,\n        value,\n        m.MIR_new_uint_op(self.ctx, @bitCast(@as(i64, 0xFFFFFFFFFFFF))),\n    );\n\n    self.OR(\n        dest,\n        m.MIR_new_uint_op(self.ctx, Value.IntegerMask),\n        dest,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueFromInteger",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueToObj from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueToObj(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) void {\n    self.NOT(dest, m.MIR_new_uint_op(self.ctx, Value.PointerMask));\n    self.AND(dest, value, dest);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueToObj",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueFromObj from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueFromObj(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) void {\n    self.OR(\n        dest,\n        m.MIR_new_uint_op(self.ctx, Value.PointerMask),\n        value,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueFromObj",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueToCString from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueToCString(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    try self.buildExternApiCall(\n        .bz_valueToCString,\n        dest,\n        &[_]m.MIR_op_t{value}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueToCString",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueToOptionalCString from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueToOptionalCString(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    const null_label = m.MIR_new_label(self.ctx);\n\n    self.MOV(\n        dest,\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    self.BEQ(\n        m.MIR_new_label_op(self.ctx, null_label),\n        value,\n        m.MIR_new_uint_op(self.ctx, Value.Null.val),\n    );\n\n    try self.buildExternApiCall(\n        .bz_valueToCString,\n        dest,\n        &[_]m.MIR_op_t{value}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueToOptionalCString",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueFromCString from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueFromCString(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    try self.buildExternApiCall(\n        .bz_stringToValueZ,\n        dest,\n        &[_]m.MIR_op_t{\n            m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n            value,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueFromCString",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueFromOptionalCString from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueFromOptionalCString(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    const null_label = m.MIR_new_label(self.ctx);\n\n    self.MOV(\n        dest,\n        m.MIR_new_uint_op(self.ctx, Value.Null.val),\n    );\n\n    self.BEQ(\n        m.MIR_new_label_op(self.ctx, null_label),\n        value,\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    try self.buildExternApiCall(\n        .bz_stringToValueZ,\n        dest,\n        &[_]m.MIR_op_t{\n            m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n            value,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueFromOptionalCString",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueToUserData from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueToUserData(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    try self.buildExternApiCall(\n        .bz_getUserDataPtr,\n        dest,\n        &[_]m.MIR_op_t{value}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueToUserData",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueToForeignContainerPtr from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueToForeignContainerPtr(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    try self.buildExternApiCall(\n        .bz_valueToForeignContainerPtr,\n        dest,\n        &[_]m.MIR_op_t{value}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueToForeignContainerPtr",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueFromForeignContainerPtr from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueFromForeignContainerPtr(self: *Self, type_def: *o.ObjTypeDef, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    try self.buildExternApiCall(\n        .bz_newForeignContainerFromSlice,\n        dest,\n        &[_]m.MIR_op_t{\n            m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n            m.MIR_new_uint_op(self.ctx, @intFromPtr(type_def)),\n            value,\n            m.MIR_new_uint_op(self.ctx, type_def.resolved_type.?.ForeignContainer.zig_type.size()),\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueFromForeignContainerPtr",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueFromOptionalForeignContainerPtr from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueFromOptionalForeignContainerPtr(self: *Self, type_def: *o.ObjTypeDef, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    const null_label = m.MIR_new_label(self.ctx);\n\n    self.MOV(\n        dest,\n        m.MIR_new_uint_op(self.ctx, Value.Null.val),\n    );\n\n    self.BEQ(\n        m.MIR_new_label_op(self.ctx, null_label),\n        value,\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    try self.buildExternApiCall(\n        .bz_newForeignContainerFromSlice,\n        dest,\n        &[_]m.MIR_op_t{\n            m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n            m.MIR_new_uint_op(self.ctx, @intFromPtr(type_def)),\n            value,\n            m.MIR_new_uint_op(self.ctx, type_def.resolved_type.?.ForeignContainer.zig_type.size()),\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueFromOptionalForeignContainerPtr",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueToOptionalForeignContainerPtr from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueToOptionalForeignContainerPtr(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    const null_label = m.MIR_new_label(self.ctx);\n\n    self.MOV(\n        dest,\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    self.BEQ(\n        m.MIR_new_label_op(self.ctx, null_label),\n        value,\n        m.MIR_new_uint_op(self.ctx, Value.Null.val),\n    );\n\n    try self.buildExternApiCall(\n        .bz_valueToForeignContainerPtr,\n        dest,\n        &[_]m.MIR_op_t{value}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueToOptionalForeignContainerPtr",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueFromUserData from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueFromUserData(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    try self.buildExternApiCall(\n        .bz_newUserData,\n        dest,\n        &[_]m.MIR_op_t{\n            m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n            value,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueFromUserData",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueFromOptionalUserData from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueFromOptionalUserData(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    const null_label = m.MIR_new_label(self.ctx);\n\n    self.MOV(\n        dest,\n        m.MIR_new_uint_op(self.ctx, Value.Null.val),\n    );\n\n    self.BEQ(\n        m.MIR_new_label_op(self.ctx, null_label),\n        value,\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    try self.buildExternApiCall(\n        .bz_newUserData,\n        dest,\n        &[_]m.MIR_op_t{\n            m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n            value,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueFromOptionalUserData",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueToOptionalUserData from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueToOptionalUserData(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    const null_label = m.MIR_new_label(self.ctx);\n\n    self.MOV(\n        dest,\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    self.BEQ(\n        m.MIR_new_label_op(self.ctx, null_label),\n        value,\n        m.MIR_new_uint_op(self.ctx, Value.Null.val),\n    );\n\n    try self.buildExternApiCall(\n        .bz_getUserDataPtr,\n        dest,\n        &[_]m.MIR_op_t{value}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueToOptionalUserData",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueFromFloat from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueFromFloat(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    // Allocate memory\n    const block = try self.REG(\"call_block\", m.MIR_T_I64);\n    self.BSTART(block);\n    defer self.BEND(block); // release alloca after result is put in dest registry\n    const addr = self.REG(\"cast\", m.MIR_T_I64) catch unreachable;\n    self.ALLOCA(addr, @sizeOf(u64));\n\n    // Put the value in it as double\n    self.FMOV(\n        m.MIR_new_mem_op(\n            self.ctx,\n            m.MIR_T_F,\n            0,\n            addr,\n            0,\n            0,\n        ),\n        value,\n    );\n\n    // Take it out as u64\n    self.MOV(\n        dest,\n        m.MIR_new_mem_op(\n            self.ctx,\n            m.MIR_T_U64,\n            0,\n            addr,\n            0,\n            0,\n        ),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueFromFloat",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueFromDouble from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueFromDouble(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    // Allocate memory\n    const block = try self.REG(\"call_block\", m.MIR_T_I64);\n    self.BSTART(block);\n    defer self.BEND(block); // release alloca after result is put in dest registry\n    const addr = self.REG(\"cast\", m.MIR_T_I64) catch unreachable;\n    self.ALLOCA(addr, @sizeOf(u64));\n\n    // Put the value in it as double\n    self.DMOV(\n        m.MIR_new_mem_op(\n            self.ctx,\n            m.MIR_T_D,\n            0,\n            addr,\n            0,\n            0,\n        ),\n        value,\n    );\n\n    // Take it out as u64\n    self.MOV(\n        dest,\n        m.MIR_new_mem_op(\n            self.ctx,\n            m.MIR_T_U64,\n            0,\n            addr,\n            0,\n            0,\n        ),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueFromDouble",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueToDouble from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueToDouble(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    // Allocate memory\n    const block = try self.REG(\"call_block\", m.MIR_T_I64);\n    self.BSTART(block);\n    defer self.BEND(block); // release alloca after result is put in dest registry\n    const addr = self.REG(\"cast\", m.MIR_T_I64) catch unreachable;\n    self.ALLOCA(addr, @sizeOf(u64));\n\n    // Put the value in it as u64\n    self.MOV(\n        m.MIR_new_mem_op(\n            self.ctx,\n            m.MIR_T_U64,\n            0,\n            addr,\n            0,\n            0,\n        ),\n        value,\n    );\n\n    // Take it out as double\n    self.DMOV(\n        dest,\n        m.MIR_new_mem_op(\n            self.ctx,\n            m.MIR_T_D,\n            0,\n            addr,\n            0,\n            0,\n        ),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueToDouble",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueToFloat from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueToFloat(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    // Allocate memory\n    const block = try self.REG(\"call_block\", m.MIR_T_I64);\n    self.BSTART(block);\n    defer self.BEND(block); // release alloca after result is put in dest registry\n    const addr = self.REG(\"cast\", m.MIR_T_I64) catch unreachable;\n    self.ALLOCA(addr, @sizeOf(u64));\n\n    // Put the value in it as u64\n    self.MOV(\n        m.MIR_new_mem_op(\n            self.ctx,\n            m.MIR_T_U64,\n            0,\n            addr,\n            0,\n            0,\n        ),\n        value,\n    );\n\n    // Take it out as double\n    self.FMOV(\n        dest,\n        m.MIR_new_mem_op(\n            self.ctx,\n            m.MIR_T_F,\n            0,\n            addr,\n            0,\n            0,\n        ),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueToFloat",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildValueToForeignContainer from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildValueToForeignContainer(self: *Self, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    const index = try self.REG(\"index\", m.MIR_T_I64);\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, index),\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    const foreign = try self.REG(\"foreign\", m.MIR_T_P);\n    try self.buildExternApiCall(\n        .bz_valueToForeignContainerPtr,\n        m.MIR_new_reg_op(self.ctx, foreign),\n        &[_]m.MIR_op_t{value}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildValueToForeignContainer",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildReturn from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildReturn(self: *Self, value: m.MIR_op_t) !void {\n    const ctx_reg = self.state.?.ctx_reg.?;\n    const index = try self.REG(\"index\", m.MIR_T_I64);\n\n    self.MOV(\n        m.MIR_new_reg_op(self.ctx, index),\n        m.MIR_new_uint_op(self.ctx, 0),\n    );\n\n    // Get base\n    // [*]Value\n    const base = m.MIR_new_mem_op(\n        self.ctx,\n        m.MIR_T_P,\n        @offsetOf(o.NativeCtx, \"base\"),\n        ctx_reg,\n        index,\n        1,\n    );\n\n    try self.buildExternApiCall(\n        .bz_closeUpValues,\n        null,\n        &[_]m.MIR_op_t{\n            m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n            base,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildReturn",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to unwrap from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn unwrap(self: *Self, def_type: o.ObjTypeDef.Type, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    return switch (def_type) {\n        .Bool => self.buildValueToBoolean(value, dest),\n        .Integer => self.buildValueToInteger(value, dest),\n        .Double => try self.buildValueToDouble(value, dest),\n        .Void => self.MOV(dest, value),\n        .String,\n        .Pattern,\n        .ObjectInstance,\n        .Object,\n        .Protocol,\n        .ProtocolInstance,\n        .Enum,\n        .EnumInstance,\n        .List,\n        .Map,\n        .Function,\n        .Type,\n        .Fiber,\n        .UserData,\n        .Range,\n        => self.buildValueToObj(value, dest),\n        .ForeignContainer => try self.buildValueToForeignContainer(value, dest),\n        .Placeholder,\n        .Generic,\n        .Any,\n        => unreachable,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "unwrap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to wrap from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn wrap(self: *Self, def_type: o.ObjTypeDef.Type, value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    return switch (def_type) {\n        .Bool => self.buildValueFromBoolean(value, dest),\n        .Integer => self.buildValueFromInteger(value, dest),\n        .Double => try self.buildValueFromDouble(value, dest),\n        .Void => self.MOV(dest, m.MIR_new_uint_op(self.ctx, Value.Void.val)),\n        .String,\n        .Pattern,\n        .ObjectInstance,\n        .Object,\n        .Protocol,\n        .ProtocolInstance,\n        .Enum,\n        .EnumInstance,\n        .List,\n        .Map,\n        .Function,\n        .Type,\n        .Fiber,\n        .UserData,\n        .Range,\n        => self.buildValueFromObj(value, dest),\n        .ForeignContainer,\n        .Placeholder,\n        .Generic,\n        .Any,\n        => unreachable,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "wrap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildExternApiCall from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildExternApiCall(self: *Self, method: ExternApi, dest: ?m.MIR_op_t, args: []const m.MIR_op_t) !void {\n    var full_args = std.ArrayList(m.MIR_op_t){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildExternApiCall",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateString from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateString(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const elements = self.state.?.ast.nodes.items(.components)[node].String;\n    const type_defs = self.state.?.ast.nodes.items(.type_def);\n\n    if (elements.len == 0) {\n        return m.MIR_new_uint_op(\n            self.ctx,\n            self.state.?.closure.function.chunk.constants.items[0].val,\n        ); // Constant 0 is the empty string\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateString",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateNamedVariable from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateNamedVariable(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].NamedVariable;\n    const type_def = self.state.?.ast.nodes.items(.type_def)[node];\n    const tags = self.state.?.ast.tokens.items(.tag);\n\n    const function_type = if (type_def.?.def_type == .Function)\n        type_def.?.resolved_type.?.Function.function_type\n    else\n        null;\n    const is_constant_fn = function_type != null and function_type.? != .Extern and function_type.? != .Anonymous;\n\n    const value = if (components.value) |val|\n        try self.generateNode(val)\n    else\n        null;\n\n    switch (components.slot_type) {\n        .Global => {\n            if (value) |val| {\n                std.debug.assert(!is_constant_fn);\n\n                if (tags[components.assign_token.?] != .Equal) {\n                    // buildGetGlobal returns the actual address of the global so no need to buildSetGlobal after\n                    const global = try self.buildGetGlobal(components.slot);\n                    try self.buildBinary(\n                        tags[components.assign_token.?],\n                        type_def.?.def_type,\n                        global,\n                        val,\n                        global,\n                    );\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateNamedVariable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateCall from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateCall(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const node_types = self.state.?.ast.nodes.items(.tag);\n    const node_components = self.state.?.ast.nodes.items(.components);\n    const components = node_components[node].Call;\n    const type_defs = self.state.?.ast.nodes.items(.type_def);\n    const lexemes = self.state.?.ast.tokens.items(.lexeme);\n\n    // This is not a call but an Enum(value)\n    if (type_defs[components.callee].?.def_type == .Enum) {\n        const result_reg = try self.REG(\"enum_case\", m.MIR_T_I64);\n\n        try self.buildExternApiCall(\n            .bz_getEnumCaseFromValue,\n            m.MIR_new_reg_op(self.ctx, result_reg),\n            &[_]m.MIR_op_t{\n                (try self.generateNode(components.callee)).?,\n                (try self.generateNode(components.arguments[0].value)).?,\n                m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateCall",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateHandleExternReturn from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateHandleExternReturn(\n    self: *Self,\n    can_fail: bool,\n    should_return: bool,\n    return_code: m.MIR_op_t,\n    arg_count: usize,\n    catch_value: ?m.MIR_op_t,\n) !m.MIR_op_t {\n    if (can_fail) {\n        const continue_label = m.MIR_new_label(self.ctx);\n\n        self.BNE(\n            continue_label,\n            return_code,\n            m.MIR_new_int_op(self.ctx, -1),\n        );\n\n        if (catch_value) |value| {\n            // Pop error\n            const discard = try self.REG(\"discard\", m.MIR_T_I64);\n            try self.buildPop(m.MIR_new_reg_op(self.ctx, discard));\n\n            // Push catch value\n            try self.buildPush(value);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateHandleExternReturn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateReturn from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateReturn(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].Return;\n\n    if (components.unconditional) {\n        self.state.?.return_emitted = true;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateReturn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateIf from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateIf(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const values = self.state.?.ast.nodes.items(.value);\n    const type_defs = self.state.?.ast.nodes.items(.type_def);\n    const components = self.state.?.ast.nodes.items(.components)[node].If;\n    // We assume that if condition is const, the codegen will already have generated the Value\n    const constant_condition = if (components.unwrapped_identifier == null and components.casted_type == null)\n        values[components.condition]\n    else\n        null;\n\n    // Generate condition\n    const condition_value = if (constant_condition == null)\n        (try self.generateNode(components.condition)).?\n    else\n        null;\n    const condition = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"condition\", m.MIR_T_I64),\n    );\n\n    const resolved = if (!components.is_statement)\n        try self.REG(\"resolved\", m.MIR_T_I64)\n    else\n        null;\n\n    if (components.casted_type) |casted_type| {\n        try self.buildExternApiCall(\n            .bz_valueIs,\n            condition,\n            &[_]m.MIR_op_t{\n                condition_value.?,\n                m.MIR_new_uint_op(\n                    self.ctx,\n                    @constCast(type_defs[casted_type].?).toValue().val,\n                ),\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateIf",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateTypeExpression from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateTypeExpression(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const type_expression = self.state.?.ast.nodes.items(.components)[node].TypeExpression;\n    return m.MIR_new_uint_op(\n        self.ctx,\n        @constCast(self.state.?.ast.nodes.items(.type_def)[type_expression].?).toValue().val,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateTypeExpression",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateTypeOfExpression from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateTypeOfExpression(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const value = (try self.generateNode(self.state.?.ast.nodes.items(.components)[node].TypeOfExpression)).?;\n    const result = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"typeof\", m.MIR_T_I64),\n    );\n\n    try self.buildExternApiCall(\n        .bz_valueTypeOf,\n        result,\n        &[_]m.MIR_op_t{\n            value,\n            m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateTypeOfExpression",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildBinary from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildBinary(\n    self: *Self,\n    operator: Token.Type,\n    def_type: o.ObjTypeDef.Type,\n    left_value: m.MIR_op_t,\n    right_value: m.MIR_op_t,\n    dest: m.MIR_op_t,\n) Error!void {\n    const left = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\n            \"left\",\n            if (def_type == .Double) m.MIR_T_D else m.MIR_T_I64,\n        ),\n    );\n    const right = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\n            \"right\",\n            if (def_type == .Double) m.MIR_T_D else m.MIR_T_I64,\n        ),\n    );\n\n    if (def_type == .Integer) {\n        try self.unwrap(.Integer, left_value, left);\n        try self.unwrap(.Integer, right_value, right);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildBinary",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateBinary from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateBinary(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const node_components = self.state.?.ast.nodes.items(.components);\n    const components = node_components[node].Binary;\n\n    return switch (components.operator) {\n        .QuestionQuestion,\n        .And,\n        .Or,\n        => try self.generateConditional(components),\n        .Less,\n        .Greater,\n        .GreaterEqual,\n        .LessEqual,\n        .EqualEqual,\n        .BangEqual,\n        => try self.generateComparison(components),\n        else => bin: {\n            const type_defs = self.state.?.ast.nodes.items(.type_def);\n            const type_def = type_defs[components.left].?.def_type;\n\n            const left_value = (try self.generateNode(components.left)).?;\n            const right_value = (try self.generateNode(components.right)).?;\n\n            const res = m.MIR_new_reg_op(\n                self.ctx,\n                try self.REG(\"res\", m.MIR_T_I64),\n            );\n\n            try self.buildBinary(\n                components.operator,\n                type_def,\n                left_value,\n                right_value,\n                res,\n            );\n\n            break :bin res;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateBinary",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateComparison from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateComparison(self: *Self, components: Ast.Binary) Error!?m.MIR_op_t {\n    const type_defs = self.state.?.ast.nodes.items(.type_def);\n\n    const left_type_def = type_defs[components.left].?.def_type;\n    const right_type_def = type_defs[components.right].?.def_type;\n\n    const left_value = (try self.generateNode(components.left)).?;\n    const right_value = (try self.generateNode(components.right)).?;\n\n    const res = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"res\", m.MIR_T_I64),\n    );\n\n    var left = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"left\", if (left_type_def == .Double) m.MIR_T_D else m.MIR_T_I64),\n    );\n    var right = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"right\", if (right_type_def == .Double) m.MIR_T_D else m.MIR_T_I64),\n    );\n\n    if (left_type_def == .Integer) {\n        try self.unwrap(.Integer, left_value, left);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateComparison",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateConditional from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateConditional(self: *Self, binary: Ast.Binary) Error!?m.MIR_op_t {\n    const value = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"value\", m.MIR_T_I64),\n    );\n\n    self.MOV(\n        value,\n        (try self.generateNode(binary.left)).?,\n    );\n\n    const out_label = m.MIR_new_label(self.ctx);\n\n    self.BNE(\n        out_label,\n        value,\n        m.MIR_new_uint_op(\n            self.ctx,\n            switch (binary.operator) {\n                .QuestionQuestion => Value.Null.val,\n                .And => Value.True.val,\n                .Or => Value.False.val,\n                else => unreachable,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateConditional",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateBitwise from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateBitwise(self: *Self, binary: Ast.Binary) Error!?m.MIR_op_t {\n    const res = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"res\", m.MIR_T_I64),\n    );\n    const left = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"left\", m.MIR_T_I64),\n    );\n    const right = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"right\", m.MIR_T_I64),\n    );\n\n    try self.unwrap(\n        .Integer,\n        (try self.generateNode(binary.left)).?,\n        left,\n    );\n    try self.unwrap(\n        .Integer,\n        (try self.generateNode(binary.right)).?,\n        right,\n    );\n\n    switch (binary.operator) {\n        .Ampersand => self.AND(res, left, right),\n        .Bor => self.OR(res, left, right),\n        .Xor => self.XOR(res, left, right),\n        .ShiftLeft => self.SHL(res, left, right),\n        .ShiftRight => self.SHR(res, left, right),\n        else => unreachable,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateBitwise",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateWhile from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateWhile(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].While;\n    const condition_value = self.state.?.ast.nodes.items(.value)[components.condition];\n\n    if (condition_value != null and !condition_value.?.boolean()) {\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateWhile",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateDoUntil from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateDoUntil(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].DoUntil;\n\n    const out_label = m.MIR_new_label(self.ctx);\n    const loop_label = m.MIR_new_label(self.ctx);\n\n    const previous_out_label = self.state.?.break_label;\n    self.state.?.break_label = out_label;\n    const previous_continue_label = self.state.?.continue_label;\n    self.state.?.continue_label = loop_label;\n\n    if (components.label != null) {\n        try self.state.?.breaks_label.append(\n            self.vm.gc.allocator,\n            .{\n                .node = node,\n                .break_label = out_label,\n                .continue_label = loop_label,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateDoUntil",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateFor from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateFor(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].For;\n    const condition_value = self.state.?.ast.nodes.items(.value)[components.condition];\n\n    if (condition_value != null and !condition_value.?.boolean()) {\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateFor",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to findBreakLabel from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn findBreakLabel(self: *Self, node: Ast.Node.Index) Break {\n    var i = self.state.?.breaks_label.items.len - 1;\n    while (i >= 0) : (i -= 1) {\n        const brk = self.state.?.breaks_label.items[i];\n\n        if (brk.node == node) {\n            return brk;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "findBreakLabel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateBreak from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateBreak(self: *Self, break_node: Ast.Node.Index) Error!?m.MIR_op_t {\n    try self.closeScope(break_node);\n\n    if (self.state.?.ast.nodes.items(.components)[break_node].Break.destination) |label_node| {\n        self.JMP(self.findBreakLabel(label_node).break_label);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateBreak",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateContinue from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateContinue(self: *Self, continue_node: Ast.Node.Index) Error!?m.MIR_op_t {\n    try self.closeScope(continue_node);\n\n    if (self.state.?.ast.nodes.items(.components)[continue_node].Continue.destination) |label_node| {\n        self.JMP(self.findBreakLabel(label_node).continue_label);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateContinue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateList from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateList(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].List;\n    const type_def = self.state.?.ast.nodes.items(.type_def)[node];\n\n    const new_list = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"new_list\", m.MIR_T_I64),\n    );\n\n    try self.buildExternApiCall(\n        .bz_newList,\n        new_list,\n        &[_]m.MIR_op_t{\n            m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n            m.MIR_new_uint_op(self.ctx, type_def.?.toValue().val),\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateList",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateRange from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateRange(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].Range;\n\n    const new_range = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"new_range\", m.MIR_T_I64),\n    );\n\n    try self.buildExternApiCall(\n        .bz_newRange,\n        new_range,\n        &[_]m.MIR_op_t{\n            m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n            (try self.generateNode(components.low)).?,\n            (try self.generateNode(components.high)).?,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateRange",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateMap from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateMap(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].Map;\n    const type_def = self.state.?.ast.nodes.items(.type_def)[node];\n\n    const new_map = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"new_map\", m.MIR_T_I64),\n    );\n\n    try self.buildExternApiCall(\n        .bz_newMap,\n        new_map,\n        &[_]m.MIR_op_t{\n            m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n            m.MIR_new_uint_op(self.ctx, @constCast(type_def.?).toValue().val),\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateMap",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateDot from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateDot(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].Dot;\n    const type_defs = self.state.?.ast.nodes.items(.type_def);\n    const tags = self.state.?.ast.tokens.items(.tag);\n\n    const callee_type = type_defs[components.callee].?;\n    const member_lexeme = self.state.?.ast.tokens.items(.lexeme)[components.identifier];\n    const member_identifier = (try self.vm.gc.copyString(member_lexeme)).toValue().val;\n\n    switch (callee_type.def_type) {\n        .Fiber => {\n            switch (components.member_kind) {\n                .Call => return try self.generateCall(components.value_or_call_or_enum.Call),\n                else => {\n                    const res = m.MIR_new_reg_op(\n                        self.ctx,\n                        try self.REG(\"res\", m.MIR_T_I64),\n                    );\n                    try self.buildExternApiCall(\n                        .bz_getFiberProperty,\n                        res,\n                        &[_]m.MIR_op_t{\n                            m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n                            (try self.generateNode(components.callee)).?,\n                            m.MIR_new_uint_op(\n                                self.ctx,\n                                o.ObjFiber.members_name.get(member_lexeme).?,\n                            ),\n                            m.MIR_new_uint_op(self.ctx, 1),\n                        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateDot",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateSubscript from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateSubscript(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].Subscript;\n    const type_defs = self.state.?.ast.nodes.items(.type_def);\n\n    const subscripted = (try self.generateNode(components.subscripted)).?;\n    const index_val = (try self.generateNode(components.index)).?;\n    const value = if (components.value) |val| (try self.generateNode(val)).? else null;\n\n    switch (type_defs[components.subscripted].?.def_type) {\n        .List => {\n            const index = m.MIR_new_reg_op(\n                self.ctx,\n                try self.REG(\"index\", m.MIR_T_I64),\n            );\n\n            try self.unwrap(.Integer, index_val, index);\n\n            if (value) |val| {\n                try self.buildExternApiCall(\n                    .bz_listSet,\n                    null,\n                    &[_]m.MIR_op_t{\n                        subscripted,\n                        index,\n                        val,\n                        m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n                    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateSubscript",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateIs from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateIs(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].Is;\n\n    const res = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"res\", m.MIR_T_I64),\n    );\n\n    try self.buildExternApiCall(\n        .bz_valueIs,\n        res,\n        &[_]m.MIR_op_t{\n            (try self.generateNode(components.left)).?,\n            m.MIR_new_uint_op(\n                self.ctx,\n                self.state.?.ast.nodes.items(.value)[components.constant].?.val,\n            ),\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateIs",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateAs from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateAs(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].As;\n\n    const left = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"left\", m.MIR_T_I64),\n    );\n    self.MOV(\n        left,\n        (try self.generateNode(components.left)).?,\n    );\n\n    const res = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"res\", m.MIR_T_I64),\n    );\n\n    try self.buildExternApiCall(\n        .bz_valueIs,\n        res,\n        &[_]m.MIR_op_t{\n            left,\n            m.MIR_new_uint_op(\n                self.ctx,\n                self.state.?.ast.nodes.items(.value)[components.constant].?.val,\n            ),\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateAs",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateTry from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateTry(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].Try;\n    const type_defs = self.state.?.ast.nodes.items(.type_def);\n\n    const raise_label = m.MIR_new_label(self.ctx);\n    const out_label = m.MIR_new_label(self.ctx);\n    const catch_label = m.MIR_new_label(self.ctx);\n    var clause_labels = std.ArrayList(m.MIR_insn_t){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateTry",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateThrow from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateThrow(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].Throw;\n\n    if (components.unconditional) {\n        self.state.?.return_emitted = true;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateThrow",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateUnwrap from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateUnwrap(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].Unwrap;\n\n    const value = (try self.generateNode(components.unwrapped)).?;\n\n    // Remember that we need to had a terminator to this block that will jump at the end of the optionals chain\n    if (self.state.?.opt_jumps.items.len == 0 or components.start_opt_jumps) {\n        try self.state.?.opt_jumps.append(\n            self.vm.gc.allocator,\n            .{\n                // Store the value on the stack, that spot will be overwritten with the final value of the optional chain\n                .alloca = try self.REG(\"opt\", m.MIR_T_I64),\n                .current_insn = .{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateUnwrap",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateObjectInit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateObjectInit(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const lexemes = self.state.?.ast.tokens.items(.lexeme);\n    const components = self.state.?.ast.nodes.items(.components)[node].ObjectInit;\n    const type_defs = self.state.?.ast.nodes.items(.type_def);\n    const type_def = type_defs[node];\n\n    if (type_def.?.def_type == .ForeignContainer) {\n        return self.generateForeignContainerInit(node);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateObjectInit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateForeignContainerInit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateForeignContainerInit(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].ObjectInit;\n    const type_defs = self.state.?.ast.nodes.items(.type_def);\n    const type_def = type_defs[node];\n    const lexemes = self.state.?.ast.tokens.items(.lexeme);\n\n    const instance = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"instance\", m.MIR_T_I64),\n    );\n    try self.buildExternApiCall(\n        .bz_newForeignContainerInstance,\n        instance,\n        &[_]m.MIR_op_t{\n            m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n            m.MIR_new_uint_op(\n                self.ctx,\n                @constCast(type_def.?).toValue().val,\n            ),\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateForeignContainerInit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateForceUnwrap from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateForceUnwrap(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].ForceUnwrap;\n\n    const expr = (try self.generateNode(components.unwrapped)).?;\n\n    const out_label = m.MIR_new_label(self.ctx);\n\n    self.BNE(\n        out_label,\n        expr,\n        m.MIR_new_uint_op(self.ctx, Value.Null.val),\n    );\n\n    try self.buildExternApiCall(\n        .bz_throw,\n        null,\n        &[_]m.MIR_op_t{\n            m.MIR_new_reg_op(self.ctx, self.state.?.vm_reg.?),\n            m.MIR_new_uint_op(self.ctx, (try self.vm.gc.copyString(\"Force unwrapped optional is null\")).toValue().val),\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateForceUnwrap",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateUnary from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateUnary(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].Unary;\n    const left_type_def = self.state.?.ast.nodes.items(.type_def)[components.expression];\n\n    const left = (try self.generateNode(components.expression)).?;\n    const result = m.MIR_new_reg_op(\n        self.ctx,\n        try self.REG(\"result\", m.MIR_T_I64),\n    );\n\n    switch (components.operator) {\n        .Bnot => {\n            try self.unwrap(.Integer, left, result);\n            self.NOT(result, result);\n            try self.wrap(.Integer, result, result);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateUnary",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generatePattern from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generatePattern(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    return m.MIR_new_uint_op(\n        self.ctx,\n        self.state.?.ast.nodes.items(.components)[node].Pattern.toValue().val,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generatePattern",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateForEach from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateForEach(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].ForEach;\n    const iterable_type_def = self.state.?.ast.nodes.items(.type_def)[components.iterable];\n\n    // If iterable is empty constant, skip the node\n    if (self.state.?.ast.nodes.items(.value)[components.iterable]) |iterable| {\n        if (switch (iterable.obj().obj_type) {\n            .List => o.ObjList.cast(iterable.obj()).?.items.items.len == 0,\n            .Map => o.ObjMap.cast(iterable.obj()).?.map.count() == 0,\n            .String => o.ObjString.cast(iterable.obj()).?.string.len == 0,\n            .Enum => o.ObjEnum.cast(iterable.obj()).?.cases.len == 0,\n            .Range => o.ObjRange.cast(iterable.obj()).?.high == o.ObjRange.cast(iterable.obj()).?.low,\n            else => unreachable,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateForEach",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateBlock from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateBlock(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    for (self.state.?.ast.nodes.items(.components)[node].Block) |statement| {\n        _ = try self.generateNode(statement);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateBlock",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateBlockExpression from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateBlockExpression(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const statements = self.state.?.ast.nodes.items(.components)[node].BlockExpression;\n\n    var out_statement: ?m.MIR_op_t = null;\n    for (statements) |statement| {\n        out_statement = try self.generateNode(statement);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateBlockExpression",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateFunDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateFunDeclaration(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    return try self.generateFunction(\n        self.state.?.ast.nodes.items(.components)[node].FunDeclaration.function,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateFunDeclaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateVarDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateVarDeclaration(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].VarDeclaration;\n\n    // We should only declare locals\n    std.debug.assert(components.slot_type == .Local);\n\n    try self.buildPush(\n        if (components.value) |value|\n            (try self.generateNode(value)).?\n        else\n            m.MIR_new_uint_op(\n                self.ctx,\n                Value.Null.val,\n            ),\n    );\n\n    return null;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateVarDeclaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateFunction from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateFunction(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const components = self.state.?.ast.nodes.items(.components)[node].Function;\n    const function_signature = self.state.?.ast.nodes.items(.components)[components.function_signature.?].FunctionType;\n    const type_defs = self.state.?.ast.nodes.items(.type_def);\n\n    const function_def = type_defs[node].?.resolved_type.?.Function;\n    const function_type = function_def.function_type;\n\n    // Those are not allowed to be compiled\n    std.debug.assert(function_type != .Extern and function_type != .Script and function_type != .ScriptEntryPoint);\n\n    // Get fully qualified name of function\n    const qualified_name = try self.getQualifiedName(node, true);\n    defer self.vm.gc.allocator.free(qualified_name);\n\n    // If this is not the root function, we need to compile this later\n    if (self.state.?.ast_node != node) {\n        const nativefn_qualified_name = try self.getQualifiedName(node, false);\n        defer self.vm.gc.allocator.free(nativefn_qualified_name);\n\n        // Remember that we need to compile this function later\n        try self.functions_queue.put(self.vm.gc.allocator, node, null);\n\n        // For now declare it\n        const native_raw = m.MIR_new_import(self.ctx, @ptrCast(qualified_name));\n        const native = m.MIR_new_import(self.ctx, @ptrCast(nativefn_qualified_name));\n\n        // Call bz_closure\n        const dest = m.MIR_new_reg_op(\n            self.ctx,\n            try self.REG(\"result\", m.MIR_T_I64),\n        );\n\n        try self.buildExternApiCall(\n            .bz_closure,\n            dest,\n            &[_]m.MIR_op_t{\n                // ctx\n                m.MIR_new_reg_op(self.ctx, self.state.?.ctx_reg.?),\n                // function_node\n                m.MIR_new_uint_op(self.ctx, node),\n                m.MIR_new_ref_op(self.ctx, native),\n                m.MIR_new_ref_op(self.ctx, native_raw),\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateFunction",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateHotspotFunction from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateHotspotFunction(self: *Self, node: Ast.Node.Index) Error!?m.MIR_op_t {\n    const tag = self.state.?.ast.nodes.items(.tag)[node];\n\n    std.debug.assert(tag.isHotspot());\n\n    const qualified_name = try self.getQualifiedName(node, false);\n    defer self.vm.gc.allocator.free(qualified_name);\n\n    const ctx_name = self.vm.gc.allocator.dupeZ(u8, \"ctx\") catch {\n        self.vm.panic(\"Out of memory\");\n        unreachable;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateHotspotFunction",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to generateNativeFn from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn generateNativeFn(self: *Self, node: Ast.Node.Index, raw_fn: m.MIR_item_t) !m.MIR_item_t {\n    const type_defs = self.state.?.ast.nodes.items(.type_def);\n\n    const function_def = type_defs[node].?.resolved_type.?.Function;\n    const function_type = function_def.function_type;\n\n    std.debug.assert(function_type != .Extern);\n\n    const nativefn_qualified_name = try self.getQualifiedName(node, false);\n    defer self.vm.gc.allocator.free(nativefn_qualified_name);\n\n    // FIXME: I don't get why we need this: a simple constant becomes rubbish as soon as we enter MIR_new_func_arr if we don't\n    const ctx_name = self.vm.gc.allocator.dupeZ(u8, \"ctx\") catch {\n        self.vm.panic(\"Out of memory\");\n        unreachable;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "generateNativeFn",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getQualifiedName from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn getQualifiedName(self: *Self, node: Ast.Node.Index, raw: bool) ![]const u8 {\n    const tag = self.state.?.ast.nodes.items(.tag)[node];\n\n    switch (tag) {\n        .Function => {\n            const components = self.state.?.ast.nodes.items(.components)[node].Function;\n            const type_defs = self.state.?.ast.nodes.items(.type_def);\n\n            const function_def = type_defs[node].?.resolved_type.?.Function;\n            const function_type = function_def.function_type;\n            const name = function_def.name.string;\n\n            var qualified_name = std.ArrayList(u8){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "getQualifiedName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to compileZdefContainer from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "pub fn compileZdefContainer(self: *Self, ast: Ast.Slice, zdef_element: Ast.Zdef.ZdefElement) Error!void {\n    var wrapper_name = std.ArrayList(u8){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "compileZdefContainer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildBuzzValueToZigValue from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildBuzzValueToZigValue(self: *Self, buzz_type: *o.ObjTypeDef, zig_type: ZigType, buzz_value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    switch (zig_type) {\n        .Int => {\n            if (buzz_type.def_type == .Double) {\n                const tmp_float = m.MIR_new_reg_op(\n                    self.ctx,\n                    try self.REG(\"tmp_float\", m.MIR_T_D),\n                );\n\n                // This is a int represented by a buzz double value\n                try self.buildValueToDouble(buzz_value, tmp_float);\n\n                // Convert it back to an int\n                self.D2I(dest, tmp_float);\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildBuzzValueToZigValue",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildZigValueToBuzzValue from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildZigValueToBuzzValue(self: *Self, buzz_type: *o.ObjTypeDef, zig_type: ZigType, zig_value: m.MIR_op_t, dest: m.MIR_op_t) !void {\n    switch (zig_type) {\n        .Int => {\n            if (buzz_type.def_type == .Double) {\n                // This is a int represented by a buzz double value\n                const tmp_float = m.MIR_new_reg_op(\n                    self.ctx,\n                    try self.REG(\"tmp_float\", m.MIR_T_D),\n                );\n\n                // Convert it back to an int\n                if (zig_type.Int.signedness == .signed) {\n                    self.I2D(tmp_float, zig_value);\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildZigValueToBuzzValue",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to compileZdef from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "pub fn compileZdef(self: *Self, buzz_ast: Ast.Slice, zdef: Ast.Zdef.ZdefElement) Error!*o.ObjNative {\n    var wrapper_name = std.ArrayList(u8){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "compileZdef",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to zigToMIRType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn zigToMIRType(zig_type: ZigType) m.MIR_type_t {\n    return switch (zig_type) {\n        .Int => if (zig_type.Int.signedness == .signed)\n            switch (zig_type.Int.bits) {\n                8 => m.MIR_T_I8,\n                16 => m.MIR_T_I16,\n                32 => m.MIR_T_I32,\n                64 => m.MIR_T_I64,\n                else => unreachable,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "zigToMIRType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to zigToMIRRegType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn zigToMIRRegType(zig_type: ZigType) m.MIR_type_t {\n    return switch (zig_type) {\n        .Int, .Bool, .Pointer => m.MIR_T_I64,\n        .Double => switch (zig_type.Double.bits) {\n            32 => m.MIR_T_F,\n            64 => m.MIR_T_D,\n            else => unreachable,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "zigToMIRRegType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildZdefWrapper from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildZdefWrapper(self: *Self, zdef_element: Ast.Zdef.ZdefElement) Error!m.MIR_item_t {\n    var wrapper_name = std.ArrayList(u8){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildZdefWrapper",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildZdefUnionGetter from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildZdefUnionGetter(\n    self: *Self,\n    union_name: []const u8,\n    field_name: []const u8,\n    buzz_type: *o.ObjTypeDef,\n    zig_type: *const ZigType,\n) Error!m.MIR_item_t {\n    var getter_name = std.ArrayList(u8){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildZdefUnionGetter",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildZdefUnionSetter from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildZdefUnionSetter(\n    self: *Self,\n    union_name: []const u8,\n    field_name: []const u8,\n    buzz_type: *o.ObjTypeDef,\n    zig_type: *const ZigType,\n) Error!m.MIR_item_t {\n    var setter_name = std.ArrayList(u8){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildZdefUnionSetter",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildZdefContainerGetter from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildZdefContainerGetter(\n    self: *Self,\n    offset: usize,\n    struct_name: []const u8,\n    field_name: []const u8,\n    buzz_type: *o.ObjTypeDef,\n    zig_type: *const ZigType,\n) Error!m.MIR_item_t {\n    var getter_name = std.ArrayList(u8){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildZdefContainerGetter",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to buildZdefContainerSetter from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn buildZdefContainerSetter(\n    self: *Self,\n    offset: usize,\n    struct_name: []const u8,\n    field_name: []const u8,\n    buzz_type: *o.ObjTypeDef,\n    zig_type: *const ZigType,\n) Error!m.MIR_item_t {\n    var setter_name = std.ArrayList(u8){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "buildZdefContainerSetter",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to LOAD from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn LOAD(self: *Self, ptr: m.MIR_op_t) !m.MIR_op_t {\n    const reg = if (ptr.mode == m.MIR_OP_REG)\n        ptr.u.reg\n    else\n        try self.REG(\"ptr\", m.MIR_T_I64);\n\n    if (ptr.mode != m.MIR_OP_REG) {\n        self.MOV(\n            m.MIR_new_reg_op(self.ctx, reg),\n            ptr,\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "LOAD",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to append from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn append(self: *Self, inst: m.MIR_insn_t) void {\n    m.MIR_append_insn(\n        self.ctx,\n        self.state.?.function.?,\n        inst,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "append",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to MOV from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn MOV(self: *Self, dest: m.MIR_op_t, value: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.MOV),\n            2,\n            &[_]m.MIR_op_t{\n                dest,\n                value,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "MOV",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to DMOV from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn DMOV(self: *Self, dest: m.MIR_op_t, value: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.DMOV),\n            2,\n            &[_]m.MIR_op_t{\n                dest,\n                value,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "DMOV",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to FMOV from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn FMOV(self: *Self, dest: m.MIR_op_t, value: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.FMOV),\n            2,\n            &[_]m.MIR_op_t{\n                dest,\n                value,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "FMOV",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to EQ from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn EQ(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.EQ),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "EQ",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to EQS from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn EQS(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.EQS),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "EQS",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to DEQ from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn DEQ(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.DEQ),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "DEQ",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to GT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn GT(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.GT),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "GT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to GTS from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn GTS(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.GTS),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "GTS",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to DGT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn DGT(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.DGT),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "DGT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to LT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn LT(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.LT),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "LT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to LTS from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn LTS(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.LTS),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "LTS",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to DLT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn DLT(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.DLT),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "DLT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to GE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn GE(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.GE),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "GE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to GES from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn GES(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.GES),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "GES",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to DGE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn DGE(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.DGE),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "DGE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to LE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn LE(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.LE),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "LE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to LES from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn LES(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.LES),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "LES",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to DLE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn DLE(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.DLE),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "DLE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to NE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn NE(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.NE),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "NE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to NES from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn NES(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.NES),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "NES",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to DNE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn DNE(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.DNE),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "DNE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to BEQ from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn BEQ(self: *Self, label: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.BEQ),\n            3,\n            &[_]m.MIR_op_t{\n                label,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "BEQ",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to BLT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn BLT(self: *Self, label: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.BLT),\n            3,\n            &[_]m.MIR_op_t{\n                label,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "BLT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to BGT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn BGT(self: *Self, label: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.BGT),\n            3,\n            &[_]m.MIR_op_t{\n                label,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "BGT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to BNE from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn BNE(self: *Self, label: m.MIR_insn_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.BNE),\n            3,\n            &[_]m.MIR_op_t{\n                m.MIR_new_label_op(self.ctx, label),\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "BNE",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to JMP from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn JMP(self: *Self, label: m.MIR_insn_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.JMP),\n            1,\n            &[_]m.MIR_op_t{\n                m.MIR_new_label_op(self.ctx, label),\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "JMP",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ADD from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn ADD(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.ADD),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "ADD",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to DADD from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn DADD(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.DADD),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "DADD",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ADDS from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn ADDS(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.ADDS),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "ADDS",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to SUB from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn SUB(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.SUB),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "SUB",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to SUBS from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn SUBS(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.SUBS),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "SUBS",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to DSUB from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn DSUB(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.DSUB),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "DSUB",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to MUL from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn MUL(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.MUL),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "MUL",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to MULS from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn MULS(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.MULS),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "MULS",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to DMUL from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn DMUL(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.DMUL),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "DMUL",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to DIV from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn DIV(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.DIV),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "DIV",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to DIVS from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn DIVS(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.DIVS),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "DIVS",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to DDIV from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn DDIV(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.DDIV),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "DDIV",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to MOD from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn MOD(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.MOD),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "MOD",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to MODS from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn MODS(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.MODS),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "MODS",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to AND from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn AND(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.AND),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "AND",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ANDS from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn ANDS(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.ANDS),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "ANDS",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to OR from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn OR(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.OR),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "OR",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ORS from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn ORS(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.ORS),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "ORS",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to XOR from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn XOR(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.XOR),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "XOR",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to SHL from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn SHL(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.LSH),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "SHL",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to SHR from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn SHR(self: *Self, dest: m.MIR_op_t, left: m.MIR_op_t, right: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.RSH),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                left,\n                right,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "SHR",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to NOT from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn NOT(self: *Self, dest: m.MIR_op_t, value: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.XOR),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                value,\n                m.MIR_new_uint_op(self.ctx, std.math.maxInt(u64)),\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "NOT",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to NOTS from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn NOTS(self: *Self, dest: m.MIR_op_t, value: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.XORS),\n            3,\n            &[_]m.MIR_op_t{\n                dest,\n                value,\n                m.MIR_new_uint_op(self.ctx, std.math.maxInt(u64)),\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "NOTS",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to I2D from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn I2D(self: *Self, dest: m.MIR_op_t, value: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.I2D),\n            2,\n            &[_]m.MIR_op_t{\n                dest,\n                value,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "I2D",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to UI2D from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn UI2D(self: *Self, dest: m.MIR_op_t, value: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.UI2D),\n            2,\n            &[_]m.MIR_op_t{\n                dest,\n                value,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "UI2D",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to D2I from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn D2I(self: *Self, dest: m.MIR_op_t, value: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.D2I),\n            2,\n            &[_]m.MIR_op_t{\n                dest,\n                value,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "D2I",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to NEG from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn NEG(self: *Self, dest: m.MIR_op_t, value: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.NEG),\n            2,\n            &[_]m.MIR_op_t{\n                dest,\n                value,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "NEG",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to DNEG from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn DNEG(self: *Self, dest: m.MIR_op_t, value: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.DNEG),\n            2,\n            &[_]m.MIR_op_t{\n                dest,\n                value,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "DNEG",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to RET from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn RET(self: *Self, return_value: m.MIR_op_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.RET),\n            1,\n            &[_]m.MIR_op_t{\n                return_value,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "RET",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ALLOCA from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn ALLOCA(self: *Self, reg: m.MIR_reg_t, size: usize) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.ALLOCA),\n            2,\n            &[_]m.MIR_op_t{\n                m.MIR_new_reg_op(self.ctx, reg),\n                m.MIR_new_uint_op(self.ctx, size),\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "ALLOCA",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to BSTART from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn BSTART(self: *Self, into: m.MIR_reg_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.BSTART),\n            1,\n            &[_]m.MIR_op_t{\n                m.MIR_new_reg_op(self.ctx, into),\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "BSTART",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to BEND from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn BEND(self: *Self, from: m.MIR_reg_t) void {\n    self.append(\n        m.MIR_new_insn_arr(\n            self.ctx,\n            @intFromEnum(m.MIR_Instruction.BEND),\n            1,\n            &[_]m.MIR_op_t{\n                m.MIR_new_reg_op(self.ctx, from),\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "BEND",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to REG from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn REG(self: *Self, name: [*:0]const u8, reg_type: m.MIR_type_t) !m.MIR_reg_t {\n    var actual_name = std.ArrayList(u8){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "REG",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to outputModule from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "fn outputModule(self: *Self, name: []const u8, module: m.MIR_module_t) void {\n    // Output MIR code to .mir file\n    var debug_path = std.ArrayList(u8){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "outputModule",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fmod from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "pub fn fmod(lhs: v.Double, rhs: v.Double) Value {\n    return Value.fromDouble(@mod(lhs, rhs));\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "fmod",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dumpInt from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "pub fn dumpInt(value: u64) void {\n    io.print(\"\\nvalue: {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "function",
      "name": "dumpInt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to OptJump from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "const OptJump = struct {\n    current_insn: std.ArrayList(m.MIR_insn_t),\n    alloca: m.MIR_reg_t,\n\n    pub fn deinit(self: *OptJump, allocator: std.mem.Allocator) void {\n        self.current_insn.deinit(allocator);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "struct",
      "name": "OptJump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Break from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "const Break = struct {\n    break_label: m.MIR_insn_t,\n    continue_label: m.MIR_insn_t,\n    node: Ast.Node.Index,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "struct",
      "name": "Break",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to GenState from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "const GenState = struct {\n    module: m.MIR_module_t,\n    prototypes: std.AutoHashMapUnmanaged(ExternApi, m.MIR_item_t) = .empty,\n\n    /// Root closure (not necessarily the one being compiled)\n    closure: *o.ObjClosure,\n    opt_jumps: std.ArrayList(OptJump) = .empty,\n\n    // Frame related stuff, since we compile one function at a time, we don't stack frames while compiling\n    ast: Ast.Slice,\n    ast_node: Ast.Node.Index,\n    return_counts: bool = false,\n    return_emitted: bool = false,\n\n    try_should_handle: ?std.AutoHashMapUnmanaged(*o.ObjTypeDef, void) = null,\n\n    function: ?m.MIR_item_t = null,\n    function_native: ?m.MIR_item_t = null,\n    function_native_proto: ?m.MIR_item_t = null,\n\n    /// Convenience registers\n    ctx_reg: ?m.MIR_reg_t = null,\n    vm_reg: ?m.MIR_reg_t = null,\n\n    /// Avoid register name collisions\n    registers: std.AutoHashMapUnmanaged([*:0]const u8, usize) = .empty,\n\n    /// Label to jump to when breaking a loop without a label\n    break_label: m.MIR_insn_t = null,\n    /// Label to jump to when continuing a loop whithout a label\n    continue_label: m.MIR_insn_t = null,\n\n    breaks_label: Breaks = .empty,\n\n    pub fn deinit(self: *GenState, allocator: std.mem.Allocator) void {\n        self.prototypes.deinit(allocator);\n        self.registers.deinit(allocator);\n        if (self.try_should_handle) |*try_should_handle| {\n            try_should_handle.deinit(allocator);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "struct",
      "name": "GenState",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to CompiledFunction from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "const CompiledFunction = struct {\n    native: *anyopaque,\n    native_raw: *anyopaque,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "struct",
      "name": "CompiledFunction",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to off from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Jit.zig",
    "response": "const off: usize = if (dest != null) 3 else 2;",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Jit.zig",
      "type": "const",
      "name": "off",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn init(\n    gc: *GC,\n    imports: *std.StringHashMapUnmanaged(ScriptImport),\n    imported: bool,\n    flavor: RunFlavor,\n) Self {\n    return .{\n        .gc = gc,\n        .imports = imports,\n        .script_imports = .{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn deinit(self: *Self) void {\n    // for (self.globals.items) |global| {\n    //     self.gc.allocator.free(global.name);\n    // }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to dlerror from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn dlerror() callconv(.c) [*:0]u8;\n\npub fn defaultBuzzPrefix() []const u8 {\n    return \".\";\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "dlerror",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buzzPrefix from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn buzzPrefix(allocator: std.mem.Allocator) error{OutOfMemory}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "buzzPrefix",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to buzzLibPath from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn buzzLibPath(allocator: std.mem.Allocator) ![]const u8 {\n    const path2 = try buzzPrefix(allocator);\n    const sep = std.fs.path.sep_str;\n    return std.fmt.bufPrint(\n        &_buzz_path_buffer2,\n        \"{s}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "buzzLibPath",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to isReferenced from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn isReferenced(self: Local, ast: Ast) bool {\n        const lexemes = ast.tokens.items(.lexeme);\n        return self.referenced or\n            self.type_def.def_type == .Void or\n            self.type_def.def_type == .Placeholder or\n            lexemes[self.name][0] == '$' or\n            (lexemes[self.name][0] == '_' and lexemes[self.name].len == 1);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "isReferenced",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isAssigned from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn isAssigned(self: Local, ast: Ast) bool {\n        const name = ast.tokens.items(.lexeme)[self.name];\n        return self.final or\n            self.assigned or\n            std.mem.eql(u8, name, \"_\") or\n            std.mem.startsWith(u8, name, \"$\") or\n            std.mem.eql(u8, name, \"this\");\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "isAssigned",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isReferenced from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn isReferenced(self: Global, ast: Ast) bool {\n        const lexemes = ast.tokens.items(.lexeme);\n        const function_type = if (self.type_def.def_type == .Function)\n            self.type_def.resolved_type.?.Function.function_type\n        else\n            null;\n\n        return self.referenced or\n            self.type_def.def_type == .Void or\n            self.type_def.def_type == .Placeholder or\n            (function_type == .Extern or function_type == .Abstract or function_type == .EntryPoint or function_type == .ScriptEntryPoint or function_type != .Repl) or\n            lexemes[self.name[self.name.len - 1]][0] == '$' or\n            (lexemes[self.name[self.name.len - 1]][0] == '_' and lexemes[self.name[self.name.len - 1]].len == 1) or\n            self.exported;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "isReferenced",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to match from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn match(self: Global, ast: Ast, qualified: []const Ast.TokenIndex, name: ?Ast.TokenIndex) bool {\n        if (self.name.len != qualified.len + 1) {\n            return false;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "match",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to matchName from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn matchName(self: Global, ast: Ast, namespace: []const Ast.TokenIndex, name: Ast.TokenIndex) bool {\n        return self.match(ast, namespace, name);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "matchName",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to matchNamespace from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn matchNamespace(self: Global, ast: Ast, namespace: []const Ast.TokenIndex) bool {\n        return self.match(ast, namespace, null);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "matchNamespace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn deinit(self: *Frame, allocator: std.mem.Allocator) void {\n        self.scopes.deinit(allocator);\n        // self.generics ends up in AST node so we don't deinit it\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveGeneric from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn resolveGeneric(self: Frame, name: *obj.ObjString) ?*obj.ObjTypeDef {\n        if (self.generics) |generics| {\n            if (generics.get(name)) |type_def| {\n                return type_def;\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "resolveGeneric",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reportErrorAtNode from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn reportErrorAtNode(self: *Self, error_type: Reporter.Error, node: Ast.Node.Index, comptime fmt: []const u8, args: anytype) void {\n    self.reporter.reportErrorFmt(\n        error_type,\n        self.ast.tokens.get(self.ast.nodes.items(.location)[node]),\n        self.ast.tokens.get(self.ast.nodes.items(.end_location)[node]),\n        fmt,\n        args,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "reportErrorAtNode",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to advance from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn advance(self: *Self) !void {\n    if (self.current_token != null and self.ast.tokens.items(.tag)[self.current_token.?] == .Eof) {\n        return;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "advance",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to advancePastEof from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn advancePastEof(self: *Self) !void {\n    self.current_token = if (self.current_token) |ct| ct + 1 else 0;\n\n    if (self.current_token.? >= self.ast.tokens.len) {\n        while (true) {\n            const new_token = try self.scanner.?.scanToken();\n\n            if (new_token.tag == .Error) {\n                self.current_token = if (self.current_token) |ct| ct - 1 else 0;\n                self.reporter.reportErrorFmt(\n                    .unknown,\n                    self.ast.tokens.get(self.current_token.? - 1),\n                    self.ast.tokens.get(self.current_token.? - 1),\n                    \"{s}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "advancePastEof",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to consume from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn consume(self: *Self, tag: Token.Type, comptime message: []const u8) !void {\n    if (self.ast.tokens.items(.tag)[self.current_token.?] == tag) {\n        try self.advance();\n        return;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "consume",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to check from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn check(self: *Self, tag: Token.Type) bool {\n    return self.ast.tokens.items(.tag)[self.current_token.?] == tag;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "check",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to checkAhead from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn checkAhead(self: *Self, tag: Token.Type, n: usize) !bool {\n    // Parse tokens if we didn't already look that far ahead\n    while (n + 1 > self.ast.tokens.len - self.current_token.? - 1) {\n        while (true) {\n            const token = try self.scanner.?.scanToken();\n            _ = try self.ast.appendToken(token);\n\n            if (token.tag == .Eof) {\n                return false;\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "checkAhead",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to match from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn match(self: *Self, tag: Token.Type) !bool {\n    if (!self.check(tag)) {\n        return false;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "match",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to matchOpEqual from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn matchOpEqual(self: *Self) !bool {\n    return try self.match(.Equal) or\n        try self.match(.PlusEqual) or\n        try self.match(.MinusEqual) or\n        try self.match(.StarEqual) or\n        try self.match(.SlashEqual) or\n        try self.match(.ShiftRightEqual) or\n        try self.match(.ShiftLeftEqual) or\n        try self.match(.XorEqual) or\n        try self.match(.BorEqual) or\n        try self.match(.BnotEqual) or\n        try self.match(.AmpersandEqual) or\n        try self.match(.PercentEqual);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "matchOpEqual",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to insertUtilityToken from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn insertUtilityToken(self: *Self, token: Token, set_location: bool) !Ast.TokenIndex {\n    const current_token = self.ast.tokens.get(self.current_token.?);\n\n    var utility_token = token;\n    if (set_location) {\n        utility_token.line = current_token.line;\n        utility_token.column = current_token.column;\n        utility_token.offset = current_token.offset;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "insertUtilityToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to synchronize from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn synchronize(self: *Self) !void {\n    self.reporter.panic_mode = false;\n\n    while (self.ast.tokens.items(.tag)[self.current_token.?] != .Eof) : (try self.advance()) {\n        if (self.ast.tokens.items(.tag)[self.current_token.? - 1] == .Semicolon) {\n            return;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "synchronize",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parse from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn parse(self: *Self, source: []const u8, file_name: ?[]const u8, name: []const u8) !?Ast {\n    if (self.scanner != null) {\n        self.scanner = null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "parse",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to beginFrame from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn beginFrame(self: *Self, function_type: obj.ObjFunction.FunctionType, function_node: Ast.Node.Index, this: ?*obj.ObjTypeDef) !void {\n    const enclosing = self.current;\n    // FIXME: is this ever deallocated?\n    self.current = try self.gc.allocator.create(Frame);\n    self.current.?.* = Frame{\n        .locals = [_]Local{undefined}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "beginFrame",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to endFrame from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn endFrame(self: *Self) Ast.Node.Index {\n    var i: usize = 0;\n    while (i < self.current.?.local_count) : (i += 1) {\n        const local = self.current.?.locals[i];\n\n        if (self.flavor != .Repl) {\n            // Check discarded locals\n            if (!local.isReferenced(self.ast)) {\n                const location = self.ast.tokens.get(local.name);\n                self.reporter.warnFmt(\n                    .unused_argument,\n                    location,\n                    location,\n                    \"Local `{s}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "endFrame",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to beginScope from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn beginScope(self: *Self, at: ?Ast.Node.Index) !void {\n    try self.current.?.scopes.append(self.gc.allocator, at);\n    self.current.?.scope_depth += 1;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "beginScope",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to endScope from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn endScope(self: *Self) ![]Chunk.OpCode {\n    const current = self.current.?;\n    _ = current.scopes.pop();\n    var closing = std.ArrayList(Chunk.OpCode).empty;\n    current.scope_depth -= 1;\n\n    while (current.local_count > 0 and current.locals[current.local_count - 1].depth > current.scope_depth) {\n        const local = current.locals[current.local_count - 1];\n\n        if (local.captured) {\n            try closing.append(self.gc.allocator, .OP_CLOSE_UPVALUE);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "endScope",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to closeScope from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn closeScope(self: *Self, upto_depth: usize) ![]Chunk.OpCode {\n    const current = self.current.?;\n    var closing = std.ArrayList(Chunk.OpCode).empty;\n\n    var local_count = current.local_count;\n    while (local_count > 0 and current.locals[local_count - 1].depth > upto_depth - 1) {\n        if (current.locals[local_count - 1].captured) {\n            try closing.append(self.gc.allocator, .OP_CLOSE_UPVALUE);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "closeScope",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getRule from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn getRule(token: Token.Type) ParseRule {\n    return rules[@intFromEnum(token)];\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "getRule",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parsePrecedence from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn parsePrecedence(self: *Self, precedence: Precedence, hanging: bool) Error!Ast.Node.Index {\n    // In case we are already parsing an expression, the current unwrap chain should not impact deeper expressions\n    // Exemple: canBeNull?.aMap[expression] <- here `expression` should not be transformed into an optional\n    const previous_opt_jumps = self.opt_jumps;\n    self.opt_jumps = null;\n\n    // If hanging is true, that means we already read the start of the expression\n    if (!hanging) {\n        _ = try self.advance();\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "parsePrecedence",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to block from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn block(self: *Self, loop_scope: ?LoopScope) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    var statements = std.ArrayList(Ast.Node.Index).empty;\n    while (!self.check(.RightBrace) and !self.check(.Eof)) {\n        if (try self.declarationOrStatement(loop_scope)) |declOrStmt| {\n            try statements.append(self.gc.allocator, declOrStmt);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "block",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to simpleType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn simpleType(self: *Self, def_type: obj.ObjTypeDef.Type) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n    const optional = try self.match(.Question);\n\n    return try self.ast.appendNode(\n        .{\n            .tag = .SimpleType,\n            .location = start_location,\n            .end_location = self.current_token.? - 1,\n            .type_def = try self.gc.type_registry.getTypeDef(\n                .{\n                    .def_type = def_type,\n                    .optional = optional,\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "simpleType",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to simpleTypeFromToken from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn simpleTypeFromToken(token: Token.Type) ?obj.ObjTypeDef.Type {\n    return switch (token) {\n        .Pat => .Pattern,\n        .Ud => .UserData,\n        .Str => .String,\n        .Int => .Integer,\n        .Double => .Double,\n        .Bool => .Bool,\n        .Range => .Range,\n        .Type => .Type,\n        .Any => .Any,\n        else => null,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "simpleTypeFromToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to declaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn declaration(self: *Self, docblock: ?Ast.TokenIndex) Error!?Ast.Node.Index {\n    const global_scope = self.current.?.scope_depth == 0;\n\n    const node = if (try self.match(.Object))\n        try self.objectDeclaration()\n    else if (try self.match(.Protocol))\n        try self.protocolDeclaration()\n    else if (try self.match(.Enum))\n        try self.enumDeclaration()\n    else if ((try self.match(.Fun)) or (global_scope and try self.match(.Extern)))\n        try self.funDeclaration()\n    else if ((try self.match(.Final)) or\n        (try self.match(.Var) or\n            (self.check(.Identifier) and std.mem.eql(u8, \"_\", self.ast.tokens.items(.lexeme)[self.current_token.?]))))\n    variable: {\n        const final = self.current_token.? > 0 and self.ast.tokens.items(.tag)[self.current_token.? - 1] == .Final;\n        try self.consume(.Identifier, \"Expected identifier\");\n        const identifier = self.current_token.? - 1;\n        const dismiss_identifier = std.mem.eql(u8, \"_\", self.ast.tokens.items(.lexeme)[identifier]);\n\n        // Type omitted?\n        if (!(try self.match(.Colon))) {\n            break :variable try self.varDeclaration(\n                identifier,\n                null,\n                .Semicolon,\n                final,\n                dismiss_identifier,\n                true,\n                false,\n            );\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "declaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to declarationOrStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn declarationOrStatement(self: *Self, loop_scope: ?LoopScope) !?Ast.Node.Index {\n    const global_scope = self.current.?.scope_depth == 0;\n    const docblock = if (global_scope and try self.match(.Docblock))\n        self.current_token.? - 1\n    else\n        null;\n\n    return try self.declaration(docblock) orelse\n        try self.statement(\n            docblock,\n            false,\n            loop_scope,\n        );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "declarationOrStatement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to statement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn statement(self: *Self, docblock: ?Ast.TokenIndex, hanging: bool, loop_scope: ?LoopScope) !?Ast.Node.Index {\n    const global_scope = self.current.?.scope_depth == 0;\n    const statement_allowed = self.flavor == .Repl or !global_scope;\n\n    if (statement_allowed) {\n        if (try self.match(.If)) {\n            std.debug.assert(!hanging);\n            return try self.ifStatement(loop_scope);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "statement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addLocal from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn addLocal(self: *Self, node: Ast.Node.Index, name: Ast.TokenIndex, local_type: *obj.ObjTypeDef, final: bool, mutable: bool) Error!usize {\n    if (self.current.?.local_count == std.math.maxInt(u8)) {\n        const location = self.ast.tokens.get(name);\n        self.reporter.reportErrorAt(\n            .locals_count,\n            location,\n            location,\n            \"Too many local variables in scope.\",\n        );\n        return 0;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "addLocal",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveReferrer from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn resolveReferrer(self: *Self, referrer: Ast.Node.Index, definition: Ast.Node.Index) Error!void {\n    std.debug.assert(definition != 0);\n    switch (self.ast.nodes.items(.tag)[referrer]) {\n        .NamedVariable => {\n            self.ast.nodes.items(.components)[referrer].NamedVariable.definition = definition;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "resolveReferrer",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to addGlobal from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn addGlobal(\n    self: *Self,\n    node: Ast.Node.Index,\n    name: Ast.TokenIndex,\n    global_type: *obj.ObjTypeDef,\n    final: bool,\n    mutable: bool,\n) Error!usize {\n    const lexemes = self.ast.tokens.items(.lexeme);\n    // Search for an existing placeholder global with the same name\n    for (self.globals.items, 0..) |*global, index| {\n        if (global.type_def.def_type == .Placeholder and\n            (self.namespace == null or global.matchNamespace(self.ast, self.namespace.?)) and\n            std.mem.eql(u8, lexemes[global.name[global.name.len - 1]], lexemes[name]))\n        {\n            global.exported = self.exporting;\n\n            if (global_type.def_type != .Placeholder) {\n                try self.resolvePlaceholder(global.type_def, global_type, final);\n\n                if (self.flavor == .Ast) {\n                    for (global.placeholder_referrers.items) |referrer| {\n                        try self.resolveReferrer(referrer, node);\n                    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "addGlobal",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveGeneric from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn resolveGeneric(self: *Self, name: *obj.ObjString) ?*obj.ObjTypeDef {\n    return if (self.current_object != null and self.current_object.?.generics != null)\n        self.current_object.?.generics.?.get(name) orelse self.current.?.resolveGeneric(name)\n    else\n        self.current.?.resolveGeneric(name);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "resolveGeneric",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveLocal from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn resolveLocal(self: *Self, frame: *Frame, name: Ast.TokenIndex) !?usize {\n    if (frame.local_count == 0) {\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "resolveLocal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveGlobal from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn resolveGlobal(self: *Self, referrer: Ast.Node.Index, name: []const Ast.TokenIndex) Error!?usize {\n    if (self.globals.items.len == 0) {\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "resolveGlobal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolvePlaceholderWithRelation from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn resolvePlaceholderWithRelation(\n    self: *Self,\n    child: *obj.ObjTypeDef,\n    resolved_type: *obj.ObjTypeDef,\n    final: bool,\n    relation: obj.PlaceholderDef.PlaceholderRelation,\n) Error!void {\n    const child_placeholder = child.resolved_type.?.Placeholder;\n    const child_placeholder_name = self.ast.tokens.items(.lexeme)[child_placeholder.where];\n\n    if (BuildOptions.debug_placeholders) {\n        io.print(\n            \"Attempts to resolve @{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "resolvePlaceholderWithRelation",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolvePlaceholder from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn resolvePlaceholder(self: *Self, placeholder: *obj.ObjTypeDef, resolved_type: *obj.ObjTypeDef, final: bool) Error!void {\n    std.debug.assert(placeholder.def_type == .Placeholder);\n\n    if (BuildOptions.debug_placeholders) {\n        io.print(\"Attempts to resolve @{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "resolvePlaceholder",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to addUpvalue from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn addUpvalue(self: *Self, node: Ast.Node.Index, frame: *Frame, index: usize, is_local: bool) Error!usize {\n    const upvalue_count: u8 = frame.upvalue_count;\n\n    var i: usize = 0;\n    while (i < upvalue_count) : (i += 1) {\n        const upvalue: *UpValue = &frame.upvalues[i];\n        if (upvalue.index == index and upvalue.is_local == is_local) {\n            return i;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "addUpvalue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveUpvalue from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn resolveUpvalue(self: *Self, frame: *Frame, name: Ast.TokenIndex) Error!?usize {\n    if (frame.enclosing == null) {\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "resolveUpvalue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to declareVariable from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn declareVariable(\n    self: *Self,\n    node: Ast.Node.Index,\n    variable_type: *obj.ObjTypeDef,\n    name: Ast.TokenIndex,\n    final: bool,\n    mutable: bool,\n    check_name: bool,\n) Error!usize {\n    const lexemes = self.ast.tokens.items(.lexeme);\n    const name_lexeme = lexemes[name];\n\n    if (self.current.?.scope_depth > 0) {\n        // Check a local with the same name doesn't exists\n        if (self.current.?.local_count > 0) {\n            var i: usize = self.current.?.local_count - 1;\n            while (check_name and i >= 0) : (i -= 1) {\n                const local: *Local = &self.current.?.locals[i];\n\n                if (local.depth != -1 and local.depth < self.current.?.scope_depth) {\n                    break;\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "declareVariable",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseVariable from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn parseVariable(\n    self: *Self,\n    node: Ast.Node.Index,\n    identifier: ?Ast.TokenIndex,\n    variable_type: *obj.ObjTypeDef,\n    final: bool,\n    mutable: bool,\n    comptime error_message: []const u8,\n) !usize {\n    if (identifier == null) {\n        try self.consume(.Identifier, error_message);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "parseVariable",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to markInitialized from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn markInitialized(self: *Self) void {\n    if (self.current.?.scope_depth == 0) {\n        self.globals.items[self.globals.items.len - 1].initialized = true;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "markInitialized",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to declarePlaceholder from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn declarePlaceholder(self: *Self, name: Ast.TokenIndex, placeholder: ?*obj.ObjTypeDef) Error!usize {\n    var placeholder_type: *obj.ObjTypeDef = undefined;\n\n    if (placeholder) |uplaceholder| {\n        placeholder_type = uplaceholder;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "declarePlaceholder",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseTypeDefFrom from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn parseTypeDefFrom(self: *Self, source: []const u8) Error!*obj.ObjTypeDef {\n    const type_scanner = Scanner.init(self.gc.allocator, self.script_name, source);\n    // Replace parser scanner with one that only looks at that substring\n    const scanner = self.scanner;\n    self.scanner = type_scanner;\n    const current_token = self.current_token;\n    const tokens_count = self.ast.tokens.len;\n\n    // If Eof, manually add new token\n    if (self.ast.tokens.items(.tag)[self.current_token.?] == .Eof) {\n        _ = try self.ast.appendToken(try self.scanner.?.scanToken());\n        self.current_token = self.current_token.? + 1;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "parseTypeDefFrom",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseTypeDef from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn parseTypeDef(\n    self: *Self,\n    generic_types: ?std.AutoArrayHashMapUnmanaged(*obj.ObjString, *obj.ObjTypeDef),\n    instance: bool,\n) Error!Ast.Node.Index {\n    const mutable = try self.match(.Mut);\n    const mutable_token = if (mutable) self.current_token.? else null;\n\n    if (try self.match(.Str)) {\n        const optional = try self.match(.Question);\n\n        if (mutable) {\n            self.reporter.report(\n                .mutable_forbidden,\n                self.ast.tokens.get(mutable_token.?),\n                self.ast.tokens.get(self.current_token.? - 1),\n                \"`str` can't be mutable\",\n            );\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "parseTypeDef",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseFiberType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn parseFiberType(self: *Self, generic_types: ?std.AutoArrayHashMapUnmanaged(*obj.ObjString, *obj.ObjTypeDef)) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    try self.consume(.Less, \"Expected `<` after `fib`\");\n    const return_type = try self.parseTypeDef(generic_types, true);\n    try self.consume(.Comma, \"Expected `,` after fiber return type\");\n    const yield_type = try self.parseTypeDef(generic_types, true);\n\n    const yield_type_def = self.ast.nodes.items(.type_def)[yield_type].?;\n    if (!yield_type_def.optional and yield_type_def.def_type != .Void) {\n        self.reportErrorAtNode(\n            .yield_type,\n            yield_type,\n            \"Expected optional type or void\",\n            .{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "parseFiberType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseListType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn parseListType(self: *Self, generic_types: ?std.AutoArrayHashMapUnmanaged(*obj.ObjString, *obj.ObjTypeDef), mutable: bool) Error!Ast.Node.Index {\n    const start_location = if (mutable) self.current_token.? - 2 else self.current_token.? - 1;\n    const item_type = try self.parseTypeDef(generic_types, true);\n\n    try self.consume(.RightBracket, \"Expected `]` after list type.\");\n\n    const list_type_def = try self.gc.type_registry.getTypeDef(\n        .{\n            .optional = try self.match(.Question),\n            .def_type = .List,\n            .resolved_type = .{\n                .List = obj.ObjList.ListDef.init(\n                    self.ast.nodes.items(.type_def)[item_type].?,\n                    mutable,\n                ),\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "parseListType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseMapType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn parseMapType(self: *Self, generic_types: ?std.AutoArrayHashMapUnmanaged(*obj.ObjString, *obj.ObjTypeDef), mutable: bool) Error!Ast.Node.Index {\n    const start_location = if (mutable) self.current_token.? - 2 else self.current_token.? - 1;\n\n    const key_type = try self.parseTypeDef(generic_types, true);\n\n    try self.consume(.Colon, \"Expected `:` after key type.\");\n\n    const value_type = try self.parseTypeDef(generic_types, true);\n\n    try self.consume(.RightBrace, \"Expected `}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "parseMapType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseFunctionType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn parseFunctionType(self: *Self, parent_generic_types: ?std.AutoArrayHashMapUnmanaged(*obj.ObjString, *obj.ObjTypeDef)) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n    const tag = self.ast.tokens.items(.tag)[start_location];\n\n    std.debug.assert(tag == .Fun or tag == .Extern);\n\n    const is_extern = tag == .Extern;\n\n    if (is_extern) {\n        try self.consume(.Fun, \"Expected `fun` after `extern`.\");\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "parseFunctionType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseObjType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn parseObjType(self: *Self, generic_types: ?std.AutoArrayHashMapUnmanaged(*obj.ObjString, *obj.ObjTypeDef)) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    try self.consume(.LeftBrace, \"Expected `{` after `obj`\");\n\n    const qualifier = try std.mem.replaceOwned(u8, self.gc.allocator, self.script_name, \"/\", \".\");\n    defer self.gc.allocator.free(qualifier);\n    var qualified_name = std.ArrayList(u8).empty;\n    defer qualified_name.deinit(self.gc.allocator);\n    try qualified_name.writer(self.gc.allocator).print(\"{s}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "parseObjType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseUserType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn parseUserType(self: *Self, instance: bool, mutable: bool) Error!Ast.Node.Index {\n    const node_slot = try self.ast.nodes.addOne(self.ast.allocator);\n\n    const user_type_name = try self.qualifiedName();\n    var var_type: ?*obj.ObjTypeDef = null;\n    var global_slot: ?usize = null;\n\n    // Search for a global with that name\n    if (try self.resolveGlobal(@intCast(node_slot), user_type_name)) |slot| {\n        const global = self.globals.items[slot];\n\n        var_type = global.type_def;\n        global_slot = @intCast(slot);\n\n        if (global.imported_from != null and self.script_imports.get(global.imported_from.?) != null) {\n            const imported_from = global.imported_from.?;\n\n            try self.script_imports.put(\n                self.gc.allocator,\n                imported_from,\n                .{\n                    .location = self.script_imports.get(imported_from).?.location,\n                    .end_location = self.script_imports.get(imported_from).?.end_location,\n                    .referenced = true,\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "parseUserType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to parseGenericResolve from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn parseGenericResolve(self: *Self, callee_type_def: *obj.ObjTypeDef, expr: ?Ast.Node.Index) Error!Ast.Node.Index {\n    const start_location = if (expr) |e|\n        self.ast.nodes.items(.location)[e]\n    else\n        self.current_token.? - 1;\n\n    var resolved_generics = std.ArrayList(Ast.Node.Index).empty;\n    var resolved_generics_types = std.ArrayList(*obj.ObjTypeDef).empty;\n\n    try self.consume(.Less, \"Expected `<` at start of generic types list\");\n\n    while (!self.check(.Greater) and !self.check(.Eof)) {\n        const resolved_generic = try self.parseTypeDef(null, true);\n\n        if (callee_type_def.def_type == .Any) {\n            self.reportErrorAtNode(\n                .any_generic,\n                resolved_generic,\n                \"`any` not allowed as generic type\",\n                .{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "parseGenericResolve",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to subscript from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn subscript(self: *Self, can_assign: bool, subscripted: Ast.Node.Index) Error!Ast.Node.Index {\n    const start_location = self.ast.nodes.items(.location)[subscripted];\n\n    const subscript_type_def = self.ast.nodes.items(.type_def)[subscripted];\n    const checked = try self.match(.Question);\n    const index = try self.expression(false);\n    const index_type_def = self.ast.nodes.items(.type_def)[index];\n\n    const type_defs = self.ast.nodes.items(.type_def);\n    if (subscript_type_def.?.def_type == .Placeholder and index_type_def.?.def_type == .Placeholder) {\n        try obj.PlaceholderDef.link(\n            self.gc.allocator,\n            type_defs[subscripted].?,\n            type_defs[index].?,\n            .Key,\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "subscript",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to expression from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub fn expression(self: *Self, hanging: bool) Error!Ast.Node.Index {\n    return try self.parsePrecedence(.Assignment, hanging);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "expression",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to expressionStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn expressionStatement(self: *Self, hanging: bool) Error!Ast.Node.Index {\n    const expr = try self.expression(hanging);\n\n    try self.consume(.Semicolon, \"Expected `;` after expression.\");\n\n    return try self.ast.appendNode(\n        .{\n            .tag = .Expression,\n            .type_def = self.ast.nodes.items(.type_def)[expr],\n            .location = self.ast.nodes.items(.location)[expr],\n            .end_location = self.current_token.? - 1,\n            .components = .{\n                .Expression = expr,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "expressionStatement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to list from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn list(self: *Self, _: bool) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    var items = std.ArrayList(Ast.Node.Index).empty;\n    var explicit_item_type: ?Ast.Node.Index = null;\n    var item_type: ?*obj.ObjTypeDef = null;\n\n    // A list expression can specify its type `[<int>, ...]`\n    if (try self.match(.Less)) {\n        explicit_item_type = try self.parseTypeDef(null, true);\n        item_type = self.ast.nodes.items(.type_def)[explicit_item_type.?];\n\n        try self.consume(.Greater, \"Expected `>` after list type.\");\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "list",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to literal from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn literal(self: *Self, _: bool) Error!Ast.Node.Index {\n    var node = Ast.Node{\n        .tag = undefined,\n        .location = self.current_token.? - 1,\n        .end_location = self.current_token.? - 1,\n        .components = undefined,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "literal",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to grouping from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn grouping(self: *Self, _: bool) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    const expr = try self.expression(false);\n\n    try self.consume(.RightParen, \"Expected ')' after expression.\");\n\n    return try self.ast.appendNode(\n        .{\n            .tag = .Grouping,\n            .location = start_location,\n            .end_location = self.current_token.? - 1,\n            .type_def = self.ast.nodes.items(.type_def)[expr],\n            .components = .{\n                .Grouping = expr,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "grouping",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to argumentList from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn argumentList(self: *Self) ![]Ast.Call.Argument {\n    var arguments = std.ArrayList(Ast.Call.Argument).empty;\n\n    const start_location = self.current_token.? - 1;\n\n    var arg_count: u8 = 0;\n    while (!(try self.match(.RightParen)) and !(try self.match(.Eof))) {\n        var hanging = false;\n        const arg_name = if (try self.match(.Identifier))\n            self.current_token.? - 1\n        else\n            null;\n\n        if (arg_name != null) {\n            if (arg_count == 0 or self.check(.Comma) or self.check(.RightParen)) {\n                // The identifier we just parsed might not be the argument name but the start of an expression or the expression itself\n                hanging = !(try self.match(.Colon));\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "argumentList",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to call from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn call(self: *Self, _: bool, callee: Ast.Node.Index) Error!Ast.Node.Index {\n    const start_location = self.ast.nodes.items(.location)[callee];\n    const callee_type_def = self.ast.nodes.items(.type_def)[callee];\n\n    const arguments = try self.argumentList();\n    const catch_default = if (try self.match(.Catch))\n        try self.expression(false)\n    else\n        null;\n\n    // Node type is Function or Native return type or nothing/placeholder\n    var type_def = if (callee_type_def != null and callee_type_def.?.def_type == .Function)\n        callee_type_def.?.resolved_type.?.Function.return_type\n    else if (callee_type_def != null and callee_type_def.?.def_type == .Enum)\n        try (try callee_type_def.?.toInstance(&self.gc.type_registry, false))\n            .cloneOptional(&self.gc.type_registry)\n    else\n        null;\n\n    // If null, create placeholder\n    if (type_def == null) {\n        if (callee_type_def == null or callee_type_def.?.def_type != .Placeholder) {\n            self.reportErrorAtNode(\n                .callable,\n                callee,\n                \"Can't be called\",\n                .{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "call",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to map from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn map(self: *Self, _: bool) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    var value_type_node: ?Ast.Node.Index = null;\n    var value_type_def: ?*obj.ObjTypeDef = null;\n    var key_type_node: ?Ast.Node.Index = null;\n    var key_type_def: ?*obj.ObjTypeDef = null;\n\n    // A map expression can specify its type `{<str: str>, ...}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "map",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to objectInit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn objectInit(self: *Self, _: bool, object: Ast.Node.Index) Error!Ast.Node.Index {\n    const start_location = self.ast.nodes.items(.location)[object];\n    const obj_type_def = self.ast.nodes.items(.type_def)[object];\n    var properties = std.ArrayList(Ast.ObjectInit.Property).empty;\n    var property_names = std.StringHashMapUnmanaged(Ast.Node.Index).empty;\n    defer property_names.deinit(self.gc.allocator);\n\n    while (!self.check(.RightBrace) and !self.check(.Eof)) {\n        try self.consume(.Identifier, \"Expected property name\");\n\n        const property_name = self.current_token.? - 1;\n        const property_name_lexeme = self.ast.tokens.items(.lexeme)[property_name];\n        if (property_names.get(property_name_lexeme)) |previous_decl| {\n            const location = self.ast.tokens.get(property_name);\n            const decl_location = self.ast.tokens.get(previous_decl);\n            self.reporter.reportWithOrigin(\n                .property_already_exists,\n                location,\n                location,\n                decl_location,\n                decl_location,\n                \"Property `{s}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "objectInit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to anonymousObjectInit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn anonymousObjectInit(self: *Self, _: bool) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n    try self.consume(.LeftBrace, \"Expected `{` after `.`\");\n\n    const qualifier = try std.mem.replaceOwned(u8, self.gc.allocator, self.script_name, \"/\", \".\");\n    defer self.gc.allocator.free(qualifier);\n    var qualified_name = std.ArrayList(u8).empty;\n    defer qualified_name.deinit(self.gc.allocator);\n    try qualified_name.writer(self.gc.allocator).print(\"{s}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "anonymousObjectInit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to dot from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn dot(self: *Self, can_assign: bool, callee: Ast.Node.Index) Error!Ast.Node.Index {\n    const start_location = self.ast.nodes.items(.location)[callee];\n\n    try self.consume(.Identifier, \"Expected property name after `.`\");\n    const member_name_token = self.current_token.? - 1;\n    const member_name = self.ast.tokens.items(.lexeme)[member_name_token];\n\n    const dot_node = try self.ast.appendNode(\n        .{\n            .tag = .Dot,\n            .location = start_location,\n            .end_location = undefined,\n            .components = .{\n                .Dot = .{\n                    .callee = callee,\n                    .identifier = member_name_token,\n                    .value_or_call_or_enum = undefined,\n                    .generic_resolve = null,\n                    .member_type_def = undefined,\n                    .member_kind = undefined,\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "dot",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to gracefulUnwrap from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn gracefulUnwrap(self: *Self, _: bool, unwrapped: Ast.Node.Index) Error!Ast.Node.Index {\n    return self.unwrap(false, unwrapped);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "gracefulUnwrap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to forceUnwrap from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn forceUnwrap(self: *Self, _: bool, unwrapped: Ast.Node.Index) Error!Ast.Node.Index {\n    return self.unwrap(true, unwrapped);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "forceUnwrap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to unwrap from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn unwrap(self: *Self, force: bool, unwrapped: Ast.Node.Index) Error!Ast.Node.Index {\n    const unwrapped_type_def = self.ast.nodes.items(.type_def)[unwrapped].?;\n\n    const node = self.ast.appendNode(\n        .{\n            .tag = if (force) .ForceUnwrap else .Unwrap,\n            .location = self.ast.nodes.items(.location)[unwrapped],\n            .end_location = self.current_token.? - 1,\n            .type_def = try unwrapped_type_def.cloneNonOptional(&self.gc.type_registry),\n            .components = if (force)\n                .{\n                    .ForceUnwrap = .{\n                        .start_opt_jumps = false,\n                        .unwrapped = unwrapped,\n                        .original_type = unwrapped_type_def,\n                    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "unwrap",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to unary from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn unary(self: *Self, _: bool) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    const operator = self.ast.tokens.items(.tag)[start_location];\n    const left = try self.parsePrecedence(.Unary, false);\n\n    return self.ast.appendNode(\n        .{\n            .tag = .Unary,\n            .location = start_location,\n            .end_location = self.current_token.? - 1,\n            .type_def = self.ast.nodes.items(.type_def)[left],\n            .components = .{\n                .Unary = .{\n                    .operator = operator,\n                    .expression = left,\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "unary",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to genericResolve from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn genericResolve(self: *Self, _: bool, expr: Ast.Node.Index) Error!Ast.Node.Index {\n    return try self.parseGenericResolve(self.ast.nodes.items(.type_def)[expr].?, expr);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "genericResolve",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to ifStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn ifStatement(self: *Self, loop_scope: ?LoopScope) Error!Ast.Node.Index {\n    return try self.@\"if\"(true, loop_scope);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "ifStatement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to inlineIf from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn inlineIf(self: *Self, _: bool) Error!Ast.Node.Index {\n    return try self.@\"if\"(false, null);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "inlineIf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isAs from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn isAs(self: *Self, left: Ast.Node.Index, is_expr: bool) Error!Ast.Node.Index {\n    const start_location = self.ast.nodes.items(.location)[left];\n    const constant = try self.parseTypeDef(null, true);\n    const type_def = self.ast.nodes.items(.type_def)[constant].?;\n\n    return try self.ast.appendNode(\n        .{\n            .tag = if (is_expr) .Is else .As,\n            .location = start_location,\n            .end_location = self.current_token.? - 1,\n            .type_def = if (is_expr)\n                self.gc.type_registry.bool_type\n            else\n                (try type_def.cloneOptional(&self.gc.type_registry)),\n            .components = if (is_expr)\n                .{\n                    .Is = .{\n                        .left = left,\n                        .constant = constant,\n                    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "isAs",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to is from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn is(self: *Self, _: bool, left: Ast.Node.Index) Error!Ast.Node.Index {\n    return self.isAs(left, true);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "is",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to as from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn as(self: *Self, _: bool, left: Ast.Node.Index) Error!Ast.Node.Index {\n    return self.isAs(left, false);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "as",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to string from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn string(self: *Self, _: bool) Error!Ast.Node.Index {\n    const string_token_index = self.current_token.? - 1;\n    const string_token = self.ast.tokens.get(string_token_index);\n    const current_token = self.current_token.?;\n\n    var string_parser = StringParser{\n        .parser = self,\n        .delimiter = string_token.lexeme[0],\n        .source = string_token.literal.String,\n        .script_name = self.script_name,\n        .line_offset = string_token.line,\n        .column_offset = string_token.column,\n        .host_offset = self.ast.tokens.items(.offset)[string_token_index],\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "string",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to namedVariable from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn namedVariable(self: *Self, name: []const Ast.TokenIndex, can_assign: bool) Error!Ast.Node.Index {\n    const node_slot = try self.ast.nodes.addOne(self.ast.allocator);\n    const start_location = name[0];\n\n    var var_def: ?*obj.ObjTypeDef = null;\n    var slot: usize = undefined;\n    var slot_type: Ast.SlotType = undefined;\n    var slot_final = false;\n    var def_node: Ast.Node.Index = 0;\n    if (name.len == 1) {\n        if (try self.resolveLocal(self.current.?, name[0])) |uslot| {\n            var_def = self.current.?.locals[uslot].type_def;\n            slot = uslot;\n            slot_type = .Local;\n            slot_final = self.current.?.locals[uslot].final;\n            def_node = self.current.?.locals[uslot].node;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "namedVariable",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to qualifiedName from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn qualifiedName(self: *Self) Error![]const Ast.TokenIndex {\n    // Assumes one identifier has already been consumed\n    std.debug.assert(self.ast.tokens.items(.tag)[self.current_token.? - 1] == .Identifier);\n\n    var name = std.ArrayList(Ast.TokenIndex).empty;\n\n    try name.append(self.gc.allocator, self.current_token.? - 1);\n    while ((try self.match(.AntiSlash)) and !self.check(.Eof)) {\n        try self.consume(.Identifier, \"Expected identifier\");\n\n        try name.append(self.gc.allocator, self.current_token.? - 1);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "qualifiedName",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to variable from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn variable(self: *Self, can_assign: bool) Error!Ast.Node.Index {\n    return try self.namedVariable(\n        try self.qualifiedName(),\n        can_assign,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "variable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to fun from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn fun(self: *Self, _: bool) Error!Ast.Node.Index {\n    return try self.function(null, .Anonymous, null);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "fun",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to function from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn function(\n    self: *Self,\n    name: ?Ast.TokenIndex,\n    function_type: obj.ObjFunction.FunctionType,\n    this: ?*obj.ObjTypeDef,\n) Error!Ast.Node.Index {\n    var error_types = std.ArrayList(Ast.Node.Index).empty;\n    var arguments = std.ArrayList(Ast.FunctionType.Argument).empty;\n    var generic_types = std.ArrayList(Ast.TokenIndex).empty;\n\n    const function_signature = try self.ast.appendNode(\n        .{\n            .tag = .FunctionType,\n            .location = if (name != null)\n                self.current_token.? - 2 // -2 to start at the .Fun token\n            else\n                self.current_token.? - 1,\n            .end_location = undefined,\n            .type_def = null,\n            .components = .{\n                .FunctionType = .{\n                    .is_signature = true,\n                    .name = name,\n                    .return_type = null,\n                    .yield_type = null,\n                    .error_types = undefined,\n                    .arguments = undefined,\n                    .generic_types = undefined,\n                    .lambda = false,\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "function",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to pattern from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn pattern(self: *Self, _: bool) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n    const source_slice = self.ast.tokens.items(.literal)[start_location].String;\n    // Replace escaped pattern delimiter with delimiter\n    const source = try std.mem.replaceOwned(\n        u8,\n        self.gc.allocator,\n        source_slice,\n        \"\\\\\\\"\",\n        \"\\\"\",\n    );\n\n    var err_code: c_int = undefined;\n    var err_offset: usize = undefined;\n    const reg = if (!is_wasm)\n        pcre.compile(\n            source.ptr,\n            source.len,\n            // TODO: provide options to user\n            0,\n            &err_code,\n            &err_offset,\n            null,\n        )\n    else {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "pattern",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to asyncCall from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn asyncCall(self: *Self, _: bool) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    const callable_node = try self.parsePrecedence(.Call, false);\n    const callable = self.ast.nodes.get(callable_node);\n    const node = try self.ast.appendNode(\n        .{\n            .tag = .AsyncCall,\n            .location = start_location,\n            .end_location = undefined,\n            .type_def = null,\n            .components = .{\n                .AsyncCall = callable_node,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "asyncCall",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to resumeFiber from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn resumeFiber(self: *Self, _: bool) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    if (self.current.?.scope_depth == 0) {\n        const location = self.ast.tokens.get(self.current_token.? - 1);\n        self.reporter.reportErrorAt(\n            .syntax,\n            location,\n            location,\n            \"`resume` not allowed in global scope\",\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "resumeFiber",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to resolveFiber from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn resolveFiber(self: *Self, _: bool) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    if (self.current.?.scope_depth == 0) {\n        const location = self.ast.tokens.get(self.current_token.? - 1);\n        self.reporter.reportErrorAt(\n            .syntax,\n            location,\n            location,\n            \"`resolve` not allowed in global scope\",\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "resolveFiber",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to yield from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn yield(self: *Self, _: bool) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    if (self.current.?.scope_depth == 0) {\n        const location = self.ast.tokens.get(self.current_token.? - 1);\n        self.reporter.reportErrorAt(\n            .syntax,\n            location,\n            location,\n            \"`yield` not allowed in global scope\",\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "yield",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to range from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn range(self: *Self, _: bool, low: Ast.Node.Index) Error!Ast.Node.Index {\n    const high = try self.expression(false);\n\n    self.markInitialized();\n\n    return try self.ast.appendNode(\n        .{\n            .tag = .Range,\n            .location = self.ast.nodes.items(.location)[low],\n            .end_location = self.current_token.? - 1,\n            .type_def = try self.gc.type_registry.getTypeDef(\n                .{\n                    .optional = false,\n                    .def_type = .Range,\n                    .resolved_type = .{\n                        .Range = {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "range",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to typeOfExpression from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn typeOfExpression(self: *Self, _: bool) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    const expr = try self.parsePrecedence(.Unary, false);\n\n    return try self.ast.appendNode(\n        .{\n            .tag = .TypeOfExpression,\n            .location = start_location,\n            .end_location = self.current_token.? - 1,\n            .type_def = try self.gc.type_registry.getTypeDef(.{ .def_type = .Type }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "typeOfExpression",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to mutableExpression from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn mutableExpression(self: *Self, _: bool) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    const expr = try self.parsePrecedence(.Unary, false);\n\n    self.ast.nodes.items(.type_def)[expr] = try self.ast.nodes.items(.type_def)[expr].?.cloneMutable(&self.gc.type_registry, true);\n    self.ast.nodes.items(.location)[expr] = start_location;\n\n    switch (self.ast.nodes.items(.tag)[expr]) {\n        .List, .Map, .ObjectInit => {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "mutableExpression",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to blockExpression from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn blockExpression(self: *Self, _: bool) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    try self.consume(.LeftBrace, \"Expected `{` at start of block expression\");\n\n    try self.beginScope(null);\n    self.current.?.in_block_expression = self.current.?.scope_depth;\n\n    var statements = std.ArrayList(Ast.Node.Index).empty;\n\n    var out: ?Ast.Node.Index = null;\n    while (!self.check(.RightBrace) and !self.check(.Eof)) {\n        if (try self.declarationOrStatement(null)) |stmt| {\n            try statements.append(self.gc.allocator, stmt);\n\n            if (self.ast.nodes.items(.tag)[stmt] == .Out) {\n                if (out != null) {\n                    self.reportErrorAtNode(\n                        .syntax,\n                        stmt,\n                        \"Only one `out` statement is allowed in block expression\",\n                        .{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "blockExpression",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to binary from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn binary(self: *Self, _: bool, left: Ast.Node.Index) Error!Ast.Node.Index {\n    const start_location = self.ast.nodes.items(.location)[left];\n\n    const operator_token = self.current_token.? - 1;\n    const operator = self.ast.tokens.items(.tag)[operator_token];\n    const rule = getRule(operator);\n\n    const right = try self.parsePrecedence(\n        @enumFromInt(@intFromEnum(rule.precedence) + 1),\n        false,\n    );\n\n    const type_defs = self.ast.nodes.items(.type_def);\n    const right_type_def = type_defs[right];\n    const left_type_def = type_defs[left];\n\n    return try self.ast.appendNode(\n        .{\n            .tag = .Binary,\n            .location = start_location,\n            .end_location = self.current_token.? - 1,\n            .type_def = switch (operator) {\n                .QuestionQuestion => right_type_def,\n\n                .Greater,\n                .Less,\n                .GreaterEqual,\n                .LessEqual,\n                .BangEqual,\n                .EqualEqual,\n                => self.gc.type_registry.bool_type,\n\n                .Plus => left_type_def orelse right_type_def,\n\n                .ShiftLeft,\n                .ShiftRight,\n                .Ampersand,\n                .Bor,\n                .Xor,\n                => self.gc.type_registry.int_type,\n\n                .Minus,\n                .Star,\n                .Percent,\n                .Slash,\n                => if ((left_type_def != null and left_type_def.?.def_type == .Double) or (right_type_def != null and right_type_def.?.def_type == .Double))\n                    self.gc.type_registry.float_type\n                else\n                    self.gc.type_registry.int_type,\n\n                else => unreachable,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "binary",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to typeExpression from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn typeExpression(self: *Self, _: bool) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    const type_def = try self.parseTypeDef(null, true);\n\n    try self.consume(.Greater, \"Expected `>` after type expression.\");\n\n    return try self.ast.appendNode(\n        .{\n            .tag = .TypeExpression,\n            .location = start_location,\n            .end_location = self.current_token.? - 1,\n            .type_def = try self.gc.type_registry.getTypeDef(.{ .def_type = .Type }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "typeExpression",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to funDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn funDeclaration(self: *Self) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    var function_type: obj.ObjFunction.FunctionType = .Function;\n\n    if (self.ast.tokens.items(.tag)[self.current_token.? - 1] == .Extern) {\n        try self.consume(.Fun, \"Expected `fun` after `extern`.\");\n\n        function_type = .Extern;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "funDeclaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to exportStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn exportStatement(self: *Self, docblock: ?Ast.TokenIndex) Error!Ast.Node.Index {\n    const node_slot = try self.ast.nodes.addOne(self.gc.allocator);\n    const start_location = self.current_token.? - 1;\n\n    if (self.namespace == null) {\n        const location = self.ast.tokens.get(self.current_token.? - 1);\n        self.reporter.reportErrorAt(\n            .syntax,\n            location,\n            location,\n            \"A exporting script must provide a namespace\",\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "exportStatement",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to objectDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn objectDeclaration(self: *Self) Error!Ast.Node.Index {\n    if (self.current.?.scope_depth > 0) {\n        const location = self.ast.tokens.get(self.current_token.? - 1);\n        self.reporter.reportErrorAt(\n            .syntax,\n            location,\n            location,\n            \"Object must be defined at top-level.\",\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "objectDeclaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to method from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn method(self: *Self, abstract: bool, static: bool, this: *obj.ObjTypeDef) Error!Ast.Node.Index {\n    try self.consume(.Identifier, \"Expected method name.\");\n\n    return try self.function(\n        self.current_token.? - 1,\n        if (abstract)\n            .Abstract\n        else if (static)\n            .Function\n        else\n            .Method,\n        this,\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "method",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to protocolDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn protocolDeclaration(self: *Self) Error!Ast.Node.Index {\n    if (self.current.?.scope_depth > 0) {\n        const location = self.ast.tokens.get(self.current_token.? - 1);\n        self.reporter.reportErrorAt(\n            .syntax,\n            location,\n            location,\n            \"Protocol must be defined at top-level.\",\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "protocolDeclaration",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to enumDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn enumDeclaration(self: *Self) Error!Ast.Node.Index {\n    const node_slot = try self.ast.nodes.addOne(self.gc.allocator);\n    const start_location = self.current_token.? - 1;\n\n    if (self.current.?.scope_depth > 0) {\n        const location = self.ast.tokens.get(self.current_token.? - 1);\n        self.reporter.reportErrorAt(\n            .syntax,\n            location,\n            location,\n            \"Enum must be defined at top-level.\",\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "enumDeclaration",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to varDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn varDeclaration(\n    self: *Self,\n    identifier: ?Ast.TokenIndex,\n    parsed_type: ?Ast.Node.Index,\n    terminator: DeclarationTerminator,\n    final: bool,\n    omits_qualifier: bool,\n    should_assign: bool,\n    type_provided_later: bool,\n) Error!Ast.Node.Index {\n    const node_slot = try self.ast.nodes.addOne(self.gc.allocator);\n    var var_type = if (parsed_type) |ptype|\n        try self.ast.nodes.items(.type_def)[ptype].?.toInstance(\n            &self.gc.type_registry,\n            self.ast.nodes.items(.type_def)[ptype].?.isMutable(), // ???\n        )\n    else\n        self.gc.type_registry.any_type; // When var type omitted, will be replaced by the value type bellow\n\n    const start_location = if (omits_qualifier)\n        identifier.?\n    else if (identifier) |id|\n        id - 1\n    else\n        self.current_token.? - 2;\n\n    const slot: usize = try self.parseVariable(\n        @intCast(node_slot),\n        identifier,\n        var_type,\n        final,\n        var_type.isMutable(),\n        \"Expected variable name.\",\n    );\n\n    const name = identifier orelse start_location;\n\n    const value = if (should_assign and try self.match(.Equal))\n        try self.expression(false)\n    else\n        null;\n    const value_type_def = if (value) |val|\n        self.ast.nodes.items(.type_def)[val]\n    else\n        null;\n\n    if (should_assign and value == null and (parsed_type == null or !self.ast.nodes.items(.type_def)[parsed_type.?].?.optional)) {\n        const location = self.ast.tokens.get(self.current_token.? - 1);\n        self.reporter.reportErrorAt(\n            .syntax,\n            location,\n            location,\n            \"Expected variable initial value\",\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "varDeclaration",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to implicitVarDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn implicitVarDeclaration(\n    self: *Self,\n    name: Ast.TokenIndex,\n    parsed_type: *obj.ObjTypeDef,\n    final: bool,\n    mutable: bool,\n) Error!Ast.Node.Index {\n    const node_slot = try self.ast.nodes.addOne(self.gc.allocator);\n    const var_type = try parsed_type.toInstance(\n        &self.gc.type_registry,\n        mutable,\n    );\n    const slot = try self.declareVariable(\n        @intCast(node_slot),\n        var_type,\n        name,\n        final,\n        mutable,\n        true,\n    );\n    self.markInitialized();\n\n    self.ast.nodes.set(\n        node_slot,\n        .{\n            .tag = .VarDeclaration,\n            .location = name,\n            .end_location = self.current_token.? - 1,\n            .type_def = var_type,\n            .components = .{\n                .VarDeclaration = .{\n                    .name = name,\n                    .value = null,\n                    .type = null,\n                    .final = final,\n                    .omits_qualifier = true,\n                    .slot = @intCast(slot),\n                    .slot_type = if (self.current.?.scope_depth > 0) .Local else .Global,\n                    .implicit = true,\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "implicitVarDeclaration",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to testStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn testStatement(self: *Self) Error!Ast.Node.Index {\n    const node_slot = try self.ast.nodes.addOne(self.gc.allocator);\n    const start_location = self.current_token.? - 1;\n    // We can't consume the name because declareVariable will do it\n    const name_token = self.current_token.?;\n\n    var function_def_placeholder = obj.ObjTypeDef{\n        .def_type = .Function,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "testStatement",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to searchPaths from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn searchPaths(self: *Self, file_name: []const u8) ![][]const u8 {\n    var paths = std.ArrayList([]const u8).empty;\n\n    for (search_paths) |path| {\n        const filled = try std.mem.replaceOwned(\n            u8,\n            self.gc.allocator,\n            path,\n            \"?\",\n            file_name,\n        );\n        defer self.gc.allocator.free(filled);\n        const suffixed = try std.mem.replaceOwned(\n            u8,\n            self.gc.allocator,\n            filled,\n            \"!\",\n            \"buzz\",\n        );\n        defer self.gc.allocator.free(suffixed);\n        const prefixed = try std.mem.replaceOwned(\n            u8,\n            self.gc.allocator,\n            suffixed,\n            \"$\",\n            try buzzLibPath(self.gc.allocator),\n        );\n\n        if (builtin.os.tag == .windows) {\n            const windows = try std.mem.replaceOwned(\n                u8,\n                self.gc.allocator,\n                prefixed,\n                \"/\",\n                \"\\\\\",\n            );\n            try paths.append(self.gc.allocator, windows);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "searchPaths",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to searchLibPaths from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn searchLibPaths(self: *Self, file_name: []const u8) ![][]const u8 {\n    var paths = std.ArrayList([]const u8).empty;\n\n    for (lib_search_paths) |path| {\n        const filled = try std.mem.replaceOwned(\n            u8,\n            self.gc.allocator,\n            path,\n            \"?\",\n            file_name,\n        );\n        defer self.gc.allocator.free(filled);\n        const suffixed = try std.mem.replaceOwned(\n            u8,\n            self.gc.allocator,\n            filled,\n            \"!\",\n            switch (builtin.os.tag) {\n                .linux, .freebsd, .openbsd => \"so\",\n                .windows => \"dll\",\n                .macos, .tvos, .watchos, .ios => \"dylib\",\n                else => unreachable,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "searchLibPaths",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to searchZdefLibPaths from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn searchZdefLibPaths(self: *Self, file_name: []const u8) ![][]const u8 {\n    var paths = std.ArrayList([]const u8).empty;\n\n    for (zdef_search_paths) |path| {\n        const filled = try std.mem.replaceOwned(u8, self.gc.allocator, path, \"?\", file_name);\n        defer self.gc.allocator.free(filled);\n        const suffixed = try std.mem.replaceOwned(\n            u8,\n            self.gc.allocator,\n            filled,\n            \"!\",\n            switch (builtin.os.tag) {\n                .linux, .freebsd, .openbsd => \"so\",\n                .windows => \"dll\",\n                .macos, .tvos, .watchos, .ios => \"dylib\",\n                else => unreachable,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "searchZdefLibPaths",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to readStaticScript from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn readStaticScript(self: *Self, file_name: []const u8) ?[2][]const u8 {\n    // We can't build the file path dynamically\n    return if (std.mem.eql(u8, file_name, \"std\"))\n        [_][]const u8{\n            @embedFile(\"lib/std.buzz\"),\n            file_name,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "readStaticScript",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to readScript from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn readScript(self: *Self, file_name: []const u8) !?[2][]const u8 {\n    const paths = try self.searchPaths(file_name);\n    var selected_absolute_path_index: ?usize = null;\n    defer {\n        for (paths, 0..) |path, index| {\n            if (selected_absolute_path_index != null and selected_absolute_path_index.? == index) {\n                continue;\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "readScript",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to importScript from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn importScript(\n    self: *Self,\n    path_token: Ast.TokenIndex,\n    file_name: []const u8,\n    prefix: ?[]const Ast.TokenIndex,\n    imported_symbols: *std.StringHashMapUnmanaged(Ast.Node.Index),\n) Error!?ScriptImport {\n    var import = self.imports.get(file_name);\n\n    if (import) |*uimport| {\n        if (uimport.imported_by.get(self.current.?) != null) {\n            const location = self.ast.tokens.get(path_token);\n            self.reporter.reportErrorFmt(\n                .import_already_exists,\n                location,\n                location,\n                \"`{s}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "importScript",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to importStaticLibSymbol from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn importStaticLibSymbol(self: *Self, file_name: []const u8, symbol: []const u8) !?*obj.ObjNative {\n    const symbol_ptr = if (libs.get(file_name)) |lib|\n        lib.get(symbol)\n    else\n        null;\n\n    if (symbol_ptr == null) {\n        const location = self.ast.tokens.get(self.current_token.? - 1);\n        self.reporter.reportErrorFmt(\n            .symbol_not_found,\n            location,\n            location,\n            \"Could not find symbol `{s}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "importStaticLibSymbol",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to importLibSymbol from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn importLibSymbol(\n    self: *Self,\n    location: Ast.TokenIndex,\n    end_location: Ast.TokenIndex,\n    full_file_name: []const u8,\n    symbol: []const u8,\n) !?*obj.ObjNative {\n    // Don't bother if we're not actually running the script\n    if (!self.flavor.resolveDynLib()) {\n        return undefined;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "importLibSymbol",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to importStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn importStatement(self: *Self) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    var imported_symbols = std.StringHashMapUnmanaged(Ast.TokenIndex).empty;\n    var symbols = std.ArrayList(Ast.TokenIndex).empty;\n\n    while ((try self.match(.Identifier)) and !self.check(.Eof)) {\n        const symbol = self.ast.tokens.items(.lexeme)[self.current_token.? - 1];\n\n        if (imported_symbols.get(symbol)) |loc| {\n            self.reporter.reportWithOrigin(\n                .import_already_exists,\n                self.ast.tokens.get(start_location),\n                self.ast.tokens.get(self.current_token.? - 1),\n                self.ast.tokens.get(loc),\n                self.ast.tokens.get(loc),\n                \"Import symbol `{s}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "importStatement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to zdefStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn zdefStatement(self: *Self) Error!Ast.Node.Index {\n    if (!BuildOptions.jit and BuildOptions.cycle_limit == null) {\n        const location = self.ast.tokens.get(self.current_token.? - 1);\n        self.reporter.reportErrorAt(\n            .zdef,\n            location,\n            location,\n            \"zdef can't be used, this instance of buzz was built with JIT compiler disabled\",\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "zdefStatement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to userVarDeclaration from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn userVarDeclaration(self: *Self, identifier: Ast.TokenIndex, final: bool, mutable: bool, omits_qualifier: bool) Error!Ast.Node.Index {\n    const node_slot = try self.ast.nodes.addOne(self.gc.allocator);\n    const start_location = self.current_token.? - 1;\n    var var_type: ?*obj.ObjTypeDef = null;\n\n    var generic_resolve: ?Ast.Node.Index = null;\n\n    // If next token is `=`, means the identifier wasn't a user type but the variable name\n    // and the type needs to be inferred\n    const user_type_name = try self.qualifiedName();\n\n    // Is it a generic type defined in enclosing functions or object?\n    if (self.resolveGeneric(try self.gc.copyString(self.ast.tokens.items(.lexeme)[self.current_token.? - 1]))) |generic_type| {\n        var_type = generic_type;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "userVarDeclaration",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to forStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn forStatement(self: *Self) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    try self.consume(.LeftParen, \"Expected `(` after `for`.\");\n\n    try self.beginScope(null);\n\n    // Should be either VarDeclaration or expression\n    var init_declarations = std.ArrayList(Ast.Node.Index).empty;\n    while (!self.check(.Semicolon) and !self.check(.Eof)) {\n        try self.consume(.Identifier, \"Expected identifier\");\n        const identifier = self.current_token.? - 1;\n\n        try init_declarations.append(\n            self.gc.allocator,\n            try self.varDeclaration(\n                identifier,\n                if (try self.match(.Colon))\n                    try self.parseTypeDef(null, true)\n                else\n                    null,\n                .Nothing,\n                false,\n                true,\n                true,\n                false,\n            ),\n        );\n\n        self.markInitialized();\n\n        if (!self.check(.Semicolon)) {\n            try self.consume(.Comma, \"Expected `,` after for loop variable\");\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "forStatement",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to forEachStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn forEachStatement(self: *Self) Error!Ast.Node.Index {\n    const node_slot = try self.ast.nodes.addOne(self.gc.allocator);\n    const start_location = self.current_token.? - 1;\n\n    try self.consume(.LeftParen, \"Expected `(` after `foreach`.\");\n\n    try self.beginScope(null);\n\n    try self.consume(.Identifier, \"Expected identifier\");\n    var key = try self.varDeclaration(\n        self.current_token.? - 1,\n        null,\n        .Nothing,\n        false,\n        true,\n        false,\n        true,\n    );\n\n    const key_omitted = !(try self.match(.Comma));\n    if (!key_omitted) {\n        try self.consume(.Identifier, \"Expected identifier\");\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "forEachStatement",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to whileStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn whileStatement(self: *Self) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    try self.consume(.LeftParen, \"Expected `(` after `while`.\");\n\n    const condition = try self.expression(false);\n\n    try self.consume(.RightParen, \"Expected `)` after `while` condition.\");\n\n    const label = if (try self.match(.Colon)) lbl: {\n        try self.consume(.Identifier, \"Expected label after `:`.\");\n\n        break :lbl self.current_token.? - 1;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "whileStatement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to doUntilStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn doUntilStatement(self: *Self) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    const label = if (try self.match(.Colon)) lbl: {\n        try self.consume(.Identifier, \"Expected label after `:`.\");\n\n        break :lbl self.current_token.? - 1;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "doUntilStatement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to returnStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn returnStatement(self: *Self) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    if (self.current.?.scope_depth == 0) {\n        const location = self.ast.tokens.get(self.current_token.? - 1);\n        self.reporter.reportErrorAt(\n            .syntax,\n            location,\n            location,\n            \"Can't use `return` at top-level.\",\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "returnStatement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to outStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn outStatement(self: *Self) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    if (self.current.?.in_block_expression == null) {\n        const location = self.ast.tokens.get(start_location);\n        self.reporter.reportErrorAt(\n            .syntax,\n            location,\n            location,\n            \"`out` statement is only allowed inside a block expression\",\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "outStatement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to throw from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn throw(self: *Self) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n    // For now we don't care about the type. Later if we have `Error` type of data, we'll type check this\n    const error_value = try self.expression(false);\n\n    try self.consume(.Semicolon, \"Expected `;` after statement.\");\n\n    return try self.ast.appendNode(\n        .{\n            .tag = .Throw,\n            .location = start_location,\n            .end_location = self.current_token.? - 1,\n            .components = .{\n                .Throw = .{\n                    .expression = error_value,\n                    .unconditional = self.current.?.scope_depth == 1,\n                }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "throw",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to namespaceStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn namespaceStatement(self: *Self) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    // Should be the first statement\n    const components = self.ast.nodes.items(.components);\n    const current_body = components[self.current.?.function_node].Function.body;\n    if (current_body == null or components[current_body.?].Block.len > 0) {\n        self.reporter.reportErrorAt(\n            .syntax,\n            self.ast.tokens.get(if (current_body) |body| self.ast.nodes.items(.location)[body] else start_location),\n            self.ast.tokens.get(if (current_body) |body| self.ast.nodes.items(.end_location)[body] else start_location),\n            \"`namespace` should be the first statement\",\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "namespaceStatement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to tryStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn tryStatement(self: *Self) Error!Ast.Node.Index {\n    const node_slot = try self.ast.nodes.addOne(self.gc.allocator);\n    const start_location = self.current_token.? - 1;\n\n    if (self.current.?.in_try) {\n        const location = self.ast.tokens.get(self.current_token.? - 1);\n        self.reporter.reportErrorAt(\n            .nested_try,\n            location,\n            location,\n            \"Nested `try` statement are not allowed\",\n        );\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "tryStatement",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to findLabel from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn findLabel(self: *Self, label: Ast.TokenIndex) ?struct { node: Ast.Node.Index, depth: u32 }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "findLabel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to breakContinueStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn breakContinueStatement(self: *Self, @\"break\": bool, loop_scope: ?LoopScope) Error!Ast.Node.Index {\n    const start_location = self.current_token.? - 1;\n\n    const label = if (try self.match(.Identifier))\n        self.current_token.? - 1\n    else\n        null;\n\n    const label_scope = if (label) |lbl|\n        self.findLabel(lbl)\n    else\n        null;\n\n    if (label != null and label_scope == null) {\n        const location = self.ast.tokens.get(label.?);\n        self.reporter.reportErrorFmt(\n            .label_does_not_exists,\n            location,\n            location,\n            \"Label `{s}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "breakContinueStatement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to continueStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn continueStatement(self: *Self, loop_scope: ?LoopScope) Error!Ast.Node.Index {\n    return self.breakContinueStatement(false, loop_scope);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "continueStatement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to breakStatement from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "fn breakStatement(self: *Self, loop_scope: ?LoopScope) Error!Ast.Node.Index {\n    return self.breakContinueStatement(true, loop_scope);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "function",
      "name": "breakStatement",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Local from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub const Local = struct {\n    name: Ast.TokenIndex,\n    node: Ast.Node.Index,\n    type_def: *obj.ObjTypeDef,\n    depth: i32,\n    captured: bool,\n    final: bool,\n    mutable: bool,\n    referenced: bool = false,\n    assigned: bool = false,\n\n    pub fn isReferenced(self: Local, ast: Ast) bool {\n        const lexemes = ast.tokens.items(.lexeme);\n        return self.referenced or\n            self.type_def.def_type == .Void or\n            self.type_def.def_type == .Placeholder or\n            lexemes[self.name][0] == '$' or\n            (lexemes[self.name][0] == '_' and lexemes[self.name].len == 1);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "struct",
      "name": "Local",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Global from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub const Global = struct {\n    name: []const Ast.TokenIndex,\n    node: Ast.Node.Index,\n    type_def: *obj.ObjTypeDef,\n    export_alias: ?Ast.TokenIndex = null,\n    imported_from: ?[]const u8 = null,\n    placeholder_referrers: std.ArrayList(Ast.Node.Index) = .{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "struct",
      "name": "Global",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to UpValue from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub const UpValue = struct {\n    index: u8,\n    is_local: bool,\n    node: Ast.Node.Index,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "struct",
      "name": "UpValue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Frame from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub const Frame = struct {\n    enclosing: ?*Frame = null,\n    locals: [255]Local,\n    local_count: u8 = 0,\n    upvalues: [255]UpValue,\n    upvalue_count: u8 = 0,\n    scope_depth: u32 = 0,\n    /// Keep track of the node that introduced the scope (useful for labeled break/continue statements)\n    scopes: std.ArrayList(?Ast.Node.Index) = .{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "struct",
      "name": "Frame",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ObjectFrame from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub const ObjectFrame = struct {\n    name: Ast.TokenIndex,\n    type_def: *obj.ObjTypeDef,\n    generics: ?*std.AutoArrayHashMapUnmanaged(*obj.ObjString, *obj.ObjTypeDef) = null,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "struct",
      "name": "ObjectFrame",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ScriptImport from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub const ScriptImport = struct {\n    function: Ast.Node.Index,\n    globals: std.ArrayList(Global) = .{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "struct",
      "name": "ScriptImport",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to LocalScriptImport from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "const LocalScriptImport = struct {\n    referenced: bool = false,\n    location: Ast.TokenIndex,\n    end_location: Ast.TokenIndex,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "struct",
      "name": "LocalScriptImport",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to LoopScope from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "pub const LoopScope = struct {\n    loop_type: LoopType,\n    loop_body_scope: usize,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "struct",
      "name": "LoopScope",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ParseRule from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "const ParseRule = struct {\n    prefix: ?ParseFn = null,\n    infix: ?InfixParseFn = null,\n    precedence: Precedence = .None,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "struct",
      "name": "ParseRule",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to function_type from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "const function_type: obj.ObjFunction.FunctionType = if (!self.imported and self.flavor == .Repl)\n        .Repl\n    else if (self.imported)\n        .Script\n    else\n        .ScriptEntryPoint;",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "const",
      "name": "function_type",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to function_name from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "const function_name: []const u8 = switch (function_type) {\n        .EntryPoint => \"main\",\n        .ScriptEntryPoint, .Script => name,\n        .Repl => \"REPL\",\n        else => \"???\",\n    };",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "const",
      "name": "function_name",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to prefixRule from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "const prefixRule: ?ParseFn = getRule(self.ast.tokens.items(.tag)[self.current_token.? - 1]).prefix;",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "const",
      "name": "prefixRule",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to global from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "const global: *Global = &self.globals.items[i];",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "const",
      "name": "global",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to upvalue_count from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "const upvalue_count: u8 = frame.upvalue_count;",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "const",
      "name": "upvalue_count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to upvalue from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "const upvalue: *UpValue = &frame.upvalues[i];",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "const",
      "name": "upvalue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to local from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "const local: ?usize = try self.resolveLocal(frame.enclosing.?, name);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "const",
      "name": "local",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to upvalue from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "const upvalue: ?usize = try self.resolveUpvalue(frame.enclosing.?, name);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "const",
      "name": "upvalue",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to local from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "const local: *Local = &self.current.?.locals[i];",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "const",
      "name": "local",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to end_token from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "const end_token: Token.Type = if (function_type.canOmitBody()) .Semicolon else .LeftBrace;",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "const",
      "name": "end_token",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slot from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "const slot: usize = try self.declareVariable(\n        @intCast(node_slot),\n        fun_typedef,\n        name_token,\n        true,\n        false,\n        true,\n    );",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "const",
      "name": "slot",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slot from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "const slot: usize = try self.declareVariable(\n        @intCast(node_slot),\n        enum_type,\n        enum_name,\n        true,\n        false,\n        true,\n    );",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "const",
      "name": "slot",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to slot from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "const slot: usize = try self.parseVariable(\n        @intCast(node_slot),\n        identifier,\n        var_type,\n        final,\n        var_type.isMutable(),\n        \"Expected variable name.\",\n    );",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "const",
      "name": "slot",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to file_name from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Parser.zig",
    "response": "const file_name: []const u8 = if (path.lexeme.len <= 1 or path.literal.String.len <= 0) invalid: {\n        self.reporter.reportErrorAt(\n            .empty_import,\n            path,\n            path,\n            \"Import path can't be empty\",\n        );",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Parser.zig",
      "type": "const",
      "name": "file_name",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn deinit(self: *Self) void {\n    // not freeing individual reports as they will be deinit by LSP\n    self.reports.deinit(self.allocator);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to color from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn color(self: ReportKind) u8 {\n        return switch (self) {\n            .@\"error\" => 31,\n            .warning => 33,\n            .hint => 34,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "color",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to name from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn name(self: ReportKind) []const u8 {\n        return switch (self) {\n            .@\"error\" => \"Error\",\n            .warning => \"Warning\",\n            .hint => \"Note\",\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "name",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to nameLower from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn nameLower(self: ReportKind) []const u8 {\n        return switch (self) {\n            .@\"error\" => \" error\",\n            .warning => \" warning\",\n            .hint => \" note\",\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "nameLower",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to prefix from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn prefix(self: ReportKind) []const u8 {\n        return switch (self) {\n            .@\"error\" => \"E\",\n            .warning => \"W\",\n            .hint => \"I\",\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "prefix",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn deinit(self: *ReportItem, allocator: std.mem.Allocator) void {\n        allocator.free(self.message);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lessThan from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn lessThan(_: SortContext, lhs: ReportItem, rhs: ReportItem) bool {\n        return lhs.end_location.line < rhs.end_location.line or\n            (lhs.end_location.line == rhs.end_location.line and lhs.end_location.column < rhs.end_location.column);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "lessThan",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn deinit(self: *Report, allocator: std.mem.Allocator) void {\n        for (self.items) |*item| {\n            @constCast(item).deinit(allocator);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to reportStderr from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn reportStderr(self: Report, reporter: *Self) !void {\n        @branchHint(.cold);\n\n        if (reporter.collect) {\n            return reporter.reports.append(reporter.allocator, self);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "reportStderr",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to report from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn report(self: Report, reporter: *Self, out: *std.Io.Writer) !void {\n        @branchHint(.cold);\n\n        assert(self.items.len > 0);\n        var env_map = try std.process.getEnvMap(reporter.allocator);\n        defer env_map.deinit();\n\n        const colorterm = env_map.get(\"COLORTERM\");\n        const true_color = if (colorterm) |ct|\n            std.mem.eql(u8, ct, \"24bit\") or std.mem.eql(u8, ct, \"truecolor\")\n        else\n            false;\n\n        // Print main error message\n        const main_item = self.items[0];\n\n        if (self.options.color) {\n            try out.print(\n                \"\\n{s}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "report",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to warn from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn warn(self: *Self, error_type: Error, location: Token, end_location: Token, message: []const u8) void {\n    const items = [_]ReportItem{\n        .{\n            .kind = .warning,\n            .location = location,\n            .end_location = end_location,\n            .message = message,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "warn",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to report from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn report(self: *Self, error_type: Error, location: Token, end_location: Token, message: []const u8) void {\n    @branchHint(.cold);\n\n    self.panic_mode = true;\n    self.last_error = error_type;\n\n    const items = [_]ReportItem{\n        .{\n            .location = location,\n            .end_location = end_location,\n            .message = message,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "report",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reportErrorAt from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn reportErrorAt(self: *Self, error_type: Error, location: Token, end_location: Token, comptime message: []const u8) void {\n    @branchHint(.cold);\n\n    if (self.panic_mode) {\n        return;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "reportErrorAt",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to warnAt from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn warnAt(self: *Self, error_type: Error, location: Token, end_location: Token, comptime message: []const u8) void {\n    self.warn(\n        error_type,\n        location,\n        end_location,\n        if (!self.collect)\n            message\n        else\n            self.allocator.dupe(u8, message) catch @panic(\"Could not report error\"),\n    );\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "warnAt",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to reportErrorFmt from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn reportErrorFmt(self: *Self, error_type: Error, location: Token, end_location: Token, comptime fmt: []const u8, args: anytype) void {\n    @branchHint(.cold);\n\n    var message = std.ArrayList(u8).empty;\n    defer {\n        if (!self.collect) {\n            message.deinit(self.allocator);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "reportErrorFmt",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to warnFmt from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn warnFmt(self: *Self, error_type: Error, location: Token, end_location: Token, comptime fmt: []const u8, args: anytype) void {\n    var message = std.ArrayList(u8).empty;\n    defer {\n        if (!self.collect) {\n            message.deinit(self.allocator);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "warnFmt",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to reportWithOrigin from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn reportWithOrigin(\n    self: *Self,\n    error_type: Error,\n    location: Token,\n    end_location: Token,\n    decl_location: Token,\n    decl_end_location: Token,\n    comptime fmt: []const u8,\n    args: anytype,\n    declared_message: ?[]const u8,\n) void {\n    @branchHint(.cold);\n\n    var message = std.ArrayList(u8).empty;\n    defer {\n        if (!self.collect) {\n            message.deinit(self.allocator);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "reportWithOrigin",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write a Zig function similar to reportTypeCheck from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn reportTypeCheck(\n    self: *Self,\n    error_type: Error,\n    expected_location: ?Token,\n    expected_end_location: ?Token,\n    expected_type: *ObjTypeDef,\n    actual_location: Token,\n    actual_end_location: Token,\n    actual_type: *ObjTypeDef,\n    message: []const u8,\n) void {\n    @branchHint(.cold);\n\n    var actual_message = std.ArrayList(u8).empty;\n    defer {\n        if (!self.collect) {\n            actual_message.deinit(self.allocator);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "reportTypeCheck",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to reportPlaceholder from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub fn reportPlaceholder(self: *Self, ast: Ast.Slice, placeholder: PlaceholderDef) void {\n    @branchHint(.cold);\n\n    if (placeholder.parent) |parent| {\n        if (parent.def_type == .Placeholder) {\n            self.reportPlaceholder(ast, parent.resolved_type.?.Placeholder);\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "function",
      "name": "reportPlaceholder",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Note from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub const Note = struct {\n    kind: ReportKind = .hint,\n    message: []const u8,\n    show_prefix: bool = true,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "struct",
      "name": "Note",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ReportItem from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub const ReportItem = struct {\n    location: Token,\n    end_location: Token,\n    kind: ReportKind = .@\"error\",\n    message: []const u8,\n\n    // Makes sense only in LSP\n    pub fn deinit(self: *ReportItem, allocator: std.mem.Allocator) void {\n        allocator.free(self.message);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "struct",
      "name": "ReportItem",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to SortContext from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub const SortContext = struct {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "struct",
      "name": "SortContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to ReportOptions from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub const ReportOptions = struct {\n    surrounding_lines: usize = 2,\n    color: bool = true,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "struct",
      "name": "ReportOptions",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Report from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Reporter.zig",
    "response": "pub const Report = struct {\n    message: []const u8,\n    error_type: Error,\n    items: []const ReportItem,\n    notes: []const Note = &[_]Note{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Reporter.zig",
      "type": "struct",
      "name": "Report",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "pub fn init(allocator: Allocator, script_name: []const u8, source: []const u8) Self {\n    return Self{\n        .allocator = allocator,\n        .source = source,\n        .script_name = script_name,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to scanToken from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "pub fn scanToken(self: *Self) Allocator.Error!Token {\n    self.skipWhitespaces();\n\n    self.current.start = self.current.offset;\n    self.current.start_line = self.current.line;\n    self.current.start_column = self.current.column;\n\n    if (self.isEOF()) {\n        return self.makeToken(.Eof, Token.NoLiteral);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "scanToken",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to skipWhitespaces from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn skipWhitespaces(self: *Self) void {\n    while (true) {\n        const char: u8 = self.peek();\n\n        switch (char) {\n            ' ', '\\r', '\\t' => _ = self.advance(),\n            '\\n' => {\n                self.current.line += 1;\n                self.current.column = 0;\n                _ = self.advance();\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "skipWhitespaces",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isNumber from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn isNumber(char: u8) bool {\n    return char >= '0' and char <= '9';\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "isNumber",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isLetter from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn isLetter(char: u8) bool {\n    return (char >= 'a' and char <= 'z') or (char >= 'A' and char <= 'Z');\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "isLetter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to docblock from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn docblock(self: *Self) !Token {\n    _ = self.advance(); // Skip third `/`\n\n    var block = std.ArrayList(u8).empty;\n\n    while (!self.isEOF()) {\n        while (!self.isEOF()) {\n            const char: u8 = self.peek();\n\n            if (char == '\\n') {\n                self.current.line += 1;\n                self.current.column = 0;\n                _ = self.advance();\n\n                try block.append(self.allocator, '\\n');\n                break;\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "docblock",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to atIdentifier from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn atIdentifier(self: *Self) Token {\n    self.current.start = self.current.offset;\n    self.current.start_line = self.current.line;\n    self.current.start_column = self.current.column;\n\n    if (self.advance() != '\"') {\n        return self.makeToken(.Error, .{ .String = \"Unterminated identifier.\" }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "atIdentifier",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to identifier from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn identifier(self: *Self) Token {\n    while (isLetter(self.peek()) or isNumber(self.peek()) or self.peek() == '_') {\n        _ = self.advance();\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "identifier",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to number from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn number(self: *Self) Token {\n    var peeked: u8 = self.peek();\n    while (isNumber(peeked) or peeked == '_') {\n        _ = self.advance();\n\n        peeked = self.peek();\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "number",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to byte from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn byte(self: *Self) Token {\n    const is_escape_sequence = self.match('\\\\');\n    const literal_integer = if (!self.isEOF())\n        self.advance()\n    else\n        null;\n\n    if (is_escape_sequence and literal_integer != '\\\\' and literal_integer != '\\'') {\n        return self.makeToken(.Error, .{ .String = \"Invalid escape sequence in char literal.\" }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "byte",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to binary from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn binary(self: *Self) Token {\n    var peeked: u8 = self.peek();\n    if (peeked == '_') {\n        return self.makeToken(.Error, .{ .String = \"'_' must be between digits\" }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "binary",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hexa from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn hexa(self: *Self) Token {\n    if (self.peek() == '_') {\n        return self.makeToken(.Error, .{ .String = \"'_' must be between digits\" }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "hexa",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to pattern from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn pattern(self: *Self) Token {\n    if (self.advance() != '\"') {\n        return self.makeToken(.Error, .{ .String = \"Unterminated pattern.\" }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "pattern",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to string from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn string(self: *Self, multiline: bool) Token {\n    const delimiter: u8 = if (multiline) '`' else '\"';\n    var in_interp: bool = false;\n    var interp_depth: usize = 0;\n    while ((self.peek() != delimiter or in_interp) and !self.isEOF()) {\n        if (self.peek() == '\\n' and !multiline) {\n            return self.makeToken(.Error, .{ .String = \"Unterminated string.\" }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "string",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isEOF from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn isEOF(self: *Self) bool {\n    return self.current.offset >= self.source.len or self.source[self.current.offset] == 0;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "isEOF",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to peek from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn peek(self: *Self) u8 {\n    if (self.isEOF()) {\n        return '\\x00';\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "peek",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to peekNext from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn peekNext(self: *Self) u8 {\n    if (self.current.offset + 1 >= self.source.len) {\n        return '\\x00';\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "peekNext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to peekNextNext from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn peekNextNext(self: *Self) u8 {\n    if (self.current.offset + 2 >= self.source.len) {\n        return '\\x00';\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "peekNextNext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to advance from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn advance(self: *Self) u8 {\n    const char = self.source[self.current.offset];\n\n    self.current.offset += 1;\n    self.current.column += 1;\n\n    return char;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "advance",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to match from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn match(self: *Self, expected: u8) bool {\n    if (self.isEOF()) {\n        return false;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "match",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to makeToken from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "fn makeToken(self: *Self, tag: Token.Type, literal: Token.Literal) Token {\n    self.token_index += 1;\n    return Token{\n        .tag = tag,\n        .lexeme = self.source[self.current.start..self.current.offset],\n        .literal = literal,\n        .offset = self.current.start,\n        .line = self.line_offset + self.current.start_line,\n        .column = self.column_offset + self.current.start_column,\n        .source = self.source,\n        .script_name = self.script_name,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "makeToken",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to highlight from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "pub fn highlight(self: *Self, out: *std.Io.Writer, true_color: bool) void {\n    var previous_offset: usize = 0;\n    var token = self.scanToken() catch unreachable;\n    while (token.tag != .Eof and token.tag != .Error) {\n        // If there some whitespace or comments between tokens?\n        // In gray because either whitespace or comment\n        if (token.offset > previous_offset) {\n            if (true_color) {\n                out.print(\n                    \"{s}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "function",
      "name": "highlight",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to SourceLocation from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "pub const SourceLocation = struct {\n    start: usize,\n    start_line: usize,\n    start_column: usize,\n    line: usize,\n    column: usize,\n    offset: usize,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "struct",
      "name": "SourceLocation",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Color from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "pub const Color = struct {\n    pub const black = \"\\x1b[30m\";\n    pub const red = \"\\x1b[31m\";\n    pub const green = \"\\x1b[32m\";\n    pub const yellow = \"\\x1b[33m\";\n    pub const blue = \"\\x1b[34m\";\n    pub const magenta = \"\\x1b[35m\";\n    pub const cyan = \"\\x1b[36m\";\n    pub const white = \"\\x1b[37m\";\n    pub const bright_black = \"\\x1b[90m\";\n    pub const bright_red = \"\\x1b[91m\";\n    pub const bright_green = \"\\x1b[92m\";\n    pub const bright_yellow = \"\\x1b[93m\";\n    pub const bright_blue = \"\\x1b[94m\";\n    pub const bright_magenta = \"\\x1b[95m\";\n    pub const bright_cyan = \"\\x1b[96m\";\n    pub const bright_white = \"\\x1b[97m\";\n    pub const dim = \"\\x1b[1m\";\n    pub const bold = \"\\x1b[2m\";\n    pub const reset = \"\\x1b[0m\";\n\n    pub const comment = \"\\x1b[38;2;99;106;114m\";\n    pub const keyword = \"\\x1b[38;2;249;140;63m\";\n    pub const punctuation = \"\\x1b[38;2;255;215;0m\";\n    pub const number = \"\\x1b[38;2;249;175;79m\";\n    pub const string = \"\\x1b[38;2;127;217;98m\";\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "struct",
      "name": "Color",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to char from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "const char: u8 = self.advance();",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "const",
      "name": "char",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to char from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "const char: u8 = self.peek();",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "const",
      "name": "char",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to char from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "const char: u8 = self.peek();",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "const",
      "name": "char",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to delimiter from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Scanner.zig",
    "response": "const delimiter: u8 = if (multiline) '`' else '\"';",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Scanner.zig",
      "type": "const",
      "name": "delimiter",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to advance from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/StringParser.zig",
    "response": "fn advance(self: *Self) ?u8 {\n    if (self.offset >= self.source.len) {\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/StringParser.zig",
      "type": "function",
      "name": "advance",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to parse from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/StringParser.zig",
    "response": "pub fn parse(self: *Self) !Ast.Node.Index {\n    const start_location = self.parser.current_token.? - 1;\n    while (self.offset < self.source.len) {\n        const char: ?u8 = self.advance();\n        if (char == null) {\n            break;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/StringParser.zig",
      "type": "function",
      "name": "parse",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to push from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/StringParser.zig",
    "response": "fn push(self: *Self, chars: []const u8) !void {\n    try self.elements.append(\n        self.parser.gc.allocator,\n        try self.parser.ast.appendNode(\n            .{\n                .tag = .StringLiteral,\n                .location = self.parser.current_token.? - 1,\n                .end_location = self.parser.current_token.? - 1,\n                .type_def = self.parser.gc.type_registry.str_type,\n                .components = .{\n                    .StringLiteral = .{\n                        .delimiter = self.delimiter,\n                        .literal = try self.parser.gc.copyString(chars),\n                    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/StringParser.zig",
      "type": "function",
      "name": "push",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to inc from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/StringParser.zig",
    "response": "fn inc(self: *Self) !void {\n    self.chunk_count += 1;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/StringParser.zig",
      "type": "function",
      "name": "inc",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to interpolation from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/StringParser.zig",
    "response": "fn interpolation(self: *Self) !void {\n    const expr = self.source[self.offset..];\n\n    const previous_current_token = self.parser.current_token.?;\n    const previous_offset = self.offset + 1;\n\n    var expr_scanner = Scanner.init(\n        self.parser.gc.allocator,\n        self.parser.script_name,\n        expr,\n    );\n    expr_scanner.line_offset = self.line_offset;\n    expr_scanner.column_offset = self.column_offset;\n\n    // Replace parser scanner with one that only looks at that substring\n    const scanner = self.parser.scanner;\n    self.parser.scanner = expr_scanner;\n\n    try self.parser.advance();\n\n    // Parse expression\n    try self.elements.append(self.parser.gc.allocator, try self.parser.expression(false));\n\n    self.offset += self.parser.scanner.?.current.offset - 1;\n    self.previous_interp = self.offset;\n\n    // Fix location of tokens created by this parsing\n    for (previous_current_token + 1..self.parser.current_token.?) |i| {\n        self.parser.ast.tokens.items(.source)[i] = scanner.?.source;\n        self.parser.ast.tokens.items(.offset)[i] += self.host_offset + previous_offset;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/StringParser.zig",
      "type": "function",
      "name": "interpolation",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to escape from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/StringParser.zig",
    "response": "fn escape(self: *Self) !void {\n    const char: ?u8 = self.advance();\n    if (char == null) {\n        return;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/StringParser.zig",
      "type": "function",
      "name": "escape",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rawChar from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/StringParser.zig",
    "response": "fn rawChar(self: *Self) !void {\n    const start: usize = self.offset - 1;\n    while (self.offset + 1 < self.source.len and self.source[self.offset + 1] >= '0' and self.source[self.offset + 1] <= '9') {\n        _ = self.advance();\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/StringParser.zig",
      "type": "function",
      "name": "rawChar",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to char from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/StringParser.zig",
    "response": "const char: ?u8 = self.advance();",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/StringParser.zig",
      "type": "const",
      "name": "char",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to char from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/StringParser.zig",
    "response": "const char: ?u8 = self.advance();",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/StringParser.zig",
      "type": "const",
      "name": "char",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to start from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/StringParser.zig",
    "response": "const start: usize = self.offset - 1;",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/StringParser.zig",
      "type": "const",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to num_str from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/StringParser.zig",
    "response": "const num_str: []const u8 = self.source[start..@min(self.offset + 1, self.source.len)];",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/StringParser.zig",
      "type": "const",
      "name": "num_str",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to number from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/StringParser.zig",
    "response": "const number: ?u8 = std.fmt.parseInt(u8, num_str, 10) catch null;",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/StringParser.zig",
      "type": "const",
      "name": "number",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to eql from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Token.zig",
    "response": "pub fn eql(self: Self, other: Self) bool {\n    return self.tag == other.tag and\n        self.line == other.line and\n        self.column == other.column and\n        self.offset == other.offset and\n        std.mem.eql(u8, self.source, other.source) and\n        std.mem.eql(u8, self.script_name, other.script_name);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Token.zig",
      "type": "function",
      "name": "eql",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to identifier from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Token.zig",
    "response": "pub fn identifier(name: []const u8) Self {\n    return .{\n        .tag = .Identifier,\n        .lexeme = name,\n        .line = 0,\n        .column = 0,\n        .source = \"\",\n        .script_name = \"\",\n        .literal = .{\n            .String = name,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Token.zig",
      "type": "function",
      "name": "identifier",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to clone from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Token.zig",
    "response": "pub fn clone(self: Self) Self {\n    return .{\n        .tag = self.tag,\n        .lexeme = self.lexeme,\n        .source = self.source,\n        .script_name = self.script_name,\n        .literal = self.literal,\n        .line = self.line,\n        .column = self.column,\n        .offset = self.offset,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Token.zig",
      "type": "function",
      "name": "clone",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getLines from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/Token.zig",
    "response": "pub fn getLines(self: Self, allocator: mem.Allocator, before: usize, after: usize) ![][]const u8 {\n    var lines = std.ArrayList([]const u8){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/Token.zig",
      "type": "function",
      "name": "getLines",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to init from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/TypeRegistry.zig",
    "response": "pub fn init(gc: *GC) !TypeRegistry {\n    var self = TypeRegistry{\n        .gc = gc,\n        .void_type = undefined,\n        .str_type = undefined,\n        .int_type = undefined,\n        .float_type = undefined,\n        .bool_type = undefined,\n        .any_type = undefined,\n        .pat_type = undefined,\n        .ud_type = undefined,\n        .rg_type = undefined,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/TypeRegistry.zig",
      "type": "function",
      "name": "init",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to deinit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/TypeRegistry.zig",
    "response": "pub fn deinit(self: *TypeRegistry) void {\n    self.registry.deinit(self.gc.allocator);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/TypeRegistry.zig",
      "type": "function",
      "name": "deinit",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to dump from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/TypeRegistry.zig",
    "response": "pub fn dump(self: *TypeRegistry) void {\n    io.print(\"\\n====== Type Registry ======\\n\", .{}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/TypeRegistry.zig",
      "type": "function",
      "name": "dump",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to getTypeDef from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/TypeRegistry.zig",
    "response": "pub fn getTypeDef(self: *TypeRegistry, type_def: o.ObjTypeDef) !*o.ObjTypeDef {\n    const hash = typeDefHash(type_def);\n\n    // We don't return a cached version of a placeholder since they all maintain a particular state (link)\n    if (type_def.def_type != .Placeholder) {\n        if (self.registry.get(hash)) |type_def_ptr| {\n            return type_def_ptr;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/TypeRegistry.zig",
      "type": "function",
      "name": "getTypeDef",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to setTypeDef from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/TypeRegistry.zig",
    "response": "pub fn setTypeDef(self: *TypeRegistry, type_def: *o.ObjTypeDef) !void {\n    const hash = typeDefHash(type_def.*);\n\n    std.debug.assert(type_def.def_type != .Placeholder);\n\n    try self.registry.put(\n        self.gc.allocator,\n        hash,\n        type_def,\n    );\n\n    if (BuildOptions.debug_placeholders or BuildOptions.debug_type_registry) {\n        io.print(\n            \"`{s}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/TypeRegistry.zig",
      "type": "function",
      "name": "setTypeDef",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to getTypeDefByName from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/TypeRegistry.zig",
    "response": "fn getTypeDefByName(self: *TypeRegistry, name: []const u8) ?*o.ObjTypeDef {\n    return self.registry.get(name);\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/TypeRegistry.zig",
      "type": "function",
      "name": "getTypeDefByName",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to mark from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/TypeRegistry.zig",
    "response": "pub fn mark(self: *TypeRegistry) !void {\n    var it = self.registry.iterator();\n    while (it.next()) |kv| {\n        try self.gc.markObj(@constCast(kv.value_ptr.*).toObj());\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/TypeRegistry.zig",
      "type": "function",
      "name": "mark",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to hashHelper from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/TypeRegistry.zig",
    "response": "fn hashHelper(hasher: *std.hash.Wyhash, type_def: *const o.ObjTypeDef) void {\n    std.hash.autoHash(hasher, type_def.def_type);\n    std.hash.autoHash(hasher, type_def.optional);\n    if (type_def.resolved_type) |resolved| {\n        switch (resolved) {\n            // We actually hash the ObjTypeDef and not its pointer since we don't put Placeholders in the registry\n            // BUT: when going deeper in those type we might encounter a pointer to a Placeholder ObjTypeDef,\n            // in that case we wan't to use the pointer (real this time) as hash value\n            .Placeholder => std.hash.autoHash(hasher, type_def),\n\n            .Bool,\n            .Double,\n            .Integer,\n            .Pattern,\n            .String,\n            .Type, // Something that holds a type, not an actual type\n            .UserData,\n            .Void,\n            .Range,\n            => {}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/TypeRegistry.zig",
      "type": "function",
      "name": "hashHelper",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to typeDefHash from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/TypeRegistry.zig",
    "response": "pub fn typeDefHash(type_def: o.ObjTypeDef) TypeDefHash {\n    var hasher = std.hash.Wyhash.init(0);\n\n    hashHelper(&hasher, &type_def);\n\n    return hasher.final();\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/TypeRegistry.zig",
      "type": "function",
      "name": "typeDefHash",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to testBehaviors from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/behavior.zig",
    "response": "fn testBehaviors(allocator: std.mem.Allocator) !Result {\n    var count: usize = 0;\n    var fail_count: usize = 0;\n    var skipped: usize = 0;\n\n    var test_dir = try std.fs.cwd().openDir(\n        \"tests\",\n        .{\n            .iterate = true,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/behavior.zig",
      "type": "function",
      "name": "testBehaviors",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to testCompileErrors from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/behavior.zig",
    "response": "fn testCompileErrors(allocator: std.mem.Allocator) !Result {\n    var count: usize = 0;\n    var fail_count: usize = 0;\n    var skipped: usize = 0;\n\n    var test_dir = try std.fs.cwd().openDir(\n        \"tests/compile_errors\",\n        .{\n            .iterate = true,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/behavior.zig",
      "type": "function",
      "name": "testCompileErrors",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to main from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/behavior.zig",
    "response": "pub fn main() !u8 {\n    var gpa = std.heap.GeneralPurposeAllocator(.{\n        .safety = true,\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/behavior.zig",
      "type": "function",
      "name": "main",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig struct similar to Result from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/behavior.zig",
    "response": "const Result = struct {\n    total: usize,\n    failed: usize,\n    skipped: usize,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/behavior.zig",
      "type": "struct",
      "name": "Result",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to file_name from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/behavior.zig",
    "response": "const file_name: []u8 = try allocator.alloc(u8, 21 + file.name.len);",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/behavior.zig",
      "type": "const",
      "name": "file_name",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to over from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/fiber.zig",
    "response": "pub fn over(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjFiber.cast(ctx.vm.peek(0).obj()).?;\n\n    ctx.vm.push(v.Value.fromBoolean(self.fiber.status == .Over));\n\n    return 1;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/fiber.zig",
      "type": "function",
      "name": "over",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to cancel from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/fiber.zig",
    "response": "pub fn cancel(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjFiber.cast(ctx.vm.peek(0).obj()).?;\n\n    // Main fiber can't be cancelled\n    if (self.fiber.parent_fiber == null) {\n        return 0;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/fiber.zig",
      "type": "function",
      "name": "cancel",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to isMain from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/fiber.zig",
    "response": "pub fn isMain(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjFiber.cast(ctx.vm.peek(0).obj()).?;\n\n    ctx.vm.push(v.Value.fromBoolean(self.fiber.parent_fiber == null));\n\n    return 1;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/fiber.zig",
      "type": "function",
      "name": "isMain",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to append from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn append(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const list_value = ctx.vm.peek(1);\n    const list = o.ObjList.cast(list_value.obj()).?;\n    const value = ctx.vm.peek(0);\n\n    list.rawAppend(\n        ctx.vm.gc,\n        value,\n    ) catch {\n        ctx.vm.panic(\"Out of memory\");\n        unreachable;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "append",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to insert from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn insert(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const list_value = ctx.vm.peek(2);\n    const list = o.ObjList.cast(list_value.obj()).?;\n    var index = ctx.vm.peek(1).integer();\n    const value = ctx.vm.peek(0);\n\n    if (index < 0 or list.items.items.len == 0) {\n        index = 0;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "insert",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to len from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn len(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const list = o.ObjList.cast(ctx.vm.peek(0).obj()).?;\n\n    ctx.vm.push(v.Value.fromInteger(@as(v.Integer, @intCast(list.items.items.len))));\n\n    return 1;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "len",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reverse from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn reverse(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const list = o.ObjList.cast(ctx.vm.peek(0).obj()).?;\n\n    var new_list = ctx.vm.gc.allocateObject(\n        o.ObjList.init(ctx.vm.gc.allocator, list.type_def) catch {\n            ctx.vm.panic(\"Out of memory\");\n            unreachable;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "reverse",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to pop from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn pop(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const list = o.ObjList.cast(ctx.vm.peek(0).obj()).?;\n\n    if (list.items.items.len > 0) {\n        ctx.vm.push(list.items.pop().?);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "pop",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to remove from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn remove(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const list = o.ObjList.cast(ctx.vm.peek(1).obj()).?;\n    const list_index = ctx.vm.peek(0).integer();\n\n    if (list_index < 0 or list_index >= list.items.items.len) {\n        ctx.vm.push(v.Value.Null);\n\n        return 1;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "remove",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to lessThan from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "fn lessThan(context: SortContext, lhs: v.Value, rhs: v.Value) bool {\n    var args = [_]*const v.Value{ &lhs, &rhs }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "lessThan",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sort from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn sort(ctx: *o.NativeCtx) callconv(.c) c_int {\n    var self = o.ObjList.cast(ctx.vm.peek(1).obj()).?;\n    // fun compare(T lhs, T rhs) > bool\n    const sort_closure = ctx.vm.peek(0);\n\n    std.sort.insertion(\n        v.Value,\n        self.items.items,\n        SortContext{\n            .sort_closure = sort_closure,\n            .ctx = ctx,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "sort",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to indexOf from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn indexOf(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjList.cast(ctx.vm.peek(1).obj()).?;\n    const needle = ctx.vm.peek(0);\n\n    var index: ?usize = null;\n    var i: usize = 0;\n    for (self.items.items) |item| {\n        if (needle.eql(item)) {\n            index = i;\n            break;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "indexOf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to cloneRaw from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "fn cloneRaw(ctx: *o.NativeCtx, mutable: bool) void {\n    const self = o.ObjList.cast(ctx.vm.peek(0).obj()).?;\n\n    var new_list = ctx.vm.gc.allocateObject(\n        o.ObjList.init(\n            ctx.vm.gc.allocator,\n            self.type_def.cloneMutable(&ctx.vm.gc.type_registry, mutable) catch {\n                ctx.vm.panic(\"Out of memory\");\n                unreachable;\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "cloneRaw",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to cloneImmutable from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn cloneImmutable(ctx: *o.NativeCtx) callconv(.c) c_int {\n    cloneRaw(ctx, false);\n\n    return 1;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "cloneImmutable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to cloneMutable from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn cloneMutable(ctx: *o.NativeCtx) callconv(.c) c_int {\n    cloneRaw(ctx, true);\n\n    return 1;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "cloneMutable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to join from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn join(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjList.cast(ctx.vm.peek(1).obj()).?;\n    const separator = o.ObjString.cast(ctx.vm.peek(0).obj()).?;\n\n    var result = std.ArrayList(u8).empty;\n    var writer = result.writer(ctx.vm.gc.allocator);\n    defer result.deinit(ctx.vm.gc.allocator);\n    for (self.items.items, 0..) |item, i| {\n        item.toString(&writer) catch {\n            ctx.vm.panic(\"Out of memory\");\n            unreachable;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "join",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to sub from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn sub(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjList.cast(ctx.vm.peek(2).obj()).?;\n    const start = @min(\n        @max(\n            0,\n            ctx.vm.peek(1).integer(),\n        ),\n        self.items.items.len - 1,\n    );\n    const upto = if (ctx.vm.peek(0).integerOrNull()) |u|\n        @max(0, u)\n    else\n        null;\n\n    const limit: usize = if (upto != null and @as(usize, @intCast(start + upto.?)) < self.items.items.len)\n        @intCast(start + upto.?)\n    else\n        self.items.items.len;\n    const substr = self.items.items[@intCast(start)..limit];\n\n    var methods = std.ArrayList(?*o.ObjNative)\n        .fromOwnedSlice(self.methods)\n        .clone(ctx.vm.gc.allocator) catch {\n        ctx.vm.panic(\"Out of memory\");\n        unreachable;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "sub",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to next from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn next(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const list_value = ctx.vm.peek(1);\n    const list = o.ObjList.cast(list_value.obj()).?;\n    const list_index = ctx.vm.peek(0);\n\n    const next_index: ?v.Integer = list.rawNext(\n        ctx.vm,\n        list_index.integerOrNull(),\n    ) catch {\n        ctx.vm.panic(\"Out of memory\");\n        unreachable;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "next",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to forEach from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn forEach(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const list = o.ObjList.cast(ctx.vm.peek(1).obj()).?;\n    const closure = ctx.vm.peek(0);\n\n    for (list.items.items, 0..) |item, index| {\n        const index_value = v.Value.fromInteger(@as(v.Integer, @intCast(index)));\n\n        var args = [_]*const v.Value{ &index_value, &item }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "forEach",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reduce from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn reduce(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const list = o.ObjList.cast(ctx.vm.peek(2).obj()).?;\n    const closure = ctx.vm.peek(1);\n    var accumulator = ctx.vm.peek(0);\n\n    for (list.items.items, 0..) |item, index| {\n        const index_value = v.Value.fromInteger(@as(v.Integer, @intCast(index)));\n\n        var args = [_]*const v.Value{\n            &index_value,\n            &item,\n            &accumulator,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "reduce",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to filter from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn filter(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const list = o.ObjList.cast(ctx.vm.peek(1).obj()).?;\n    const closure = ctx.vm.peek(0);\n\n    var new_list = ctx.vm.gc.allocateObject(\n        o.ObjList.init(\n            ctx.vm.gc.allocator,\n            list.type_def,\n        ) catch {\n            ctx.vm.panic(\"Out of memory\");\n            unreachable;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "filter",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to map from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn map(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const list = o.ObjList.cast(ctx.vm.peek(1).obj()).?;\n    const closure = ctx.vm.peek(0);\n\n    const mapped_type = o.ObjClosure.cast(closure.obj()).?\n        .function\n        .type_def.resolved_type.?.Function\n        .return_type;\n\n    var new_list = ctx.vm.gc.allocateObject(\n        o.ObjList.init(\n            ctx.vm.gc.allocator,\n            ctx.vm.gc.type_registry.getTypeDef(\n                .{\n                    .def_type = .List,\n                    .resolved_type = .{\n                        .List = o.ObjList.ListDef.init(\n                            mapped_type,\n                            false,\n                        ),\n                    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "map",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to fill from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "pub fn fill(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjList.cast(ctx.vm.peek(3).obj()).?;\n    const value = ctx.vm.peek(2);\n    const start: usize = @intCast(\n        @min(\n            @max(\n                0,\n                ctx.vm.peek(1).integerOrNull() orelse 0,\n            ),\n            self.items.items.len - 1,\n        ),\n    );\n    const count: ?usize = if (ctx.vm.peek(0).integerOrNull()) |c|\n        @intCast(@max(0, c))\n    else\n        null;\n\n    const limit: usize = if (count != null and start + count.? < self.items.items.len)\n        start + count.?\n    else\n        self.items.items.len;\n\n    for (start..limit) |i| {\n        self.items.items[i] = value;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "function",
      "name": "fill",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to SortContext from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "const SortContext = struct {\n    sort_closure: v.Value,\n    ctx: *o.NativeCtx,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "struct",
      "name": "SortContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to limit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "const limit: usize = if (upto != null and @as(usize, @intCast(start + upto.?)) < self.items.items.len)\n        @intCast(start + upto.?)\n    else\n        self.items.items.len;",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "const",
      "name": "limit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to next_index from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "const next_index: ?v.Integer = list.rawNext(\n        ctx.vm,\n        list_index.integerOrNull(),\n    ) catch {\n        ctx.vm.panic(\"Out of memory\");",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "const",
      "name": "next_index",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to start from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "const start: usize = @intCast(\n        @min(\n            @max(\n                0,\n                ctx.vm.peek(1).integerOrNull() orelse 0,\n            ),\n            self.items.items.len - 1,\n        ),\n    );",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "const",
      "name": "start",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to count from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "const count: ?usize = if (ctx.vm.peek(0).integerOrNull()) |c|\n        @intCast(@max(0, c))\n    else\n        null;",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "const",
      "name": "count",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to limit from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/list.zig",
    "response": "const limit: usize = if (count != null and start + count.? < self.items.items.len)\n        start + count.?\n    else\n        self.items.items.len;",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/list.zig",
      "type": "const",
      "name": "limit",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to cloneRaw from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "fn cloneRaw(ctx: *o.NativeCtx, mutable: bool) void {\n    const self = o.ObjMap.cast(ctx.vm.peek(0).obj()).?;\n\n    var new_map = ctx.vm.gc.allocateObject(\n        o.ObjMap.init(\n            ctx.vm.gc.allocator,\n            self.type_def.cloneMutable(&ctx.vm.gc.type_registry, mutable) catch {\n                ctx.vm.panic(\"Out of memory\");\n                unreachable;\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "function",
      "name": "cloneRaw",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to cloneMutable from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "pub fn cloneMutable(ctx: *o.NativeCtx) callconv(.c) c_int {\n    cloneRaw(ctx, true);\n\n    return 1;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "function",
      "name": "cloneMutable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to cloneImmutable from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "pub fn cloneImmutable(ctx: *o.NativeCtx) callconv(.c) c_int {\n    cloneRaw(ctx, false);\n\n    return 1;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "function",
      "name": "cloneImmutable",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to reduce from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "pub fn reduce(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjMap.cast(ctx.vm.peek(2).obj()).?;\n    const closure = ctx.vm.peek(1);\n    var accumulator = ctx.vm.peek(0);\n\n    var it = self.map.iterator();\n    while (it.next()) |kv| {\n        var args = [_]*const v.Value{ kv.key_ptr, kv.value_ptr, &accumulator }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "function",
      "name": "reduce",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to filter from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "pub fn filter(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjMap.cast(ctx.vm.peek(1).obj()).?;\n    const closure = ctx.vm.peek(0);\n\n    var new_map = ctx.vm.gc.allocateObject(\n        o.ObjMap.init(\n            ctx.vm.gc.allocator,\n            self.type_def,\n        ) catch {\n            ctx.vm.panic(\"Out of memory\");\n            unreachable;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "function",
      "name": "filter",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to forEach from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "pub fn forEach(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjMap.cast(ctx.vm.peek(1).obj()).?;\n    const closure = ctx.vm.peek(0);\n\n    var it = self.map.iterator();\n    while (it.next()) |kv| {\n        var args = [_]*const v.Value{ kv.key_ptr, kv.value_ptr }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "function",
      "name": "forEach",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to map from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "pub fn map(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjMap.cast(ctx.vm.peek(1).obj()).?;\n    const closure = ctx.vm.peek(0);\n\n    const mapped_type = o.ObjClosure.cast(closure.obj()).?.function.type_def.resolved_type.?.Function\n        .return_type.resolved_type.?.ObjectInstance.of\n        .resolved_type.?.Object;\n\n    var new_map = ctx.vm.gc.allocateObject(\n        o.ObjMap.init(\n            ctx.vm.gc.allocator,\n            ctx.vm.gc.type_registry.getTypeDef(\n                .{\n                    .optional = false,\n                    .def_type = .Map,\n                    .resolved_type = .{\n                        .Map = o.ObjMap.MapDef.init(\n                            mapped_type.fields.get(\"key\").?.type_def,\n                            mapped_type.fields.get(\"value\").?.type_def,\n                            self.type_def.resolved_type.?.Map.mutable,\n                        ),\n                    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "function",
      "name": "map",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to lessThan from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "pub fn lessThan(context: SortContext, lhs_index: usize, rhs_index: usize) bool {\n        const map_keys = context.map.map.keys();\n        const lhs = map_keys[lhs_index];\n        const rhs = map_keys[rhs_index];\n\n        var args = [_]*const v.Value{ &lhs, &rhs }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "function",
      "name": "lessThan",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to sort from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "pub fn sort(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjMap.cast(ctx.vm.peek(1).obj()).?;\n    const sort_closure = ctx.vm.peek(0);\n\n    self.map.sort(\n        SortContext{\n            .sort_closure = sort_closure,\n            .ctx = ctx,\n            .map = self,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "function",
      "name": "sort",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to diff from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "pub fn diff(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const lhs = o.ObjMap.cast(ctx.vm.peek(1).obj()).?;\n    const rhs = o.ObjMap.cast(ctx.vm.peek(0).obj()).?;\n\n    var new_map = ctx.vm.gc.allocateObject(\n        o.ObjMap.init(\n            ctx.vm.gc.allocator,\n            lhs.type_def,\n        ) catch {\n            ctx.vm.panic(\"Out of memory\");\n            unreachable;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "function",
      "name": "diff",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to intersect from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "pub fn intersect(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const lhs = o.ObjMap.cast(ctx.vm.peek(1).obj()).?;\n    const rhs = o.ObjMap.cast(ctx.vm.peek(0).obj()).?;\n\n    var new_map = ctx.vm.gc.allocateObject(\n        o.ObjMap.init(\n            ctx.vm.gc.allocator,\n            lhs.type_def,\n        ) catch {\n            ctx.vm.panic(\"Out of memory\");\n            unreachable;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "function",
      "name": "intersect",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to size from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "pub fn size(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjMap.cast(ctx.vm.peek(0).obj()).?;\n\n    ctx.vm.push(v.Value.fromInteger(@intCast(self.map.count())));\n\n    return 1;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "function",
      "name": "size",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to remove from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "pub fn remove(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjMap.cast(ctx.vm.peek(1).obj()).?;\n    const map_key = ctx.vm.peek(0);\n\n    if (self.map.fetchOrderedRemove(map_key)) |removed| {\n        ctx.vm.push(removed.value);\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "function",
      "name": "remove",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to keys from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "pub fn keys(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjMap.cast(ctx.vm.peek(0).obj()).?;\n\n    const map_keys = self.map.keys();\n    var result = std.ArrayList(v.Value){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "function",
      "name": "keys",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to values from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "pub fn values(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjMap.cast(ctx.vm.peek(0).obj()).?;\n\n    const map_values: []v.Value = self.map.values();\n    var result = std.ArrayList(v.Value){}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "function",
      "name": "values",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig struct similar to SortContext from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "const SortContext = struct {\n    sort_closure: v.Value,\n    ctx: *o.NativeCtx,\n    map: *o.ObjMap,\n\n    pub fn lessThan(context: SortContext, lhs_index: usize, rhs_index: usize) bool {\n        const map_keys = context.map.map.keys();\n        const lhs = map_keys[lhs_index];\n        const rhs = map_keys[rhs_index];\n\n        var args = [_]*const v.Value{ &lhs, &rhs }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "struct",
      "name": "SortContext",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig const similar to map_values from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/map.zig",
    "response": "const map_values: []v.Value = self.map.values();",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/map.zig",
      "type": "const",
      "name": "map_values",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to patternReplaceLength from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/pattern.zig",
    "response": "fn patternReplaceLength(\n    string_ptr: [*]const u8,\n    string_len: isize,\n    replacement_ptr: [*]const u8,\n    replacement_len: isize,\n    pattern_ptr: [*]const u8,\n    pattern_len: isize,\n) callconv(.c) isize;\n\nextern fn patternReplace(\n    string_ptr: [*]const u8,\n    string_len: isize,\n    replacement_ptr: [*]const u8,\n    replacement_len: isize,\n    pattern_ptr: [*]const u8,\n    pattern_len: isize,\n    output_ptr: [*]const u8,\n    output_len: isize,\n) callconv(.c) void;\n\nextern fn patternReplaceAllLength(\n    string_ptr: [*]const u8,\n    string_len: isize,\n    replacement_ptr: [*]const u8,\n    replacement_len: isize,\n    pattern_ptr: [*]const u8,\n    pattern_len: isize,\n) callconv(.c) isize;\n\nextern fn patternReplaceAll(\n    string_ptr: [*]const u8,\n    string_len: isize,\n    replacement_ptr: [*]const u8,\n    replacement_len: isize,\n    pattern_ptr: [*]const u8,\n    pattern_len: isize,\n    output_ptr: [*]const u8,\n    output_len: isize,\n) callconv(.c) void;\n\npub const pcre = @import(\"../pcre.zig\");\n\nconst fake_token: Token = .{\n    .lexeme = \"\",\n    .source = \"builtin\",\n    .script_name = \"builtin\",\n    .tag = .Obj,\n    .line = 0,\n    .column = 0,\n    .offset = 0,\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/pattern.zig",
      "type": "function",
      "name": "patternReplaceLength",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to matchType from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/pattern.zig",
    "response": "fn matchType(vm: *VM) !*o.ObjTypeDef {\n    var object_def = o.ObjObject.ObjectDef.init(\n        0,\n        try vm.gc.copyString(\"match\"),\n        try vm.gc.copyString(\"builtin.match\"),\n        true,\n    );\n\n    try object_def.fields.put(\n        vm.gc.allocator,\n        \"capture\",\n        .{\n            .name = \"capture\",\n            .index = 0,\n            .location = 0,\n            .type_def = vm.gc.type_registry.str_type,\n            .final = true,\n            .method = false,\n            .static = false,\n            .has_default = false,\n            .mutable = false,\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/pattern.zig",
      "type": "function",
      "name": "matchType",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to rawMatch from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/pattern.zig",
    "response": "fn rawMatch(self: *o.ObjPattern, vm: *VM, subject: *o.ObjString, offset: *usize) !?*o.ObjList {\n    if (subject.string.len == 0) {\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/pattern.zig",
      "type": "function",
      "name": "rawMatch",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rawMatchAll from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/pattern.zig",
    "response": "fn rawMatchAll(self: *o.ObjPattern, vm: *VM, subject: *o.ObjString) !?*o.ObjList {\n    if (subject.string.len == 0) {\n        return null;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/pattern.zig",
      "type": "function",
      "name": "rawMatchAll",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rawReplace from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/pattern.zig",
    "response": "fn rawReplace(self: *o.ObjPattern, vm: *VM, subject: *o.ObjString, replacement: *o.ObjString, offset: *usize) !*o.ObjString {\n    if (subject.string.len == 0) {\n        return subject;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/pattern.zig",
      "type": "function",
      "name": "rawReplace",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to rawReplaceAll from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/pattern.zig",
    "response": "fn rawReplaceAll(self: *o.ObjPattern, vm: *VM, subject: *o.ObjString, replacement: *o.ObjString) !*o.ObjString {\n    if (subject.string.len == 0) {\n        return subject;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/pattern.zig",
      "type": "function",
      "name": "rawReplaceAll",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to match from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/pattern.zig",
    "response": "pub fn match(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjPattern.cast(ctx.vm.peek(1).obj()).?;\n    const subject = o.ObjString.cast(ctx.vm.peek(0).obj()).?;\n\n    var offset: usize = 0;\n    if (rawMatch(\n        self,\n        ctx.vm,\n        subject,\n        &offset,\n    ) catch {\n        ctx.vm.panic(\"Out of memory\");\n        unreachable;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/pattern.zig",
      "type": "function",
      "name": "match",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to replace from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/pattern.zig",
    "response": "pub fn replace(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjPattern.cast(ctx.vm.peek(2).obj()).?;\n    const subject = o.ObjString.cast(ctx.vm.peek(1).obj()).?;\n    const replacement = o.ObjString.cast(ctx.vm.peek(0).obj()).?;\n\n    if (!is_wasm) {\n        var offset: usize = 0;\n        const result = rawReplace(\n            self,\n            ctx.vm,\n            subject,\n            replacement,\n            &offset,\n        ) catch {\n            ctx.vm.panic(\"Out of memory\");\n            unreachable;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/pattern.zig",
      "type": "function",
      "name": "replace",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to matchAll from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/pattern.zig",
    "response": "pub fn matchAll(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjPattern.cast(ctx.vm.peek(1).obj()).?;\n    const subject = o.ObjString.cast(ctx.vm.peek(0).obj()).?;\n\n    if (rawMatchAll(\n        self,\n        ctx.vm,\n        subject,\n    ) catch {\n        ctx.vm.panic(\"Out of memory\");\n        unreachable;\n    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/pattern.zig",
      "type": "function",
      "name": "matchAll",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to replaceAll from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/pattern.zig",
    "response": "pub fn replaceAll(ctx: *o.NativeCtx) callconv(.c) c_int {\n    const self = o.ObjPattern.cast(ctx.vm.peek(2).obj()).?;\n    const subject = o.ObjString.cast(ctx.vm.peek(1).obj()).?;\n    const replacement = o.ObjString.cast(ctx.vm.peek(0).obj()).?;\n\n    if (!is_wasm) {\n        const result = rawReplaceAll(\n            self,\n            ctx.vm,\n            subject,\n            replacement,\n        ) catch {\n            ctx.vm.panic(\"Out of memory\");\n            unreachable;\n        }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/pattern.zig",
      "type": "function",
      "name": "replaceAll",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig const similar to fake_token from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/pattern.zig",
    "response": "const fake_token: Token = .{\n    .lexeme = \"\",\n    .source = \"builtin\",\n    .script_name = \"builtin\",\n    .tag = .Obj,\n    .line = 0,\n    .column = 0,\n    .offset = 0,\n};",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/pattern.zig",
      "type": "const",
      "name": "fake_token",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to toList from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/range.zig",
    "response": "pub fn toList(ctx: *obj.NativeCtx) callconv(.c) c_int {\n    const range = ctx.vm.peek(0).obj().access(obj.ObjRange, .Range, ctx.vm.gc).?;\n\n    var list = ctx.vm.gc.allocateObject(\n        obj.ObjList.init(\n            ctx.vm.gc.allocator,\n            ctx.vm.gc.type_registry.getTypeDef(\n                .{\n                    .def_type = .List,\n                    .resolved_type = .{\n                        .List = obj.ObjList.ListDef.init(\n                            ctx.vm.gc.type_registry.int_type,\n                            false,\n                        ),\n                    }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/range.zig",
      "type": "function",
      "name": "toList",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to len from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/range.zig",
    "response": "pub fn len(ctx: *obj.NativeCtx) callconv(.c) c_int {\n    const range = ctx.vm.peek(0).obj().access(obj.ObjRange, .Range, ctx.vm.gc).?;\n\n    ctx.vm.push(\n        v.Value.fromInteger(\n            if (range.low < range.high)\n                range.high - range.low\n            else\n                range.low - range.high,\n        ),\n    );\n\n    return 1;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/range.zig",
      "type": "function",
      "name": "len",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to invert from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/range.zig",
    "response": "pub fn invert(ctx: *obj.NativeCtx) callconv(.c) c_int {\n    const range = ctx.vm.peek(0).obj().access(obj.ObjRange, .Range, ctx.vm.gc).?;\n\n    ctx.vm.push(\n        v.Value.fromObj((ctx.vm.gc.allocateObject(\n            obj.ObjRange{\n                .high = range.low,\n                .low = range.high,\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/range.zig",
      "type": "function",
      "name": "invert",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to subsetOf from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/range.zig",
    "response": "pub fn subsetOf(ctx: *obj.NativeCtx) callconv(.c) c_int {\n    const rangeA = ctx.vm.peek(1).obj().access(obj.ObjRange, .Range, ctx.vm.gc).?;\n    const rangeB = ctx.vm.peek(0).obj().access(obj.ObjRange, .Range, ctx.vm.gc).?;\n\n    ctx.vm.push(\n        v.Value.fromBoolean(\n            @min(rangeA.low, rangeA.high) >= @min(rangeB.low, rangeB.high) and\n                @max(rangeA.low, rangeA.high) <= @max(rangeB.low, rangeB.high),\n        ),\n    );\n\n    return 1;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/range.zig",
      "type": "function",
      "name": "subsetOf",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to intersect from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/range.zig",
    "response": "pub fn intersect(ctx: *obj.NativeCtx) callconv(.c) c_int {\n    const rangeA = ctx.vm.peek(1).obj().access(obj.ObjRange, .Range, ctx.vm.gc).?;\n    const rangeB = ctx.vm.peek(0).obj().access(obj.ObjRange, .Range, ctx.vm.gc).?;\n\n    ctx.vm.push(\n        v.Value.fromObj((ctx.vm.gc.allocateObject(\n            obj.ObjRange{\n                .high = @max(\n                    @min(rangeB.low, rangeB.high),\n                    @min(rangeA.low, rangeA.high),\n                ),\n                .low = @min(\n                    @max(rangeB.low, rangeB.high),\n                    @max(rangeA.low, rangeA.high),\n                ),\n            }",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/range.zig",
      "type": "function",
      "name": "intersect",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write a Zig function similar to high from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/range.zig",
    "response": "pub fn high(ctx: *obj.NativeCtx) callconv(.c) c_int {\n    ctx.vm.push(\n        v.Value.fromInteger(\n            ctx.vm.peek(0).obj().access(obj.ObjRange, .Range, ctx.vm.gc).?.high,\n        ),\n    );\n\n    return 1;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/range.zig",
      "type": "function",
      "name": "high",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to low from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/range.zig",
    "response": "pub fn low(ctx: *obj.NativeCtx) callconv(.c) c_int {\n    ctx.vm.push(\n        v.Value.fromInteger(\n            ctx.vm.peek(0).obj().access(obj.ObjRange, .Range, ctx.vm.gc).?.low,\n        ),\n    );\n\n    return 1;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/range.zig",
      "type": "function",
      "name": "low",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write a Zig function similar to contains from buzz-language/buzz",
    "context": "Repository: buzz-language/buzz (1414 ⭐)\nFile: src/builtin/range.zig",
    "response": "pub fn contains(ctx: *obj.NativeCtx) callconv(.c) c_int {\n    const range = ctx.vm.peek(1).obj().access(obj.ObjRange, .Range, ctx.vm.gc).?;\n    const value = ctx.vm.peek(0).integer();\n\n    ctx.vm.push(\n        v.Value.fromBoolean(\n            (range.high >= range.low and value >= range.low and value < range.high) or\n                (range.low >= range.high and value >= range.high and value < range.low),\n        ),\n    );\n\n    return 1;\n}",
    "metadata": {
      "repo": "buzz-language/buzz",
      "stars": 1414,
      "file": "src/builtin/range.zig",
      "type": "function",
      "name": "contains",
      "difficulty": "easy"
    }
  }
]