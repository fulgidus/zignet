[
  {
    "instruction": "Explain Zig Version in Zig 0.15.1",
    "context": "",
    "response": "0.1.1 | 0.2.0 | 0.3.0 | 0.4.0 | 0.5.0 | 0.6.0 | 0.7.1 | 0.8.1 | 0.9.1 | 0.10.1 | 0.11.0 | 0.12.1 | 0.13.0 | 0.14.1 | 0.15.1 | 0.15.2 | master",
    "metadata": {
      "version": "0.15.1",
      "topic": "Zig Version",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Table of Contents in Zig 0.15.1",
    "context": "",
    "response": "Introduction Zig Standard Library Hello World Comments Doc Comments Top-Level Doc Comments Values Primitive Types Primitive Values String Literals and Unicode Code Point Literals Escape Sequences Multiline String Literals Assignment undefined Destructuring Zig Test Test Declarations Doctests Test Failure Skip Tests Report Memory Leaks Detecting Test Build Test Output and Logging The Testing Namespace Test Tool Documentation Variables Identifiers Container Level Variables Static Local Variables Thread Local Variables Local Variables Integers Integer Literals Runtime Integer Values Floats Float Literals Floating Point Operations Operators Table of Operators Precedence Arrays Multidimensional Arrays Sentinel-Terminated Arrays Destructuring Arrays Vectors Destructuring Vectors Pointers volatile Alignment allowzero Sentinel-Terminated Pointers Slices Sentinel-Terminated Slices struct Default Field Values Faulty Default Field Values extern struct packed struct Struct Naming Anonymous Struct ",
    "metadata": {
      "version": "0.15.1",
      "topic": "Table of Contents",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Introduction § in Zig 0.15.1",
    "context": "",
    "response": "Zig is a general-purpose programming language and toolchain for maintaining robust , optimal , and reusable software. Robust Behavior is correct even for edge cases such as out of memory. Optimal Write programs the best way they can behave and perform. Reusable The same code works in many environments which have different constraints. Maintainable Precisely communicate intent to the compiler and other programmers. The language imposes a low overhead to reading code and is resilient to changing requirements and environments. Often the most efficient way to learn something new is to see examples, so this documentation shows how to use each of Zig's features. It is all on one page so you can search with your browser's search tool. The code samples in this document are compiled and tested as part of the main test suite of Zig. This HTML document depends on no external files, so you can use it offline.",
    "metadata": {
      "version": "0.15.1",
      "topic": "Introduction §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Zig Standard Library § in Zig 0.15.1",
    "context": "",
    "response": "The Zig Standard Library has its own documentation. Zig's Standard Library contains commonly used algorithms, data structures, and definitions to help you build programs or libraries. You will see many examples of Zig's Standard Library used in this documentation. To learn more about the Zig Standard Library, visit the link above. Alternatively, the Zig Standard Library documentation is provided with each Zig distribution. It can be rendered via a local webserver with: Shell",
    "metadata": {
      "version": "0.15.1",
      "topic": "Zig Standard Library §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Hello World §",
    "context": "hello.zig Shell Most of the time, it is more appropriate to write to stderr rather than stdout, and whether or not the message is successfully written to the stream is irrelevant. Also, formatted printing often comes in handy. For this common case, there is a simpler API: hello_again.zig Shell In this case, the ! may be omitted from the return type of main because no errors are returned from the function. See also: Values Tuples @import Errors Entry Point Source Encoding try",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> std.fs.File.stdout().writeAll(<span class=\"tok-str\">\"Hello, World!\\n\"</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Hello World §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Hello World §",
    "context": "hello.zig Shell Most of the time, it is more appropriate to write to stderr rather than stdout, and whether or not the message is successfully written to the stream is irrelevant. Also, formatted printing often comes in handy. For this common case, there is a simpler API: hello_again.zig Shell In this case, the ! may be omitted from the return type of main because no errors are returned from the function. See also: Values Tuples @import Errors Entry Point Source Encoding try",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    std.debug.print(<span class=\"tok-str\">\"Hello, {s}!\\n\"</span>, .{<span class=\"tok-str\">\"World\"</span>});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Hello World §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Hello World § in Zig 0.15.1",
    "context": "",
    "response": "hello.zig Shell Most of the time, it is more appropriate to write to stderr rather than stdout, and whether or not the message is successfully written to the stream is irrelevant. Also, formatted printing often comes in handy. For this common case, there is a simpler API: hello_again.zig Shell In this case, the ! may be omitted from the return type of main because no errors are returned from the function. See also: Values Tuples @import Errors Entry Point Source Encoding try",
    "metadata": {
      "version": "0.15.1",
      "topic": "Hello World §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Comments §",
    "context": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly t",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-comment\">// Comments in Zig start with \"//\" and end at the next LF byte (end of line).</span>\n    <span class=\"tok-comment\">// The line below is a comment and won't be executed.</span>\n\n    <span class=\"tok-comment\">//print(\"Hello?\", .{});</span>\n\n    print(<span class=\"tok-str\">\"Hello, world!\\n\"</span>, .{}); <span class=\"tok-comment\">// another comment</span>\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Comments §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Comments §",
    "context": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly t",
    "response": "<span class=\"tok-comment\">/// A structure for storing a timestamp, with nanosecond precision (this is a</span>\n<span class=\"tok-comment\">/// multiline doc comment).</span>\n<span class=\"tok-kw\">const</span> Timestamp = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-comment\">/// The number of seconds since the epoch (this is also a doc comment).</span>\n    seconds: <span class=\"tok-type\">i64</span>, <span class=\"tok-comment\">// signed so we can represent pre-1970 (not a doc comment)</span>\n    <span class=\"tok-comment\">/// The number of nanoseconds past the second (doc comment again).</span>\n    nanos: <span class=\"tok-type\">u32</span>,\n\n    <span class=\"tok-comment\">/// Returns a `Timestamp` struct representing the Unix epoch; that is, the</span>\n    <span class=\"tok-comment\">/// moment of 1970 Jan 1 00:00:00 UTC (this is a doc comment too).</span>\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">unixEpoch</span>() Timestamp {\n        <span class=\"tok-kw\">return</span> Timestamp{\n            .seconds = <span class=\"tok-number\">0</span>,\n            .nanos = <span class=\"tok-number\">0</span>,\n        };\n    }\n};",
    "metadata": {
      "version": "0.15.1",
      "topic": "Comments §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Comments §",
    "context": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly t",
    "response": "<span class=\"tok-comment\">/// doc-comment</span>\n<span class=\"tok-comment\">//! top-level doc-comment</span>\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);",
    "metadata": {
      "version": "0.15.1",
      "topic": "Comments §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Comments §",
    "context": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly t",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {}\n\n<span class=\"tok-comment\">/// End of file</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Comments §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Comments §",
    "context": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly t",
    "response": "<span class=\"tok-comment\">//! This module provides functions for retrieving the current date and</span>\n<span class=\"tok-comment\">//! time with varying degrees of precision and accuracy. It does not</span>\n<span class=\"tok-comment\">//! depend on libc, but will use functions from it if available.</span>\n\n<span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-comment\">//! Top level comments are allowed inside a container other than a module,</span>\n    <span class=\"tok-comment\">//! but it is not very useful.  Currently, when producing the package</span>\n    <span class=\"tok-comment\">//! documentation, these comments are ignored.</span>\n};",
    "metadata": {
      "version": "0.15.1",
      "topic": "Comments §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Comments § in Zig 0.15.1",
    "context": "",
    "response": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly three slashes (i.e. /// but not //// ); multiple doc comments in a row are merged together to form a multiline doc comment. The doc comment documents whatever immediately follows it. doc_comments.zig Doc comments are only allowed in certain places; it is a compile error to have a doc comment in an unexpected place, such as in the middle of an expression, or just before a non-doc comment. invalid_doc-comment.zig Shell unattached_doc-comment.zig Shell Doc comments can be interleaved with normal com",
    "metadata": {
      "version": "0.15.1",
      "topic": "Comments §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-comment\">// Top-level declarations are order-independent:</span>\n<span class=\"tok-kw\">const</span> print = std.debug.print;\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> os = std.os;\n<span class=\"tok-kw\">const</span> assert = std.debug.assert;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-comment\">// integers</span>\n    <span class=\"tok-kw\">const</span> one_plus_one: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span> + <span class=\"tok-number\">1</span>;\n    print(<span class=\"tok-str\">\"1 + 1 = {}\\n\"</span>, .{one_plus_one});\n\n    <span class=\"tok-comment\">// floats</span>\n    <span class=\"tok-kw\">const</span> seven_div_three: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">7.0</span> / <span class=\"tok-number\">3.0</span>;\n    print(<span class=\"tok-str\">\"7.0 / 3.0 = {}\\n\"</span>, .{seven_div_three});\n\n    <span class=\"tok-comment\">// boolean</span>\n    print(<span class=\"tok-str\">\"{}\\n{}\\n{}\\n\"</span>, .{\n        <span class=\"tok-null\">true</span> <span class=\"tok-kw\">and</span> <span class=\"tok-null\">false</span>,\n        <span class=\"tok-null\">true</span> <span class=\"tok-kw\">or</span> <span class=\"tok-null\">false</span>,\n        !<span class=\"tok-null\">true</span>,\n    });\n\n    <span class=\"tok-comment\">// optional</span>\n    <span class=\"tok-kw\">var</span> optional_value: ?[]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-null\">null</span>;\n    assert(optional_value == <span class=\"tok-null\">null</span>);\n\n    print(<span class=\"tok-str\">\"\\noptional 1\\ntype: {}\\nvalue: {?s}\\n\"</span>, .{\n        <span class=\"tok-builtin\">@TypeOf</span>(optional_value), optional_value,\n    });\n\n    optional_value = <span class=\"tok-str\">\"hi\"</span>;\n    assert(optional_value != <span class=\"tok-null\">null</span>);\n\n    print(<span class=\"tok-str\">\"\\noptional 2\\ntype: {}\\nvalue: {?s}\\n\"</span>, .{\n        <span class=\"tok-builtin\">@TypeOf</span>(optional_value), optional_value,\n    });\n\n    <span class=\"tok-comment\">// error union</span>\n    <span class=\"tok-kw\">var</span> number_or_error: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">i32</span> = <span class=\"tok-kw\">error</span>.ArgNotFound;\n\n    print(<span class=\"tok-str\">\"\\nerror union 1\\ntype: {}\\nvalue: {!}\\n\"</span>, .{\n        <span class=\"tok-builtin\">@TypeOf</span>(number_or_error),\n        number_or_error,\n    });\n\n    number_or_error = <span class=\"tok-number\">1234</span>;\n\n    print(<span class=\"tok-str\">\"\\nerror union 2\\ntype: {}\\nvalue: {!}\\n\"</span>, .{\n        <span class=\"tok-builtin\">@TypeOf</span>(number_or_error), number_or_error,\n    });\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Values §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem; <span class=\"tok-comment\">// will be used to compare bytes</span>\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> bytes = <span class=\"tok-str\">\"hello\"</span>;\n    print(<span class=\"tok-str\">\"{}\\n\"</span>, .{<span class=\"tok-builtin\">@TypeOf</span>(bytes)}); <span class=\"tok-comment\">// *const [5:0]u8</span>\n    print(<span class=\"tok-str\">\"{d}\\n\"</span>, .{bytes.len}); <span class=\"tok-comment\">// 5</span>\n    print(<span class=\"tok-str\">\"{c}\\n\"</span>, .{bytes[<span class=\"tok-number\">1</span>]}); <span class=\"tok-comment\">// 'e'</span>\n    print(<span class=\"tok-str\">\"{d}\\n\"</span>, .{bytes[<span class=\"tok-number\">5</span>]}); <span class=\"tok-comment\">// 0</span>\n    print(<span class=\"tok-str\">\"{}\\n\"</span>, .{<span class=\"tok-str\">'e'</span> == <span class=\"tok-str\">'\\x65'</span>}); <span class=\"tok-comment\">// true</span>\n    print(<span class=\"tok-str\">\"{d}\\n\"</span>, .{<span class=\"tok-str\">'\\u{1f4a9}'</span>}); <span class=\"tok-comment\">// 128169</span>\n    print(<span class=\"tok-str\">\"{d}\\n\"</span>, .{<span class=\"tok-str\">'💯'</span>}); <span class=\"tok-comment\">// 128175</span>\n    print(<span class=\"tok-str\">\"{u}\\n\"</span>, .{<span class=\"tok-str\">'⚡'</span>});\n    print(<span class=\"tok-str\">\"{}\\n\"</span>, .{mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-str\">\"hello\"</span>, <span class=\"tok-str\">\"h\\x65llo\"</span>)}); <span class=\"tok-comment\">// true</span>\n    print(<span class=\"tok-str\">\"{}\\n\"</span>, .{mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-str\">\"💯\"</span>, <span class=\"tok-str\">\"\\xf0\\x9f\\x92\\xaf\"</span>)}); <span class=\"tok-comment\">// also true</span>\n    <span class=\"tok-kw\">const</span> invalid_utf8 = <span class=\"tok-str\">\"\\xff\\xfe\"</span>; <span class=\"tok-comment\">// non-UTF-8 strings are possible with \\xNN notation.</span>\n    print(<span class=\"tok-str\">\"0x{x}\\n\"</span>, .{invalid_utf8[<span class=\"tok-number\">1</span>]}); <span class=\"tok-comment\">// indexing them returns individual bytes...</span>\n    print(<span class=\"tok-str\">\"0x{x}\\n\"</span>, .{<span class=\"tok-str\">\"💯\"</span>[<span class=\"tok-number\">1</span>]}); <span class=\"tok-comment\">// ...as does indexing part-way through non-ASCII characters</span>\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Values §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> hello_world_in_c =\n    <span class=\"tok-str\">\\\\#include <stdio.h></span>\n    <span class=\"tok-str\">\\\\</span>\n    <span class=\"tok-str\">\\\\int main(int argc, char **argv) {</span>\n    <span class=\"tok-str\">\\\\    printf(\"hello world\\n\");</span>\n    <span class=\"tok-str\">\\\\    return 0;</span>\n    <span class=\"tok-str\">\\\\}</span>\n;",
    "metadata": {
      "version": "0.15.1",
      "topic": "Values §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> x = <span class=\"tok-number\">1234</span>;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-comment\">// It works at file scope as well as inside functions.</span>\n    <span class=\"tok-kw\">const</span> y = <span class=\"tok-number\">5678</span>;\n\n    <span class=\"tok-comment\">// Once assigned, an identifier cannot be changed.</span>\n    y += <span class=\"tok-number\">1</span>;\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    foo();\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Values §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">5678</span>;\n\n    y += <span class=\"tok-number\">1</span>;\n\n    print(<span class=\"tok-str\">\"{d}\"</span>, .{y});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Values §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span>;\n\n    x = <span class=\"tok-number\">1</span>;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Values §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n    x = <span class=\"tok-number\">1</span>;\n    print(<span class=\"tok-str\">\"{d}\"</span>, .{x});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Values §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u32</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">u32</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">var</span> z: <span class=\"tok-type\">u32</span> = <span class=\"tok-null\">undefined</span>;\n\n    <span class=\"tok-kw\">const</span> tuple = .{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span> };\n\n    x, y, z = tuple;\n\n    print(<span class=\"tok-str\">\"tuple: x = {}, y = {}, z = {}\\n\"</span>, .{x, y, z});\n\n    <span class=\"tok-kw\">const</span> array = [_]<span class=\"tok-type\">u32</span>{ <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span> };\n\n    x, y, z = array;\n\n    print(<span class=\"tok-str\">\"array: x = {}, y = {}, z = {}\\n\"</span>, .{x, y, z});\n\n    <span class=\"tok-kw\">const</span> vector: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">3</span>, <span class=\"tok-type\">u32</span>) = .{ <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span>, <span class=\"tok-number\">9</span> };\n\n    x, y, z = vector;\n\n    print(<span class=\"tok-str\">\"vector: x = {}, y = {}, z = {}\\n\"</span>, .{x, y, z});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Values §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u32</span> = <span class=\"tok-null\">undefined</span>;\n\n    <span class=\"tok-kw\">const</span> tuple = .{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span> };\n\n    x, <span class=\"tok-kw\">var</span> y : <span class=\"tok-type\">u32</span>, <span class=\"tok-kw\">const</span> z = tuple;\n\n    print(<span class=\"tok-str\">\"x = {}, y = {}, z = {}\\n\"</span>, .{x, y, z});\n\n    <span class=\"tok-comment\">// y is mutable</span>\n    y = <span class=\"tok-number\">100</span>;\n\n    <span class=\"tok-comment\">// You can use _ to throw away unwanted values.</span>\n    _, x, _ = tuple;\n\n    print(<span class=\"tok-str\">\"x = {}\"</span>, .{x});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Values §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Values § in Zig 0.15.1",
    "context": "",
    "response": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintptr_t , size_t unsigned pointer sized integer. Also see #5185 c_char char for ABI compatibility with C c_short short for ABI compatibility with C c_ushort unsigned short for ABI compatibility with C c_int int for ABI compatibility with C c_uint unsigned int for ABI compatibility with C c_long long for ABI compatibility with C c_ulong unsigned long for ABI compatibility with C c_longlong long long for ABI compatibility with C c_ulonglong unsigned long long for ABI compatibility with C c_longdouble ",
    "metadata": {
      "version": "0.15.1",
      "topic": "Values §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"expect addOne adds one to 41\"</span> {\n\n    <span class=\"tok-comment\">// The Standard Library contains useful functions to help create tests.</span>\n    <span class=\"tok-comment\">// `expect` is a function that verifies its argument is true.</span>\n    <span class=\"tok-comment\">// It will return an error if its argument is false to indicate a failure.</span>\n    <span class=\"tok-comment\">// `try` is used to return an error to the test runner to notify it that the test failed.</span>\n    <span class=\"tok-kw\">try</span> std.testing.expect(addOne(<span class=\"tok-number\">41</span>) == <span class=\"tok-number\">42</span>);\n}\n\n<span class=\"tok-kw\">test</span> addOne {\n    <span class=\"tok-comment\">// A test name can also be written using an identifier.</span>\n    <span class=\"tok-comment\">// This is a doctest, and serves as documentation for `addOne`.</span>\n    <span class=\"tok-kw\">try</span> std.testing.expect(addOne(<span class=\"tok-number\">41</span>) == <span class=\"tok-number\">42</span>);\n}\n\n<span class=\"tok-comment\">/// The function `addOne` adds one to the number given as its argument.</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">addOne</span>(number: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> number + <span class=\"tok-number\">1</span>;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"expect this to fail\"</span> {\n    <span class=\"tok-kw\">try</span> std.testing.expect(<span class=\"tok-null\">false</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"expect this to succeed\"</span> {\n    <span class=\"tok-kw\">try</span> std.testing.expect(<span class=\"tok-null\">true</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"this will be skipped\"</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.SkipZigTest;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"detect leak\"</span> {\n    <span class=\"tok-kw\">var</span> list = std.array_list.Managed(<span class=\"tok-type\">u21</span>).init(std.testing.allocator);\n    <span class=\"tok-comment\">// missing `defer list.deinit();`</span>\n    <span class=\"tok-kw\">try</span> list.append(<span class=\"tok-str\">'☔'</span>);\n\n    <span class=\"tok-kw\">try</span> std.testing.expect(list.items.len == <span class=\"tok-number\">1</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"builtin.is_test\"</span> {\n    <span class=\"tok-kw\">try</span> expect(isATest());\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">isATest</span>() <span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">return</span> builtin.is_test;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"expectEqual demo\"</span> {\n    <span class=\"tok-kw\">const</span> expected: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">42</span>;\n    <span class=\"tok-kw\">const</span> actual = <span class=\"tok-number\">42</span>;\n\n    <span class=\"tok-comment\">// The first argument to `expectEqual` is the known, expected, result.</span>\n    <span class=\"tok-comment\">// The second argument is the result of some expression.</span>\n    <span class=\"tok-comment\">// The actual's type is casted to the type of expected.</span>\n    <span class=\"tok-kw\">try</span> std.testing.expectEqual(expected, actual);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"expectError demo\"</span> {\n    <span class=\"tok-kw\">const</span> expected_error = <span class=\"tok-kw\">error</span>.DemoError;\n    <span class=\"tok-kw\">const</span> actual_error_union: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">void</span> = <span class=\"tok-kw\">error</span>.DemoError;\n\n    <span class=\"tok-comment\">// `expectError` will fail when the actual error is different than</span>\n    <span class=\"tok-comment\">// the expected error.</span>\n    <span class=\"tok-kw\">try</span> std.testing.expectError(expected_error, actual_error_union);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Zig Test § in Zig 0.15.1",
    "context": "",
    "response": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Library as its main entry point. During the build, test declarations found while resolving the given Zig source file are included for the default test runner to run and report on. This documentation discusses the features of the default test runner as provided by the Zig Standard Library. Its source code is located in lib/compiler/test_runner.zig . The shell output shown above displays two lines after the zig test command. These lines are printed to standard error by the default test runner: 1/2 t",
    "metadata": {
      "version": "0.15.1",
      "topic": "Zig Test §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">const</span> @\"identifier with spaces in it\" = <span class=\"tok-number\">0xff</span>;\n<span class=\"tok-kw\">const</span> @\"1SmallStep4Man\" = <span class=\"tok-number\">112358</span>;\n\n<span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).c;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"c\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">@\"error\"</span>() <span class=\"tok-type\">void</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"c\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">@\"fstat$INODE64\"</span>(fd: c.fd_t, buf: *c.Stat) <span class=\"tok-type\">c_int</span>;\n\n<span class=\"tok-kw\">const</span> Color = <span class=\"tok-kw\">enum</span> {\n    red,\n    @\"really red\",\n};\n<span class=\"tok-kw\">const</span> color: Color = .@\"really red\";",
    "metadata": {
      "version": "0.15.1",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">i32</span> = add(<span class=\"tok-number\">10</span>, x);\n<span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">i32</span> = add(<span class=\"tok-number\">12</span>, <span class=\"tok-number\">34</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"container level variables\"</span> {\n    <span class=\"tok-kw\">try</span> expect(x == <span class=\"tok-number\">46</span>);\n    <span class=\"tok-kw\">try</span> expect(y == <span class=\"tok-number\">56</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> a + b;\n}\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;",
    "metadata": {
      "version": "0.15.1",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"namespaced container level variable\"</span> {\n    <span class=\"tok-kw\">try</span> expect(foo() == <span class=\"tok-number\">1235</span>);\n    <span class=\"tok-kw\">try</span> expect(foo() == <span class=\"tok-number\">1236</span>);\n}\n\n<span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">i32</span> {\n    S.x += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">return</span> S.x;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"static local variable\"</span> {\n    <span class=\"tok-kw\">try</span> expect(foo() == <span class=\"tok-number\">1235</span>);\n    <span class=\"tok-kw\">try</span> expect(foo() == <span class=\"tok-number\">1236</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> {\n        <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    };\n    S.x += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">return</span> S.x;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> assert = std.debug.assert;\n\n<span class=\"tok-kw\">threadlocal</span> <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"thread local storage\"</span> {\n    <span class=\"tok-kw\">const</span> thread1 = <span class=\"tok-kw\">try</span> std.Thread.spawn(.{}, testTls, .{});\n    <span class=\"tok-kw\">const</span> thread2 = <span class=\"tok-kw\">try</span> std.Thread.spawn(.{}, testTls, .{});\n    testTls();\n    thread1.join();\n    thread2.join();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">testTls</span>() <span class=\"tok-type\">void</span> {\n    assert(x == <span class=\"tok-number\">1234</span>);\n    x += <span class=\"tok-number\">1</span>;\n    assert(x == <span class=\"tok-number\">1235</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"comptime vars\"</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n\n    x += <span class=\"tok-number\">1</span>;\n    y += <span class=\"tok-number\">1</span>;\n\n    <span class=\"tok-kw\">try</span> expect(x == <span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">try</span> expect(y == <span class=\"tok-number\">2</span>);\n\n    <span class=\"tok-kw\">if</span> (y != <span class=\"tok-number\">2</span>) {\n        <span class=\"tok-comment\">// This compile error never triggers because y is a comptime variable,</span>\n        <span class=\"tok-comment\">// and so `y != 2` is a comptime value, and this if is statically evaluated.</span>\n        <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"wrong y value\"</span>);\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Variables § in Zig 0.15.1",
    "context": "",
    "response": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both cases, the type of the variable must be C ABI compatible. See also: Exporting a C Library Identifiers § Variable identifiers are never allowed to shadow identifiers from an outer scope. Identifiers must start with an alphabetic character or underscore and may be followed by any number of alphanumeric characters or underscores. They must not overlap with any keywords. See Keyword Reference . If a name that does not fit these requirements is needed, such as for linking with external libraries, the @&q",
    "metadata": {
      "version": "0.15.1",
      "topic": "Variables §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Integers §",
    "context": "Integer Literals § integer_literals.zig Runtime Integer Values § Integer literals have no size limitation, and if any Illegal Behavior occurs, the compiler catches it. However, once an integer value is no longer known at compile-time, it must have a known size, and is vulnerable to safety-checked Illegal Behavior . runtime_vs_comptime.zig In this function, values a and b are known only at runtime, and thus this division operation is vulnerable to both Integer Overflow and Division by Zero . Oper",
    "response": "<span class=\"tok-kw\">const</span> decimal_int = <span class=\"tok-number\">98222</span>;\n<span class=\"tok-kw\">const</span> hex_int = <span class=\"tok-number\">0xff</span>;\n<span class=\"tok-kw\">const</span> another_hex_int = <span class=\"tok-number\">0xFF</span>;\n<span class=\"tok-kw\">const</span> octal_int = <span class=\"tok-number\">0o755</span>;\n<span class=\"tok-kw\">const</span> binary_int = <span class=\"tok-number\">0b11110000</span>;\n\n<span class=\"tok-comment\">// underscores may be placed between two digits as a visual separator</span>\n<span class=\"tok-kw\">const</span> one_billion = <span class=\"tok-number\">1_000_000_000</span>;\n<span class=\"tok-kw\">const</span> binary_mask = <span class=\"tok-number\">0b1_1111_1111</span>;\n<span class=\"tok-kw\">const</span> permissions = <span class=\"tok-number\">0o7_5_5</span>;\n<span class=\"tok-kw\">const</span> big_address = <span class=\"tok-number\">0xFF80_0000_0000_0000</span>;",
    "metadata": {
      "version": "0.15.1",
      "topic": "Integers §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Integers §",
    "context": "Integer Literals § integer_literals.zig Runtime Integer Values § Integer literals have no size limitation, and if any Illegal Behavior occurs, the compiler catches it. However, once an integer value is no longer known at compile-time, it must have a known size, and is vulnerable to safety-checked Illegal Behavior . runtime_vs_comptime.zig In this function, values a and b are known only at runtime, and thus this division operation is vulnerable to both Integer Overflow and Division by Zero . Oper",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">divide</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> a / b;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Integers §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Integers § in Zig 0.15.1",
    "context": "",
    "response": "Integer Literals § integer_literals.zig Runtime Integer Values § Integer literals have no size limitation, and if any Illegal Behavior occurs, the compiler catches it. However, once an integer value is no longer known at compile-time, it must have a known size, and is vulnerable to safety-checked Illegal Behavior . runtime_vs_comptime.zig In this function, values a and b are known only at runtime, and thus this division operation is vulnerable to both Integer Overflow and Division by Zero . Operators such as + and - cause Illegal Behavior on integer overflow. Alternative operators are provided for wrapping and saturating arithmetic on all targets. +% and -% perform wrapping arithmetic while +| and -| perform saturating arithmetic. Zig supports arbitrary bit-width integers, referenced by using an identifier of i or u followed by digits. For example, the identifier i7 refers to a signed 7-bit integer. The maximum allowed bit-width of an integer type is 65535 . For signed integer types, Z",
    "metadata": {
      "version": "0.15.1",
      "topic": "Integers §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Floats §",
    "context": "Zig has the following floating point types: f16 - IEEE-754-2008 binary16 f32 - IEEE-754-2008 binary32 f64 - IEEE-754-2008 binary64 f80 - IEEE-754-2008 80-bit extended precision f128 - IEEE-754-2008 binary128 c_longdouble - matches long double for the target C ABI Float Literals § Float literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128 . Float literals coerce to any floating point type, and to an",
    "response": "<span class=\"tok-kw\">const</span> floating_point = <span class=\"tok-number\">123.0E+77</span>;\n<span class=\"tok-kw\">const</span> another_float = <span class=\"tok-number\">123.0</span>;\n<span class=\"tok-kw\">const</span> yet_another = <span class=\"tok-number\">123.0e+77</span>;\n\n<span class=\"tok-kw\">const</span> hex_floating_point = <span class=\"tok-number\">0x103.70p-5</span>;\n<span class=\"tok-kw\">const</span> another_hex_float = <span class=\"tok-number\">0x103.70</span>;\n<span class=\"tok-kw\">const</span> yet_another_hex_float = <span class=\"tok-number\">0x103.70P-5</span>;\n\n<span class=\"tok-comment\">// underscores may be placed between two digits as a visual separator</span>\n<span class=\"tok-kw\">const</span> lightspeed = <span class=\"tok-number\">299_792_458.000_000</span>;\n<span class=\"tok-kw\">const</span> nanosecond = <span class=\"tok-number\">0.000_000_001</span>;\n<span class=\"tok-kw\">const</span> more_hex = <span class=\"tok-number\">0x1234_5678.9ABC_CDEFp-10</span>;",
    "metadata": {
      "version": "0.15.1",
      "topic": "Floats §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Floats §",
    "context": "Zig has the following floating point types: f16 - IEEE-754-2008 binary16 f32 - IEEE-754-2008 binary32 f64 - IEEE-754-2008 binary64 f80 - IEEE-754-2008 80-bit extended precision f128 - IEEE-754-2008 binary128 c_longdouble - matches long double for the target C ABI Float Literals § Float literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128 . Float literals coerce to any floating point type, and to an",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> inf = std.math.inf(<span class=\"tok-type\">f32</span>);\n<span class=\"tok-kw\">const</span> negative_inf = -std.math.inf(<span class=\"tok-type\">f64</span>);\n<span class=\"tok-kw\">const</span> nan = std.math.nan(<span class=\"tok-type\">f128</span>);",
    "metadata": {
      "version": "0.15.1",
      "topic": "Floats §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Floats §",
    "context": "Zig has the following floating point types: f16 - IEEE-754-2008 binary16 f32 - IEEE-754-2008 binary32 f64 - IEEE-754-2008 binary64 f80 - IEEE-754-2008 80-bit extended precision f128 - IEEE-754-2008 binary128 c_longdouble - matches long double for the target C ABI Float Literals § Float literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128 . Float literals coerce to any floating point type, and to an",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> big = <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">f64</span>, <span class=\"tok-number\">1</span> << <span class=\"tok-number\">40</span>);\n\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo_strict</span>(x: <span class=\"tok-type\">f64</span>) <span class=\"tok-type\">f64</span> {\n    <span class=\"tok-kw\">return</span> x + big - big;\n}\n\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo_optimized</span>(x: <span class=\"tok-type\">f64</span>) <span class=\"tok-type\">f64</span> {\n    <span class=\"tok-builtin\">@setFloatMode</span>(.optimized);\n    <span class=\"tok-kw\">return</span> x + big - big;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Floats §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Floats §",
    "context": "Zig has the following floating point types: f16 - IEEE-754-2008 binary16 f32 - IEEE-754-2008 binary32 f64 - IEEE-754-2008 binary64 f80 - IEEE-754-2008 80-bit extended precision f128 - IEEE-754-2008 binary128 c_longdouble - matches long double for the target C ABI Float Literals § Float literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128 . Float literals coerce to any floating point type, and to an",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo_strict</span>(x: <span class=\"tok-type\">f64</span>) <span class=\"tok-type\">f64</span>;\n<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo_optimized</span>(x: <span class=\"tok-type\">f64</span>) <span class=\"tok-type\">f64</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> x = <span class=\"tok-number\">0.001</span>;\n    print(<span class=\"tok-str\">\"optimized = {}\\n\"</span>, .{foo_optimized(x)});\n    print(<span class=\"tok-str\">\"strict = {}\\n\"</span>, .{foo_strict(x)});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Floats §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Floats § in Zig 0.15.1",
    "context": "",
    "response": "Zig has the following floating point types: f16 - IEEE-754-2008 binary16 f32 - IEEE-754-2008 binary32 f64 - IEEE-754-2008 binary64 f80 - IEEE-754-2008 80-bit extended precision f128 - IEEE-754-2008 binary128 c_longdouble - matches long double for the target C ABI Float Literals § Float literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128 . Float literals coerce to any floating point type, and to any integer type when there is no fractional component. float_literals.zig There is no syntax for NaN, infinity, or negative infinity. For these special values, one must use the standard library: float_special_values.zig Floating Point Operations § By default floating point operations use Strict mode, but you can switch to Optimized mode on a per-block basis: float_mode_obj.zig Shell For this test we have to separate code into two object files - otherwise the optimizer figures out all the values a",
    "metadata": {
      "version": "0.15.1",
      "topic": "Floats §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a + b\na += b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">2</span> + <span class=\"tok-number\">5</span> == <span class=\"tok-number\">7</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a +% b\na +%= b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-number\">0xffffffff</span>) +% <span class=\"tok-number\">1</span> == <span class=\"tok-number\">0</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a +| b\na +|= b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">255</span>) +| <span class=\"tok-number\">1</span> == <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">255</span>)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a - b\na -= b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">2</span> - <span class=\"tok-number\">5</span> == -<span class=\"tok-number\">3</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a -% b\na -%= b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">0</span>) -% <span class=\"tok-number\">1</span> == <span class=\"tok-number\">255</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a -| b\na -|= b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-number\">0</span>) -| <span class=\"tok-number\">1</span> == <span class=\"tok-number\">0</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "-<span class=\"tok-number\">1</span> == <span class=\"tok-number\">0</span> - <span class=\"tok-number\">1</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "-%<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">i8</span>, -<span class=\"tok-number\">128</span>) == -<span class=\"tok-number\">128</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a * b\na *= b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">2</span> * <span class=\"tok-number\">5</span> == <span class=\"tok-number\">10</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a *% b\na *%= b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">200</span>) *% <span class=\"tok-number\">2</span> == <span class=\"tok-number\">144</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a *| b\na *|= b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">200</span>) *| <span class=\"tok-number\">2</span> == <span class=\"tok-number\">255</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a / b\na /= b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">10</span> / <span class=\"tok-number\">5</span> == <span class=\"tok-number\">2</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a % b\na %= b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">10</span> % <span class=\"tok-number\">3</span> == <span class=\"tok-number\">1</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a << b\na <<= b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">0b1</span> << <span class=\"tok-number\">8</span> == <span class=\"tok-number\">0b100000000</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <<| b\na <<|= b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">1</span>) <<| <span class=\"tok-number\">8</span> == <span class=\"tok-number\">255</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a >> b\na >>= b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">0b1010</span> >> <span class=\"tok-number\">1</span> == <span class=\"tok-number\">0b101</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a & b\na &= b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">0b011</span> & <span class=\"tok-number\">0b101</span> == <span class=\"tok-number\">0b001</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a | b\na |= b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">0b010</span> | <span class=\"tok-number\">0b100</span> == <span class=\"tok-number\">0b110</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a ^ b\na ^= b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">0b011</span> ^ <span class=\"tok-number\">0b101</span> == <span class=\"tok-number\">0b110</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "~<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">0b10101111</span>) == <span class=\"tok-number\">0b01010000</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <span class=\"tok-kw\">orelse</span> b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> value: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-null\">null</span>;\n<span class=\"tok-kw\">const</span> unwrapped = value <span class=\"tok-kw\">orelse</span> <span class=\"tok-number\">1234</span>;\nunwrapped == <span class=\"tok-number\">1234</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <span class=\"tok-kw\">orelse</span> <span class=\"tok-kw\">unreachable</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> value: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">5678</span>;\nvalue.? == <span class=\"tok-number\">5678</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <span class=\"tok-kw\">catch</span> b\na <span class=\"tok-kw\">catch</span> |err| b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> value: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> = <span class=\"tok-kw\">error</span>.Broken;\n<span class=\"tok-kw\">const</span> unwrapped = value <span class=\"tok-kw\">catch</span> <span class=\"tok-number\">1234</span>;\nunwrapped == <span class=\"tok-number\">1234</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <span class=\"tok-kw\">and</span> b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-null\">false</span> <span class=\"tok-kw\">and</span> <span class=\"tok-null\">true</span>) == <span class=\"tok-null\">false</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <span class=\"tok-kw\">or</span> b",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-null\">false</span> <span class=\"tok-kw\">or</span> <span class=\"tok-null\">true</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "!<span class=\"tok-null\">false</span> == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">1</span> == <span class=\"tok-number\">1</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a == <span class=\"tok-null\">null</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> value: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-null\">null</span>;\n(value == <span class=\"tok-null\">null</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">1</span> != <span class=\"tok-number\">1</span>) == <span class=\"tok-null\">false</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a != <span class=\"tok-null\">null</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> value: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-null\">null</span>;\n(value != <span class=\"tok-null\">null</span>) == <span class=\"tok-null\">false</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">2</span> > <span class=\"tok-number\">1</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">2</span> >= <span class=\"tok-number\">1</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">1</span> < <span class=\"tok-number\">2</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">1</span> <= <span class=\"tok-number\">2</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem;\n<span class=\"tok-kw\">const</span> array1 = [_]<span class=\"tok-type\">u32</span>{<span class=\"tok-number\">1</span>,<span class=\"tok-number\">2</span>};\n<span class=\"tok-kw\">const</span> array2 = [_]<span class=\"tok-type\">u32</span>{<span class=\"tok-number\">3</span>,<span class=\"tok-number\">4</span>};\n<span class=\"tok-kw\">const</span> together = array1 ++ array2;\nmem.eql(<span class=\"tok-type\">u32</span>, &together, &[_]<span class=\"tok-type\">u32</span>{<span class=\"tok-number\">1</span>,<span class=\"tok-number\">2</span>,<span class=\"tok-number\">3</span>,<span class=\"tok-number\">4</span>})",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem;\n<span class=\"tok-kw\">const</span> pattern = <span class=\"tok-str\">\"ab\"</span> ** <span class=\"tok-number\">3</span>;\nmem.eql(<span class=\"tok-type\">u8</span>, pattern, <span class=\"tok-str\">\"ababab\"</span>)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">1234</span>;\n<span class=\"tok-kw\">const</span> ptr = &x;\nptr.* == <span class=\"tok-number\">1234</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">1234</span>;\n<span class=\"tok-kw\">const</span> ptr = &x;\nptr.* == <span class=\"tok-number\">1234</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> A = <span class=\"tok-kw\">error</span>{One};\n<span class=\"tok-kw\">const</span> B = <span class=\"tok-kw\">error</span>{Two};\n(A || B) == <span class=\"tok-kw\">error</span>{One, Two}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "x() x[] x.y x.* x.?\na!b\nx{}\n!x -x -%x ~x &x ?x\n* / % ** *% *| ||\n+ - ++ +% -% +| -|\n<< >> <<|\n& ^ | <span class=\"tok-kw\">orelse</span> <span class=\"tok-kw\">catch</span>\n== != < > <= >=\n<span class=\"tok-kw\">and</span>\n<span class=\"tok-kw\">or</span>\n= *= *%= *|= /= %= += +%= +|= -= -%= -|= <<= <<|= >>= &= ^= |=",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Operators § in Zig 0.15.1",
    "context": "",
    "response": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes Peer Type Resolution for the operands. Subtraction Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @subWithOverflow . Wrapping Subtraction Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @subWithOverflow . Saturating Subtraction Integers Invokes Peer Type Resolution for the operands. Negation Integers Floats Can cause overflow for integers. Wrapping Negation Integers Twos-complement wrapp",
    "metadata": {
      "version": "0.15.1",
      "topic": "Operators §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Arrays §",
    "context": "test_arrays.zig Shell See also: for Slices Multidimensional Arrays § Multidimensional arrays can be created by nesting arrays: test_multidimensional_arrays.zig Shell Sentinel-Terminated Arrays § The syntax [N:x]T describes an array which has a sentinel element of value x at the index corresponding to the length N . test_null_terminated_array.zig Shell See also: Sentinel-Terminated Pointers Sentinel-Terminated Slices Destructuring Arrays § Arrays can be destructured: destructuring_arrays.zig Shel",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n<span class=\"tok-kw\">const</span> assert = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.assert;\n<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem;\n\n<span class=\"tok-comment\">// array literal</span>\n<span class=\"tok-kw\">const</span> message = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'o'</span> };\n\n<span class=\"tok-comment\">// alternative initialization using result location</span>\n<span class=\"tok-kw\">const</span> alt_message: [<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span> = .{ <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'o'</span> };\n\n<span class=\"tok-kw\">comptime</span> {\n    assert(mem.eql(<span class=\"tok-type\">u8</span>, &message, &alt_message));\n}\n\n<span class=\"tok-comment\">// get the size of an array</span>\n<span class=\"tok-kw\">comptime</span> {\n    assert(message.len == <span class=\"tok-number\">5</span>);\n}\n\n<span class=\"tok-comment\">// A string literal is a single-item pointer to an array.</span>\n<span class=\"tok-kw\">const</span> same_message = <span class=\"tok-str\">\"hello\"</span>;\n\n<span class=\"tok-kw\">comptime</span> {\n    assert(mem.eql(<span class=\"tok-type\">u8</span>, &message, same_message));\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"iterate over an array\"</span> {\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">for</span> (message) |byte| {\n        sum += byte;\n    }\n    <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-str\">'h'</span> + <span class=\"tok-str\">'e'</span> + <span class=\"tok-str\">'l'</span> * <span class=\"tok-number\">2</span> + <span class=\"tok-str\">'o'</span>);\n}\n\n<span class=\"tok-comment\">// modifiable array</span>\n<span class=\"tok-kw\">var</span> some_integers: [<span class=\"tok-number\">100</span>]<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"modify an array\"</span> {\n    <span class=\"tok-kw\">for</span> (&some_integers, <span class=\"tok-number\">0</span>..) |*item, i| {\n        item.* = <span class=\"tok-builtin\">@intCast</span>(i);\n    }\n    <span class=\"tok-kw\">try</span> expect(some_integers[<span class=\"tok-number\">10</span>] == <span class=\"tok-number\">10</span>);\n    <span class=\"tok-kw\">try</span> expect(some_integers[<span class=\"tok-number\">99</span>] == <span class=\"tok-number\">99</span>);\n}\n\n<span class=\"tok-comment\">// array concatenation works if the values are known</span>\n<span class=\"tok-comment\">// at compile time</span>\n<span class=\"tok-kw\">const</span> part_one = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n<span class=\"tok-kw\">const</span> part_two = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span> };\n<span class=\"tok-kw\">const</span> all_of_it = part_one ++ part_two;\n<span class=\"tok-kw\">comptime</span> {\n    assert(mem.eql(<span class=\"tok-type\">i32</span>, &all_of_it, &[_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span> }));\n}\n\n<span class=\"tok-comment\">// remember that string literals are arrays</span>\n<span class=\"tok-kw\">const</span> hello = <span class=\"tok-str\">\"hello\"</span>;\n<span class=\"tok-kw\">const</span> world = <span class=\"tok-str\">\"world\"</span>;\n<span class=\"tok-kw\">const</span> hello_world = hello ++ <span class=\"tok-str\">\" \"</span> ++ world;\n<span class=\"tok-kw\">comptime</span> {\n    assert(mem.eql(<span class=\"tok-type\">u8</span>, hello_world, <span class=\"tok-str\">\"hello world\"</span>));\n}\n\n<span class=\"tok-comment\">// ** does repeating patterns</span>\n<span class=\"tok-kw\">const</span> pattern = <span class=\"tok-str\">\"ab\"</span> ** <span class=\"tok-number\">3</span>;\n<span class=\"tok-kw\">comptime</span> {\n    assert(mem.eql(<span class=\"tok-type\">u8</span>, pattern, <span class=\"tok-str\">\"ababab\"</span>));\n}\n\n<span class=\"tok-comment\">// initialize an array to zero</span>\n<span class=\"tok-kw\">const</span> all_zero = [_]<span class=\"tok-type\">u16</span>{<span class=\"tok-number\">0</span>} ** <span class=\"tok-number\">10</span>;\n\n<span class=\"tok-kw\">comptime</span> {\n    assert(all_zero.len == <span class=\"tok-number\">10</span>);\n    assert(all_zero[<span class=\"tok-number\">5</span>] == <span class=\"tok-number\">0</span>);\n}\n\n<span class=\"tok-comment\">// use compile-time code to initialize an array</span>\n<span class=\"tok-kw\">var</span> fancy_array = init: {\n    <span class=\"tok-kw\">var</span> initial_value: [<span class=\"tok-number\">10</span>]Point = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">for</span> (&initial_value, <span class=\"tok-number\">0</span>..) |*pt, i| {\n        pt.* = Point{\n            .x = <span class=\"tok-builtin\">@intCast</span>(i),\n            .y = <span class=\"tok-builtin\">@intCast</span>(i * <span class=\"tok-number\">2</span>),\n        };\n    }\n    <span class=\"tok-kw\">break</span> :init initial_value;\n};\n<span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> {\n    x: <span class=\"tok-type\">i32</span>,\n    y: <span class=\"tok-type\">i32</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"compile-time array initialization\"</span> {\n    <span class=\"tok-kw\">try</span> expect(fancy_array[<span class=\"tok-number\">4</span>].x == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(fancy_array[<span class=\"tok-number\">4</span>].y == <span class=\"tok-number\">8</span>);\n}\n\n<span class=\"tok-comment\">// call a function to initialize an array</span>\n<span class=\"tok-kw\">var</span> more_points = [_]Point{makePoint(<span class=\"tok-number\">3</span>)} ** <span class=\"tok-number\">10</span>;\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">makePoint</span>(x: <span class=\"tok-type\">i32</span>) Point {\n    <span class=\"tok-kw\">return</span> Point{\n        .x = x,\n        .y = x * <span class=\"tok-number\">2</span>,\n    };\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"array initialization with function calls\"</span> {\n    <span class=\"tok-kw\">try</span> expect(more_points[<span class=\"tok-number\">4</span>].x == <span class=\"tok-number\">3</span>);\n    <span class=\"tok-kw\">try</span> expect(more_points[<span class=\"tok-number\">4</span>].y == <span class=\"tok-number\">6</span>);\n    <span class=\"tok-kw\">try</span> expect(more_points.len == <span class=\"tok-number\">10</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Arrays §",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Arrays §",
    "context": "test_arrays.zig Shell See also: for Slices Multidimensional Arrays § Multidimensional arrays can be created by nesting arrays: test_multidimensional_arrays.zig Shell Sentinel-Terminated Arrays § The syntax [N:x]T describes an array which has a sentinel element of value x at the index corresponding to the length N . test_null_terminated_array.zig Shell See also: Sentinel-Terminated Pointers Sentinel-Terminated Slices Destructuring Arrays § Arrays can be destructured: destructuring_arrays.zig Shel",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> expectEqual = std.testing.expectEqual;\n\n<span class=\"tok-kw\">const</span> mat4x5 = [<span class=\"tok-number\">4</span>][<span class=\"tok-number\">5</span>]<span class=\"tok-type\">f32</span>{\n    [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span> },\n    [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span> },\n    [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span> },\n    [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">9.9</span> },\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"multidimensional arrays\"</span> {\n    <span class=\"tok-comment\">// mat4x5 itself is a one-dimensional array of arrays.</span>\n    <span class=\"tok-kw\">try</span> expectEqual(mat4x5[<span class=\"tok-number\">1</span>], [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span> });\n\n    <span class=\"tok-comment\">// Access the 2D array by indexing the outer array, and then the inner array.</span>\n    <span class=\"tok-kw\">try</span> expect(mat4x5[<span class=\"tok-number\">3</span>][<span class=\"tok-number\">4</span>] == <span class=\"tok-number\">9.9</span>);\n\n    <span class=\"tok-comment\">// Here we iterate with for loops.</span>\n    <span class=\"tok-kw\">for</span> (mat4x5, <span class=\"tok-number\">0</span>..) |row, row_index| {\n        <span class=\"tok-kw\">for</span> (row, <span class=\"tok-number\">0</span>..) |cell, column_index| {\n            <span class=\"tok-kw\">if</span> (row_index == column_index) {\n                <span class=\"tok-kw\">try</span> expect(cell == <span class=\"tok-number\">1.0</span>);\n            }\n        }\n    }\n\n    <span class=\"tok-comment\">// Initialize a multidimensional array to zeros.</span>\n    <span class=\"tok-kw\">const</span> all_zero: [<span class=\"tok-number\">4</span>][<span class=\"tok-number\">5</span>]<span class=\"tok-type\">f32</span> = .{.{<span class=\"tok-number\">0</span>} ** <span class=\"tok-number\">5</span>} ** <span class=\"tok-number\">4</span>;\n    <span class=\"tok-kw\">try</span> expect(all_zero[<span class=\"tok-number\">0</span>][<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">0</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Arrays §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Arrays §",
    "context": "test_arrays.zig Shell See also: for Slices Multidimensional Arrays § Multidimensional arrays can be created by nesting arrays: test_multidimensional_arrays.zig Shell Sentinel-Terminated Arrays § The syntax [N:x]T describes an array which has a sentinel element of value x at the index corresponding to the length N . test_null_terminated_array.zig Shell See also: Sentinel-Terminated Pointers Sentinel-Terminated Slices Destructuring Arrays § Arrays can be destructured: destructuring_arrays.zig Shel",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"0-terminated sentinel array\"</span> {\n    <span class=\"tok-kw\">const</span> array = [_:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(array) == [<span class=\"tok-number\">4</span>:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>);\n    <span class=\"tok-kw\">try</span> expect(array.len == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">4</span>] == <span class=\"tok-number\">0</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"extra 0s in 0-terminated sentinel array\"</span> {\n    <span class=\"tok-comment\">// The sentinel value may appear earlier, but does not influence the compile-time 'len'.</span>\n    <span class=\"tok-kw\">const</span> array = [_:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span>, <span class=\"tok-number\">0</span>, <span class=\"tok-number\">4</span> };\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(array) == [<span class=\"tok-number\">4</span>:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>);\n    <span class=\"tok-kw\">try</span> expect(array.len == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">4</span>] == <span class=\"tok-number\">0</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Arrays §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Arrays §",
    "context": "test_arrays.zig Shell See also: for Slices Multidimensional Arrays § Multidimensional arrays can be created by nesting arrays: test_multidimensional_arrays.zig Shell Sentinel-Terminated Arrays § The syntax [N:x]T describes an array which has a sentinel element of value x at the index corresponding to the length N . test_null_terminated_array.zig Shell See also: Sentinel-Terminated Pointers Sentinel-Terminated Slices Destructuring Arrays § Arrays can be destructured: destructuring_arrays.zig Shel",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">swizzleRgbaToBgra</span>(rgba: [<span class=\"tok-number\">4</span>]<span class=\"tok-type\">u8</span>) [<span class=\"tok-number\">4</span>]<span class=\"tok-type\">u8</span> {\n    <span class=\"tok-comment\">// readable swizzling by destructuring</span>\n    <span class=\"tok-kw\">const</span> r, <span class=\"tok-kw\">const</span> g, <span class=\"tok-kw\">const</span> b, <span class=\"tok-kw\">const</span> a = rgba;\n    <span class=\"tok-kw\">return</span> .{ b, g, r, a };\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> pos = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span> };\n    <span class=\"tok-kw\">const</span> x, <span class=\"tok-kw\">const</span> y = pos;\n    print(<span class=\"tok-str\">\"x = {}, y = {}\\n\"</span>, .{x, y});\n\n    <span class=\"tok-kw\">const</span> orange: [<span class=\"tok-number\">4</span>]<span class=\"tok-type\">u8</span> = .{ <span class=\"tok-number\">255</span>, <span class=\"tok-number\">165</span>, <span class=\"tok-number\">0</span>, <span class=\"tok-number\">255</span> };\n    print(<span class=\"tok-str\">\"{any}\\n\"</span>, .{swizzleRgbaToBgra(orange)});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Arrays §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Arrays § in Zig 0.15.1",
    "context": "",
    "response": "test_arrays.zig Shell See also: for Slices Multidimensional Arrays § Multidimensional arrays can be created by nesting arrays: test_multidimensional_arrays.zig Shell Sentinel-Terminated Arrays § The syntax [N:x]T describes an array which has a sentinel element of value x at the index corresponding to the length N . test_null_terminated_array.zig Shell See also: Sentinel-Terminated Pointers Sentinel-Terminated Slices Destructuring Arrays § Arrays can be destructured: destructuring_arrays.zig Shell See also: Destructuring Destructuring Tuples Destructuring Vectors",
    "metadata": {
      "version": "0.15.1",
      "topic": "Arrays §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Vectors §",
    "context": "A vector is a group of booleans, Integers , Floats , or Pointers which are operated on in parallel, using SIMD instructions if possible. Vector types are created with the builtin function @Vector . Vectors generally support the same builtin operators as their underlying base types. The only exception to this is the keywords `and` and `or` on vectors of bools, since these operators affect control flow, which is not allowed for vectors. All other operations are performed element-wise, and return a",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expectEqual = std.testing.expectEqual;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"Basic vector usage\"</span> {\n    <span class=\"tok-comment\">// Vectors have a compile-time known length and base type.</span>\n    <span class=\"tok-kw\">const</span> a = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">i32</span>){ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">i32</span>){ <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span> };\n\n    <span class=\"tok-comment\">// Math operations take place element-wise.</span>\n    <span class=\"tok-kw\">const</span> c = a + b;\n\n    <span class=\"tok-comment\">// Individual vector elements can be accessed using array indexing syntax.</span>\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">6</span>, c[<span class=\"tok-number\">0</span>]);\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">8</span>, c[<span class=\"tok-number\">1</span>]);\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">10</span>, c[<span class=\"tok-number\">2</span>]);\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">12</span>, c[<span class=\"tok-number\">3</span>]);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"Conversion between vectors, arrays, and slices\"</span> {\n    <span class=\"tok-comment\">// Vectors and fixed-length arrays can be automatically assigned back and forth</span>\n    <span class=\"tok-kw\">const</span> arr1: [<span class=\"tok-number\">4</span>]<span class=\"tok-type\">f32</span> = [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.1</span>, <span class=\"tok-number\">3.2</span>, <span class=\"tok-number\">4.5</span>, <span class=\"tok-number\">5.6</span> };\n    <span class=\"tok-kw\">const</span> vec: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">f32</span>) = arr1;\n    <span class=\"tok-kw\">const</span> arr2: [<span class=\"tok-number\">4</span>]<span class=\"tok-type\">f32</span> = vec;\n    <span class=\"tok-kw\">try</span> expectEqual(arr1, arr2);\n\n    <span class=\"tok-comment\">// You can also assign from a slice with comptime-known length to a vector using .*</span>\n    <span class=\"tok-kw\">const</span> vec2: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">2</span>, <span class=\"tok-type\">f32</span>) = arr1[<span class=\"tok-number\">1</span>..<span class=\"tok-number\">3</span>].*;\n\n    <span class=\"tok-kw\">const</span> slice: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">f32</span> = &arr1;\n    <span class=\"tok-kw\">var</span> offset: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">1</span>; <span class=\"tok-comment\">// var to make it runtime-known</span>\n    _ = &offset; <span class=\"tok-comment\">// suppress 'var is never mutated' error</span>\n    <span class=\"tok-comment\">// To extract a comptime-known length from a runtime-known offset,</span>\n    <span class=\"tok-comment\">// first extract a new slice from the starting offset, then an array of</span>\n    <span class=\"tok-comment\">// comptime-known length</span>\n    <span class=\"tok-kw\">const</span> vec3: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">2</span>, <span class=\"tok-type\">f32</span>) = slice[offset..][<span class=\"tok-number\">0</span>..<span class=\"tok-number\">2</span>].*;\n    <span class=\"tok-kw\">try</span> expectEqual(slice[offset], vec2[<span class=\"tok-number\">0</span>]);\n    <span class=\"tok-kw\">try</span> expectEqual(slice[offset + <span class=\"tok-number\">1</span>], vec2[<span class=\"tok-number\">1</span>]);\n    <span class=\"tok-kw\">try</span> expectEqual(vec2, vec3);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Vectors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Vectors §",
    "context": "A vector is a group of booleans, Integers , Floats , or Pointers which are operated on in parallel, using SIMD instructions if possible. Vector types are created with the builtin function @Vector . Vectors generally support the same builtin operators as their underlying base types. The only exception to this is the keywords `and` and `or` on vectors of bools, since these operators affect control flow, which is not allowed for vectors. All other operations are performed element-wise, and return a",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-comment\">// emulate punpckldq</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">unpack</span>(x: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">f32</span>), y: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">f32</span>)) <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">f32</span>) {\n    <span class=\"tok-kw\">const</span> a, <span class=\"tok-kw\">const</span> c, _, _ = x;\n    <span class=\"tok-kw\">const</span> b, <span class=\"tok-kw\">const</span> d, _, _ = y;\n    <span class=\"tok-kw\">return</span> .{ a, b, c, d };\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">f32</span>) = .{ <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">2.0</span>, <span class=\"tok-number\">3.0</span>, <span class=\"tok-number\">4.0</span> };\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">f32</span>) = .{ <span class=\"tok-number\">5.0</span>, <span class=\"tok-number\">6.0</span>, <span class=\"tok-number\">7.0</span>, <span class=\"tok-number\">8.0</span> };\n    print(<span class=\"tok-str\">\"{}\"</span>, .{unpack(x, y)});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Vectors §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Vectors § in Zig 0.15.1",
    "context": "",
    "response": "A vector is a group of booleans, Integers , Floats , or Pointers which are operated on in parallel, using SIMD instructions if possible. Vector types are created with the builtin function @Vector . Vectors generally support the same builtin operators as their underlying base types. The only exception to this is the keywords `and` and `or` on vectors of bools, since these operators affect control flow, which is not allowed for vectors. All other operations are performed element-wise, and return a vector of the same length as the input vectors. This includes: Arithmetic ( + , - , / , * , @divFloor , @sqrt , @ceil , @log , etc.) Bitwise operators ( &gt;&gt; , &lt;&lt; , &amp; , | , ~ , etc.) Comparison operators ( &lt; , &gt; , == , etc.) Boolean not ( ! ) It is prohibited to use a math operator on a mixture of scalars (individual numbers) and vectors. Zig provides the @splat builtin to easily convert from scalars to vectors, and it supports @reduce and array indexing syntax to convert fr",
    "metadata": {
      "version": "0.15.1",
      "topic": "Vectors §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"address of syntax\"</span> {\n    <span class=\"tok-comment\">// Get the address of a variable:</span>\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> x_ptr = &x;\n\n    <span class=\"tok-comment\">// Dereference a pointer:</span>\n    <span class=\"tok-kw\">try</span> expect(x_ptr.* == <span class=\"tok-number\">1234</span>);\n\n    <span class=\"tok-comment\">// When you get the address of a const variable, you get a const single-item pointer.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(x_ptr) == *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span>);\n\n    <span class=\"tok-comment\">// If you want to mutate the value, you'd need an address of a mutable variable:</span>\n    <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">5678</span>;\n    <span class=\"tok-kw\">const</span> y_ptr = &y;\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(y_ptr) == *<span class=\"tok-type\">i32</span>);\n    y_ptr.* += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(y_ptr.* == <span class=\"tok-number\">5679</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer array access\"</span> {\n    <span class=\"tok-comment\">// Taking an address of an individual element gives a</span>\n    <span class=\"tok-comment\">// single-item pointer. This kind of pointer</span>\n    <span class=\"tok-comment\">// does not support pointer arithmetic.</span>\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span>, <span class=\"tok-number\">9</span>, <span class=\"tok-number\">10</span> };\n    <span class=\"tok-kw\">const</span> ptr = &array[<span class=\"tok-number\">2</span>];\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(ptr) == *<span class=\"tok-type\">u8</span>);\n\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">2</span>] == <span class=\"tok-number\">3</span>);\n    ptr.* += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">2</span>] == <span class=\"tok-number\">4</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"slice syntax\"</span> {\n    <span class=\"tok-comment\">// Get a pointer to a variable:</span>\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> x_ptr = &x;\n\n    <span class=\"tok-comment\">// Convert to array pointer using slice syntax:</span>\n    <span class=\"tok-kw\">const</span> x_array_ptr = x_ptr[<span class=\"tok-number\">0</span>..<span class=\"tok-number\">1</span>];\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(x_array_ptr) == *[<span class=\"tok-number\">1</span>]<span class=\"tok-type\">i32</span>);\n\n    <span class=\"tok-comment\">// Coerce to many-item pointer:</span>\n    <span class=\"tok-kw\">const</span> x_many_ptr: [*]<span class=\"tok-type\">i32</span> = x_array_ptr;\n    <span class=\"tok-kw\">try</span> expect(x_many_ptr[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1234</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer arithmetic with many-item pointer\"</span> {\n    <span class=\"tok-kw\">const</span> array = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n    <span class=\"tok-kw\">var</span> ptr: [*]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span> = &array;\n\n    <span class=\"tok-kw\">try</span> expect(ptr[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1</span>);\n    ptr += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(ptr[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">2</span>);\n\n    <span class=\"tok-comment\">// slicing a many-item pointer without an end is equivalent to</span>\n    <span class=\"tok-comment\">// pointer arithmetic: `ptr[start..] == ptr + start`</span>\n    <span class=\"tok-kw\">try</span> expect(ptr[<span class=\"tok-number\">1</span>..] == ptr + <span class=\"tok-number\">1</span>);\n\n    <span class=\"tok-comment\">// subtraction between any two pointers except slices based on element size is supported</span>\n    <span class=\"tok-kw\">try</span> expect(&ptr[<span class=\"tok-number\">1</span>] - &ptr[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer arithmetic with slices\"</span> {\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n    <span class=\"tok-kw\">var</span> length: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>; <span class=\"tok-comment\">// var to make it runtime-known</span>\n    _ = &length; <span class=\"tok-comment\">// suppress 'var is never mutated' error</span>\n    <span class=\"tok-kw\">var</span> slice = array[length..array.len];\n\n    <span class=\"tok-kw\">try</span> expect(slice[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(slice.len == <span class=\"tok-number\">4</span>);\n\n    slice.ptr += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-comment\">// now the slice is in an bad state since len has not been updated</span>\n\n    <span class=\"tok-kw\">try</span> expect(slice[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">try</span> expect(slice.len == <span class=\"tok-number\">4</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer slicing\"</span> {\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span>, <span class=\"tok-number\">9</span>, <span class=\"tok-number\">10</span> };\n    <span class=\"tok-kw\">var</span> start: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">2</span>; <span class=\"tok-comment\">// var to make it runtime-known</span>\n    _ = &start; <span class=\"tok-comment\">// suppress 'var is never mutated' error</span>\n    <span class=\"tok-kw\">const</span> slice = array[start..<span class=\"tok-number\">4</span>];\n    <span class=\"tok-kw\">try</span> expect(slice.len == <span class=\"tok-number\">2</span>);\n\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">3</span>] == <span class=\"tok-number\">4</span>);\n    slice[<span class=\"tok-number\">1</span>] += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">3</span>] == <span class=\"tok-number\">5</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"comptime pointers\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">const</span> ptr = &x;\n        ptr.* += <span class=\"tok-number\">1</span>;\n        x += <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">try</span> expect(ptr.* == <span class=\"tok-number\">3</span>);\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@intFromPtr and @ptrFromInt\"</span> {\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0xdeadbee0</span>);\n    <span class=\"tok-kw\">const</span> addr = <span class=\"tok-builtin\">@intFromPtr</span>(ptr);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(addr) == <span class=\"tok-type\">usize</span>);\n    <span class=\"tok-kw\">try</span> expect(addr == <span class=\"tok-number\">0xdeadbee0</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"comptime @ptrFromInt\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-comment\">// Zig is able to do this at compile-time, as long as</span>\n        <span class=\"tok-comment\">// ptr is never dereferenced.</span>\n        <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0xdeadbee0</span>);\n        <span class=\"tok-kw\">const</span> addr = <span class=\"tok-builtin\">@intFromPtr</span>(ptr);\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(addr) == <span class=\"tok-type\">usize</span>);\n        <span class=\"tok-kw\">try</span> expect(addr == <span class=\"tok-number\">0xdeadbee0</span>);\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer casting\"</span> {\n    <span class=\"tok-kw\">const</span> bytes <span class=\"tok-kw\">align</span>(<span class=\"tok-builtin\">@alignOf</span>(<span class=\"tok-type\">u32</span>)) = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">0x12</span>, <span class=\"tok-number\">0x12</span>, <span class=\"tok-number\">0x12</span>, <span class=\"tok-number\">0x12</span> };\n    <span class=\"tok-kw\">const</span> u32_ptr: *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u32</span> = <span class=\"tok-builtin\">@ptrCast</span>(&bytes);\n    <span class=\"tok-kw\">try</span> expect(u32_ptr.* == <span class=\"tok-number\">0x12121212</span>);\n\n    <span class=\"tok-comment\">// Even this example is contrived - there are better ways to do the above than</span>\n    <span class=\"tok-comment\">// pointer casting. For example, using a slice narrowing cast:</span>\n    <span class=\"tok-kw\">const</span> u32_value = std.mem.bytesAsSlice(<span class=\"tok-type\">u32</span>, bytes[<span class=\"tok-number\">0</span>..])[<span class=\"tok-number\">0</span>];\n    <span class=\"tok-kw\">try</span> expect(u32_value == <span class=\"tok-number\">0x12121212</span>);\n\n    <span class=\"tok-comment\">// And even another way, the most straightforward way to do it:</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-builtin\">@bitCast</span>(bytes)) == <span class=\"tok-number\">0x12121212</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer child type\"</span> {\n    <span class=\"tok-comment\">// pointer types have a `child` field which tells you the type they point to.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(*<span class=\"tok-type\">u32</span>).pointer.child == <span class=\"tok-type\">u32</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"volatile\"</span> {\n    <span class=\"tok-kw\">const</span> mmio_ptr: *<span class=\"tok-kw\">volatile</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0x12345678</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(mmio_ptr) == *<span class=\"tok-kw\">volatile</span> <span class=\"tok-type\">u8</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"variable alignment\"</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> align_of_i32 = <span class=\"tok-builtin\">@alignOf</span>(<span class=\"tok-builtin\">@TypeOf</span>(x));\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&x) == *<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(*<span class=\"tok-type\">i32</span> == *<span class=\"tok-kw\">align</span>(align_of_i32) <span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">if</span> (builtin.target.cpu.arch == .x86_64) {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(*<span class=\"tok-type\">i32</span>).pointer.alignment == <span class=\"tok-number\">4</span>);\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">var</span> foo: <span class=\"tok-type\">u8</span> <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) = <span class=\"tok-number\">100</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"global variable alignment\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(&foo)).pointer.alignment == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&foo) == *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">u8</span>);\n    <span class=\"tok-kw\">const</span> as_pointer_to_array: *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) [<span class=\"tok-number\">1</span>]<span class=\"tok-type\">u8</span> = &foo;\n    <span class=\"tok-kw\">const</span> as_slice: []<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">u8</span> = as_pointer_to_array;\n    <span class=\"tok-kw\">const</span> as_unaligned_slice: []<span class=\"tok-type\">u8</span> = as_slice;\n    <span class=\"tok-kw\">try</span> expect(as_unaligned_slice[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">100</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">derp</span>() <span class=\"tok-kw\">align</span>(<span class=\"tok-builtin\">@sizeOf</span>(<span class=\"tok-type\">usize</span>) * <span class=\"tok-number\">2</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">1234</span>;\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">noop1</span>() <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">1</span>) <span class=\"tok-type\">void</span> {}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">noop4</span>() <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">void</span> {}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"function alignment\"</span> {\n    <span class=\"tok-kw\">try</span> expect(derp() == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(derp) == <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&derp) == *<span class=\"tok-kw\">align</span>(<span class=\"tok-builtin\">@sizeOf</span>(<span class=\"tok-type\">usize</span>) * <span class=\"tok-number\">2</span>) <span class=\"tok-kw\">const</span> <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">i32</span>);\n\n    noop1();\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(noop1) == <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">void</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&noop1) == *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">1</span>) <span class=\"tok-kw\">const</span> <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">void</span>);\n\n    noop4();\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(noop4) == <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">void</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&noop4) == *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-kw\">const</span> <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">void</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer alignment safety\"</span> {\n    <span class=\"tok-kw\">var</span> array <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) = [_]<span class=\"tok-type\">u32</span>{ <span class=\"tok-number\">0x11111111</span>, <span class=\"tok-number\">0x11111111</span> };\n    <span class=\"tok-kw\">const</span> bytes = std.mem.sliceAsBytes(array[<span class=\"tok-number\">0</span>..]);\n    <span class=\"tok-kw\">try</span> std.testing.expect(foo(bytes) == <span class=\"tok-number\">0x11111111</span>);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(bytes: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">const</span> slice4 = bytes[<span class=\"tok-number\">1</span>..<span class=\"tok-number\">5</span>];\n    <span class=\"tok-kw\">const</span> int_slice = std.mem.bytesAsSlice(<span class=\"tok-type\">u32</span>, <span class=\"tok-builtin\">@as</span>([]<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">u8</span>, <span class=\"tok-builtin\">@alignCast</span>(slice4)));\n    <span class=\"tok-kw\">return</span> int_slice[<span class=\"tok-number\">0</span>];\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"allowzero\"</span> {\n    <span class=\"tok-kw\">var</span> zero: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>; <span class=\"tok-comment\">// var to make to runtime-known</span>\n    _ = &zero; <span class=\"tok-comment\">// suppress 'var is never mutated' error</span>\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-kw\">allowzero</span> <span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(zero);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromPtr</span>(ptr) == <span class=\"tok-number\">0</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-comment\">// This is also available as `std.c.printf`.</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"c\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">printf</span>(format: [*:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, ...) <span class=\"tok-type\">c_int</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">void</span> {\n    _ = printf(<span class=\"tok-str\">\"Hello, world!\\n\"</span>); <span class=\"tok-comment\">// OK</span>\n\n    <span class=\"tok-kw\">const</span> msg = <span class=\"tok-str\">\"Hello, world!\\n\"</span>;\n    <span class=\"tok-kw\">const</span> non_null_terminated_msg: [msg.len]<span class=\"tok-type\">u8</span> = msg.*;\n    _ = printf(&non_null_terminated_msg);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Pointers § in Zig 0.15.1",
    "context": "",
    "response": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot be anyopaque or any other opaque type . These types are closely related to Arrays and Slices : *[N]T - pointer to N items, same as single-item pointer to an array. Supports index syntax: array_ptr[i] Supports slice syntax: array_ptr[start..end] Supports len property: array_ptr.len Supports pointer subtraction: array_ptr - array_ptr []T - is a slice (a fat pointer, which contains a pointer of type [*]T and a length). Supports index syntax: slice[i] Supports slice syntax: slice[start..end] Suppor",
    "metadata": {
      "version": "0.15.1",
      "topic": "Pointers §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Slices §",
    "context": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the len field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value at",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n<span class=\"tok-kw\">const</span> expectEqualSlices = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expectEqualSlices;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"basic slices\"</span> {\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n    <span class=\"tok-kw\">var</span> known_at_runtime_zero: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    _ = &known_at_runtime_zero;\n    <span class=\"tok-kw\">const</span> slice = array[known_at_runtime_zero..array.len];\n\n    <span class=\"tok-comment\">// alternative initialization using result location</span>\n    <span class=\"tok-kw\">const</span> alt_slice: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span> = &.{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n\n    <span class=\"tok-kw\">try</span> expectEqualSlices(<span class=\"tok-type\">i32</span>, slice, alt_slice);\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(slice) == []<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(&slice[<span class=\"tok-number\">0</span>] == &array[<span class=\"tok-number\">0</span>]);\n    <span class=\"tok-kw\">try</span> expect(slice.len == array.len);\n\n    <span class=\"tok-comment\">// If you slice with comptime-known start and end positions, the result is</span>\n    <span class=\"tok-comment\">// a pointer to an array, rather than a slice.</span>\n    <span class=\"tok-kw\">const</span> array_ptr = array[<span class=\"tok-number\">0</span>..array.len];\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(array_ptr) == *[array.len]<span class=\"tok-type\">i32</span>);\n\n    <span class=\"tok-comment\">// You can perform a slice-by-length by slicing twice. This allows the compiler</span>\n    <span class=\"tok-comment\">// to perform some optimisations like recognising a comptime-known length when</span>\n    <span class=\"tok-comment\">// the start position is only known at runtime.</span>\n    <span class=\"tok-kw\">var</span> runtime_start: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">1</span>;\n    _ = &runtime_start;\n    <span class=\"tok-kw\">const</span> length = <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">const</span> array_ptr_len = array[runtime_start..][<span class=\"tok-number\">0</span>..length];\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(array_ptr_len) == *[length]<span class=\"tok-type\">i32</span>);\n\n    <span class=\"tok-comment\">// Using the address-of operator on a slice gives a single-item pointer.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&slice[<span class=\"tok-number\">0</span>]) == *<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-comment\">// Using the `ptr` field gives a many-item pointer.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(slice.ptr) == [*]<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromPtr</span>(slice.ptr) == <span class=\"tok-builtin\">@intFromPtr</span>(&slice[<span class=\"tok-number\">0</span>]));\n\n    <span class=\"tok-comment\">// Slices have array bounds checking. If you try to access something out</span>\n    <span class=\"tok-comment\">// of bounds, you'll get a safety check failure:</span>\n    slice[<span class=\"tok-number\">10</span>] += <span class=\"tok-number\">1</span>;\n\n    <span class=\"tok-comment\">// Note that `slice.ptr` does not invoke safety checking, while `&slice[0]`</span>\n    <span class=\"tok-comment\">// asserts that the slice has len > 0.</span>\n\n    <span class=\"tok-comment\">// Empty slices can be created like this:</span>\n    <span class=\"tok-kw\">const</span> empty1 = &[<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>{};\n    <span class=\"tok-comment\">// If the type is known you can use this short hand:</span>\n    <span class=\"tok-kw\">const</span> empty2: []<span class=\"tok-type\">u8</span> = &.{};\n    <span class=\"tok-kw\">try</span> expect(empty1.len == <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(empty2.len == <span class=\"tok-number\">0</span>);\n\n    <span class=\"tok-comment\">// A zero-length initialization can always be used to create an empty slice, even if the slice is mutable.</span>\n    <span class=\"tok-comment\">// This is because the pointed-to data is zero bits long, so its immutability is irrelevant.</span>\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Slices §",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Slices §",
    "context": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the len field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value at",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> mem = std.mem;\n<span class=\"tok-kw\">const</span> fmt = std.fmt;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"using slices for strings\"</span> {\n    <span class=\"tok-comment\">// Zig has no concept of strings. String literals are const pointers</span>\n    <span class=\"tok-comment\">// to null-terminated arrays of u8, and by convention parameters</span>\n    <span class=\"tok-comment\">// that are \"strings\" are expected to be UTF-8 encoded slices of u8.</span>\n    <span class=\"tok-comment\">// Here we coerce *const [5:0]u8 and *const [6:0]u8 to []const u8</span>\n    <span class=\"tok-kw\">const</span> hello: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>;\n    <span class=\"tok-kw\">const</span> world: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"世界\"</span>;\n\n    <span class=\"tok-kw\">var</span> all_together: [<span class=\"tok-number\">100</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-comment\">// You can use slice syntax with at least one runtime-known index on an</span>\n    <span class=\"tok-comment\">// array to convert an array into a slice.</span>\n    <span class=\"tok-kw\">var</span> start: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    _ = &start;\n    <span class=\"tok-kw\">const</span> all_together_slice = all_together[start..];\n    <span class=\"tok-comment\">// String concatenation example.</span>\n    <span class=\"tok-kw\">const</span> hello_world = <span class=\"tok-kw\">try</span> fmt.bufPrint(all_together_slice, <span class=\"tok-str\">\"{s} {s}\"</span>, .{ hello, world });\n\n    <span class=\"tok-comment\">// Generally, you can use UTF-8 and not worry about whether something is a</span>\n    <span class=\"tok-comment\">// string. If you don't need to deal with individual characters, no need</span>\n    <span class=\"tok-comment\">// to decode.</span>\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, hello_world, <span class=\"tok-str\">\"hello 世界\"</span>));\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"slice pointer\"</span> {\n    <span class=\"tok-kw\">var</span> array: [<span class=\"tok-number\">10</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">const</span> ptr = &array;\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(ptr) == *[<span class=\"tok-number\">10</span>]<span class=\"tok-type\">u8</span>);\n\n    <span class=\"tok-comment\">// A pointer to an array can be sliced just like an array:</span>\n    <span class=\"tok-kw\">var</span> start: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">var</span> end: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">5</span>;\n    _ = .{ &start, &end };\n    <span class=\"tok-kw\">const</span> slice = ptr[start..end];\n    <span class=\"tok-comment\">// The slice is mutable because we sliced a mutable pointer.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(slice) == []<span class=\"tok-type\">u8</span>);\n    slice[<span class=\"tok-number\">2</span>] = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">2</span>] == <span class=\"tok-number\">3</span>);\n\n    <span class=\"tok-comment\">// Again, slicing with comptime-known indexes will produce another pointer</span>\n    <span class=\"tok-comment\">// to an array:</span>\n    <span class=\"tok-kw\">const</span> ptr2 = slice[<span class=\"tok-number\">2</span>..<span class=\"tok-number\">3</span>];\n    <span class=\"tok-kw\">try</span> expect(ptr2.len == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(ptr2[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">3</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(ptr2) == *[<span class=\"tok-number\">1</span>]<span class=\"tok-type\">u8</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Slices §",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Slices §",
    "context": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the len field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value at",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"0-terminated slice\"</span> {\n    <span class=\"tok-kw\">const</span> slice: [:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>;\n\n    <span class=\"tok-kw\">try</span> expect(slice.len == <span class=\"tok-number\">5</span>);\n    <span class=\"tok-kw\">try</span> expect(slice[<span class=\"tok-number\">5</span>] == <span class=\"tok-number\">0</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Slices §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Slices §",
    "context": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the len field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value at",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"0-terminated slicing\"</span> {\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">3</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span> };\n    <span class=\"tok-kw\">var</span> runtime_length: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">3</span>;\n    _ = &runtime_length;\n    <span class=\"tok-kw\">const</span> slice = array[<span class=\"tok-number\">0</span>..runtime_length :<span class=\"tok-number\">0</span>];\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(slice) == [:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>);\n    <span class=\"tok-kw\">try</span> expect(slice.len == <span class=\"tok-number\">3</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Slices §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Slices §",
    "context": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the len field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value at",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"sentinel mismatch\"</span> {\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">3</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span> };\n\n    <span class=\"tok-comment\">// Creating a sentinel-terminated slice from the array with a length of 2</span>\n    <span class=\"tok-comment\">// will result in the value `1` occupying the sentinel element position.</span>\n    <span class=\"tok-comment\">// This does not match the indicated sentinel value of `0` and will lead</span>\n    <span class=\"tok-comment\">// to a runtime panic.</span>\n    <span class=\"tok-kw\">var</span> runtime_length: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">2</span>;\n    _ = &runtime_length;\n    <span class=\"tok-kw\">const</span> slice = array[<span class=\"tok-number\">0</span>..runtime_length :<span class=\"tok-number\">0</span>];\n\n    _ = slice;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Slices §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Slices § in Zig 0.15.1",
    "context": "",
    "response": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the len field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value at the element indexed by the length. The type does not guarantee that there are no sentinel elements before that. Sentinel-terminated slices allow element access to the len index. test_null_terminated_slice.zig Shell Sentinel-terminated slices can also be created using a variation of the slice syntax data[start..end :x] , where data is a many-item pointer, array or slice and x is the sentinel value. test_null_terminated_slicing.zig Shell Sentinel-terminated slicing asserts that the element in the",
    "metadata": {
      "version": "0.15.1",
      "topic": "Slices §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-comment\">// Declare a struct.</span>\n<span class=\"tok-comment\">// Zig gives no guarantees about the order of fields and the size of</span>\n<span class=\"tok-comment\">// the struct but the fields are guaranteed to be ABI-aligned.</span>\n<span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> {\n    x: <span class=\"tok-type\">f32</span>,\n    y: <span class=\"tok-type\">f32</span>,\n};\n\n<span class=\"tok-comment\">// Declare an instance of a struct.</span>\n<span class=\"tok-kw\">const</span> p: Point = .{\n    .x = <span class=\"tok-number\">0.12</span>,\n    .y = <span class=\"tok-number\">0.34</span>,\n};\n\n<span class=\"tok-comment\">// Functions in the struct's namespace can be called with dot syntax.</span>\n<span class=\"tok-kw\">const</span> Vec3 = <span class=\"tok-kw\">struct</span> {\n    x: <span class=\"tok-type\">f32</span>,\n    y: <span class=\"tok-type\">f32</span>,\n    z: <span class=\"tok-type\">f32</span>,\n\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">init</span>(x: <span class=\"tok-type\">f32</span>, y: <span class=\"tok-type\">f32</span>, z: <span class=\"tok-type\">f32</span>) Vec3 {\n        <span class=\"tok-kw\">return</span> Vec3{\n            .x = x,\n            .y = y,\n            .z = z,\n        };\n    }\n\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">dot</span>(self: Vec3, other: Vec3) <span class=\"tok-type\">f32</span> {\n        <span class=\"tok-kw\">return</span> self.x * other.x + self.y * other.y + self.z * other.z;\n    }\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"dot product\"</span> {\n    <span class=\"tok-kw\">const</span> v1 = Vec3.init(<span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>);\n    <span class=\"tok-kw\">const</span> v2 = Vec3.init(<span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span>);\n    <span class=\"tok-kw\">try</span> expect(v1.dot(v2) == <span class=\"tok-number\">0.0</span>);\n\n    <span class=\"tok-comment\">// Other than being available to call with dot syntax, struct methods are</span>\n    <span class=\"tok-comment\">// not special. You can reference them as any other declaration inside</span>\n    <span class=\"tok-comment\">// the struct:</span>\n    <span class=\"tok-kw\">try</span> expect(Vec3.dot(v1, v2) == <span class=\"tok-number\">0.0</span>);\n}\n\n<span class=\"tok-comment\">// Structs can have declarations.</span>\n<span class=\"tok-comment\">// Structs can have 0 fields.</span>\n<span class=\"tok-kw\">const</span> Empty = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> PI = <span class=\"tok-number\">3.14</span>;\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"struct namespaced variable\"</span> {\n    <span class=\"tok-kw\">try</span> expect(Empty.PI == <span class=\"tok-number\">3.14</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@sizeOf</span>(Empty) == <span class=\"tok-number\">0</span>);\n\n    <span class=\"tok-comment\">// Empty structs can be instantiated the same as usual.</span>\n    <span class=\"tok-kw\">const</span> does_nothing: Empty = .{};\n\n    _ = does_nothing;\n}\n\n<span class=\"tok-comment\">// Struct field order is determined by the compiler, however, a base pointer</span>\n<span class=\"tok-comment\">// can be computed from a field pointer:</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">setYBasedOnX</span>(x: *<span class=\"tok-type\">f32</span>, y: <span class=\"tok-type\">f32</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> point: *Point = <span class=\"tok-builtin\">@fieldParentPtr</span>(<span class=\"tok-str\">\"x\"</span>, x);\n    point.y = y;\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"field parent pointer\"</span> {\n    <span class=\"tok-kw\">var</span> point = Point{\n        .x = <span class=\"tok-number\">0.1234</span>,\n        .y = <span class=\"tok-number\">0.5678</span>,\n    };\n    setYBasedOnX(&point.x, <span class=\"tok-number\">0.9</span>);\n    <span class=\"tok-kw\">try</span> expect(point.y == <span class=\"tok-number\">0.9</span>);\n}\n\n<span class=\"tok-comment\">// Structs can be returned from functions.</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">LinkedList</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">struct</span> {\n        <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> Node = <span class=\"tok-kw\">struct</span> {\n            prev: ?*Node,\n            next: ?*Node,\n            data: T,\n        };\n\n        first: ?*Node,\n        last: ?*Node,\n        len: <span class=\"tok-type\">usize</span>,\n    };\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"linked list\"</span> {\n    <span class=\"tok-comment\">// Functions called at compile-time are memoized.</span>\n    <span class=\"tok-kw\">try</span> expect(LinkedList(<span class=\"tok-type\">i32</span>) == LinkedList(<span class=\"tok-type\">i32</span>));\n\n    <span class=\"tok-kw\">const</span> list = LinkedList(<span class=\"tok-type\">i32</span>){\n        .first = <span class=\"tok-null\">null</span>,\n        .last = <span class=\"tok-null\">null</span>,\n        .len = <span class=\"tok-number\">0</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(list.len == <span class=\"tok-number\">0</span>);\n\n    <span class=\"tok-comment\">// Since types are first class values you can instantiate the type</span>\n    <span class=\"tok-comment\">// by assigning it to a variable:</span>\n    <span class=\"tok-kw\">const</span> ListOfInts = LinkedList(<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(ListOfInts == LinkedList(<span class=\"tok-type\">i32</span>));\n\n    <span class=\"tok-kw\">var</span> node = ListOfInts.Node{\n        .prev = <span class=\"tok-null\">null</span>,\n        .next = <span class=\"tok-null\">null</span>,\n        .data = <span class=\"tok-number\">1234</span>,\n    };\n    <span class=\"tok-kw\">const</span> list2 = LinkedList(<span class=\"tok-type\">i32</span>){\n        .first = &node,\n        .last = &node,\n        .len = <span class=\"tok-number\">1</span>,\n    };\n\n    <span class=\"tok-comment\">// When using a pointer to a struct, fields can be accessed directly,</span>\n    <span class=\"tok-comment\">// without explicitly dereferencing the pointer.</span>\n    <span class=\"tok-comment\">// So you can do</span>\n    <span class=\"tok-kw\">try</span> expect(list2.first.?.data == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-comment\">// instead of try expect(list2.first.?.*.data == 1234);</span>\n}\n\n<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>,\n    b: <span class=\"tok-type\">i32</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"default struct initialization fields\"</span> {\n    <span class=\"tok-kw\">const</span> x: Foo = .{\n        .b = <span class=\"tok-number\">5</span>,\n    };\n    <span class=\"tok-kw\">if</span> (x.a + x.b != <span class=\"tok-number\">1239</span>) {\n        <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">unreachable</span>;\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> Threshold = <span class=\"tok-kw\">struct</span> {\n    minimum: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">0.25</span>,\n    maximum: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">0.75</span>,\n\n    <span class=\"tok-kw\">const</span> Category = <span class=\"tok-kw\">enum</span> { low, medium, high };\n\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">categorize</span>(t: Threshold, value: <span class=\"tok-type\">f32</span>) Category {\n        assert(t.maximum >= t.minimum);\n        <span class=\"tok-kw\">if</span> (value < t.minimum) <span class=\"tok-kw\">return</span> .low;\n        <span class=\"tok-kw\">if</span> (value > t.maximum) <span class=\"tok-kw\">return</span> .high;\n        <span class=\"tok-kw\">return</span> .medium;\n    }\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> threshold: Threshold = .{\n        .maximum = <span class=\"tok-number\">0.20</span>,\n    };\n    <span class=\"tok-kw\">const</span> category = threshold.categorize(<span class=\"tok-number\">0.90</span>);\n    <span class=\"tok-kw\">try</span> std.fs.File.stdout().writeAll(<span class=\"tok-builtin\">@tagName</span>(category));\n}\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> assert = std.debug.assert;",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> Threshold = <span class=\"tok-kw\">struct</span> {\n    minimum: <span class=\"tok-type\">f32</span>,\n    maximum: <span class=\"tok-type\">f32</span>,\n\n    <span class=\"tok-kw\">const</span> default: Threshold = .{\n        .minimum = <span class=\"tok-number\">0.25</span>,\n        .maximum = <span class=\"tok-number\">0.75</span>,\n    };\n};",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> native_endian = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>).target.cpu.arch.endian();\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Full = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    number: <span class=\"tok-type\">u16</span>,\n};\n<span class=\"tok-kw\">const</span> Divided = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    half1: <span class=\"tok-type\">u8</span>,\n    quarter3: <span class=\"tok-type\">u4</span>,\n    quarter4: <span class=\"tok-type\">u4</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@bitCast between packed structs\"</span> {\n    <span class=\"tok-kw\">try</span> doTheTest();\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> doTheTest();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doTheTest</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@sizeOf</span>(Full) == <span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@sizeOf</span>(Divided) == <span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">const</span> full = Full{ .number = <span class=\"tok-number\">0x1234</span> };\n    <span class=\"tok-kw\">const</span> divided: Divided = <span class=\"tok-builtin\">@bitCast</span>(full);\n    <span class=\"tok-kw\">try</span> expect(divided.half1 == <span class=\"tok-number\">0x34</span>);\n    <span class=\"tok-kw\">try</span> expect(divided.quarter3 == <span class=\"tok-number\">0x2</span>);\n    <span class=\"tok-kw\">try</span> expect(divided.quarter4 == <span class=\"tok-number\">0x1</span>);\n\n    <span class=\"tok-kw\">const</span> ordered: [<span class=\"tok-number\">2</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@bitCast</span>(full);\n    <span class=\"tok-kw\">switch</span> (native_endian) {\n        .big => {\n            <span class=\"tok-kw\">try</span> expect(ordered[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">0x12</span>);\n            <span class=\"tok-kw\">try</span> expect(ordered[<span class=\"tok-number\">1</span>] == <span class=\"tok-number\">0x34</span>);\n        },\n        .little => {\n            <span class=\"tok-kw\">try</span> expect(ordered[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">0x34</span>);\n            <span class=\"tok-kw\">try</span> expect(ordered[<span class=\"tok-number\">1</span>] == <span class=\"tok-number\">0x12</span>);\n        },\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"missized packed struct\"</span> {\n    <span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span>(<span class=\"tok-type\">u32</span>) { a: <span class=\"tok-type\">u16</span>, b: <span class=\"tok-type\">u8</span> };\n    _ = S{ .a = <span class=\"tok-number\">4</span>, .b = <span class=\"tok-number\">2</span> };\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> BitField = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">u3</span>,\n    b: <span class=\"tok-type\">u3</span>,\n    c: <span class=\"tok-type\">u2</span>,\n};\n\n<span class=\"tok-kw\">var</span> foo = BitField{\n    .a = <span class=\"tok-number\">1</span>,\n    .b = <span class=\"tok-number\">2</span>,\n    .c = <span class=\"tok-number\">3</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer to non-byte-aligned field\"</span> {\n    <span class=\"tok-kw\">const</span> ptr = &foo.b;\n    <span class=\"tok-kw\">try</span> expect(ptr.* == <span class=\"tok-number\">2</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> BitField = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">u3</span>,\n    b: <span class=\"tok-type\">u3</span>,\n    c: <span class=\"tok-type\">u2</span>,\n};\n\n<span class=\"tok-kw\">var</span> bit_field = BitField{\n    .a = <span class=\"tok-number\">1</span>,\n    .b = <span class=\"tok-number\">2</span>,\n    .c = <span class=\"tok-number\">3</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer to non-byte-aligned field\"</span> {\n    <span class=\"tok-kw\">try</span> expect(bar(&bit_field.b) == <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>(x: *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u3</span>) <span class=\"tok-type\">u3</span> {\n    <span class=\"tok-kw\">return</span> x.*;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> BitField = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">u3</span>,\n    b: <span class=\"tok-type\">u3</span>,\n    c: <span class=\"tok-type\">u2</span>,\n};\n\n<span class=\"tok-kw\">var</span> bit_field = BitField{\n    .a = <span class=\"tok-number\">1</span>,\n    .b = <span class=\"tok-number\">2</span>,\n    .c = <span class=\"tok-number\">3</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointers of sub-byte-aligned fields share addresses\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromPtr</span>(&bit_field.a) == <span class=\"tok-builtin\">@intFromPtr</span>(&bit_field.b));\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromPtr</span>(&bit_field.a) == <span class=\"tok-builtin\">@intFromPtr</span>(&bit_field.c));\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> BitField = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">u3</span>,\n    b: <span class=\"tok-type\">u3</span>,\n    c: <span class=\"tok-type\">u2</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"offsets of non-byte-aligned fields\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@bitOffsetOf</span>(BitField, <span class=\"tok-str\">\"a\"</span>) == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@bitOffsetOf</span>(BitField, <span class=\"tok-str\">\"b\"</span>) == <span class=\"tok-number\">3</span>);\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@bitOffsetOf</span>(BitField, <span class=\"tok-str\">\"c\"</span>) == <span class=\"tok-number\">6</span>);\n\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@offsetOf</span>(BitField, <span class=\"tok-str\">\"a\"</span>) == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@offsetOf</span>(BitField, <span class=\"tok-str\">\"b\"</span>) == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@offsetOf</span>(BitField, <span class=\"tok-str\">\"c\"</span>) == <span class=\"tok-number\">0</span>);\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">u32</span>,\n    b: <span class=\"tok-type\">u32</span>,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"overaligned pointer to packed struct\"</span> {\n    <span class=\"tok-kw\">var</span> foo: S <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) = .{ .a = <span class=\"tok-number\">1</span>, .b = <span class=\"tok-number\">2</span> };\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) S = &foo;\n    <span class=\"tok-kw\">const</span> ptr_to_b: *<span class=\"tok-type\">u32</span> = &ptr.b;\n    <span class=\"tok-kw\">try</span> expect(ptr_to_b.* == <span class=\"tok-number\">2</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expectEqual = std.testing.expectEqual;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"aligned struct fields\"</span> {\n    <span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> {\n        a: <span class=\"tok-type\">u32</span> <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">2</span>),\n        b: <span class=\"tok-type\">u32</span> <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">64</span>),\n    };\n    <span class=\"tok-kw\">var</span> foo = S{ .a = <span class=\"tok-number\">1</span>, .b = <span class=\"tok-number\">2</span> };\n\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">64</span>, <span class=\"tok-builtin\">@alignOf</span>(S));\n    <span class=\"tok-kw\">try</span> expectEqual(*<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">2</span>) <span class=\"tok-type\">u32</span>, <span class=\"tok-builtin\">@TypeOf</span>(&foo.a));\n    <span class=\"tok-kw\">try</span> expectEqual(*<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">64</span>) <span class=\"tok-type\">u32</span>, <span class=\"tok-builtin\">@TypeOf</span>(&foo.b));\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"packed struct equality\"</span> {\n    <span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n        a: <span class=\"tok-type\">u4</span>,\n        b: <span class=\"tok-type\">u4</span>,\n    };\n    <span class=\"tok-kw\">const</span> x: S = .{ .a = <span class=\"tok-number\">1</span>, .b = <span class=\"tok-number\">2</span> };\n    <span class=\"tok-kw\">const</span> y: S = .{ .b = <span class=\"tok-number\">2</span>, .a = <span class=\"tok-number\">1</span> };\n    <span class=\"tok-kw\">try</span> expect(x == y);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> GpioRegister = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span>(<span class=\"tok-type\">u8</span>) {\n    GPIO0: <span class=\"tok-type\">bool</span>,\n    GPIO1: <span class=\"tok-type\">bool</span>,\n    GPIO2: <span class=\"tok-type\">bool</span>,\n    GPIO3: <span class=\"tok-type\">bool</span>,\n    reserved: <span class=\"tok-type\">u4</span> = <span class=\"tok-number\">0</span>,\n};\n\n<span class=\"tok-kw\">const</span> gpio: *<span class=\"tok-kw\">volatile</span> GpioRegister = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0x0123</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">writeToGpio</span>(new_states: GpioRegister) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-comment\">// Example of what not to do:</span>\n    <span class=\"tok-comment\">// BAD! gpio.GPIO0 = true; BAD!</span>\n\n    <span class=\"tok-comment\">// Instead, do this:</span>\n    gpio.* = new_states;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">struct</span> {};\n    std.debug.print(<span class=\"tok-str\">\"variable: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@typeName</span>(Foo)});\n    std.debug.print(<span class=\"tok-str\">\"anonymous: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@typeName</span>(<span class=\"tok-kw\">struct</span> {})});\n    std.debug.print(<span class=\"tok-str\">\"function: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@typeName</span>(List(<span class=\"tok-type\">i32</span>))});\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">List</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">struct</span> {\n        x: T,\n    };\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> { x: <span class=\"tok-type\">i32</span>, y: <span class=\"tok-type\">i32</span> };\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"anonymous struct literal\"</span> {\n    <span class=\"tok-kw\">const</span> pt: Point = .{\n        .x = <span class=\"tok-number\">13</span>,\n        .y = <span class=\"tok-number\">67</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(pt.x == <span class=\"tok-number\">13</span>);\n    <span class=\"tok-kw\">try</span> expect(pt.y == <span class=\"tok-number\">67</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fully anonymous struct\"</span> {\n    <span class=\"tok-kw\">try</span> check(.{\n        .int = <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-number\">1234</span>),\n        .float = <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">f64</span>, <span class=\"tok-number\">12.34</span>),\n        .b = <span class=\"tok-null\">true</span>,\n        .s = <span class=\"tok-str\">\"hi\"</span>,\n    });\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">check</span>(args: <span class=\"tok-kw\">anytype</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> expect(args.int == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> expect(args.float == <span class=\"tok-number\">12.34</span>);\n    <span class=\"tok-kw\">try</span> expect(args.b);\n    <span class=\"tok-kw\">try</span> expect(args.s[<span class=\"tok-number\">0</span>] == <span class=\"tok-str\">'h'</span>);\n    <span class=\"tok-kw\">try</span> expect(args.s[<span class=\"tok-number\">1</span>] == <span class=\"tok-str\">'i'</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"tuple\"</span> {\n    <span class=\"tok-kw\">const</span> values = .{\n        <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-number\">1234</span>),\n        <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">f64</span>, <span class=\"tok-number\">12.34</span>),\n        <span class=\"tok-null\">true</span>,\n        <span class=\"tok-str\">\"hi\"</span>,\n    } ++ .{<span class=\"tok-null\">false</span>} ** <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">try</span> expect(values[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> expect(values[<span class=\"tok-number\">4</span>] == <span class=\"tok-null\">false</span>);\n    <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">for</span> (values, <span class=\"tok-number\">0</span>..) |v, i| {\n        <span class=\"tok-kw\">if</span> (i != <span class=\"tok-number\">2</span>) <span class=\"tok-kw\">continue</span>;\n        <span class=\"tok-kw\">try</span> expect(v);\n    }\n    <span class=\"tok-kw\">try</span> expect(values.len == <span class=\"tok-number\">6</span>);\n    <span class=\"tok-kw\">try</span> expect(values.@\"3\"[<span class=\"tok-number\">0</span>] == <span class=\"tok-str\">'h'</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> digits = [_]<span class=\"tok-type\">i8</span> { <span class=\"tok-number\">3</span>, <span class=\"tok-number\">8</span>, <span class=\"tok-number\">9</span>, <span class=\"tok-number\">0</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">1</span> };\n\n    <span class=\"tok-kw\">const</span> min, <span class=\"tok-kw\">const</span> max = blk: {\n        <span class=\"tok-kw\">var</span> min: <span class=\"tok-type\">i8</span> = <span class=\"tok-number\">127</span>;\n        <span class=\"tok-kw\">var</span> max: <span class=\"tok-type\">i8</span> = -<span class=\"tok-number\">128</span>;\n\n        <span class=\"tok-kw\">for</span> (digits) |digit| {\n            <span class=\"tok-kw\">if</span> (digit < min) min = digit;\n            <span class=\"tok-kw\">if</span> (digit > max) max = digit;\n        }\n\n        <span class=\"tok-kw\">break</span> :blk .{ min, max };\n    };\n\n    print(<span class=\"tok-str\">\"min = {}\"</span>, .{ min });\n    print(<span class=\"tok-str\">\"max = {}\"</span>, .{ max });\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">divmod</span>(numerator: <span class=\"tok-type\">u32</span>, denominator: <span class=\"tok-type\">u32</span>) <span class=\"tok-kw\">struct</span> { <span class=\"tok-type\">u32</span>, <span class=\"tok-type\">u32</span> } {\n    <span class=\"tok-kw\">return</span> .{ numerator / denominator, numerator % denominator };\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> div, <span class=\"tok-kw\">const</span> mod = divmod(<span class=\"tok-number\">10</span>, <span class=\"tok-number\">3</span>);\n\n    print(<span class=\"tok-str\">\"10 / 3 = {}\\n\"</span>, .{div});\n    print(<span class=\"tok-str\">\"10 % 3 = {}\\n\"</span>, .{mod});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain struct § in Zig 0.15.1",
    "context": "",
    "response": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: bad_default_value.zig Shell Above you can see the danger of ignoring this principle. The default field values caused the data invariant to be violated, causing illegal behavior. To fix this, remove the default values from all the struct fields, and provide a named default value: struct_default_value.zig If a struct value requires a runtime-known value in order to be initialized without violating data invariants, then use an initialization method that accepts those run",
    "metadata": {
      "version": "0.15.1",
      "topic": "struct §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: enum §",
    "context": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum mus",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem;\n\n<span class=\"tok-comment\">// Declare an enum.</span>\n<span class=\"tok-kw\">const</span> Type = <span class=\"tok-kw\">enum</span> {\n    ok,\n    not_ok,\n};\n\n<span class=\"tok-comment\">// Declare a specific enum field.</span>\n<span class=\"tok-kw\">const</span> c = Type.ok;\n\n<span class=\"tok-comment\">// If you want access to the ordinal value of an enum, you</span>\n<span class=\"tok-comment\">// can specify the tag type.</span>\n<span class=\"tok-kw\">const</span> Value = <span class=\"tok-kw\">enum</span>(<span class=\"tok-type\">u2</span>) {\n    zero,\n    one,\n    two,\n};\n<span class=\"tok-comment\">// Now you can cast between u2 and Value.</span>\n<span class=\"tok-comment\">// The ordinal value starts from 0, counting up by 1 from the previous member.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum ordinal value\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value.zero) == <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value.one) == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value.two) == <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-comment\">// You can override the ordinal value for an enum.</span>\n<span class=\"tok-kw\">const</span> Value2 = <span class=\"tok-kw\">enum</span>(<span class=\"tok-type\">u32</span>) {\n    hundred = <span class=\"tok-number\">100</span>,\n    thousand = <span class=\"tok-number\">1000</span>,\n    million = <span class=\"tok-number\">1000000</span>,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"set enum ordinal value\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value2.hundred) == <span class=\"tok-number\">100</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value2.thousand) == <span class=\"tok-number\">1000</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value2.million) == <span class=\"tok-number\">1000000</span>);\n}\n\n<span class=\"tok-comment\">// You can also override only some values.</span>\n<span class=\"tok-kw\">const</span> Value3 = <span class=\"tok-kw\">enum</span>(<span class=\"tok-type\">u4</span>) {\n    a,\n    b = <span class=\"tok-number\">8</span>,\n    c,\n    d = <span class=\"tok-number\">4</span>,\n    e,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum implicit ordinal values and overridden values\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value3.a) == <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value3.b) == <span class=\"tok-number\">8</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value3.c) == <span class=\"tok-number\">9</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value3.d) == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value3.e) == <span class=\"tok-number\">5</span>);\n}\n\n<span class=\"tok-comment\">// Enums can have methods, the same as structs and unions.</span>\n<span class=\"tok-comment\">// Enum methods are not special, they are only namespaced</span>\n<span class=\"tok-comment\">// functions that you can call with dot syntax.</span>\n<span class=\"tok-kw\">const</span> Suit = <span class=\"tok-kw\">enum</span> {\n    clubs,\n    spades,\n    diamonds,\n    hearts,\n\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">isClubs</span>(self: Suit) <span class=\"tok-type\">bool</span> {\n        <span class=\"tok-kw\">return</span> self == Suit.clubs;\n    }\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum method\"</span> {\n    <span class=\"tok-kw\">const</span> p = Suit.spades;\n    <span class=\"tok-kw\">try</span> expect(!p.isClubs());\n}\n\n<span class=\"tok-comment\">// An enum can be switched upon.</span>\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">enum</span> {\n    string,\n    number,\n    none,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum switch\"</span> {\n    <span class=\"tok-kw\">const</span> p = Foo.number;\n    <span class=\"tok-kw\">const</span> what_is_it = <span class=\"tok-kw\">switch</span> (p) {\n        Foo.string => <span class=\"tok-str\">\"this is a string\"</span>,\n        Foo.number => <span class=\"tok-str\">\"this is a number\"</span>,\n        Foo.none => <span class=\"tok-str\">\"this is a none\"</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, what_is_it, <span class=\"tok-str\">\"this is a number\"</span>));\n}\n\n<span class=\"tok-comment\">// @typeInfo can be used to access the integer tag type of an enum.</span>\n<span class=\"tok-kw\">const</span> Small = <span class=\"tok-kw\">enum</span> {\n    one,\n    two,\n    three,\n    four,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"std.meta.Tag\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(Small).@\"enum\".tag_type == <span class=\"tok-type\">u2</span>);\n}\n\n<span class=\"tok-comment\">// @typeInfo tells us the field count and the fields names:</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@typeInfo\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(Small).@\"enum\".fields.len == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-builtin\">@typeInfo</span>(Small).@\"enum\".fields[<span class=\"tok-number\">1</span>].name, <span class=\"tok-str\">\"two\"</span>));\n}\n\n<span class=\"tok-comment\">// @tagName gives a [:0]const u8 representation of an enum value:</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@tagName\"</span> {\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-builtin\">@tagName</span>(Small.three), <span class=\"tok-str\">\"three\"</span>));\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "enum §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: enum §",
    "context": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum mus",
    "response": "<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">enum</span> { a, b, c };\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">entry</span>(foo: Foo) <span class=\"tok-type\">void</span> {\n    _ = foo;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "enum §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: enum §",
    "context": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum mus",
    "response": "<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">enum</span>(<span class=\"tok-type\">c_int</span>) { a, b, c };\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">entry</span>(foo: Foo) <span class=\"tok-type\">void</span> {\n    _ = foo;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "enum §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: enum §",
    "context": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum mus",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Color = <span class=\"tok-kw\">enum</span> {\n    auto,\n    off,\n    on,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum literals\"</span> {\n    <span class=\"tok-kw\">const</span> color1: Color = .auto;\n    <span class=\"tok-kw\">const</span> color2 = Color.auto;\n    <span class=\"tok-kw\">try</span> expect(color1 == color2);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch using enum literals\"</span> {\n    <span class=\"tok-kw\">const</span> color = Color.on;\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">switch</span> (color) {\n        .auto => <span class=\"tok-null\">false</span>,\n        .on => <span class=\"tok-null\">true</span>,\n        .off => <span class=\"tok-null\">false</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(result);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "enum §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: enum §",
    "context": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum mus",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Number = <span class=\"tok-kw\">enum</span>(<span class=\"tok-type\">u8</span>) {\n    one,\n    two,\n    three,\n    _,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch on non-exhaustive enum\"</span> {\n    <span class=\"tok-kw\">const</span> number = Number.one;\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">switch</span> (number) {\n        .one => <span class=\"tok-null\">true</span>,\n        .two, .three => <span class=\"tok-null\">false</span>,\n        _ => <span class=\"tok-null\">false</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(result);\n    <span class=\"tok-kw\">const</span> is_one = <span class=\"tok-kw\">switch</span> (number) {\n        .one => <span class=\"tok-null\">true</span>,\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-null\">false</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(is_one);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "enum §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain enum § in Zig 0.15.1",
    "context": "",
    "response": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum must specify a tag type and cannot consume every enumeration value. @enumFromInt on a non-exhaustive enum involves the safety semantics of @intCast to the integer tag type, but beyond that always results in a well-defined enum value. A switch on a non-exhaustive enum can include a _ prong as an alternative to an else prong. With a _ prong the compiler errors if all the known tag names are not handled by the switch. test_switch_non-exhaustive.zig Shell",
    "metadata": {
      "version": "0.15.1",
      "topic": "enum §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entir",
    "response": "<span class=\"tok-kw\">const</span> Payload = <span class=\"tok-kw\">union</span> {\n    int: <span class=\"tok-type\">i64</span>,\n    float: <span class=\"tok-type\">f64</span>,\n    boolean: <span class=\"tok-type\">bool</span>,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"simple union\"</span> {\n    <span class=\"tok-kw\">var</span> payload = Payload{ .int = <span class=\"tok-number\">1234</span> };\n    payload.float = <span class=\"tok-number\">12.34</span>;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "union §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entir",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Payload = <span class=\"tok-kw\">union</span> {\n    int: <span class=\"tok-type\">i64</span>,\n    float: <span class=\"tok-type\">f64</span>,\n    boolean: <span class=\"tok-type\">bool</span>,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"simple union\"</span> {\n    <span class=\"tok-kw\">var</span> payload = Payload{ .int = <span class=\"tok-number\">1234</span> };\n    <span class=\"tok-kw\">try</span> expect(payload.int == <span class=\"tok-number\">1234</span>);\n    payload = Payload{ .float = <span class=\"tok-number\">12.34</span> };\n    <span class=\"tok-kw\">try</span> expect(payload.float == <span class=\"tok-number\">12.34</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entir",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> ComplexTypeTag = <span class=\"tok-kw\">enum</span> {\n    ok,\n    not_ok,\n};\n<span class=\"tok-kw\">const</span> ComplexType = <span class=\"tok-kw\">union</span>(ComplexTypeTag) {\n    ok: <span class=\"tok-type\">u8</span>,\n    not_ok: <span class=\"tok-type\">void</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch on tagged union\"</span> {\n    <span class=\"tok-kw\">const</span> c = ComplexType{ .ok = <span class=\"tok-number\">42</span> };\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@as</span>(ComplexTypeTag, c) == ComplexTypeTag.ok);\n\n    <span class=\"tok-kw\">switch</span> (c) {\n        .ok => |value| <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">42</span>),\n        .not_ok => <span class=\"tok-kw\">unreachable</span>,\n    }\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"get tag type\"</span> {\n    <span class=\"tok-kw\">try</span> expect(std.meta.Tag(ComplexType) == ComplexTypeTag);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entir",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> ComplexTypeTag = <span class=\"tok-kw\">enum</span> {\n    ok,\n    not_ok,\n};\n<span class=\"tok-kw\">const</span> ComplexType = <span class=\"tok-kw\">union</span>(ComplexTypeTag) {\n    ok: <span class=\"tok-type\">u8</span>,\n    not_ok: <span class=\"tok-type\">void</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"modify tagged union in switch\"</span> {\n    <span class=\"tok-kw\">var</span> c = ComplexType{ .ok = <span class=\"tok-number\">42</span> };\n\n    <span class=\"tok-kw\">switch</span> (c) {\n        ComplexTypeTag.ok => |*value| value.* += <span class=\"tok-number\">1</span>,\n        ComplexTypeTag.not_ok => <span class=\"tok-kw\">unreachable</span>,\n    }\n\n    <span class=\"tok-kw\">try</span> expect(c.ok == <span class=\"tok-number\">43</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entir",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Variant = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n    int: <span class=\"tok-type\">i32</span>,\n    boolean: <span class=\"tok-type\">bool</span>,\n\n    <span class=\"tok-comment\">// void can be omitted when inferring enum tag type.</span>\n    none,\n\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">truthy</span>(self: Variant) <span class=\"tok-type\">bool</span> {\n        <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (self) {\n            Variant.int => |x_int| x_int != <span class=\"tok-number\">0</span>,\n            Variant.boolean => |x_bool| x_bool,\n            Variant.none => <span class=\"tok-null\">false</span>,\n        };\n    }\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"union method\"</span> {\n    <span class=\"tok-kw\">var</span> v1: Variant = .{ .int = <span class=\"tok-number\">1</span> };\n    <span class=\"tok-kw\">var</span> v2: Variant = .{ .boolean = <span class=\"tok-null\">false</span> };\n    <span class=\"tok-kw\">var</span> v3: Variant = .none;\n\n    <span class=\"tok-kw\">try</span> expect(v1.truthy());\n    <span class=\"tok-kw\">try</span> expect(!v2.truthy());\n    <span class=\"tok-kw\">try</span> expect(!v3.truthy());\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entir",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Tagged = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>(<span class=\"tok-type\">u32</span>)) {\n    int: <span class=\"tok-type\">i64</span> = <span class=\"tok-number\">123</span>,\n    boolean: <span class=\"tok-type\">bool</span> = <span class=\"tok-number\">67</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"tag values\"</span> {\n    <span class=\"tok-kw\">const</span> int: Tagged = .{ .int = -<span class=\"tok-number\">40</span> };\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(int) == <span class=\"tok-number\">123</span>);\n\n    <span class=\"tok-kw\">const</span> boolean: Tagged = .{ .boolean = <span class=\"tok-null\">false</span> };\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(boolean) == <span class=\"tok-number\">67</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entir",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Small2 = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n    a: <span class=\"tok-type\">i32</span>,\n    b: <span class=\"tok-type\">bool</span>,\n    c: <span class=\"tok-type\">u8</span>,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@tagName\"</span> {\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-builtin\">@tagName</span>(Small2.a), <span class=\"tok-str\">\"a\"</span>));\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entir",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Number = <span class=\"tok-kw\">union</span> {\n    int: <span class=\"tok-type\">i32</span>,\n    float: <span class=\"tok-type\">f64</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"anonymous union literal syntax\"</span> {\n    <span class=\"tok-kw\">const</span> i: Number = .{ .int = <span class=\"tok-number\">42</span> };\n    <span class=\"tok-kw\">const</span> f = makeNumber();\n    <span class=\"tok-kw\">try</span> expect(i.int == <span class=\"tok-number\">42</span>);\n    <span class=\"tok-kw\">try</span> expect(f.float == <span class=\"tok-number\">12.34</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">makeNumber</span>() Number {\n    <span class=\"tok-kw\">return</span> .{ .float = <span class=\"tok-number\">12.34</span> };\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain union § in Zig 0.15.1",
    "context": "",
    "response": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entire union: test_simple_union.zig Shell In order to use switch with a union, it must be a Tagged union . To initialize a union when the tag is a comptime -known name, see @unionInit . Tagged union § Unions can be declared with an enum tag type. This turns the union into a tagged union, which makes it eligible to use with switch expressions. Tagged unions coerce to their tag type: Type Coercion: Unions and Enums . test_tagged_union.zig Shell In order to modify the payload of a tagged union in a swit",
    "metadata": {
      "version": "0.15.1",
      "topic": "union §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: opaque §",
    "context": "opaque {} declares a new type with an unknown (but non-zero) size and alignment. It can contain declarations the same as structs , unions , and enums . This is typically used for type safety when interacting with C code that does not expose struct details. Example: test_opaque.zig Shell",
    "response": "<span class=\"tok-kw\">const</span> Derp = <span class=\"tok-kw\">opaque</span> {};\n<span class=\"tok-kw\">const</span> Wat = <span class=\"tok-kw\">opaque</span> {};\n\n<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>(d: *Derp) <span class=\"tok-type\">void</span>;\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(w: *Wat) <span class=\"tok-kw\">callconv</span>(.c) <span class=\"tok-type\">void</span> {\n    bar(w);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"call foo\"</span> {\n    foo(<span class=\"tok-null\">undefined</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "opaque §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain opaque § in Zig 0.15.1",
    "context": "",
    "response": "opaque {} declares a new type with an unknown (but non-zero) size and alignment. It can contain declarations the same as structs , unions , and enums . This is typically used for type safety when interacting with C code that does not expose struct details. Example: test_opaque.zig Shell",
    "metadata": {
      "version": "0.15.1",
      "topic": "opaque §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Blocks §",
    "context": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing wit",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"access variable after block scope\"</span> {\n    {\n        <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n        _ = &x;\n    }\n    x += <span class=\"tok-number\">1</span>;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Blocks §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Blocks §",
    "context": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing wit",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"labeled break from labeled block expression\"</span> {\n    <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">123</span>;\n\n    <span class=\"tok-kw\">const</span> x = blk: {\n        y += <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">break</span> :blk y;\n    };\n    <span class=\"tok-kw\">try</span> expect(x == <span class=\"tok-number\">124</span>);\n    <span class=\"tok-kw\">try</span> expect(y == <span class=\"tok-number\">124</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Blocks §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Blocks §",
    "context": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing wit",
    "response": "<span class=\"tok-kw\">const</span> pi = <span class=\"tok-number\">3.14</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inside test block\"</span> {\n    <span class=\"tok-comment\">// Let's even go inside another block</span>\n    {\n        <span class=\"tok-kw\">var</span> pi: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Blocks §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Blocks §",
    "context": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing wit",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"separate scopes\"</span> {\n    {\n        <span class=\"tok-kw\">const</span> pi = <span class=\"tok-number\">3.14</span>;\n        _ = pi;\n    }\n    {\n        <span class=\"tok-kw\">var</span> pi: <span class=\"tok-type\">bool</span> = <span class=\"tok-null\">true</span>;\n        _ = &pi;\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Blocks §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Blocks §",
    "context": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing wit",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> {\n    <span class=\"tok-kw\">const</span> a = {};\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-type\">void</span>{};\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(a) == <span class=\"tok-type\">void</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(b) == <span class=\"tok-type\">void</span>);\n    <span class=\"tok-kw\">try</span> expect(a == b);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Blocks §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Blocks § in Zig 0.15.1",
    "context": "",
    "response": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing within the scope it is defined. Note that you can, however, use the same name if the scopes are separate: test_scopes.zig Shell Empty Blocks § An empty block is equivalent to void {} : test_empty_block.zig Shell",
    "metadata": {
      "version": "0.15.1",
      "topic": "Blocks §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch simple\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">const</span> zz: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">103</span>;\n\n    <span class=\"tok-comment\">// All branches of a switch expression must be able to be coerced to a</span>\n    <span class=\"tok-comment\">// common type.</span>\n    <span class=\"tok-comment\">//</span>\n    <span class=\"tok-comment\">// Branches cannot fallthrough. If fallthrough behavior is desired, combine</span>\n    <span class=\"tok-comment\">// the cases and use an if.</span>\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-kw\">switch</span> (a) {\n        <span class=\"tok-comment\">// Multiple cases can be combined via a ','</span>\n        <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span> => <span class=\"tok-number\">0</span>,\n\n        <span class=\"tok-comment\">// Ranges can be specified using the ... syntax. These are inclusive</span>\n        <span class=\"tok-comment\">// of both ends.</span>\n        <span class=\"tok-number\">5</span>...<span class=\"tok-number\">100</span> => <span class=\"tok-number\">1</span>,\n\n        <span class=\"tok-comment\">// Branches can be arbitrarily complex.</span>\n        <span class=\"tok-number\">101</span> => blk: {\n            <span class=\"tok-kw\">const</span> c: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">5</span>;\n            <span class=\"tok-kw\">break</span> :blk c * <span class=\"tok-number\">2</span> + <span class=\"tok-number\">1</span>;\n        },\n\n        <span class=\"tok-comment\">// Switching on arbitrary expressions is allowed as long as the</span>\n        <span class=\"tok-comment\">// expression is known at compile-time.</span>\n        zz => zz,\n        blk: {\n            <span class=\"tok-kw\">const</span> d: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">5</span>;\n            <span class=\"tok-kw\">const</span> e: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">100</span>;\n            <span class=\"tok-kw\">break</span> :blk d + e;\n        } => <span class=\"tok-number\">107</span>,\n\n        <span class=\"tok-comment\">// The else branch catches everything not already captured.</span>\n        <span class=\"tok-comment\">// Else branches are mandatory unless the entire range of values</span>\n        <span class=\"tok-comment\">// is handled.</span>\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-number\">9</span>,\n    };\n\n    <span class=\"tok-kw\">try</span> expect(b == <span class=\"tok-number\">1</span>);\n}\n\n<span class=\"tok-comment\">// Switch expressions can be used outside a function:</span>\n<span class=\"tok-kw\">const</span> os_msg = <span class=\"tok-kw\">switch</span> (builtin.target.os.tag) {\n    .linux => <span class=\"tok-str\">\"we found a linux user\"</span>,\n    <span class=\"tok-kw\">else</span> => <span class=\"tok-str\">\"not a linux user\"</span>,\n};\n\n<span class=\"tok-comment\">// Inside a function, switch statements implicitly are compile-time</span>\n<span class=\"tok-comment\">// evaluated if the target expression is compile-time known.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch inside function\"</span> {\n    <span class=\"tok-kw\">switch</span> (builtin.target.os.tag) {\n        .fuchsia => {\n            <span class=\"tok-comment\">// On an OS other than fuchsia, block is not even analyzed,</span>\n            <span class=\"tok-comment\">// so this compile error is not triggered.</span>\n            <span class=\"tok-comment\">// On fuchsia this compile error would be triggered.</span>\n            <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"fuchsia not supported\"</span>);\n        },\n        <span class=\"tok-kw\">else</span> => {},\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch on tagged union\"</span> {\n    <span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> {\n        x: <span class=\"tok-type\">u8</span>,\n        y: <span class=\"tok-type\">u8</span>,\n    };\n    <span class=\"tok-kw\">const</span> Item = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n        a: <span class=\"tok-type\">u32</span>,\n        c: Point,\n        d,\n        e: <span class=\"tok-type\">u32</span>,\n    };\n\n    <span class=\"tok-kw\">var</span> a = Item{ .c = Point{ .x = <span class=\"tok-number\">1</span>, .y = <span class=\"tok-number\">2</span> } };\n\n    <span class=\"tok-comment\">// Switching on more complex enums is allowed.</span>\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-kw\">switch</span> (a) {\n        <span class=\"tok-comment\">// A capture group is allowed on a match, and will return the enum</span>\n        <span class=\"tok-comment\">// value matched. If the payload types of both cases are the same</span>\n        <span class=\"tok-comment\">// they can be put into the same switch prong.</span>\n        Item.a, Item.e => |item| item,\n\n        <span class=\"tok-comment\">// A reference to the matched value can be obtained using `*` syntax.</span>\n        Item.c => |*item| blk: {\n            item.*.x += <span class=\"tok-number\">1</span>;\n            <span class=\"tok-kw\">break</span> :blk <span class=\"tok-number\">6</span>;\n        },\n\n        <span class=\"tok-comment\">// No else is required if the types cases was exhaustively handled</span>\n        Item.d => <span class=\"tok-number\">8</span>,\n    };\n\n    <span class=\"tok-kw\">try</span> expect(b == <span class=\"tok-number\">6</span>);\n    <span class=\"tok-kw\">try</span> expect(a.c.x == <span class=\"tok-number\">2</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> Color = <span class=\"tok-kw\">enum</span> {\n    auto,\n    off,\n    on,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"exhaustive switching\"</span> {\n    <span class=\"tok-kw\">const</span> color = Color.off;\n    <span class=\"tok-kw\">switch</span> (color) {\n        Color.auto => {},\n        Color.on => {},\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "switch §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Color = <span class=\"tok-kw\">enum</span> {\n    auto,\n    off,\n    on,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum literals with switch\"</span> {\n    <span class=\"tok-kw\">const</span> color = Color.off;\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">switch</span> (color) {\n        .auto => <span class=\"tok-null\">false</span>,\n        .on => <span class=\"tok-null\">false</span>,\n        .off => <span class=\"tok-null\">true</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(result);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch continue\"</span> {\n    sw: <span class=\"tok-kw\">switch</span> (<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">i32</span>, <span class=\"tok-number\">5</span>)) {\n        <span class=\"tok-number\">5</span> => <span class=\"tok-kw\">continue</span> :sw <span class=\"tok-number\">4</span>,\n\n        <span class=\"tok-comment\">// `continue` can occur multiple times within a single switch prong.</span>\n        <span class=\"tok-number\">2</span>...<span class=\"tok-number\">4</span> => |v| {\n            <span class=\"tok-kw\">if</span> (v > <span class=\"tok-number\">3</span>) {\n                <span class=\"tok-kw\">continue</span> :sw <span class=\"tok-number\">2</span>;\n            } <span class=\"tok-kw\">else</span> <span class=\"tok-kw\">if</span> (v == <span class=\"tok-number\">3</span>) {\n\n                <span class=\"tok-comment\">// `break` can target labeled loops.</span>\n                <span class=\"tok-kw\">break</span> :sw;\n            }\n\n            <span class=\"tok-kw\">continue</span> :sw <span class=\"tok-number\">1</span>;\n        },\n\n        <span class=\"tok-number\">1</span> => <span class=\"tok-kw\">return</span>,\n\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">unreachable</span>,\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "switch §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch continue, equivalent loop\"</span> {\n    <span class=\"tok-kw\">var</span> sw: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">5</span>;\n    <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n        <span class=\"tok-kw\">switch</span> (sw) {\n            <span class=\"tok-number\">5</span> => {\n                sw = <span class=\"tok-number\">4</span>;\n                <span class=\"tok-kw\">continue</span>;\n            },\n            <span class=\"tok-number\">2</span>...<span class=\"tok-number\">4</span> => |v| {\n                <span class=\"tok-kw\">if</span> (v > <span class=\"tok-number\">3</span>) {\n                    sw = <span class=\"tok-number\">2</span>;\n                    <span class=\"tok-kw\">continue</span>;\n                } <span class=\"tok-kw\">else</span> <span class=\"tok-kw\">if</span> (v == <span class=\"tok-number\">3</span>) {\n                    <span class=\"tok-kw\">break</span>;\n                }\n\n                sw = <span class=\"tok-number\">1</span>;\n                <span class=\"tok-kw\">continue</span>;\n            },\n            <span class=\"tok-number\">1</span> => <span class=\"tok-kw\">return</span>,\n            <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">unreachable</span>,\n        }\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "switch §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expectEqual = std.testing.expectEqual;\n\n<span class=\"tok-kw\">const</span> Instruction = <span class=\"tok-kw\">enum</span> {\n    add,\n    mul,\n    end,\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">evaluate</span>(initial_stack: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span>, code: []<span class=\"tok-kw\">const</span> Instruction) !<span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> buffer: [<span class=\"tok-number\">8</span>]<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">var</span> stack = std.ArrayListUnmanaged(<span class=\"tok-type\">i32</span>).initBuffer(&buffer);\n    <span class=\"tok-kw\">try</span> stack.appendSliceBounded(initial_stack);\n    <span class=\"tok-kw\">var</span> ip: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n\n    <span class=\"tok-kw\">return</span> vm: <span class=\"tok-kw\">switch</span> (code[ip]) {\n        <span class=\"tok-comment\">// Because all code after `continue` is unreachable, this branch does</span>\n        <span class=\"tok-comment\">// not provide a result.</span>\n        .add => {\n            <span class=\"tok-kw\">try</span> stack.appendBounded(stack.pop().? + stack.pop().?);\n\n            ip += <span class=\"tok-number\">1</span>;\n            <span class=\"tok-kw\">continue</span> :vm code[ip];\n        },\n        .mul => {\n            <span class=\"tok-kw\">try</span> stack.appendBounded(stack.pop().? * stack.pop().?);\n\n            ip += <span class=\"tok-number\">1</span>;\n            <span class=\"tok-kw\">continue</span> :vm code[ip];\n        },\n        .end => stack.pop().?,\n    };\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"evaluate\"</span> {\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">try</span> evaluate(&.{ <span class=\"tok-number\">7</span>, <span class=\"tok-number\">2</span>, -<span class=\"tok-number\">3</span> }, &.{ .mul, .add, .end });\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">1</span>, result);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> expectError = std.testing.expectError;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">isFieldOptional</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, field_index: <span class=\"tok-type\">usize</span>) !<span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">const</span> fields = <span class=\"tok-builtin\">@typeInfo</span>(T).@\"struct\".fields;\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (field_index) {\n        <span class=\"tok-comment\">// This prong is analyzed twice with `idx` being a</span>\n        <span class=\"tok-comment\">// comptime-known value each time.</span>\n        <span class=\"tok-kw\">inline</span> <span class=\"tok-number\">0</span>, <span class=\"tok-number\">1</span> => |idx| <span class=\"tok-builtin\">@typeInfo</span>(fields[idx].<span class=\"tok-type\">type</span>) == .optional,\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.IndexOutOfBounds,\n    };\n}\n\n<span class=\"tok-kw\">const</span> Struct1 = <span class=\"tok-kw\">struct</span> { a: <span class=\"tok-type\">u32</span>, b: ?<span class=\"tok-type\">u32</span> };\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"using @typeInfo with runtime values\"</span> {\n    <span class=\"tok-kw\">var</span> index: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">try</span> expect(!<span class=\"tok-kw\">try</span> isFieldOptional(Struct1, index));\n    index += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-kw\">try</span> isFieldOptional(Struct1, index));\n    index += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expectError(<span class=\"tok-kw\">error</span>.IndexOutOfBounds, isFieldOptional(Struct1, index));\n}\n\n<span class=\"tok-comment\">// Calls to `isFieldOptional` on `Struct1` get unrolled to an equivalent</span>\n<span class=\"tok-comment\">// of this function:</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">isFieldOptionalUnrolled</span>(field_index: <span class=\"tok-type\">usize</span>) !<span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (field_index) {\n        <span class=\"tok-number\">0</span> => <span class=\"tok-null\">false</span>,\n        <span class=\"tok-number\">1</span> => <span class=\"tok-null\">true</span>,\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.IndexOutOfBounds,\n    };\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">isFieldOptional</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, field_index: <span class=\"tok-type\">usize</span>) !<span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">const</span> fields = <span class=\"tok-builtin\">@typeInfo</span>(T).@\"struct\".fields;\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (field_index) {\n        <span class=\"tok-kw\">inline</span> <span class=\"tok-number\">0</span>...fields.len - <span class=\"tok-number\">1</span> => |idx| <span class=\"tok-builtin\">@typeInfo</span>(fields[idx].<span class=\"tok-type\">type</span>) == .optional,\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.IndexOutOfBounds,\n    };\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> SliceTypeA = <span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">struct</span> {\n    len: <span class=\"tok-type\">usize</span>,\n    ptr: [*]<span class=\"tok-type\">u32</span>,\n};\n<span class=\"tok-kw\">const</span> SliceTypeB = <span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">struct</span> {\n    ptr: [*]SliceTypeA,\n    len: <span class=\"tok-type\">usize</span>,\n};\n<span class=\"tok-kw\">const</span> AnySlice = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n    a: SliceTypeA,\n    b: SliceTypeB,\n    c: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>,\n    d: []AnySlice,\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">withFor</span>(any: AnySlice) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">const</span> Tag = <span class=\"tok-builtin\">@typeInfo</span>(AnySlice).@\"union\".tag_type.?;\n    <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">for</span> (<span class=\"tok-builtin\">@typeInfo</span>(Tag).@\"enum\".fields) |field| {\n        <span class=\"tok-comment\">// With `inline for` the function gets generated as</span>\n        <span class=\"tok-comment\">// a series of `if` statements relying on the optimizer</span>\n        <span class=\"tok-comment\">// to convert it to a switch.</span>\n        <span class=\"tok-kw\">if</span> (field.value == <span class=\"tok-builtin\">@intFromEnum</span>(any)) {\n            <span class=\"tok-kw\">return</span> <span class=\"tok-builtin\">@field</span>(any, field.name).len;\n        }\n    }\n    <span class=\"tok-comment\">// When using `inline for` the compiler doesn't know that every</span>\n    <span class=\"tok-comment\">// possible case has been handled requiring an explicit `unreachable`.</span>\n    <span class=\"tok-kw\">unreachable</span>;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">withSwitch</span>(any: AnySlice) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (any) {\n        <span class=\"tok-comment\">// With `inline else` the function is explicitly generated</span>\n        <span class=\"tok-comment\">// as the desired switch and the compiler can check that</span>\n        <span class=\"tok-comment\">// every possible case is handled.</span>\n        <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">else</span> => |slice| slice.len,\n    };\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inline for and inline else similarity\"</span> {\n    <span class=\"tok-kw\">const</span> any = AnySlice{ .c = <span class=\"tok-str\">\"hello\"</span> };\n    <span class=\"tok-kw\">try</span> expect(withFor(any) == <span class=\"tok-number\">5</span>);\n    <span class=\"tok-kw\">try</span> expect(withSwitch(any) == <span class=\"tok-number\">5</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> U = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n    a: <span class=\"tok-type\">u32</span>,\n    b: <span class=\"tok-type\">f32</span>,\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">getNum</span>(u: U) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">switch</span> (u) {\n        <span class=\"tok-comment\">// Here `num` is a runtime-known value that is either</span>\n        <span class=\"tok-comment\">// `u.a` or `u.b` and `tag` is `u`'s comptime-known tag value.</span>\n        <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">else</span> => |num, tag| {\n            <span class=\"tok-kw\">if</span> (tag == .b) {\n                <span class=\"tok-kw\">return</span> <span class=\"tok-builtin\">@intFromFloat</span>(num);\n            }\n            <span class=\"tok-kw\">return</span> num;\n        },\n    }\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"test\"</span> {\n    <span class=\"tok-kw\">const</span> u = U{ .b = <span class=\"tok-number\">42</span> };\n    <span class=\"tok-kw\">try</span> expect(getNum(u) == <span class=\"tok-number\">42</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain switch § in Zig 0.15.1",
    "context": "",
    "response": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value.zig Shell Switching with Enum Literals § Enum Literals can be useful to use with switch to avoid repetitively specifying enum or union types: test_exhaustive_switch.zig Shell Labeled switch § When a switch statement is labeled, it can be referenced from a break or continue . break will return a value from the switch . A continue targeting a switch must have an operand. When executed, it will jump to the matching prong, as if the switch were executed again with the continue 's operand replacing ",
    "metadata": {
      "version": "0.15.1",
      "topic": "switch §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while basic\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">10</span>) {\n        i += <span class=\"tok-number\">1</span>;\n    }\n    <span class=\"tok-kw\">try</span> expect(i == <span class=\"tok-number\">10</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while break\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n        <span class=\"tok-kw\">if</span> (i == <span class=\"tok-number\">10</span>)\n            <span class=\"tok-kw\">break</span>;\n        i += <span class=\"tok-number\">1</span>;\n    }\n    <span class=\"tok-kw\">try</span> expect(i == <span class=\"tok-number\">10</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while continue\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n        i += <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">if</span> (i < <span class=\"tok-number\">10</span>)\n            <span class=\"tok-kw\">continue</span>;\n        <span class=\"tok-kw\">break</span>;\n    }\n    <span class=\"tok-kw\">try</span> expect(i == <span class=\"tok-number\">10</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while loop continue expression\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">10</span>) : (i += <span class=\"tok-number\">1</span>) {}\n    <span class=\"tok-kw\">try</span> expect(i == <span class=\"tok-number\">10</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while loop continue expression, more complicated\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">var</span> j: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">while</span> (i * j < <span class=\"tok-number\">2000</span>) : ({\n        i *= <span class=\"tok-number\">2</span>;\n        j *= <span class=\"tok-number\">3</span>;\n    }) {\n        <span class=\"tok-kw\">const</span> my_ij = i * j;\n        <span class=\"tok-kw\">try</span> expect(my_ij < <span class=\"tok-number\">2000</span>);\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while else\"</span> {\n    <span class=\"tok-kw\">try</span> expect(rangeHasNumber(<span class=\"tok-number\">0</span>, <span class=\"tok-number\">10</span>, <span class=\"tok-number\">5</span>));\n    <span class=\"tok-kw\">try</span> expect(!rangeHasNumber(<span class=\"tok-number\">0</span>, <span class=\"tok-number\">10</span>, <span class=\"tok-number\">15</span>));\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">rangeHasNumber</span>(begin: <span class=\"tok-type\">usize</span>, end: <span class=\"tok-type\">usize</span>, number: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">var</span> i = begin;\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">while</span> (i < end) : (i += <span class=\"tok-number\">1</span>) {\n        <span class=\"tok-kw\">if</span> (i == number) {\n            <span class=\"tok-kw\">break</span> <span class=\"tok-null\">true</span>;\n        }\n    } <span class=\"tok-kw\">else</span> <span class=\"tok-null\">false</span>;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"nested break\"</span> {\n    outer: <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n        <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n            <span class=\"tok-kw\">break</span> :outer;\n        }\n    }\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"nested continue\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    outer: <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">10</span>) : (i += <span class=\"tok-number\">1</span>) {\n        <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n            <span class=\"tok-kw\">continue</span> :outer;\n        }\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "while §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while null capture\"</span> {\n    <span class=\"tok-kw\">var</span> sum1: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    numbers_left = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">while</span> (eventuallyNullSequence()) |value| {\n        sum1 += value;\n    }\n    <span class=\"tok-kw\">try</span> expect(sum1 == <span class=\"tok-number\">3</span>);\n\n    <span class=\"tok-comment\">// null capture with an else block</span>\n    <span class=\"tok-kw\">var</span> sum2: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    numbers_left = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">while</span> (eventuallyNullSequence()) |value| {\n        sum2 += value;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">try</span> expect(sum2 == <span class=\"tok-number\">3</span>);\n    }\n\n    <span class=\"tok-comment\">// null capture with a continue expression</span>\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">var</span> sum3: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    numbers_left = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">while</span> (eventuallyNullSequence()) |value| : (i += <span class=\"tok-number\">1</span>) {\n        sum3 += value;\n    }\n    <span class=\"tok-kw\">try</span> expect(i == <span class=\"tok-number\">3</span>);\n}\n\n<span class=\"tok-kw\">var</span> numbers_left: <span class=\"tok-type\">u32</span> = <span class=\"tok-null\">undefined</span>;\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">eventuallyNullSequence</span>() ?<span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (numbers_left == <span class=\"tok-number\">0</span>) <span class=\"tok-null\">null</span> <span class=\"tok-kw\">else</span> blk: {\n        numbers_left -= <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">break</span> :blk numbers_left;\n    };\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while error union capture\"</span> {\n    <span class=\"tok-kw\">var</span> sum1: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    numbers_left = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">while</span> (eventuallyErrorSequence()) |value| {\n        sum1 += value;\n    } <span class=\"tok-kw\">else</span> |err| {\n        <span class=\"tok-kw\">try</span> expect(err == <span class=\"tok-kw\">error</span>.ReachedZero);\n    }\n}\n\n<span class=\"tok-kw\">var</span> numbers_left: <span class=\"tok-type\">u32</span> = <span class=\"tok-null\">undefined</span>;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">eventuallyErrorSequence</span>() <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (numbers_left == <span class=\"tok-number\">0</span>) <span class=\"tok-kw\">error</span>.ReachedZero <span class=\"tok-kw\">else</span> blk: {\n        numbers_left -= <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">break</span> :blk numbers_left;\n    };\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inline while loop\"</span> {\n    <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> i = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">3</span>) : (i += <span class=\"tok-number\">1</span>) {\n        <span class=\"tok-kw\">const</span> T = <span class=\"tok-kw\">switch</span> (i) {\n            <span class=\"tok-number\">0</span> => <span class=\"tok-type\">f32</span>,\n            <span class=\"tok-number\">1</span> => <span class=\"tok-type\">i8</span>,\n            <span class=\"tok-number\">2</span> => <span class=\"tok-type\">bool</span>,\n            <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">unreachable</span>,\n        };\n        sum += typeNameLength(T);\n    }\n    <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-number\">9</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">typeNameLength</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-builtin\">@typeName</span>(T).len;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain while § in Zig 0.15.1",
    "context": "",
    "response": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expression is the result of the else clause of a while loop, which is executed when the condition of the while loop is tested as false. break , like return , accepts a value parameter. This is the result of the while expression. When you break from a while loop, the else branch is not evaluated. test_while_else.zig Shell Labeled while § When a while loop is labeled, it can be referenced from a break or continue from within a nested loop: test_while_nested_break.zig Shell while with Optionals § Just like",
    "metadata": {
      "version": "0.15.1",
      "topic": "while §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: for §",
    "context": "test_for.zig Shell Labeled for § When a for loop is labeled, it can be referenced from a break or continue from within a nested loop: test_for_nested_break.zig Shell inline for § For loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known. test_inline_for.zig Shell It is recommended to use inline loop",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"for basics\"</span> {\n    <span class=\"tok-kw\">const</span> items = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">0</span> };\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n\n    <span class=\"tok-comment\">// For loops iterate over slices and arrays.</span>\n    <span class=\"tok-kw\">for</span> (items) |value| {\n        <span class=\"tok-comment\">// Break and continue are supported.</span>\n        <span class=\"tok-kw\">if</span> (value == <span class=\"tok-number\">0</span>) {\n            <span class=\"tok-kw\">continue</span>;\n        }\n        sum += value;\n    }\n    <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-number\">16</span>);\n\n    <span class=\"tok-comment\">// To iterate over a portion of a slice, reslice.</span>\n    <span class=\"tok-kw\">for</span> (items[<span class=\"tok-number\">0</span>..<span class=\"tok-number\">1</span>]) |value| {\n        sum += value;\n    }\n    <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-number\">20</span>);\n\n    <span class=\"tok-comment\">// To access the index of iteration, specify a second condition as well</span>\n    <span class=\"tok-comment\">// as a second capture value.</span>\n    <span class=\"tok-kw\">var</span> sum2: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">for</span> (items, <span class=\"tok-number\">0</span>..) |_, i| {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(i) == <span class=\"tok-type\">usize</span>);\n        sum2 += <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">i32</span>, <span class=\"tok-builtin\">@intCast</span>(i));\n    }\n    <span class=\"tok-kw\">try</span> expect(sum2 == <span class=\"tok-number\">10</span>);\n\n    <span class=\"tok-comment\">// To iterate over consecutive integers, use the range syntax.</span>\n    <span class=\"tok-comment\">// Unbounded range is always a compile error.</span>\n    <span class=\"tok-kw\">var</span> sum3: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">for</span> (<span class=\"tok-number\">0</span>..<span class=\"tok-number\">5</span>) |i| {\n        sum3 += i;\n    }\n    <span class=\"tok-kw\">try</span> expect(sum3 == <span class=\"tok-number\">10</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"multi object for\"</span> {\n    <span class=\"tok-kw\">const</span> items = [_]<span class=\"tok-type\">usize</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span> };\n    <span class=\"tok-kw\">const</span> items2 = [_]<span class=\"tok-type\">usize</span>{ <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span> };\n    <span class=\"tok-kw\">var</span> count: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n\n    <span class=\"tok-comment\">// Iterate over multiple objects.</span>\n    <span class=\"tok-comment\">// All lengths must be equal at the start of the loop, otherwise detectable</span>\n    <span class=\"tok-comment\">// illegal behavior occurs.</span>\n    <span class=\"tok-kw\">for</span> (items, items2) |i, j| {\n        count += i + j;\n    }\n\n    <span class=\"tok-kw\">try</span> expect(count == <span class=\"tok-number\">21</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"for reference\"</span> {\n    <span class=\"tok-kw\">var</span> items = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">2</span> };\n\n    <span class=\"tok-comment\">// Iterate over the slice by reference by</span>\n    <span class=\"tok-comment\">// specifying that the capture value is a pointer.</span>\n    <span class=\"tok-kw\">for</span> (&items) |*value| {\n        value.* += <span class=\"tok-number\">1</span>;\n    }\n\n    <span class=\"tok-kw\">try</span> expect(items[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(items[<span class=\"tok-number\">1</span>] == <span class=\"tok-number\">5</span>);\n    <span class=\"tok-kw\">try</span> expect(items[<span class=\"tok-number\">2</span>] == <span class=\"tok-number\">3</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"for else\"</span> {\n    <span class=\"tok-comment\">// For allows an else attached to it, the same as a while loop.</span>\n    <span class=\"tok-kw\">const</span> items = [_]?<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-null\">null</span>, <span class=\"tok-number\">5</span> };\n\n    <span class=\"tok-comment\">// For loops can also be used as expressions.</span>\n    <span class=\"tok-comment\">// Similar to while loops, when you break from a for loop, the else branch is not evaluated.</span>\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">for</span> (items) |value| {\n        <span class=\"tok-kw\">if</span> (value != <span class=\"tok-null\">null</span>) {\n            sum += value.?;\n        }\n    } <span class=\"tok-kw\">else</span> blk: {\n        <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-number\">12</span>);\n        <span class=\"tok-kw\">break</span> :blk sum;\n    };\n    <span class=\"tok-kw\">try</span> expect(result == <span class=\"tok-number\">12</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "for §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: for §",
    "context": "test_for.zig Shell Labeled for § When a for loop is labeled, it can be referenced from a break or continue from within a nested loop: test_for_nested_break.zig Shell inline for § For loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known. test_inline_for.zig Shell It is recommended to use inline loop",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"nested break\"</span> {\n    <span class=\"tok-kw\">var</span> count: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    outer: <span class=\"tok-kw\">for</span> (<span class=\"tok-number\">1</span>..<span class=\"tok-number\">6</span>) |_| {\n        <span class=\"tok-kw\">for</span> (<span class=\"tok-number\">1</span>..<span class=\"tok-number\">6</span>) |_| {\n            count += <span class=\"tok-number\">1</span>;\n            <span class=\"tok-kw\">break</span> :outer;\n        }\n    }\n    <span class=\"tok-kw\">try</span> expect(count == <span class=\"tok-number\">1</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"nested continue\"</span> {\n    <span class=\"tok-kw\">var</span> count: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    outer: <span class=\"tok-kw\">for</span> (<span class=\"tok-number\">1</span>..<span class=\"tok-number\">9</span>) |_| {\n        <span class=\"tok-kw\">for</span> (<span class=\"tok-number\">1</span>..<span class=\"tok-number\">6</span>) |_| {\n            count += <span class=\"tok-number\">1</span>;\n            <span class=\"tok-kw\">continue</span> :outer;\n        }\n    }\n\n    <span class=\"tok-kw\">try</span> expect(count == <span class=\"tok-number\">8</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "for §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: for §",
    "context": "test_for.zig Shell Labeled for § When a for loop is labeled, it can be referenced from a break or continue from within a nested loop: test_for_nested_break.zig Shell inline for § For loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known. test_inline_for.zig Shell It is recommended to use inline loop",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inline for loop\"</span> {\n    <span class=\"tok-kw\">const</span> nums = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">2</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">6</span> };\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">for</span> (nums) |i| {\n        <span class=\"tok-kw\">const</span> T = <span class=\"tok-kw\">switch</span> (i) {\n            <span class=\"tok-number\">2</span> => <span class=\"tok-type\">f32</span>,\n            <span class=\"tok-number\">4</span> => <span class=\"tok-type\">i8</span>,\n            <span class=\"tok-number\">6</span> => <span class=\"tok-type\">bool</span>,\n            <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">unreachable</span>,\n        };\n        sum += typeNameLength(T);\n    }\n    <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-number\">9</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">typeNameLength</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-builtin\">@typeName</span>(T).len;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "for §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain for § in Zig 0.15.1",
    "context": "",
    "response": "test_for.zig Shell Labeled for § When a for loop is labeled, it can be referenced from a break or continue from within a nested loop: test_for_nested_break.zig Shell inline for § For loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known. test_inline_for.zig Shell It is recommended to use inline loops only for one of these reasons: You need the loop to execute at comptime for the semantics to work. You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster. See also: while comptime Arrays Slices",
    "metadata": {
      "version": "0.15.1",
      "topic": "for §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: if §",
    "context": "test_if.zig Shell if with Optionals § test_if_optionals.zig Shell See also: Optionals Errors",
    "response": "<span class=\"tok-comment\">// If expressions have three uses, corresponding to the three types:</span>\n<span class=\"tok-comment\">// * bool</span>\n<span class=\"tok-comment\">// * ?T</span>\n<span class=\"tok-comment\">// * anyerror!T</span>\n\n<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"if expression\"</span> {\n    <span class=\"tok-comment\">// If expressions are used instead of a ternary expression.</span>\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">5</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">4</span>;\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">if</span> (a != b) <span class=\"tok-number\">47</span> <span class=\"tok-kw\">else</span> <span class=\"tok-number\">3089</span>;\n    <span class=\"tok-kw\">try</span> expect(result == <span class=\"tok-number\">47</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"if boolean\"</span> {\n    <span class=\"tok-comment\">// If expressions test boolean conditions.</span>\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">5</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">4</span>;\n    <span class=\"tok-kw\">if</span> (a != b) {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-null\">true</span>);\n    } <span class=\"tok-kw\">else</span> <span class=\"tok-kw\">if</span> (a == <span class=\"tok-number\">9</span>) {\n        <span class=\"tok-kw\">unreachable</span>;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"if error union\"</span> {\n    <span class=\"tok-comment\">// If expressions test for errors.</span>\n    <span class=\"tok-comment\">// Note the |err| capture on the else.</span>\n\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">if</span> (a) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">0</span>);\n    } <span class=\"tok-kw\">else</span> |err| {\n        _ = err;\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> = <span class=\"tok-kw\">error</span>.BadValue;\n    <span class=\"tok-kw\">if</span> (b) |value| {\n        _ = value;\n        <span class=\"tok-kw\">unreachable</span>;\n    } <span class=\"tok-kw\">else</span> |err| {\n        <span class=\"tok-kw\">try</span> expect(err == <span class=\"tok-kw\">error</span>.BadValue);\n    }\n\n    <span class=\"tok-comment\">// The else and |err| capture is strictly required.</span>\n    <span class=\"tok-kw\">if</span> (a) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">0</span>);\n    } <span class=\"tok-kw\">else</span> |_| {}\n\n    <span class=\"tok-comment\">// To check only the error value, use an empty block expression.</span>\n    <span class=\"tok-kw\">if</span> (b) |_| {} <span class=\"tok-kw\">else</span> |err| {\n        <span class=\"tok-kw\">try</span> expect(err == <span class=\"tok-kw\">error</span>.BadValue);\n    }\n\n    <span class=\"tok-comment\">// Access the value by reference using a pointer capture.</span>\n    <span class=\"tok-kw\">var</span> c: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">if</span> (c) |*value| {\n        value.* = <span class=\"tok-number\">9</span>;\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">if</span> (c) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">9</span>);\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "if §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: if §",
    "context": "test_if.zig Shell if with Optionals § test_if_optionals.zig Shell See also: Optionals Errors",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"if optional\"</span> {\n    <span class=\"tok-comment\">// If expressions test for null.</span>\n\n    <span class=\"tok-kw\">const</span> a: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">if</span> (a) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">0</span>);\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">const</span> b: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-null\">null</span>;\n    <span class=\"tok-kw\">if</span> (b) |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-null\">true</span>);\n    }\n\n    <span class=\"tok-comment\">// The else is not required.</span>\n    <span class=\"tok-kw\">if</span> (a) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">0</span>);\n    }\n\n    <span class=\"tok-comment\">// To test against null only, use the binary equality operator.</span>\n    <span class=\"tok-kw\">if</span> (b == <span class=\"tok-null\">null</span>) {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-null\">true</span>);\n    }\n\n    <span class=\"tok-comment\">// Access the value by reference using a pointer capture.</span>\n    <span class=\"tok-kw\">var</span> c: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">if</span> (c) |*value| {\n        value.* = <span class=\"tok-number\">2</span>;\n    }\n\n    <span class=\"tok-kw\">if</span> (c) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">2</span>);\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"if error union with optional\"</span> {\n    <span class=\"tok-comment\">// If expressions test for errors before unwrapping optionals.</span>\n    <span class=\"tok-comment\">// The |optional_value| capture's type is ?u32.</span>\n\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">if</span> (a) |optional_value| {\n        <span class=\"tok-kw\">try</span> expect(optional_value.? == <span class=\"tok-number\">0</span>);\n    } <span class=\"tok-kw\">else</span> |err| {\n        _ = err;\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">u32</span> = <span class=\"tok-null\">null</span>;\n    <span class=\"tok-kw\">if</span> (b) |optional_value| {\n        <span class=\"tok-kw\">try</span> expect(optional_value == <span class=\"tok-null\">null</span>);\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">const</span> c: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">u32</span> = <span class=\"tok-kw\">error</span>.BadValue;\n    <span class=\"tok-kw\">if</span> (c) |optional_value| {\n        _ = optional_value;\n        <span class=\"tok-kw\">unreachable</span>;\n    } <span class=\"tok-kw\">else</span> |err| {\n        <span class=\"tok-kw\">try</span> expect(err == <span class=\"tok-kw\">error</span>.BadValue);\n    }\n\n    <span class=\"tok-comment\">// Access the value by reference by using a pointer capture each time.</span>\n    <span class=\"tok-kw\">var</span> d: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">if</span> (d) |*optional_value| {\n        <span class=\"tok-kw\">if</span> (optional_value.*) |*value| {\n            value.* = <span class=\"tok-number\">9</span>;\n        }\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">if</span> (d) |optional_value| {\n        <span class=\"tok-kw\">try</span> expect(optional_value.? == <span class=\"tok-number\">9</span>);\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "if §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: defer §",
    "context": "Executes an expression unconditionally at scope exit. test_defer.zig Shell Defer expressions are evaluated in reverse order. defer_unwind.zig Shell Inside a defer expression the return statement is not allowed. test_invalid_defer.zig Shell See also: Errors",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> print = std.debug.print;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">deferExample</span>() !<span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">1</span>;\n\n    {\n        <span class=\"tok-kw\">defer</span> a = <span class=\"tok-number\">2</span>;\n        a = <span class=\"tok-number\">1</span>;\n    }\n    <span class=\"tok-kw\">try</span> expect(a == <span class=\"tok-number\">2</span>);\n\n    a = <span class=\"tok-number\">5</span>;\n    <span class=\"tok-kw\">return</span> a;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"defer basics\"</span> {\n    <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> deferExample()) == <span class=\"tok-number\">5</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "defer §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: defer §",
    "context": "Executes an expression unconditionally at scope exit. test_defer.zig Shell Defer expressions are evaluated in reverse order. defer_unwind.zig Shell Inside a defer expression the return statement is not allowed. test_invalid_defer.zig Shell See also: Errors",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> print = std.debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    print(<span class=\"tok-str\">\"\\n\"</span>, .{});\n\n    <span class=\"tok-kw\">defer</span> {\n        print(<span class=\"tok-str\">\"1 \"</span>, .{});\n    }\n    <span class=\"tok-kw\">defer</span> {\n        print(<span class=\"tok-str\">\"2 \"</span>, .{});\n    }\n    <span class=\"tok-kw\">if</span> (<span class=\"tok-null\">false</span>) {\n        <span class=\"tok-comment\">// defers are not run if they are never executed.</span>\n        <span class=\"tok-kw\">defer</span> {\n            print(<span class=\"tok-str\">\"3 \"</span>, .{});\n        }\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "defer §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: defer §",
    "context": "Executes an expression unconditionally at scope exit. test_defer.zig Shell Defer expressions are evaluated in reverse order. defer_unwind.zig Shell Inside a defer expression the return statement is not allowed. test_invalid_defer.zig Shell See also: Errors",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">deferInvalidExample</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">defer</span> {\n        <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.DeferError;\n    }\n\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.DeferError;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "defer §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain defer § in Zig 0.15.1",
    "context": "",
    "response": "Executes an expression unconditionally at scope exit. test_defer.zig Shell Defer expressions are evaluated in reverse order. defer_unwind.zig Shell Inside a defer expression the return statement is not allowed. test_invalid_defer.zig Shell See also: Errors",
    "metadata": {
      "version": "0.15.1",
      "topic": "defer §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: unreachable §",
    "context": "In Debug and ReleaseSafe mode unreachable emits a call to panic with the message reached unreachable code . In ReleaseFast and ReleaseSmall mode, the optimizer uses the assumption that unreachable code will never be hit to perform optimizations. Basics § test_unreachable.zig Shell In fact, this is how std.debug.assert is implemented: test_assertion_failure.zig Shell At Compile-Time § test_comptime_unreachable.zig Shell See also: Zig Test Build Mode comptime",
    "response": "<span class=\"tok-comment\">// unreachable is used to assert that control flow will never reach a</span>\n<span class=\"tok-comment\">// particular location:</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"basic math\"</span> {\n    <span class=\"tok-kw\">const</span> x = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> y = <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">if</span> (x + y != <span class=\"tok-number\">3</span>) {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "unreachable §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: unreachable §",
    "context": "In Debug and ReleaseSafe mode unreachable emits a call to panic with the message reached unreachable code . In ReleaseFast and ReleaseSmall mode, the optimizer uses the assumption that unreachable code will never be hit to perform optimizations. Basics § test_unreachable.zig Shell In fact, this is how std.debug.assert is implemented: test_assertion_failure.zig Shell At Compile-Time § test_comptime_unreachable.zig Shell See also: Zig Test Build Mode comptime",
    "response": "<span class=\"tok-comment\">// This is how std.debug.assert is implemented</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">assert</span>(ok: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (!ok) <span class=\"tok-kw\">unreachable</span>; <span class=\"tok-comment\">// assertion failure</span>\n}\n\n<span class=\"tok-comment\">// This test will fail because we hit unreachable.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"this will fail\"</span> {\n    assert(<span class=\"tok-null\">false</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "unreachable §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: unreachable §",
    "context": "In Debug and ReleaseSafe mode unreachable emits a call to panic with the message reached unreachable code . In ReleaseFast and ReleaseSmall mode, the optimizer uses the assumption that unreachable code will never be hit to perform optimizations. Basics § test_unreachable.zig Shell In fact, this is how std.debug.assert is implemented: test_assertion_failure.zig Shell At Compile-Time § test_comptime_unreachable.zig Shell See also: Zig Test Build Mode comptime",
    "response": "<span class=\"tok-kw\">const</span> assert = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.assert;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"type of unreachable\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-comment\">// The type of unreachable is noreturn.</span>\n\n        <span class=\"tok-comment\">// However this assertion will still fail to compile because</span>\n        <span class=\"tok-comment\">// unreachable expressions are compile errors.</span>\n\n        assert(<span class=\"tok-builtin\">@TypeOf</span>(<span class=\"tok-kw\">unreachable</span>) == <span class=\"tok-type\">noreturn</span>);\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "unreachable §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain unreachable § in Zig 0.15.1",
    "context": "",
    "response": "In Debug and ReleaseSafe mode unreachable emits a call to panic with the message reached unreachable code . In ReleaseFast and ReleaseSmall mode, the optimizer uses the assumption that unreachable code will never be hit to perform optimizations. Basics § test_unreachable.zig Shell In fact, this is how std.debug.assert is implemented: test_assertion_failure.zig Shell At Compile-Time § test_comptime_unreachable.zig Shell See also: Zig Test Build Mode comptime",
    "metadata": {
      "version": "0.15.1",
      "topic": "unreachable §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: noreturn §",
    "context": "noreturn is the type of: break continue return unreachable while ( true ) {} When resolving types together, such as if clauses or switch prongs, the noreturn type is compatible with every other type. Consider: test_noreturn.zig Shell Another use case for noreturn is the exit function: test_noreturn_from_exit.zig Shell",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(condition: <span class=\"tok-type\">bool</span>, b: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> a = <span class=\"tok-kw\">if</span> (condition) b <span class=\"tok-kw\">else</span> <span class=\"tok-kw\">return</span>;\n    _ = a;\n    <span class=\"tok-builtin\">@panic</span>(<span class=\"tok-str\">\"do something with a\"</span>);\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"noreturn\"</span> {\n    foo(<span class=\"tok-null\">false</span>, <span class=\"tok-number\">1</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "noreturn §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: noreturn §",
    "context": "noreturn is the type of: break continue return unreachable while ( true ) {} When resolving types together, such as if clauses or switch prongs, the noreturn type is compatible with every other type. Consider: test_noreturn.zig Shell Another use case for noreturn is the exit function: test_noreturn_from_exit.zig Shell",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> native_arch = builtin.cpu.arch;\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> WINAPI: std.builtin.CallingConvention = <span class=\"tok-kw\">if</span> (native_arch == .x86) .{ .x86_stdcall = .{} } <span class=\"tok-kw\">else</span> .c;\n<span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"kernel32\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">ExitProcess</span>(exit_code: <span class=\"tok-type\">c_uint</span>) <span class=\"tok-kw\">callconv</span>(WINAPI) <span class=\"tok-type\">noreturn</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"foo\"</span> {\n    <span class=\"tok-kw\">const</span> value = bar() <span class=\"tok-kw\">catch</span> ExitProcess(<span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">1234</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>() <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">1234</span>;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "noreturn §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain noreturn § in Zig 0.15.1",
    "context": "",
    "response": "noreturn is the type of: break continue return unreachable while ( true ) {} When resolving types together, such as if clauses or switch prongs, the noreturn type is compatible with every other type. Consider: test_noreturn.zig Shell Another use case for noreturn is the exit function: test_noreturn_from_exit.zig Shell",
    "metadata": {
      "version": "0.15.1",
      "topic": "noreturn §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Functions §",
    "context": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, an",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> native_arch = builtin.cpu.arch;\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-comment\">// Functions are declared like this</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(a: <span class=\"tok-type\">i8</span>, b: <span class=\"tok-type\">i8</span>) <span class=\"tok-type\">i8</span> {\n    <span class=\"tok-kw\">if</span> (a == <span class=\"tok-number\">0</span>) {\n        <span class=\"tok-kw\">return</span> b;\n    }\n\n    <span class=\"tok-kw\">return</span> a + b;\n}\n\n<span class=\"tok-comment\">// The export specifier makes a function externally visible in the generated</span>\n<span class=\"tok-comment\">// object file, and makes it use the C ABI.</span>\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">sub</span>(a: <span class=\"tok-type\">i8</span>, b: <span class=\"tok-type\">i8</span>) <span class=\"tok-type\">i8</span> {\n    <span class=\"tok-kw\">return</span> a - b;\n}\n\n<span class=\"tok-comment\">// The extern specifier is used to declare a function that will be resolved</span>\n<span class=\"tok-comment\">// at link time, when linking statically, or at runtime, when linking</span>\n<span class=\"tok-comment\">// dynamically. The quoted identifier after the extern keyword specifies</span>\n<span class=\"tok-comment\">// the library that has the function. (e.g. \"c\" -> libc.so)</span>\n<span class=\"tok-comment\">// The callconv specifier changes the calling convention of the function.</span>\n<span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"kernel32\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">ExitProcess</span>(exit_code: <span class=\"tok-type\">u32</span>) <span class=\"tok-kw\">callconv</span>(.winapi) <span class=\"tok-type\">noreturn</span>;\n<span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"c\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">atan2</span>(a: <span class=\"tok-type\">f64</span>, b: <span class=\"tok-type\">f64</span>) <span class=\"tok-type\">f64</span>;\n\n<span class=\"tok-comment\">// The @branchHint builtin can be used to tell the optimizer that a function is rarely called (\"cold\").</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">abort</span>() <span class=\"tok-type\">noreturn</span> {\n    <span class=\"tok-builtin\">@branchHint</span>(.cold);\n    <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {}\n}\n\n<span class=\"tok-comment\">// The naked calling convention makes a function not have any function prologue or epilogue.</span>\n<span class=\"tok-comment\">// This can be useful when integrating with assembly.</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">_start</span>() <span class=\"tok-kw\">callconv</span>(.naked) <span class=\"tok-type\">noreturn</span> {\n    abort();\n}\n\n<span class=\"tok-comment\">// The inline calling convention forces a function to be inlined at all call sites.</span>\n<span class=\"tok-comment\">// If the function cannot be inlined, it is a compile-time error.</span>\n<span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">shiftLeftOne</span>(a: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">return</span> a << <span class=\"tok-number\">1</span>;\n}\n\n<span class=\"tok-comment\">// The pub specifier allows the function to be visible when importing.</span>\n<span class=\"tok-comment\">// Another file can use @import and call sub2</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">sub2</span>(a: <span class=\"tok-type\">i8</span>, b: <span class=\"tok-type\">i8</span>) <span class=\"tok-type\">i8</span> {\n    <span class=\"tok-kw\">return</span> a - b;\n}\n\n<span class=\"tok-comment\">// Function pointers are prefixed with `*const `.</span>\n<span class=\"tok-kw\">const</span> Call2Op = *<span class=\"tok-kw\">const</span> <span class=\"tok-kw\">fn</span> (a: <span class=\"tok-type\">i8</span>, b: <span class=\"tok-type\">i8</span>) <span class=\"tok-type\">i8</span>;\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doOp</span>(fnCall: Call2Op, op1: <span class=\"tok-type\">i8</span>, op2: <span class=\"tok-type\">i8</span>) <span class=\"tok-type\">i8</span> {\n    <span class=\"tok-kw\">return</span> fnCall(op1, op2);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"function\"</span> {\n    <span class=\"tok-kw\">try</span> expect(doOp(add, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>) == <span class=\"tok-number\">11</span>);\n    <span class=\"tok-kw\">try</span> expect(doOp(sub2, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>) == -<span class=\"tok-number\">1</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Functions §",
    "context": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, an",
    "response": "<span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> {\n    x: <span class=\"tok-type\">i32</span>,\n    y: <span class=\"tok-type\">i32</span>,\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(point: Point) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-comment\">// Here, `point` could be a reference, or a copy. The function body</span>\n    <span class=\"tok-comment\">// can ignore the difference and treat it as a value. Be very careful</span>\n    <span class=\"tok-comment\">// taking the address of the parameter - it should be treated as if</span>\n    <span class=\"tok-comment\">// the address will become invalid when the function returns.</span>\n    <span class=\"tok-kw\">return</span> point.x + point.y;\n}\n\n<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pass struct to function\"</span> {\n    <span class=\"tok-kw\">try</span> expect(foo(Point{ .x = <span class=\"tok-number\">1</span>, .y = <span class=\"tok-number\">2</span> }) == <span class=\"tok-number\">3</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Functions §",
    "context": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, an",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">addFortyTwo</span>(x: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(x) {\n    <span class=\"tok-kw\">return</span> x + <span class=\"tok-number\">42</span>;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fn type inference\"</span> {\n    <span class=\"tok-kw\">try</span> expect(addFortyTwo(<span class=\"tok-number\">1</span>) == <span class=\"tok-number\">43</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(addFortyTwo(<span class=\"tok-number\">1</span>)) == <span class=\"tok-type\">comptime_int</span>);\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-type\">i64</span> = <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">try</span> expect(addFortyTwo(y) == <span class=\"tok-number\">44</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(addFortyTwo(y)) == <span class=\"tok-type\">i64</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Functions §",
    "context": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, an",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (foo(<span class=\"tok-number\">1200</span>, <span class=\"tok-number\">34</span>) != <span class=\"tok-number\">1234</span>) {\n        <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"bad\"</span>);\n    }\n}\n\n<span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    std.debug.print(<span class=\"tok-str\">\"runtime a = {} b = {}\"</span>, .{ a, b });\n    <span class=\"tok-kw\">return</span> a + b;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Functions §",
    "context": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, an",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> math = std.math;\n<span class=\"tok-kw\">const</span> testing = std.testing;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fn reflection\"</span> {\n    <span class=\"tok-kw\">try</span> testing.expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(testing.expect)).@\"fn\".params[<span class=\"tok-number\">0</span>].<span class=\"tok-type\">type</span>.? == <span class=\"tok-type\">bool</span>);\n    <span class=\"tok-kw\">try</span> testing.expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(testing.tmpDir)).@\"fn\".return_type.? == testing.TmpDir);\n\n    <span class=\"tok-kw\">try</span> testing.expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(math.Log2Int)).@\"fn\".is_generic);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Functions § in Zig 0.15.1",
    "context": "",
    "response": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, and arrays can sometimes be more efficiently passed as a reference, since a copy could be arbitrarily expensive depending on the size. When these types are passed as parameters, Zig may choose to copy and pass by value, or pass by reference, whichever way Zig decides will be faster. This is made possible, in part, by the fact that parameters are immutable. test_pass_by_reference_or_value.zig Shell For extern functions, Zig follows the C ABI for passing structs and unions by value. Function Paramet",
    "metadata": {
      "version": "0.15.1",
      "topic": "Functions §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> FileOpenError = <span class=\"tok-kw\">error</span>{\n    AccessDenied,\n    OutOfMemory,\n    FileNotFound,\n};\n\n<span class=\"tok-kw\">const</span> AllocationError = <span class=\"tok-kw\">error</span>{\n    OutOfMemory,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coerce subset to superset\"</span> {\n    <span class=\"tok-kw\">const</span> err = foo(AllocationError.OutOfMemory);\n    <span class=\"tok-kw\">try</span> std.testing.expect(err == FileOpenError.OutOfMemory);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(err: AllocationError) FileOpenError {\n    <span class=\"tok-kw\">return</span> err;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> FileOpenError = <span class=\"tok-kw\">error</span>{\n    AccessDenied,\n    OutOfMemory,\n    FileNotFound,\n};\n\n<span class=\"tok-kw\">const</span> AllocationError = <span class=\"tok-kw\">error</span>{\n    OutOfMemory,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coerce superset to subset\"</span> {\n    foo(FileOpenError.OutOfMemory) <span class=\"tok-kw\">catch</span> {};\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(err: FileOpenError) AllocationError {\n    <span class=\"tok-kw\">return</span> err;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> err = <span class=\"tok-kw\">error</span>.FileNotFound;",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> err = (<span class=\"tok-kw\">error</span>{FileNotFound}).FileNotFound;",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> maxInt = std.math.maxInt;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">parseU64</span>(buf: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, radix: <span class=\"tok-type\">u8</span>) !<span class=\"tok-type\">u64</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">0</span>;\n\n    <span class=\"tok-kw\">for</span> (buf) |c| {\n        <span class=\"tok-kw\">const</span> digit = charToDigit(c);\n\n        <span class=\"tok-kw\">if</span> (digit >= radix) {\n            <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.InvalidChar;\n        }\n\n        <span class=\"tok-comment\">// x *= radix</span>\n        <span class=\"tok-kw\">var</span> ov = <span class=\"tok-builtin\">@mulWithOverflow</span>(x, radix);\n        <span class=\"tok-kw\">if</span> (ov[<span class=\"tok-number\">1</span>] != <span class=\"tok-number\">0</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.OverFlow;\n\n        <span class=\"tok-comment\">// x += digit</span>\n        ov = <span class=\"tok-builtin\">@addWithOverflow</span>(ov[<span class=\"tok-number\">0</span>], digit);\n        <span class=\"tok-kw\">if</span> (ov[<span class=\"tok-number\">1</span>] != <span class=\"tok-number\">0</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.OverFlow;\n        x = ov[<span class=\"tok-number\">0</span>];\n    }\n\n    <span class=\"tok-kw\">return</span> x;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">charToDigit</span>(c: <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (c) {\n        <span class=\"tok-str\">'0'</span>...<span class=\"tok-str\">'9'</span> => c - <span class=\"tok-str\">'0'</span>,\n        <span class=\"tok-str\">'A'</span>...<span class=\"tok-str\">'Z'</span> => c - <span class=\"tok-str\">'A'</span> + <span class=\"tok-number\">10</span>,\n        <span class=\"tok-str\">'a'</span>...<span class=\"tok-str\">'z'</span> => c - <span class=\"tok-str\">'a'</span> + <span class=\"tok-number\">10</span>,\n        <span class=\"tok-kw\">else</span> => maxInt(<span class=\"tok-type\">u8</span>),\n    };\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"parse u64\"</span> {\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">try</span> parseU64(<span class=\"tok-str\">\"1234\"</span>, <span class=\"tok-number\">10</span>);\n    <span class=\"tok-kw\">try</span> std.testing.expect(result == <span class=\"tok-number\">1234</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> parseU64 = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"error_union_parsing_u64.zig\"</span>).parseU64;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(str: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> number = parseU64(str, <span class=\"tok-number\">10</span>) <span class=\"tok-kw\">catch</span> <span class=\"tok-number\">13</span>;\n    _ = number; <span class=\"tok-comment\">// ...</span>\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> parseU64 = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"error_union_parsing_u64.zig\"</span>).parseU64;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(str: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> number = parseU64(str, <span class=\"tok-number\">10</span>) <span class=\"tok-kw\">catch</span> blk: {\n        <span class=\"tok-comment\">// do things</span>\n        <span class=\"tok-kw\">break</span> :blk <span class=\"tok-number\">13</span>;\n    };\n    _ = number; <span class=\"tok-comment\">// number is now initialized</span>\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> parseU64 = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"error_union_parsing_u64.zig\"</span>).parseU64;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(str: []<span class=\"tok-type\">u8</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> number = parseU64(str, <span class=\"tok-number\">10</span>) <span class=\"tok-kw\">catch</span> |err| <span class=\"tok-kw\">return</span> err;\n    _ = number; <span class=\"tok-comment\">// ...</span>\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> parseU64 = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"error_union_parsing_u64.zig\"</span>).parseU64;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(str: []<span class=\"tok-type\">u8</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> number = <span class=\"tok-kw\">try</span> parseU64(str, <span class=\"tok-number\">10</span>);\n    _ = number; <span class=\"tok-comment\">// ...</span>\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(str: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (parseU64(str, <span class=\"tok-number\">10</span>)) |number| {\n        doSomethingWithNumber(number);\n    } <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.Overflow => {\n            <span class=\"tok-comment\">// handle overflow...</span>\n        },\n        <span class=\"tok-comment\">// we promise that InvalidChar won't happen (or crash in debug mode if it does)</span>\n        <span class=\"tok-kw\">error</span>.InvalidChar => <span class=\"tok-kw\">unreachable</span>,\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAnotherThing</span>(str: []<span class=\"tok-type\">u8</span>) <span class=\"tok-kw\">error</span>{InvalidChar}!<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (parseU64(str, <span class=\"tok-number\">10</span>)) |number| {\n        doSomethingWithNumber(number);\n    } <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.Overflow => {\n            <span class=\"tok-comment\">// handle overflow...</span>\n        },\n        <span class=\"tok-kw\">else</span> => |leftover_err| <span class=\"tok-kw\">return</span> leftover_err,\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doADifferentThing</span>(str: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (parseU64(str, <span class=\"tok-number\">10</span>)) |number| {\n        doSomethingWithNumber(number);\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-comment\">// do as you'd like</span>\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">createFoo</span>(param: <span class=\"tok-type\">i32</span>) !Foo {\n    <span class=\"tok-kw\">const</span> foo = <span class=\"tok-kw\">try</span> tryToAllocateFoo();\n    <span class=\"tok-comment\">// now we have allocated foo. we need to free it if the function fails.</span>\n    <span class=\"tok-comment\">// but we want to return it if the function succeeds.</span>\n    <span class=\"tok-kw\">errdefer</span> deallocateFoo(foo);\n\n    <span class=\"tok-kw\">const</span> tmp_buf = allocateTmpBuffer() <span class=\"tok-kw\">orelse</span> <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.OutOfMemory;\n    <span class=\"tok-comment\">// tmp_buf is truly a temporary resource, and we for sure want to clean it up</span>\n    <span class=\"tok-comment\">// before this block leaves scope</span>\n    <span class=\"tok-kw\">defer</span> deallocateTmpBuffer(tmp_buf);\n\n    <span class=\"tok-kw\">if</span> (param > <span class=\"tok-number\">1337</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.InvalidParam;\n\n    <span class=\"tok-comment\">// here the errdefer will not run since we're returning success from the function.</span>\n    <span class=\"tok-comment\">// but the defer will run!</span>\n    <span class=\"tok-kw\">return</span> foo;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">captureError</span>(captured: *?<span class=\"tok-type\">anyerror</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">errdefer</span> |err| {\n        captured.* = err;\n    }\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.GeneralFailure;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"errdefer capture\"</span> {\n    <span class=\"tok-kw\">var</span> captured: ?<span class=\"tok-type\">anyerror</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-kw\">if</span> (captureError(&captured)) <span class=\"tok-kw\">unreachable</span> <span class=\"tok-kw\">else</span> |err| {\n        <span class=\"tok-kw\">try</span> std.testing.expectEqual(<span class=\"tok-kw\">error</span>.GeneralFailure, captured.?);\n        <span class=\"tok-kw\">try</span> std.testing.expectEqual(<span class=\"tok-kw\">error</span>.GeneralFailure, err);\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"error union\"</span> {\n    <span class=\"tok-kw\">var</span> foo: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n\n    <span class=\"tok-comment\">// Coerce from child type of an error union:</span>\n    foo = <span class=\"tok-number\">1234</span>;\n\n    <span class=\"tok-comment\">// Coerce from an error set:</span>\n    foo = <span class=\"tok-kw\">error</span>.SomeError;\n\n    <span class=\"tok-comment\">// Use compile-time reflection to access the payload type of an error union:</span>\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(foo)).error_union.payload == <span class=\"tok-type\">i32</span>);\n\n    <span class=\"tok-comment\">// Use compile-time reflection to access the error set type of an error union:</span>\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(foo)).error_union.error_set == <span class=\"tok-type\">anyerror</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> A = <span class=\"tok-kw\">error</span>{\n    NotDir,\n\n    <span class=\"tok-comment\">/// A doc comment</span>\n    PathNotFound,\n};\n<span class=\"tok-kw\">const</span> B = <span class=\"tok-kw\">error</span>{\n    OutOfMemory,\n\n    <span class=\"tok-comment\">/// B doc comment</span>\n    PathNotFound,\n};\n\n<span class=\"tok-kw\">const</span> C = A || B;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() C!<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.NotDir;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"merge error sets\"</span> {\n    <span class=\"tok-kw\">if</span> (foo()) {\n        <span class=\"tok-builtin\">@panic</span>(<span class=\"tok-str\">\"unexpected\"</span>);\n    } <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.OutOfMemory => <span class=\"tok-builtin\">@panic</span>(<span class=\"tok-str\">\"unexpected\"</span>),\n        <span class=\"tok-kw\">error</span>.PathNotFound => <span class=\"tok-builtin\">@panic</span>(<span class=\"tok-str\">\"unexpected\"</span>),\n        <span class=\"tok-kw\">error</span>.NotDir => {},\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-comment\">// With an inferred error set</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add_inferred</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) !T {\n    <span class=\"tok-kw\">const</span> ov = <span class=\"tok-builtin\">@addWithOverflow</span>(a, b);\n    <span class=\"tok-kw\">if</span> (ov[<span class=\"tok-number\">1</span>] != <span class=\"tok-number\">0</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.Overflow;\n    <span class=\"tok-kw\">return</span> ov[<span class=\"tok-number\">0</span>];\n}\n\n<span class=\"tok-comment\">// With an explicit error set</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add_explicit</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) Error!T {\n    <span class=\"tok-kw\">const</span> ov = <span class=\"tok-builtin\">@addWithOverflow</span>(a, b);\n    <span class=\"tok-kw\">if</span> (ov[<span class=\"tok-number\">1</span>] != <span class=\"tok-number\">0</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.Overflow;\n    <span class=\"tok-kw\">return</span> ov[<span class=\"tok-number\">0</span>];\n}\n\n<span class=\"tok-kw\">const</span> Error = <span class=\"tok-kw\">error</span>{\n    Overflow,\n};\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inferred error set\"</span> {\n    <span class=\"tok-kw\">if</span> (add_inferred(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">255</span>, <span class=\"tok-number\">1</span>)) |_| <span class=\"tok-kw\">unreachable</span> <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.Overflow => {}, <span class=\"tok-comment\">// ok</span>\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> foo(<span class=\"tok-number\">12</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(x: <span class=\"tok-type\">i32</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (x >= <span class=\"tok-number\">5</span>) {\n        <span class=\"tok-kw\">try</span> bar();\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">try</span> bang2();\n    }\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (baz()) {\n        <span class=\"tok-kw\">try</span> quux();\n    } <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.FileNotFound => <span class=\"tok-kw\">try</span> hello(),\n    }\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">baz</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> bang1();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">quux</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> bang2();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">hello</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> bang2();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bang1</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.FileNotFound;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bang2</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.PermissionDenied;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    foo(<span class=\"tok-number\">12</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(x: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (x >= <span class=\"tok-number\">5</span>) {\n        bar();\n    } <span class=\"tok-kw\">else</span> {\n        bang2();\n    }\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (baz()) {\n        quux();\n    } <span class=\"tok-kw\">else</span> {\n        hello();\n    }\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">baz</span>() <span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">return</span> bang1();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">quux</span>() <span class=\"tok-type\">void</span> {\n    bang2();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">hello</span>() <span class=\"tok-type\">void</span> {\n    bang2();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bang1</span>() <span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-null\">false</span>;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bang2</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-builtin\">@panic</span>(<span class=\"tok-str\">\"PermissionDenied\"</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> StackTrace = <span class=\"tok-kw\">struct</span> {\n    index: <span class=\"tok-type\">usize</span>,\n    instruction_addresses: [N]<span class=\"tok-type\">usize</span>,\n};",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-comment\">// marked as \"no-inline\" in LLVM IR</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">__zig_return_error</span>(stack_trace: *StackTrace) <span class=\"tok-type\">void</span> {\n    stack_trace.instruction_addresses[stack_trace.index] = <span class=\"tok-builtin\">@returnAddress</span>();\n    stack_trace.index = (stack_trace.index + <span class=\"tok-number\">1</span>) % N;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Errors § in Zig 0.15.1",
    "context": "",
    "response": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent all of the error values will be used. You can coerce an error from a subset to a superset: test_coerce_error_subset_to_superset.zig Shell But you cannot coerce an error from a superset to a subset: test_coerce_error_superset_to_subset.zig Shell There is a shortcut for declaring an error set with only 1 value, and then getting that value: single_value_error_set_shortcut.zig This is equivalent to: single_value_error_set.zig This becomes useful when using Inferred Error Sets . The Global Error Set § ",
    "metadata": {
      "version": "0.15.1",
      "topic": "Errors §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-comment\">// normal integer</span>\n<span class=\"tok-kw\">const</span> normal_int: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n\n<span class=\"tok-comment\">// optional integer</span>\n<span class=\"tok-kw\">const</span> optional_int: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-number\">5678</span>;",
    "metadata": {
      "version": "0.15.1",
      "topic": "Optionals §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "// malloc prototype included for reference\nvoid *malloc(size_t size);\n\nstruct Foo *do_a_thing(void) {\n    char *ptr = malloc(1234);\n    if (!ptr) return NULL;\n    // ...\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Optionals §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-comment\">// malloc prototype included for reference</span>\n<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">malloc</span>(size: <span class=\"tok-type\">usize</span>) ?[*]<span class=\"tok-type\">u8</span>;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>() ?*Foo {\n    <span class=\"tok-kw\">const</span> ptr = malloc(<span class=\"tok-number\">1234</span>) <span class=\"tok-kw\">orelse</span> <span class=\"tok-kw\">return</span> <span class=\"tok-null\">null</span>;\n    _ = ptr; <span class=\"tok-comment\">// ...</span>\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Optionals §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "void do_a_thing(struct Foo *foo) {\n    // do some stuff\n\n    if (foo) {\n        do_something_with_foo(foo);\n    }\n\n    // do some stuff\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Optionals §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">struct</span> {};\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doSomethingWithFoo</span>(foo: *Foo) <span class=\"tok-type\">void</span> {\n    _ = foo;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(optional_foo: ?*Foo) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-comment\">// do some stuff</span>\n\n    <span class=\"tok-kw\">if</span> (optional_foo) |foo| {\n        doSomethingWithFoo(foo);\n    }\n\n    <span class=\"tok-comment\">// do some stuff</span>\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Optionals §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"optional type\"</span> {\n    <span class=\"tok-comment\">// Declare an optional and coerce from null:</span>\n    <span class=\"tok-kw\">var</span> foo: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-comment\">// Coerce from child type of an optional</span>\n    foo = <span class=\"tok-number\">1234</span>;\n\n    <span class=\"tok-comment\">// Use compile-time reflection to access the child type of the optional:</span>\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(foo)).optional.child == <span class=\"tok-type\">i32</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Optionals §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-kw\">const</span> optional_value: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;",
    "metadata": {
      "version": "0.15.1",
      "topic": "Optionals §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"optional pointers\"</span> {\n    <span class=\"tok-comment\">// Pointers cannot be null. If you want a null pointer, use the optional</span>\n    <span class=\"tok-comment\">// prefix `?` to make the pointer type optional.</span>\n    <span class=\"tok-kw\">var</span> ptr: ?*<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n    ptr = &x;\n\n    <span class=\"tok-kw\">try</span> expect(ptr.?.* == <span class=\"tok-number\">1</span>);\n\n    <span class=\"tok-comment\">// Optional pointers are the same size as normal pointers, because pointer</span>\n    <span class=\"tok-comment\">// value 0 is used as the null value.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@sizeOf</span>(?*<span class=\"tok-type\">i32</span>) == <span class=\"tok-builtin\">@sizeOf</span>(*<span class=\"tok-type\">i32</span>));\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Optionals §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Optionals § in Zig 0.15.1",
    "context": "",
    "response": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer science . Zig does not have them. Instead, you can use an optional pointer. This secretly compiles down to a normal pointer, since we know we can use 0 as the null value for the optional type. But the compiler can check your work and make sure you don't assign null to something that can't be null. Typically the downside of not having null is that it makes the code more verbose to write. But, let's compare some equivalent C code and Zig code. Task: call malloc, if the result is null, return null",
    "metadata": {
      "version": "0.15.1",
      "topic": "Optionals §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"type coercion - variable declaration\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u16</span> = a;\n    _ = b;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"type coercion - function call\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">1</span>;\n    foo(a);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(b: <span class=\"tok-type\">u16</span>) <span class=\"tok-type\">void</span> {\n    _ = b;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"type coercion - @as builtin\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u16</span>, a);\n    _ = b;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Casting §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"type coercion - const qualification\"</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> b: *<span class=\"tok-type\">i32</span> = &a;\n    foo(b);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(_: *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">void</span> {}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Casting §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> mem = std.mem;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"cast *[1][*:0]const u8 to []const ?[*:0]const u8\"</span> {\n    <span class=\"tok-kw\">const</span> window_name = [<span class=\"tok-number\">1</span>][*:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>{<span class=\"tok-str\">\"window name\"</span>};\n    <span class=\"tok-kw\">const</span> x: []<span class=\"tok-kw\">const</span> ?[*:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = &window_name;\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, mem.span(x[<span class=\"tok-number\">0</span>].?), <span class=\"tok-str\">\"window name\"</span>));\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> mem = std.mem;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"integer widening\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">250</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u16</span> = a;\n    <span class=\"tok-kw\">const</span> c: <span class=\"tok-type\">u32</span> = b;\n    <span class=\"tok-kw\">const</span> d: <span class=\"tok-type\">u64</span> = c;\n    <span class=\"tok-kw\">const</span> e: <span class=\"tok-type\">u64</span> = d;\n    <span class=\"tok-kw\">const</span> f: <span class=\"tok-type\">u128</span> = e;\n    <span class=\"tok-kw\">try</span> expect(f == a);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"implicit unsigned integer to signed integer\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">250</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">i16</span> = a;\n    <span class=\"tok-kw\">try</span> expect(b == <span class=\"tok-number\">250</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"float widening\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">f16</span> = <span class=\"tok-number\">12.34</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">f32</span> = a;\n    <span class=\"tok-kw\">const</span> c: <span class=\"tok-type\">f64</span> = b;\n    <span class=\"tok-kw\">const</span> d: <span class=\"tok-type\">f128</span> = c;\n    <span class=\"tok-kw\">try</span> expect(d == a);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-comment\">// Compile time coercion of float to int</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"implicit cast to comptime_int\"</span> {\n    <span class=\"tok-kw\">const</span> f: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">54.0</span> / <span class=\"tok-number\">5</span>;\n    _ = f;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-comment\">// You can assign constant pointers to arrays to a slice with</span>\n<span class=\"tok-comment\">// const modifier on the element type. Useful in particular for</span>\n<span class=\"tok-comment\">// String literals.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*const [N]T to []const T\"</span> {\n    <span class=\"tok-kw\">const</span> x1: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>;\n    <span class=\"tok-kw\">const</span> x2: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = &[<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span>{ <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-number\">111</span> };\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, x1, x2));\n\n    <span class=\"tok-kw\">const</span> y: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">f32</span> = &[<span class=\"tok-number\">2</span>]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.2</span>, <span class=\"tok-number\">3.4</span> };\n    <span class=\"tok-kw\">try</span> expect(y[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1.2</span>);\n}\n\n<span class=\"tok-comment\">// Likewise, it works when the destination type is an error union.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*const [N]T to E![]const T\"</span> {\n    <span class=\"tok-kw\">const</span> x1: <span class=\"tok-type\">anyerror</span>![]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>;\n    <span class=\"tok-kw\">const</span> x2: <span class=\"tok-type\">anyerror</span>![]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = &[<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span>{ <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-number\">111</span> };\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-kw\">try</span> x1, <span class=\"tok-kw\">try</span> x2));\n\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-type\">anyerror</span>![]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">f32</span> = &[<span class=\"tok-number\">2</span>]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.2</span>, <span class=\"tok-number\">3.4</span> };\n    <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> y)[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1.2</span>);\n}\n\n<span class=\"tok-comment\">// Likewise, it works when the destination type is an optional.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*const [N]T to ?[]const T\"</span> {\n    <span class=\"tok-kw\">const</span> x1: ?[]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>;\n    <span class=\"tok-kw\">const</span> x2: ?[]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = &[<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span>{ <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-number\">111</span> };\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, x1.?, x2.?));\n\n    <span class=\"tok-kw\">const</span> y: ?[]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">f32</span> = &[<span class=\"tok-number\">2</span>]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.2</span>, <span class=\"tok-number\">3.4</span> };\n    <span class=\"tok-kw\">try</span> expect(y.?[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1.2</span>);\n}\n\n<span class=\"tok-comment\">// In this cast, the array length becomes the slice length.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*[N]T to []T\"</span> {\n    <span class=\"tok-kw\">var</span> buf: [<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>.*;\n    <span class=\"tok-kw\">const</span> x: []<span class=\"tok-type\">u8</span> = &buf;\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, x, <span class=\"tok-str\">\"hello\"</span>));\n\n    <span class=\"tok-kw\">const</span> buf2 = [<span class=\"tok-number\">2</span>]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.2</span>, <span class=\"tok-number\">3.4</span> };\n    <span class=\"tok-kw\">const</span> x2: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">f32</span> = &buf2;\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">f32</span>, x2, &[<span class=\"tok-number\">2</span>]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.2</span>, <span class=\"tok-number\">3.4</span> }));\n}\n\n<span class=\"tok-comment\">// Single-item pointers to arrays can be coerced to many-item pointers.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*[N]T to [*]T\"</span> {\n    <span class=\"tok-kw\">var</span> buf: [<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>.*;\n    <span class=\"tok-kw\">const</span> x: [*]<span class=\"tok-type\">u8</span> = &buf;\n    <span class=\"tok-kw\">try</span> expect(x[<span class=\"tok-number\">4</span>] == <span class=\"tok-str\">'o'</span>);\n    <span class=\"tok-comment\">// x[5] would be an uncaught out of bounds pointer dereference!</span>\n}\n\n<span class=\"tok-comment\">// Likewise, it works when the destination type is an optional.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*[N]T to ?[*]T\"</span> {\n    <span class=\"tok-kw\">var</span> buf: [<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>.*;\n    <span class=\"tok-kw\">const</span> x: ?[*]<span class=\"tok-type\">u8</span> = &buf;\n    <span class=\"tok-kw\">try</span> expect(x.?[<span class=\"tok-number\">4</span>] == <span class=\"tok-str\">'o'</span>);\n}\n\n<span class=\"tok-comment\">// Single-item pointers can be cast to len-1 single-item arrays.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*T to *[1]T\"</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> y: *[<span class=\"tok-number\">1</span>]<span class=\"tok-type\">i32</span> = &x;\n    <span class=\"tok-kw\">const</span> z: [*]<span class=\"tok-type\">i32</span> = y;\n    <span class=\"tok-kw\">try</span> expect(z[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1234</span>);\n}\n\n<span class=\"tok-comment\">// Sentinel-terminated slices can be coerced into sentinel-terminated pointers</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"[:x]T to [*:x]T\"</span> {\n    <span class=\"tok-kw\">const</span> buf: [:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>;\n    <span class=\"tok-kw\">const</span> buf2: [*:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = buf;\n    <span class=\"tok-kw\">try</span> expect(buf2[<span class=\"tok-number\">4</span>] == <span class=\"tok-str\">'o'</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coerce to optionals\"</span> {\n    <span class=\"tok-kw\">const</span> x: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> y: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-kw\">try</span> expect(x.? == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> expect(y == <span class=\"tok-null\">null</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coerce to optionals wrapped in error union\"</span> {\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> x).? == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> y) == <span class=\"tok-null\">null</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coercion to error unions\"</span> {\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">i32</span> = <span class=\"tok-kw\">error</span>.Failure;\n\n    <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> x) == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> std.testing.expectError(<span class=\"tok-kw\">error</span>.Failure, y);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coercing large integer type to smaller one when value is comptime-known to fit\"</span> {\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">255</span>;\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-type\">u8</span> = x;\n    <span class=\"tok-kw\">try</span> expect(y == <span class=\"tok-number\">255</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> E = <span class=\"tok-kw\">enum</span> {\n    one,\n    two,\n    three,\n};\n\n<span class=\"tok-kw\">const</span> U = <span class=\"tok-kw\">union</span>(E) {\n    one: <span class=\"tok-type\">i32</span>,\n    two: <span class=\"tok-type\">f32</span>,\n    three,\n};\n\n<span class=\"tok-kw\">const</span> U2 = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n    a: <span class=\"tok-type\">void</span>,\n    b: <span class=\"tok-type\">f32</span>,\n\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">tag</span>(self: U2) <span class=\"tok-type\">usize</span> {\n        <span class=\"tok-kw\">switch</span> (self) {\n            .a => <span class=\"tok-kw\">return</span> <span class=\"tok-number\">1</span>,\n            .b => <span class=\"tok-kw\">return</span> <span class=\"tok-number\">2</span>,\n        }\n    }\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coercion between unions and enums\"</span> {\n    <span class=\"tok-kw\">const</span> u = U{ .two = <span class=\"tok-number\">12.34</span> };\n    <span class=\"tok-kw\">const</span> e: E = u; <span class=\"tok-comment\">// coerce union to enum</span>\n    <span class=\"tok-kw\">try</span> expect(e == E.two);\n\n    <span class=\"tok-kw\">const</span> three = E.three;\n    <span class=\"tok-kw\">const</span> u_2: U = three; <span class=\"tok-comment\">// coerce enum to union</span>\n    <span class=\"tok-kw\">try</span> expect(u_2 == E.three);\n\n    <span class=\"tok-kw\">const</span> u_3: U = .three; <span class=\"tok-comment\">// coerce enum literal to union</span>\n    <span class=\"tok-kw\">try</span> expect(u_3 == E.three);\n\n    <span class=\"tok-kw\">const</span> u_4: U2 = .a; <span class=\"tok-comment\">// coerce enum literal to union with inferred enum tag type.</span>\n    <span class=\"tok-kw\">try</span> expect(u_4.tag() == <span class=\"tok-number\">1</span>);\n\n    <span class=\"tok-comment\">// The following example is invalid.</span>\n    <span class=\"tok-comment\">// error: coercion from enum '@TypeOf(.enum_literal)' to union 'test_coerce_unions_enum.U2' must initialize 'f32' field 'b'</span>\n    <span class=\"tok-comment\">//var u_5: U2 = .b;</span>\n    <span class=\"tok-comment\">//try expect(u_5.tag() == 2);</span>\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Tuple = <span class=\"tok-kw\">struct</span> { <span class=\"tok-type\">u8</span>, <span class=\"tok-type\">u8</span> };\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coercion from homogeneous tuple to array\"</span> {\n    <span class=\"tok-kw\">const</span> tuple: Tuple = .{ <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span> };\n    <span class=\"tok-kw\">const</span> array: [<span class=\"tok-number\">2</span>]<span class=\"tok-type\">u8</span> = tuple;\n    _ = array;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Casting §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> mem = std.mem;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer resolve int widening\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">i8</span> = <span class=\"tok-number\">12</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">i16</span> = <span class=\"tok-number\">34</span>;\n    <span class=\"tok-kw\">const</span> c = a + b;\n    <span class=\"tok-kw\">try</span> expect(c == <span class=\"tok-number\">46</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(c) == <span class=\"tok-type\">i16</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer resolve arrays of different size to const slice\"</span> {\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, boolToStr(<span class=\"tok-null\">true</span>), <span class=\"tok-str\">\"true\"</span>));\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, boolToStr(<span class=\"tok-null\">false</span>), <span class=\"tok-str\">\"false\"</span>));\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, boolToStr(<span class=\"tok-null\">true</span>), <span class=\"tok-str\">\"true\"</span>));\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, boolToStr(<span class=\"tok-null\">false</span>), <span class=\"tok-str\">\"false\"</span>));\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">boolToStr</span>(b: <span class=\"tok-type\">bool</span>) []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (b) <span class=\"tok-str\">\"true\"</span> <span class=\"tok-kw\">else</span> <span class=\"tok-str\">\"false\"</span>;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer resolve array and const slice\"</span> {\n    <span class=\"tok-kw\">try</span> testPeerResolveArrayConstSlice(<span class=\"tok-null\">true</span>);\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> testPeerResolveArrayConstSlice(<span class=\"tok-null\">true</span>);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">testPeerResolveArrayConstSlice</span>(b: <span class=\"tok-type\">bool</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> value1 = <span class=\"tok-kw\">if</span> (b) <span class=\"tok-str\">\"aoeu\"</span> <span class=\"tok-kw\">else</span> <span class=\"tok-builtin\">@as</span>([]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, <span class=\"tok-str\">\"zz\"</span>);\n    <span class=\"tok-kw\">const</span> value2 = <span class=\"tok-kw\">if</span> (b) <span class=\"tok-builtin\">@as</span>([]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, <span class=\"tok-str\">\"zz\"</span>) <span class=\"tok-kw\">else</span> <span class=\"tok-str\">\"aoeu\"</span>;\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, value1, <span class=\"tok-str\">\"aoeu\"</span>));\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, value2, <span class=\"tok-str\">\"zz\"</span>));\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer type resolution: ?T and T\"</span> {\n    <span class=\"tok-kw\">try</span> expect(peerTypeTAndOptionalT(<span class=\"tok-null\">true</span>, <span class=\"tok-null\">false</span>).? == <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(peerTypeTAndOptionalT(<span class=\"tok-null\">false</span>, <span class=\"tok-null\">false</span>).? == <span class=\"tok-number\">3</span>);\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">try</span> expect(peerTypeTAndOptionalT(<span class=\"tok-null\">true</span>, <span class=\"tok-null\">false</span>).? == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect(peerTypeTAndOptionalT(<span class=\"tok-null\">false</span>, <span class=\"tok-null\">false</span>).? == <span class=\"tok-number\">3</span>);\n    }\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">peerTypeTAndOptionalT</span>(c: <span class=\"tok-type\">bool</span>, b: <span class=\"tok-type\">bool</span>) ?<span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">if</span> (c) {\n        <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (b) <span class=\"tok-null\">null</span> <span class=\"tok-kw\">else</span> <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">usize</span>, <span class=\"tok-number\">0</span>);\n    }\n\n    <span class=\"tok-kw\">return</span> <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">usize</span>, <span class=\"tok-number\">3</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer type resolution: *[0]u8 and []const u8\"</span> {\n    <span class=\"tok-kw\">try</span> expect(peerTypeEmptyArrayAndSlice(<span class=\"tok-null\">true</span>, <span class=\"tok-str\">\"hi\"</span>).len == <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(peerTypeEmptyArrayAndSlice(<span class=\"tok-null\">false</span>, <span class=\"tok-str\">\"hi\"</span>).len == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">try</span> expect(peerTypeEmptyArrayAndSlice(<span class=\"tok-null\">true</span>, <span class=\"tok-str\">\"hi\"</span>).len == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect(peerTypeEmptyArrayAndSlice(<span class=\"tok-null\">false</span>, <span class=\"tok-str\">\"hi\"</span>).len == <span class=\"tok-number\">1</span>);\n    }\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">peerTypeEmptyArrayAndSlice</span>(a: <span class=\"tok-type\">bool</span>, slice: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">if</span> (a) {\n        <span class=\"tok-kw\">return</span> &[_]<span class=\"tok-type\">u8</span>{};\n    }\n\n    <span class=\"tok-kw\">return</span> slice[<span class=\"tok-number\">0</span>..<span class=\"tok-number\">1</span>];\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer type resolution: *[0]u8, []const u8, and anyerror![]u8\"</span> {\n    {\n        <span class=\"tok-kw\">var</span> data = <span class=\"tok-str\">\"hi\"</span>.*;\n        <span class=\"tok-kw\">const</span> slice = data[<span class=\"tok-number\">0</span>..];\n        <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> peerTypeEmptyArrayAndSliceAndError(<span class=\"tok-null\">true</span>, slice)).len == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> peerTypeEmptyArrayAndSliceAndError(<span class=\"tok-null\">false</span>, slice)).len == <span class=\"tok-number\">1</span>);\n    }\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">var</span> data = <span class=\"tok-str\">\"hi\"</span>.*;\n        <span class=\"tok-kw\">const</span> slice = data[<span class=\"tok-number\">0</span>..];\n        <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> peerTypeEmptyArrayAndSliceAndError(<span class=\"tok-null\">true</span>, slice)).len == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> peerTypeEmptyArrayAndSliceAndError(<span class=\"tok-null\">false</span>, slice)).len == <span class=\"tok-number\">1</span>);\n    }\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">peerTypeEmptyArrayAndSliceAndError</span>(a: <span class=\"tok-type\">bool</span>, slice: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">anyerror</span>![]<span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">if</span> (a) {\n        <span class=\"tok-kw\">return</span> &[_]<span class=\"tok-type\">u8</span>{};\n    }\n\n    <span class=\"tok-kw\">return</span> slice[<span class=\"tok-number\">0</span>..<span class=\"tok-number\">1</span>];\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer type resolution: *const T and ?*T\"</span> {\n    <span class=\"tok-kw\">const</span> a: *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">usize</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0x123456780</span>);\n    <span class=\"tok-kw\">const</span> b: ?*<span class=\"tok-type\">usize</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0x123456780</span>);\n    <span class=\"tok-kw\">try</span> expect(a == b);\n    <span class=\"tok-kw\">try</span> expect(b == a);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer type resolution: error union switch\"</span> {\n    <span class=\"tok-comment\">// The non-error and error cases are only peers if the error case is just a switch expression;</span>\n    <span class=\"tok-comment\">// the pattern `if (x) {...} else |err| blk: { switch (err) {...} }` does not consider the</span>\n    <span class=\"tok-comment\">// non-error and error case to be peers.</span>\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-kw\">error</span>{ A, B, C }!<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    _ = &a;\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-kw\">if</span> (a) |x|\n        x + <span class=\"tok-number\">3</span>\n    <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.A => <span class=\"tok-number\">0</span>,\n        <span class=\"tok-kw\">error</span>.B => <span class=\"tok-number\">1</span>,\n        <span class=\"tok-kw\">error</span>.C => <span class=\"tok-null\">null</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(b) == ?<span class=\"tok-type\">u32</span>);\n\n    <span class=\"tok-comment\">// The non-error and error cases are only peers if the error case is just a switch expression;</span>\n    <span class=\"tok-comment\">// the pattern `x catch |err| blk: { switch (err) {...} }` does not consider the unwrapped `x`</span>\n    <span class=\"tok-comment\">// and error case to be peers.</span>\n    <span class=\"tok-kw\">const</span> c = a <span class=\"tok-kw\">catch</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.A => <span class=\"tok-number\">0</span>,\n        <span class=\"tok-kw\">error</span>.B => <span class=\"tok-number\">1</span>,\n        <span class=\"tok-kw\">error</span>.C => <span class=\"tok-null\">null</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(c) == ?<span class=\"tok-type\">u32</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Casting §",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Explain Casting § in Zig 0.15.1",
    "context": "",
    "response": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Shell Type coercions are only allowed when it is completely unambiguous how to get from one type to another, and the transformation is guaranteed to be safe. There is one exception, which is C Pointers . Type Coercion: Stricter Qualification § Values which have the same representation at runtime can be cast to increase the strictness of the qualifiers, no matter how nested the qualifiers are: const - non-const to const is allowed volatile - non-volatile to volatile is allowed align - bigger to sma",
    "metadata": {
      "version": "0.15.1",
      "topic": "Casting §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Zero Bit Types §",
    "context": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no c",
    "response": "<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">entry</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">void</span> = {};\n    <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">void</span> = {};\n    x = y;\n    y = x;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Zero Bit Types §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Zero Bit Types §",
    "context": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no c",
    "response": "0000000000000010 <entry>:\n  10:\t55                   \tpush   %rbp\n  11:\t48 89 e5             \tmov    %rsp,%rbp\n  14:\t5d                   \tpop    %rbp\n  15:\tc3                   \tretq",
    "metadata": {
      "version": "0.15.1",
      "topic": "Zero Bit Types §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Zero Bit Types §",
    "context": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no c",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"turn HashMap into a set with void\"</span> {\n    <span class=\"tok-kw\">var</span> map = std.AutoHashMap(<span class=\"tok-type\">i32</span>, <span class=\"tok-type\">void</span>).init(std.testing.allocator);\n    <span class=\"tok-kw\">defer</span> map.deinit();\n\n    <span class=\"tok-kw\">try</span> map.put(<span class=\"tok-number\">1</span>, {});\n    <span class=\"tok-kw\">try</span> map.put(<span class=\"tok-number\">2</span>, {});\n\n    <span class=\"tok-kw\">try</span> expect(map.contains(<span class=\"tok-number\">2</span>));\n    <span class=\"tok-kw\">try</span> expect(!map.contains(<span class=\"tok-number\">3</span>));\n\n    _ = map.remove(<span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">try</span> expect(!map.contains(<span class=\"tok-number\">2</span>));\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Zero Bit Types §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Zero Bit Types §",
    "context": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no c",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"ignoring expression value\"</span> {\n    foo();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">1234</span>;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Zero Bit Types §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Zero Bit Types §",
    "context": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no c",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"void is ignored\"</span> {\n    returnsVoid();\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"explicitly ignoring expression value\"</span> {\n    _ = foo();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">returnsVoid</span>() <span class=\"tok-type\">void</span> {}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">1234</span>;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Zero Bit Types §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Zero Bit Types § in Zig 0.15.1",
    "context": "",
    "response": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no code generated in the body of entry , even in Debug mode. For example, on x86_64: These assembly instructions do not have any code associated with the void values - they only perform the function call prologue and epilogue. void § void can be useful for instantiating generic types. For example, given a Map(Key, Value) , one can pass void for the Value type to make it into a Set : test_void_in_hashmap.zig Shell Note that this is different from using a dummy value for the hash map value. By using v",
    "metadata": {
      "version": "0.15.1",
      "topic": "Zero Bit Types §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Result Location Semantics §",
    "context": "During compilation, every Zig expression and sub-expression is assigned optional result location information. This information dictates what type the expression should have (its result type), and where the resulting value should be placed in memory (its result location). The information is optional in the sense that not every expression has this information: assignment to _ , for instance, does not provide any information about the type of an expression, nor does it provide a concrete memory loc",
    "response": "<span class=\"tok-kw\">const</span> expectEqual = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expectEqual;\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"result type propagates through struct initializer\"</span> {\n    <span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> { x: <span class=\"tok-type\">u32</span> };\n    <span class=\"tok-kw\">const</span> val: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">123</span>;\n    <span class=\"tok-kw\">const</span> s: S = .{ .x = <span class=\"tok-builtin\">@intCast</span>(val) };\n    <span class=\"tok-comment\">// .{ .x = @intCast(val) }   has result type `S` due to the type annotation</span>\n    <span class=\"tok-comment\">//         @intCast(val)     has result type `u32` due to the type of the field `S.x`</span>\n    <span class=\"tok-comment\">//                  val      has no result type, as it is permitted to be any integer type</span>\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-number\">123</span>), s.x);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Result Location Semantics §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Result Location Semantics §",
    "context": "During compilation, every Zig expression and sub-expression is assigned optional result location information. This information dictates what type the expression should have (its result type), and where the resulting value should be placed in memory (its result location). The information is optional in the sense that not every expression has this information: assignment to _ , for instance, does not provide any information about the type of an expression, nor does it provide a concrete memory loc",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"attempt to swap array elements with array initializer\"</span> {\n    <span class=\"tok-kw\">var</span> arr: [<span class=\"tok-number\">2</span>]<span class=\"tok-type\">u32</span> = .{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span> };\n    arr = .{ arr[<span class=\"tok-number\">1</span>], arr[<span class=\"tok-number\">0</span>] };\n    <span class=\"tok-comment\">// The previous line is equivalent to the following two lines:</span>\n    <span class=\"tok-comment\">//   arr[0] = arr[1];</span>\n    <span class=\"tok-comment\">//   arr[1] = arr[0];</span>\n    <span class=\"tok-comment\">// So this fails!</span>\n    <span class=\"tok-kw\">try</span> expect(arr[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">2</span>); <span class=\"tok-comment\">// succeeds</span>\n    <span class=\"tok-kw\">try</span> expect(arr[<span class=\"tok-number\">1</span>] == <span class=\"tok-number\">1</span>); <span class=\"tok-comment\">// fails</span>\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Result Location Semantics §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Result Location Semantics § in Zig 0.15.1",
    "context": "",
    "response": "During compilation, every Zig expression and sub-expression is assigned optional result location information. This information dictates what type the expression should have (its result type), and where the resulting value should be placed in memory (its result location). The information is optional in the sense that not every expression has this information: assignment to _ , for instance, does not provide any information about the type of an expression, nor does it provide a concrete memory location to place it in. As a motivating example, consider the statement const x: u32 = 42 ; . The type annotation here provides a result type of u32 to the initialization expression 42 , instructing the compiler to coerce this integer (initially of type comptime_int ) to this type. We will see more examples shortly. This is not an implementation detail: the logic outlined above is codified into the Zig language specification, and is the primary mechanism of type inference in the language. This sys",
    "metadata": {
      "version": "0.15.1",
      "topic": "Result Location Semantics §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">max</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) T {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (a > b) a <span class=\"tok-kw\">else</span> b;\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">gimmeTheBiggerFloat</span>(a: <span class=\"tok-type\">f32</span>, b: <span class=\"tok-type\">f32</span>) <span class=\"tok-type\">f32</span> {\n    <span class=\"tok-kw\">return</span> max(<span class=\"tok-type\">f32</span>, a, b);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">gimmeTheBiggerInteger</span>(a: <span class=\"tok-type\">u64</span>, b: <span class=\"tok-type\">u64</span>) <span class=\"tok-type\">u64</span> {\n    <span class=\"tok-kw\">return</span> max(<span class=\"tok-type\">u64</span>, a, b);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">max</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) T {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (a > b) a <span class=\"tok-kw\">else</span> b;\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"try to pass a runtime type\"</span> {\n    foo(<span class=\"tok-null\">false</span>);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(condition: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> result = max(<span class=\"tok-kw\">if</span> (condition) <span class=\"tok-type\">f32</span> <span class=\"tok-kw\">else</span> <span class=\"tok-type\">u64</span>, <span class=\"tok-number\">1234</span>, <span class=\"tok-number\">5678</span>);\n    _ = result;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">max</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) T {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (a > b) a <span class=\"tok-kw\">else</span> b;\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"try to compare bools\"</span> {\n    _ = max(<span class=\"tok-type\">bool</span>, <span class=\"tok-null\">true</span>, <span class=\"tok-null\">false</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">max</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) T {\n    <span class=\"tok-kw\">if</span> (T == <span class=\"tok-type\">bool</span>) {\n        <span class=\"tok-kw\">return</span> a <span class=\"tok-kw\">or</span> b;\n    } <span class=\"tok-kw\">else</span> <span class=\"tok-kw\">if</span> (a > b) {\n        <span class=\"tok-kw\">return</span> a;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">return</span> b;\n    }\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"try to compare bools\"</span> {\n    <span class=\"tok-kw\">try</span> <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect(max(<span class=\"tok-type\">bool</span>, <span class=\"tok-null\">false</span>, <span class=\"tok-null\">true</span>) == <span class=\"tok-null\">true</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">max</span>(a: <span class=\"tok-type\">bool</span>, b: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">bool</span> {\n    {\n        <span class=\"tok-kw\">return</span> a <span class=\"tok-kw\">or</span> b;\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">const</span> CmdFn = <span class=\"tok-kw\">struct</span> {\n    name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>,\n    func: <span class=\"tok-kw\">fn</span> (<span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span>,\n};\n\n<span class=\"tok-kw\">const</span> cmd_fns = [_]CmdFn{\n    CmdFn{ .name = <span class=\"tok-str\">\"one\"</span>, .func = one },\n    CmdFn{ .name = <span class=\"tok-str\">\"two\"</span>, .func = two },\n    CmdFn{ .name = <span class=\"tok-str\">\"three\"</span>, .func = three },\n};\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">one</span>(value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> value + <span class=\"tok-number\">1</span>;\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">two</span>(value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> value + <span class=\"tok-number\">2</span>;\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">three</span>(value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> value + <span class=\"tok-number\">3</span>;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">performFn</span>(<span class=\"tok-kw\">comptime</span> prefix_char: <span class=\"tok-type\">u8</span>, start_value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> result: <span class=\"tok-type\">i32</span> = start_value;\n    <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> i = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">while</span> (i < cmd_fns.len) : (i += <span class=\"tok-number\">1</span>) {\n        <span class=\"tok-kw\">if</span> (cmd_fns[i].name[<span class=\"tok-number\">0</span>] == prefix_char) {\n            result = cmd_fns[i].func(result);\n        }\n    }\n    <span class=\"tok-kw\">return</span> result;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"perform fn\"</span> {\n    <span class=\"tok-kw\">try</span> expect(performFn(<span class=\"tok-str\">'t'</span>, <span class=\"tok-number\">1</span>) == <span class=\"tok-number\">6</span>);\n    <span class=\"tok-kw\">try</span> expect(performFn(<span class=\"tok-str\">'o'</span>, <span class=\"tok-number\">0</span>) == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(performFn(<span class=\"tok-str\">'w'</span>, <span class=\"tok-number\">99</span>) == <span class=\"tok-number\">99</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-comment\">// From the line:</span>\n<span class=\"tok-comment\">// expect(performFn('t', 1) == 6);</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">performFn</span>(start_value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> result: <span class=\"tok-type\">i32</span> = start_value;\n    result = two(result);\n    result = three(result);\n    <span class=\"tok-kw\">return</span> result;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-comment\">// From the line:</span>\n<span class=\"tok-comment\">// expect(performFn('o', 0) == 1);</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">performFn</span>(start_value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> result: <span class=\"tok-type\">i32</span> = start_value;\n    result = one(result);\n    <span class=\"tok-kw\">return</span> result;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-comment\">// From the line:</span>\n<span class=\"tok-comment\">// expect(performFn('w', 99) == 99);</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">performFn</span>(start_value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> result: <span class=\"tok-type\">i32</span> = start_value;\n    _ = &result;\n    <span class=\"tok-kw\">return</span> result;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">exit</span>() <span class=\"tok-type\">noreturn</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"foo\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        exit();\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">fibonacci</span>(index: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">if</span> (index < <span class=\"tok-number\">2</span>) <span class=\"tok-kw\">return</span> index;\n    <span class=\"tok-kw\">return</span> fibonacci(index - <span class=\"tok-number\">1</span>) + fibonacci(index - <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fibonacci\"</span> {\n    <span class=\"tok-comment\">// test fibonacci at run-time</span>\n    <span class=\"tok-kw\">try</span> expect(fibonacci(<span class=\"tok-number\">7</span>) == <span class=\"tok-number\">13</span>);\n\n    <span class=\"tok-comment\">// test fibonacci at compile-time</span>\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(fibonacci(<span class=\"tok-number\">7</span>) == <span class=\"tok-number\">13</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">fibonacci</span>(index: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-comment\">//if (index < 2) return index;</span>\n    <span class=\"tok-kw\">return</span> fibonacci(index - <span class=\"tok-number\">1</span>) + fibonacci(index - <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fibonacci\"</span> {\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(fibonacci(<span class=\"tok-number\">7</span>) == <span class=\"tok-number\">13</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> assert = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.assert;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">fibonacci</span>(index: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-comment\">//if (index < 2) return index;</span>\n    <span class=\"tok-kw\">return</span> fibonacci(index - <span class=\"tok-number\">1</span>) + fibonacci(index - <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fibonacci\"</span> {\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> assert(fibonacci(<span class=\"tok-number\">7</span>) == <span class=\"tok-number\">13</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> assert = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.assert;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">fibonacci</span>(index: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">if</span> (index < <span class=\"tok-number\">2</span>) <span class=\"tok-kw\">return</span> index;\n    <span class=\"tok-kw\">return</span> fibonacci(index - <span class=\"tok-number\">1</span>) + fibonacci(index - <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fibonacci\"</span> {\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> assert(fibonacci(<span class=\"tok-number\">7</span>) == <span class=\"tok-number\">99999</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> first_25_primes = firstNPrimes(<span class=\"tok-number\">25</span>);\n<span class=\"tok-kw\">const</span> sum_of_first_25_primes = sum(&first_25_primes);\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">firstNPrimes</span>(<span class=\"tok-kw\">comptime</span> n: <span class=\"tok-type\">usize</span>) [n]<span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> prime_list: [n]<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">var</span> next_index: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">var</span> test_number: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">while</span> (next_index < prime_list.len) : (test_number += <span class=\"tok-number\">1</span>) {\n        <span class=\"tok-kw\">var</span> test_prime_index: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n        <span class=\"tok-kw\">var</span> is_prime = <span class=\"tok-null\">true</span>;\n        <span class=\"tok-kw\">while</span> (test_prime_index < next_index) : (test_prime_index += <span class=\"tok-number\">1</span>) {\n            <span class=\"tok-kw\">if</span> (test_number % prime_list[test_prime_index] == <span class=\"tok-number\">0</span>) {\n                is_prime = <span class=\"tok-null\">false</span>;\n                <span class=\"tok-kw\">break</span>;\n            }\n        }\n        <span class=\"tok-kw\">if</span> (is_prime) {\n            prime_list[next_index] = test_number;\n            next_index += <span class=\"tok-number\">1</span>;\n        }\n    }\n    <span class=\"tok-kw\">return</span> prime_list;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">sum</span>(numbers: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> result: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">for</span> (numbers) |x| {\n        result += x;\n    }\n    <span class=\"tok-kw\">return</span> result;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"variable values\"</span> {\n    <span class=\"tok-kw\">try</span> <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect(sum_of_first_25_primes == <span class=\"tok-number\">1060</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "@0 = internal unnamed_addr constant [25 x i32] [i32 2, i32 3, i32 5, i32 7, i32 11, i32 13, i32 17, i32 19, i32 23, i32 29, i32 31, i32 37, i32 41, i32 43, i32 47, i32 53, i32 59, i32 61, i32 67, i32 71, i32 73, i32 79, i32 83, i32 89, i32 97]\n@1 = internal unnamed_addr constant i32 1060",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">List</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">struct</span> {\n        items: []T,\n        len: <span class=\"tok-type\">usize</span>,\n    };\n}\n\n<span class=\"tok-comment\">// The generic List data structure can be instantiated by passing in a type:</span>\n<span class=\"tok-kw\">var</span> buffer: [<span class=\"tok-number\">10</span>]<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n<span class=\"tok-kw\">var</span> list = List(<span class=\"tok-type\">i32</span>){\n    .items = &buffer,\n    .len = <span class=\"tok-number\">0</span>,\n};",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> Node = <span class=\"tok-kw\">struct</span> {\n    next: ?*Node,\n    name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>,\n};\n\n<span class=\"tok-kw\">var</span> node_a = Node{\n    .next = <span class=\"tok-null\">null</span>,\n    .name = <span class=\"tok-str\">\"Node A\"</span>,\n};\n\n<span class=\"tok-kw\">var</span> node_b = Node{\n    .next = &node_a,\n    .name = <span class=\"tok-str\">\"Node B\"</span>,\n};",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">const</span> a_number: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n<span class=\"tok-kw\">const</span> a_string = <span class=\"tok-str\">\"foobar\"</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    print(<span class=\"tok-str\">\"here is a string: '{s}' here is a number: {}\\n\"</span>, .{ a_string, a_number });\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> Writer = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-comment\">/// Calls print and then flushes the buffer.</span>\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">print</span>(self: *Writer, <span class=\"tok-kw\">comptime</span> format: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, args: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">void</span> {\n        <span class=\"tok-kw\">const</span> State = <span class=\"tok-kw\">enum</span> {\n            start,\n            open_brace,\n            close_brace,\n        };\n\n        <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> start_index: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n        <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> state = State.start;\n        <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> next_arg: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n\n        <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">for</span> (format, <span class=\"tok-number\">0</span>..) |c, i| {\n            <span class=\"tok-kw\">switch</span> (state) {\n                State.start => <span class=\"tok-kw\">switch</span> (c) {\n                    <span class=\"tok-str\">'{'</span> => {\n                        <span class=\"tok-kw\">if</span> (start_index < i) <span class=\"tok-kw\">try</span> self.write(format[start_index..i]);\n                        state = State.open_brace;\n                    },\n                    <span class=\"tok-str\">'}'</span> => {\n                        <span class=\"tok-kw\">if</span> (start_index < i) <span class=\"tok-kw\">try</span> self.write(format[start_index..i]);\n                        state = State.close_brace;\n                    },\n                    <span class=\"tok-kw\">else</span> => {},\n                },\n                State.open_brace => <span class=\"tok-kw\">switch</span> (c) {\n                    <span class=\"tok-str\">'{'</span> => {\n                        state = State.start;\n                        start_index = i;\n                    },\n                    <span class=\"tok-str\">'}'</span> => {\n                        <span class=\"tok-kw\">try</span> self.printValue(args[next_arg]);\n                        next_arg += <span class=\"tok-number\">1</span>;\n                        state = State.start;\n                        start_index = i + <span class=\"tok-number\">1</span>;\n                    },\n                    <span class=\"tok-str\">'s'</span> => {\n                        <span class=\"tok-kw\">continue</span>;\n                    },\n                    <span class=\"tok-kw\">else</span> => <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"Unknown format character: \"</span> ++ [<span class=\"tok-number\">1</span>]<span class=\"tok-type\">u8</span>{c}),\n                },\n                State.close_brace => <span class=\"tok-kw\">switch</span> (c) {\n                    <span class=\"tok-str\">'}'</span> => {\n                        state = State.start;\n                        start_index = i;\n                    },\n                    <span class=\"tok-kw\">else</span> => <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"Single '}' encountered in format string\"</span>),\n                },\n            }\n        }\n        <span class=\"tok-kw\">comptime</span> {\n            <span class=\"tok-kw\">if</span> (args.len != next_arg) {\n                <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"Unused arguments\"</span>);\n            }\n            <span class=\"tok-kw\">if</span> (state != State.start) {\n                <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"Incomplete format string: \"</span> ++ format);\n            }\n        }\n        <span class=\"tok-kw\">if</span> (start_index < format.len) {\n            <span class=\"tok-kw\">try</span> self.write(format[start_index..format.len]);\n        }\n        <span class=\"tok-kw\">try</span> self.flush();\n    }\n\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">write</span>(self: *Writer, value: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) !<span class=\"tok-type\">void</span> {\n        _ = self;\n        _ = value;\n    }\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">printValue</span>(self: *Writer, value: <span class=\"tok-kw\">anytype</span>) !<span class=\"tok-type\">void</span> {\n        _ = self;\n        _ = value;\n    }\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">flush</span>(self: *Writer) !<span class=\"tok-type\">void</span> {\n        _ = self;\n    }\n};",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">print</span>(self: *Writer, arg0: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, arg1: <span class=\"tok-type\">i32</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> self.write(<span class=\"tok-str\">\"here is a string: '\"</span>);\n    <span class=\"tok-kw\">try</span> self.printValue(arg0);\n    <span class=\"tok-kw\">try</span> self.write(<span class=\"tok-str\">\"' here is a number: \"</span>);\n    <span class=\"tok-kw\">try</span> self.printValue(arg1);\n    <span class=\"tok-kw\">try</span> self.write(<span class=\"tok-str\">\"\\n\"</span>);\n    <span class=\"tok-kw\">try</span> self.flush();\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> Writer = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">printValue</span>(self: *Writer, value: <span class=\"tok-kw\">anytype</span>) !<span class=\"tok-type\">void</span> {\n        <span class=\"tok-kw\">switch</span> (<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(value))) {\n            .int => {\n                <span class=\"tok-kw\">return</span> self.writeInt(value);\n            },\n            .float => {\n                <span class=\"tok-kw\">return</span> self.writeFloat(value);\n            },\n            .pointer => {\n                <span class=\"tok-kw\">return</span> self.write(value);\n            },\n            <span class=\"tok-kw\">else</span> => {\n                <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"Unable to print type '\"</span> ++ <span class=\"tok-builtin\">@typeName</span>(<span class=\"tok-builtin\">@TypeOf</span>(value)) ++ <span class=\"tok-str\">\"'\"</span>);\n            },\n        }\n    }\n\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">write</span>(self: *Writer, value: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) !<span class=\"tok-type\">void</span> {\n        _ = self;\n        _ = value;\n    }\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">writeInt</span>(self: *Writer, value: <span class=\"tok-kw\">anytype</span>) !<span class=\"tok-type\">void</span> {\n        _ = self;\n        _ = value;\n    }\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">writeFloat</span>(self: *Writer, value: <span class=\"tok-kw\">anytype</span>) !<span class=\"tok-type\">void</span> {\n        _ = self;\n        _ = value;\n    }\n};",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">const</span> a_number: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n<span class=\"tok-kw\">const</span> a_string = <span class=\"tok-str\">\"foobar\"</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"print too many arguments\"</span> {\n    print(<span class=\"tok-str\">\"here is a string: '{s}' here is a number: {}\\n\"</span>, .{\n        a_string,\n        a_number,\n        a_number,\n    });\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">const</span> a_number: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n<span class=\"tok-kw\">const</span> a_string = <span class=\"tok-str\">\"foobar\"</span>;\n<span class=\"tok-kw\">const</span> fmt = <span class=\"tok-str\">\"here is a string: '{s}' here is a number: {}\\n\"</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    print(fmt, .{ a_string, a_number });\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain comptime § in Zig 0.15.1",
    "context": "",
    "response": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as parameters to functions, and returned from functions. However, they can only be used in expressions which are known at compile-time , which is why the parameter T in the above snippet must be marked with comptime . A comptime parameter means that: At the callsite, the value must be known at compile-time, or it is a compile error. In the function definition, the value is known at compile-time. For example, if we were to introduce another function to the above snippet: test_unresolved_comptime_value.",
    "metadata": {
      "version": "0.15.1",
      "topic": "comptime §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Assembly §",
    "context": "For some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly: inline_assembly.zig Shell Dissecting the syntax: Assembly Syntax Explained.zig For x86 and x86_64 targets, the syntax is AT&amp;T syntax, rather than the more popular Intel syntax. This is due to technical constraints",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">noreturn</span> {\n    <span class=\"tok-kw\">const</span> msg = <span class=\"tok-str\">\"hello world\\n\"</span>;\n    _ = syscall3(SYS_write, STDOUT_FILENO, <span class=\"tok-builtin\">@intFromPtr</span>(msg), msg.len);\n    _ = syscall1(SYS_exit, <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">unreachable</span>;\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> SYS_write = <span class=\"tok-number\">1</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> SYS_exit = <span class=\"tok-number\">60</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> STDOUT_FILENO = <span class=\"tok-number\">1</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">syscall1</span>(number: <span class=\"tok-type\">usize</span>, arg1: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">asm</span> <span class=\"tok-kw\">volatile</span> (<span class=\"tok-str\">\"syscall\"</span>\n        : [ret] <span class=\"tok-str\">\"={rax}\"</span> (-> <span class=\"tok-type\">usize</span>),\n        : [number] <span class=\"tok-str\">\"{rax}\"</span> (number),\n          [arg1] <span class=\"tok-str\">\"{rdi}\"</span> (arg1),\n        : .{ .rcx = <span class=\"tok-null\">true</span>, .r11 = <span class=\"tok-null\">true</span> });\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">syscall3</span>(number: <span class=\"tok-type\">usize</span>, arg1: <span class=\"tok-type\">usize</span>, arg2: <span class=\"tok-type\">usize</span>, arg3: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">asm</span> <span class=\"tok-kw\">volatile</span> (<span class=\"tok-str\">\"syscall\"</span>\n        : [ret] <span class=\"tok-str\">\"={rax}\"</span> (-> <span class=\"tok-type\">usize</span>),\n        : [number] <span class=\"tok-str\">\"{rax}\"</span> (number),\n          [arg1] <span class=\"tok-str\">\"{rdi}\"</span> (arg1),\n          [arg2] <span class=\"tok-str\">\"{rsi}\"</span> (arg2),\n          [arg3] <span class=\"tok-str\">\"{rdx}\"</span> (arg3),\n        : .{ .rcx = <span class=\"tok-null\">true</span>, .r11 = <span class=\"tok-null\">true</span> });\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Assembly §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Assembly §",
    "context": "For some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly: inline_assembly.zig Shell Dissecting the syntax: Assembly Syntax Explained.zig For x86 and x86_64 targets, the syntax is AT&amp;T syntax, rather than the more popular Intel syntax. This is due to technical constraints",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">syscall1</span>(number: <span class=\"tok-type\">usize</span>, arg1: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-comment\">// Inline assembly is an expression which returns a value.</span>\n    <span class=\"tok-comment\">// the `asm` keyword begins the expression.</span>\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">asm</span>\n    <span class=\"tok-comment\">// `volatile` is an optional modifier that tells Zig this</span>\n    <span class=\"tok-comment\">// inline assembly expression has side-effects. Without</span>\n    <span class=\"tok-comment\">// `volatile`, Zig is allowed to delete the inline assembly</span>\n    <span class=\"tok-comment\">// code if the result is unused.</span>\n    <span class=\"tok-kw\">volatile</span> (\n    <span class=\"tok-comment\">// Next is a comptime string which is the assembly code.</span>\n    <span class=\"tok-comment\">// Inside this string one may use `%[ret]`, `%[number]`,</span>\n    <span class=\"tok-comment\">// or `%[arg1]` where a register is expected, to specify</span>\n    <span class=\"tok-comment\">// the register that Zig uses for the argument or return value,</span>\n    <span class=\"tok-comment\">// if the register constraint strings are used. However in</span>\n    <span class=\"tok-comment\">// the below code, this is not used. A literal `%` can be</span>\n    <span class=\"tok-comment\">// obtained by escaping it with a double percent: `%%`.</span>\n    <span class=\"tok-comment\">// Often multiline string syntax comes in handy here.</span>\n        <span class=\"tok-str\">\\\\syscall</span>\n        <span class=\"tok-comment\">// Next is the output. It is possible in the future Zig will</span>\n        <span class=\"tok-comment\">// support multiple outputs, depending on how</span>\n        <span class=\"tok-comment\">// https://github.com/ziglang/zig/issues/215 is resolved.</span>\n        <span class=\"tok-comment\">// It is allowed for there to be no outputs, in which case</span>\n        <span class=\"tok-comment\">// this colon would be directly followed by the colon for the inputs.</span>\n        :\n        <span class=\"tok-comment\">// This specifies the name to be used in `%[ret]` syntax in</span>\n        <span class=\"tok-comment\">// the above assembly string. This example does not use it,</span>\n        <span class=\"tok-comment\">// but the syntax is mandatory.</span>\n          [ret]\n          <span class=\"tok-comment\">// Next is the output constraint string. This feature is still</span>\n          <span class=\"tok-comment\">// considered unstable in Zig, and so LLVM/GCC documentation</span>\n          <span class=\"tok-comment\">// must be used to understand the semantics.</span>\n          <span class=\"tok-comment\">// http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string</span>\n          <span class=\"tok-comment\">// https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html</span>\n          <span class=\"tok-comment\">// In this example, the constraint string means \"the result value of</span>\n          <span class=\"tok-comment\">// this inline assembly instruction is whatever is in $rax\".</span>\n          <span class=\"tok-str\">\"={rax}\"</span>\n          <span class=\"tok-comment\">// Next is either a value binding, or `->` and then a type. The</span>\n          <span class=\"tok-comment\">// type is the result type of the inline assembly expression.</span>\n          <span class=\"tok-comment\">// If it is a value binding, then `%[ret]` syntax would be used</span>\n          <span class=\"tok-comment\">// to refer to the register bound to the value.</span>\n          (-> <span class=\"tok-type\">usize</span>),\n          <span class=\"tok-comment\">// Next is the list of inputs.</span>\n          <span class=\"tok-comment\">// The constraint for these inputs means, \"when the assembly code is</span>\n          <span class=\"tok-comment\">// executed, $rax shall have the value of `number` and $rdi shall have</span>\n          <span class=\"tok-comment\">// the value of `arg1`\". Any number of input parameters is allowed,</span>\n          <span class=\"tok-comment\">// including none.</span>\n        : [number] <span class=\"tok-str\">\"{rax}\"</span> (number),\n          [arg1] <span class=\"tok-str\">\"{rdi}\"</span> (arg1),\n          <span class=\"tok-comment\">// Next is the list of clobbers. These declare a set of registers whose</span>\n          <span class=\"tok-comment\">// values will not be preserved by the execution of this assembly code.</span>\n          <span class=\"tok-comment\">// These do not include output or input registers. The special clobber</span>\n          <span class=\"tok-comment\">// value of \"memory\" means that the assembly writes to arbitrary undeclared</span>\n          <span class=\"tok-comment\">// memory locations - not only the memory pointed to by a declared indirect</span>\n          <span class=\"tok-comment\">// output. In this example we list $rcx and $r11 because it is known the</span>\n          <span class=\"tok-comment\">// kernel syscall does not preserve these registers.</span>\n        : .{ .rcx = <span class=\"tok-null\">true</span>, .r11 = <span class=\"tok-null\">true</span> });\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Assembly §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Assembly §",
    "context": "For some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly: inline_assembly.zig Shell Dissecting the syntax: Assembly Syntax Explained.zig For x86 and x86_64 targets, the syntax is AT&amp;T syntax, rather than the more popular Intel syntax. This is due to technical constraints",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">asm</span> (\n        <span class=\"tok-str\">\\\\.global my_func;</span>\n        <span class=\"tok-str\">\\\\.type my_func, @function;</span>\n        <span class=\"tok-str\">\\\\my_func:</span>\n        <span class=\"tok-str\">\\\\  lea (%rdi,%rsi,1),%eax</span>\n        <span class=\"tok-str\">\\\\  retq</span>\n    );\n}\n\n<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">my_func</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"global assembly\"</span> {\n    <span class=\"tok-kw\">try</span> expect(my_func(<span class=\"tok-number\">12</span>, <span class=\"tok-number\">34</span>) == <span class=\"tok-number\">46</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Assembly §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Assembly § in Zig 0.15.1",
    "context": "",
    "response": "For some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly: inline_assembly.zig Shell Dissecting the syntax: Assembly Syntax Explained.zig For x86 and x86_64 targets, the syntax is AT&amp;T syntax, rather than the more popular Intel syntax. This is due to technical constraints; assembly parsing is provided by LLVM and its support for Intel syntax is buggy and not well tested. Some day Zig may have its own assembler. This would allow it to integrate more seamlessly into the language, as well as be compatible with the popular NASM syntax. This documentation section will be updated before 1.0.0 is released, with a conclusive statement about the status of AT&amp;T vs Intel/NASM syntax. Output Constraints § Output constraints are still considered to be unstable in Zig, an",
    "metadata": {
      "version": "0.15.1",
      "topic": "Assembly §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Atomics § in Zig 0.15.1",
    "context": "",
    "response": "TODO: @atomic rmw TODO: builtin atomic memory ordering enum See also: @atomicLoad @atomicStore @atomicRmw @cmpxchgWeak @cmpxchgStrong",
    "metadata": {
      "version": "0.15.1",
      "topic": "Atomics §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Async Functions § in Zig 0.15.1",
    "context": "",
    "response": "Async functions regressed with the release of 0.11.0. The current plan is to reintroduce them as a lower level primitive that powers I/O implementations. Tracking issue: Proposal: stackless coroutines as low-level primitives",
    "metadata": {
      "version": "0.15.1",
      "topic": "Async Functions §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@addrSpaceCast</span>(ptr: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@addWithOverflow</span>(a: <span class=\"tok-kw\">anytype</span>, b: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">struct</span> { <span class=\"tok-builtin\">@TypeOf</span>(a, b), <span class=\"tok-type\">u1</span> }",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@alignCast</span>(ptr: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@alignOf</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">comptime_int</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> assert = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.assert;\n<span class=\"tok-kw\">comptime</span> {\n    assert(*<span class=\"tok-type\">u32</span> == *<span class=\"tok-kw\">align</span>(<span class=\"tok-builtin\">@alignOf</span>(<span class=\"tok-type\">u32</span>)) <span class=\"tok-type\">u32</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, expression) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@atomicLoad</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *<span class=\"tok-kw\">const</span> T, <span class=\"tok-kw\">comptime</span> ordering: AtomicOrder) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@atomicRmw</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, <span class=\"tok-kw\">comptime</span> op: AtomicRmwOp, operand: T, <span class=\"tok-kw\">comptime</span> ordering: AtomicOrder) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@atomicStore</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, value: T, <span class=\"tok-kw\">comptime</span> ordering: AtomicOrder) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@bitCast</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@bitOffsetOf</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">comptime_int</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@bitSizeOf</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">comptime_int</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@branchHint</span>(hint: BranchHint) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@breakpoint</span>() <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@mulAdd</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T, c: T) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@byteSwap</span>(operand: <span class=\"tok-kw\">anytype</span>) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@bitReverse</span>(integer: <span class=\"tok-kw\">anytype</span>) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@offsetOf</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">comptime_int</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@call</span>(modifier: std.builtin.CallModifier, function: <span class=\"tok-kw\">anytype</span>, args: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"noinline function call\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@call</span>(.auto, add, .{ <span class=\"tok-number\">3</span>, <span class=\"tok-number\">9</span> }) == <span class=\"tok-number\">12</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> a + b;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> CallModifier = <span class=\"tok-kw\">enum</span> {\n    <span class=\"tok-comment\">/// Equivalent to function call syntax.</span>\n    auto,\n\n    <span class=\"tok-comment\">/// Equivalent to async keyword used with function call syntax.</span>\n    async_kw,\n\n    <span class=\"tok-comment\">/// Prevents tail call optimization. This guarantees that the return</span>\n    <span class=\"tok-comment\">/// address will point to the callsite, as opposed to the callsite's</span>\n    <span class=\"tok-comment\">/// callsite. If the call is otherwise required to be tail-called</span>\n    <span class=\"tok-comment\">/// or inlined, a compile error is emitted instead.</span>\n    never_tail,\n\n    <span class=\"tok-comment\">/// Guarantees that the call will not be inlined. If the call is</span>\n    <span class=\"tok-comment\">/// otherwise required to be inlined, a compile error is emitted instead.</span>\n    never_inline,\n\n    <span class=\"tok-comment\">/// Asserts that the function call will not suspend. This allows a</span>\n    <span class=\"tok-comment\">/// non-async function to call an async function.</span>\n    no_async,\n\n    <span class=\"tok-comment\">/// Guarantees that the call will be generated with tail call optimization.</span>\n    <span class=\"tok-comment\">/// If this is not possible, a compile error is emitted instead.</span>\n    always_tail,\n\n    <span class=\"tok-comment\">/// Guarantees that the call will be inlined at the callsite.</span>\n    <span class=\"tok-comment\">/// If this is not possible, a compile error is emitted instead.</span>\n    always_inline,\n\n    <span class=\"tok-comment\">/// Evaluates the call at compile-time. If the call cannot be completed at</span>\n    <span class=\"tok-comment\">/// compile-time, a compile error is emitted instead.</span>\n    compile_time,\n};",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-kw\">comptime</span> name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, value) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "#define _GNU_SOURCE",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"_GNU_SOURCE\"</span>, {})",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cImport</span>(expression) <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-kw\">comptime</span> path: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@clz</span>(operand: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cmpxchgStrong</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">cmpxchgStrongButNotAtomic</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, expected_value: T, new_value: T) ?T {\n    <span class=\"tok-kw\">const</span> old_value = ptr.*;\n    <span class=\"tok-kw\">if</span> (old_value == expected_value) {\n        ptr.* = new_value;\n        <span class=\"tok-kw\">return</span> <span class=\"tok-null\">null</span>;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">return</span> old_value;\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cmpxchgWeak</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">cmpxchgWeakButNotAtomic</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, expected_value: T, new_value: T) ?T {\n    <span class=\"tok-kw\">const</span> old_value = ptr.*;\n    <span class=\"tok-kw\">if</span> (old_value == expected_value <span class=\"tok-kw\">and</span> usuallyTrueButSometimesFalse()) {\n        ptr.* = new_value;\n        <span class=\"tok-kw\">return</span> <span class=\"tok-null\">null</span>;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">return</span> old_value;\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-kw\">comptime</span> msg: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">noreturn</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@compileLog</span>(...) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">const</span> num1 = blk: {\n    <span class=\"tok-kw\">var</span> val1: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">99</span>;\n    <span class=\"tok-builtin\">@compileLog</span>(<span class=\"tok-str\">\"comptime val1 = \"</span>, val1);\n    val1 = val1 + <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">break</span> :blk val1;\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"main\"</span> {\n    <span class=\"tok-builtin\">@compileLog</span>(<span class=\"tok-str\">\"comptime in main\"</span>);\n\n    print(<span class=\"tok-str\">\"Runtime in main, num1 = {}.\\n\"</span>, .{num1});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@constCast</span>(value: <span class=\"tok-kw\">anytype</span>) DestType",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@ctz</span>(operand: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cUndef</span>(<span class=\"tok-kw\">comptime</span> name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cVaArg</span>(operand: *std.builtin.VaList, <span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cVaCopy</span>(src: *std.builtin.VaList) std.builtin.VaList",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cVaEnd</span>(src: *std.builtin.VaList) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cVaStart</span>() std.builtin.VaList",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@divExact</span>(numerator: T, denominator: T) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@divFloor</span>(numerator: T, denominator: T) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@divTrunc</span>(numerator: T, denominator: T) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@embedFile</span>(<span class=\"tok-kw\">comptime</span> path: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) *<span class=\"tok-kw\">const</span> [N:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@enumFromInt</span>(integer: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@errorFromInt</span>(value: std.meta.Int(.unsigned, <span class=\"tok-builtin\">@bitSizeOf</span>(<span class=\"tok-type\">anyerror</span>))) <span class=\"tok-type\">anyerror</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@errorName</span>(err: <span class=\"tok-type\">anyerror</span>) [:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@errorReturnTrace</span>() ?*builtin.StackTrace",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@errorCast</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@export</span>(<span class=\"tok-kw\">comptime</span> ptr: *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">anyopaque</span>, <span class=\"tok-kw\">comptime</span> options: std.builtin.ExportOptions) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-builtin\">@export</span>(&internalName, .{ .name = <span class=\"tok-str\">\"foo\"</span>, .linkage = .strong });\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">internalName</span>() <span class=\"tok-kw\">callconv</span>(.c) <span class=\"tok-type\">void</span> {}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">void</span> {}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">@\"A function name that is a complete sentence.\"</span>() <span class=\"tok-type\">void</span> {}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "00000000000001f0 T A function name that is a complete sentence.",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@extern</span>(T: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> options: std.builtin.ExternOptions) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@field</span>(lhs: <span class=\"tok-kw\">anytype</span>, <span class=\"tok-kw\">comptime</span> field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) (field)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> {\n    x: <span class=\"tok-type\">u32</span>,\n    y: <span class=\"tok-type\">u32</span>,\n\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">var</span> z: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">1</span>;\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"field access by string\"</span> {\n    <span class=\"tok-kw\">const</span> expect = std.testing.expect;\n    <span class=\"tok-kw\">var</span> p = Point{ .x = <span class=\"tok-number\">0</span>, .y = <span class=\"tok-number\">0</span> };\n\n    <span class=\"tok-builtin\">@field</span>(p, <span class=\"tok-str\">\"x\"</span>) = <span class=\"tok-number\">4</span>;\n    <span class=\"tok-builtin\">@field</span>(p, <span class=\"tok-str\">\"y\"</span>) = <span class=\"tok-builtin\">@field</span>(p, <span class=\"tok-str\">\"x\"</span>) + <span class=\"tok-number\">1</span>;\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@field</span>(p, <span class=\"tok-str\">\"x\"</span>) == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@field</span>(p, <span class=\"tok-str\">\"y\"</span>) == <span class=\"tok-number\">5</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"decl access by string\"</span> {\n    <span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@field</span>(Point, <span class=\"tok-str\">\"z\"</span>) == <span class=\"tok-number\">1</span>);\n\n    <span class=\"tok-builtin\">@field</span>(Point, <span class=\"tok-str\">\"z\"</span>) = <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@field</span>(Point, <span class=\"tok-str\">\"z\"</span>) == <span class=\"tok-number\">2</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@fieldParentPtr</span>(<span class=\"tok-kw\">comptime</span> field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, field_ptr: *T) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@FieldType</span>(<span class=\"tok-kw\">comptime</span> Type: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@floatCast</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@floatFromInt</span>(int: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@frameAddress</span>() <span class=\"tok-type\">usize</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@hasDecl</span>(<span class=\"tok-kw\">comptime</span> Container: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">bool</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">struct</span> {\n    nope: <span class=\"tok-type\">i32</span>,\n\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">var</span> blah = <span class=\"tok-str\">\"xxx\"</span>;\n    <span class=\"tok-kw\">const</span> hi = <span class=\"tok-number\">1</span>;\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@hasDecl\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@hasDecl</span>(Foo, <span class=\"tok-str\">\"blah\"</span>));\n\n    <span class=\"tok-comment\">// Even though `hi` is private, @hasDecl returns true because this test is</span>\n    <span class=\"tok-comment\">// in the same file scope as Foo. It would return false if Foo was declared</span>\n    <span class=\"tok-comment\">// in a different file.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@hasDecl</span>(Foo, <span class=\"tok-str\">\"hi\"</span>));\n\n    <span class=\"tok-comment\">// @hasDecl is for declarations; not fields.</span>\n    <span class=\"tok-kw\">try</span> expect(!<span class=\"tok-builtin\">@hasDecl</span>(Foo, <span class=\"tok-str\">\"nope\"</span>));\n    <span class=\"tok-kw\">try</span> expect(!<span class=\"tok-builtin\">@hasDecl</span>(Foo, <span class=\"tok-str\">\"nope1234\"</span>));\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@hasField</span>(<span class=\"tok-kw\">comptime</span> Container: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">bool</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@import</span>(<span class=\"tok-kw\">comptime</span> target: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@inComptime</span>() <span class=\"tok-type\">bool</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intCast</span>(int: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"integer cast panic\"</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">u16</span> = <span class=\"tok-number\">0xabcd</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &a;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@intCast</span>(a);\n    _ = b;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intFromBool</span>(value: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">u1</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intFromEnum</span>(enum_or_tagged_union: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intFromError</span>(err: <span class=\"tok-kw\">anytype</span>) std.meta.Int(.unsigned, <span class=\"tok-builtin\">@bitSizeOf</span>(<span class=\"tok-type\">anyerror</span>))",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intFromFloat</span>(float: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intFromPtr</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-type\">usize</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@max</span>(...) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@memcpy</span>(<span class=\"tok-kw\">noalias</span> dest, <span class=\"tok-kw\">noalias</span> source) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@memset</span>(dest, elem) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@memmove</span>(dest, source) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@min</span>(...) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@wasmMemorySize</span>(index: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">usize</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@wasmMemoryGrow</span>(index: <span class=\"tok-type\">u32</span>, delta: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">isize</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> native_arch = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>).target.cpu.arch;\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@wasmMemoryGrow\"</span> {\n    <span class=\"tok-kw\">if</span> (native_arch != .wasm32) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.SkipZigTest;\n\n    <span class=\"tok-kw\">const</span> prev = <span class=\"tok-builtin\">@wasmMemorySize</span>(<span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(prev == <span class=\"tok-builtin\">@wasmMemoryGrow</span>(<span class=\"tok-number\">0</span>, <span class=\"tok-number\">1</span>));\n    <span class=\"tok-kw\">try</span> expect(prev + <span class=\"tok-number\">1</span> == <span class=\"tok-builtin\">@wasmMemorySize</span>(<span class=\"tok-number\">0</span>));\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@mod</span>(numerator: T, denominator: T) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@mulWithOverflow</span>(a: <span class=\"tok-kw\">anytype</span>, b: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">struct</span> { <span class=\"tok-builtin\">@TypeOf</span>(a, b), <span class=\"tok-type\">u1</span> }",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@panic</span>(message: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">noreturn</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@popCount</span>(operand: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@prefetch</span>(ptr: <span class=\"tok-kw\">anytype</span>, <span class=\"tok-kw\">comptime</span> options: PrefetchOptions) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@ptrCast</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@ptrFromInt</span>(address: <span class=\"tok-type\">usize</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@rem</span>(numerator: T, denominator: T) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@returnAddress</span>() <span class=\"tok-type\">usize</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@select</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, pred: <span class=\"tok-builtin\">@Vector</span>(len, <span class=\"tok-type\">bool</span>), a: <span class=\"tok-builtin\">@Vector</span>(len, T), b: <span class=\"tok-builtin\">@Vector</span>(len, T)) <span class=\"tok-builtin\">@Vector</span>(len, T)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@setEvalBranchQuota</span>(<span class=\"tok-kw\">comptime</span> new_quota: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"foo\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">var</span> i = <span class=\"tok-number\">0</span>;\n        <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">1001</span>) : (i += <span class=\"tok-number\">1</span>) {}\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"foo\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-builtin\">@setEvalBranchQuota</span>(<span class=\"tok-number\">1001</span>);\n        <span class=\"tok-kw\">var</span> i = <span class=\"tok-number\">0</span>;\n        <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">1001</span>) : (i += <span class=\"tok-number\">1</span>) {}\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@setFloatMode</span>(<span class=\"tok-kw\">comptime</span> mode: FloatMode) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@setRuntimeSafety</span>(<span class=\"tok-kw\">comptime</span> safety_on: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@setRuntimeSafety\"</span> {\n    <span class=\"tok-comment\">// The builtin applies to the scope that it is called in. So here, integer overflow</span>\n    <span class=\"tok-comment\">// will not be caught in ReleaseFast and ReleaseSmall modes:</span>\n    <span class=\"tok-comment\">// var x: u8 = 255;</span>\n    <span class=\"tok-comment\">// x += 1; // Unchecked Illegal Behavior in ReleaseFast/ReleaseSmall modes.</span>\n    {\n        <span class=\"tok-comment\">// However this block has safety enabled, so safety checks happen here,</span>\n        <span class=\"tok-comment\">// even in ReleaseFast and ReleaseSmall modes.</span>\n        <span class=\"tok-builtin\">@setRuntimeSafety</span>(<span class=\"tok-null\">true</span>);\n        <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n        x += <span class=\"tok-number\">1</span>;\n\n        {\n            <span class=\"tok-comment\">// The value can be overridden at any scope. So here integer overflow</span>\n            <span class=\"tok-comment\">// would not be caught in any build mode.</span>\n            <span class=\"tok-builtin\">@setRuntimeSafety</span>(<span class=\"tok-null\">false</span>);\n            <span class=\"tok-comment\">// var x: u8 = 255;</span>\n            <span class=\"tok-comment\">// x += 1; // Unchecked Illegal Behavior in all build modes.</span>\n        }\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@shlExact</span>(value: T, shift_amt: Log2T) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@shlWithOverflow</span>(a: <span class=\"tok-kw\">anytype</span>, shift_amt: Log2T) <span class=\"tok-kw\">struct</span> { <span class=\"tok-builtin\">@TypeOf</span>(a), <span class=\"tok-type\">u1</span> }",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@shrExact</span>(value: T, shift_amt: Log2T) T",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@shuffle</span>(<span class=\"tok-kw\">comptime</span> E: <span class=\"tok-type\">type</span>, a: <span class=\"tok-builtin\">@Vector</span>(a_len, E), b: <span class=\"tok-builtin\">@Vector</span>(b_len, E), <span class=\"tok-kw\">comptime</span> mask: <span class=\"tok-builtin\">@Vector</span>(mask_len, <span class=\"tok-type\">i32</span>)) <span class=\"tok-builtin\">@Vector</span>(mask_len, E)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"vector @shuffle\"</span> {\n    <span class=\"tok-kw\">const</span> a = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">7</span>, <span class=\"tok-type\">u8</span>){ <span class=\"tok-str\">'o'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'r'</span>, <span class=\"tok-str\">'z'</span>, <span class=\"tok-str\">'w'</span> };\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">u8</span>){ <span class=\"tok-str\">'w'</span>, <span class=\"tok-str\">'d'</span>, <span class=\"tok-str\">'!'</span>, <span class=\"tok-str\">'x'</span> };\n\n    <span class=\"tok-comment\">// To shuffle within a single vector, pass undefined as the second argument.</span>\n    <span class=\"tok-comment\">// Notice that we can re-order, duplicate, or omit elements of the input vector</span>\n    <span class=\"tok-kw\">const</span> mask1 = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">5</span>, <span class=\"tok-type\">i32</span>){ <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">1</span>, <span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span> };\n    <span class=\"tok-kw\">const</span> res1: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">5</span>, <span class=\"tok-type\">u8</span>) = <span class=\"tok-builtin\">@shuffle</span>(<span class=\"tok-type\">u8</span>, a, <span class=\"tok-null\">undefined</span>, mask1);\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, &<span class=\"tok-builtin\">@as</span>([<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span>, res1), <span class=\"tok-str\">\"hello\"</span>));\n\n    <span class=\"tok-comment\">// Combining two vectors</span>\n    <span class=\"tok-kw\">const</span> mask2 = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">6</span>, <span class=\"tok-type\">i32</span>){ -<span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">1</span>, -<span class=\"tok-number\">2</span>, -<span class=\"tok-number\">3</span> };\n    <span class=\"tok-kw\">const</span> res2: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">6</span>, <span class=\"tok-type\">u8</span>) = <span class=\"tok-builtin\">@shuffle</span>(<span class=\"tok-type\">u8</span>, a, b, mask2);\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, &<span class=\"tok-builtin\">@as</span>([<span class=\"tok-number\">6</span>]<span class=\"tok-type\">u8</span>, res2), <span class=\"tok-str\">\"world!\"</span>));\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@sizeOf</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">comptime_int</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@splat</span>(scalar: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"vector @splat\"</span> {\n    <span class=\"tok-kw\">const</span> scalar: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">5</span>;\n    <span class=\"tok-kw\">const</span> result: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">u32</span>) = <span class=\"tok-builtin\">@splat</span>(scalar);\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u32</span>, &<span class=\"tok-builtin\">@as</span>([<span class=\"tok-number\">4</span>]<span class=\"tok-type\">u32</span>, result), &[_]<span class=\"tok-type\">u32</span>{ <span class=\"tok-number\">5</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">5</span> }));\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"array @splat\"</span> {\n    <span class=\"tok-kw\">const</span> scalar: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">5</span>;\n    <span class=\"tok-kw\">const</span> result: [<span class=\"tok-number\">4</span>]<span class=\"tok-type\">u32</span> = <span class=\"tok-builtin\">@splat</span>(scalar);\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u32</span>, &<span class=\"tok-builtin\">@as</span>([<span class=\"tok-number\">4</span>]<span class=\"tok-type\">u32</span>, result), &[_]<span class=\"tok-type\">u32</span>{ <span class=\"tok-number\">5</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">5</span> }));\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@reduce</span>(<span class=\"tok-kw\">comptime</span> op: std.builtin.ReduceOp, value: <span class=\"tok-kw\">anytype</span>) E",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"vector @reduce\"</span> {\n    <span class=\"tok-kw\">const</span> V = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">const</span> value = V{ <span class=\"tok-number\">1</span>, -<span class=\"tok-number\">1</span>, <span class=\"tok-number\">1</span>, -<span class=\"tok-number\">1</span> };\n    <span class=\"tok-kw\">const</span> result = value > <span class=\"tok-builtin\">@as</span>(V, <span class=\"tok-builtin\">@splat</span>(<span class=\"tok-number\">0</span>));\n    <span class=\"tok-comment\">// result is { true, false, true, false };</span>\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(result) == <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">bool</span>));\n    <span class=\"tok-kw\">const</span> is_all_true = <span class=\"tok-builtin\">@reduce</span>(.And, result);\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(is_all_true) == <span class=\"tok-type\">bool</span>);\n    <span class=\"tok-kw\">try</span> expect(is_all_true == <span class=\"tok-null\">false</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@src</span>() std.builtin.SourceLocation",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@src\"</span> {\n    <span class=\"tok-kw\">try</span> doTheTest();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doTheTest</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> src = <span class=\"tok-builtin\">@src</span>();\n\n    <span class=\"tok-kw\">try</span> expect(src.line == <span class=\"tok-number\">9</span>);\n    <span class=\"tok-kw\">try</span> expect(src.column == <span class=\"tok-number\">17</span>);\n    <span class=\"tok-kw\">try</span> expect(std.mem.endsWith(<span class=\"tok-type\">u8</span>, src.fn_name, <span class=\"tok-str\">\"doTheTest\"</span>));\n    <span class=\"tok-kw\">try</span> expect(std.mem.endsWith(<span class=\"tok-type\">u8</span>, src.file, <span class=\"tok-str\">\"test_src_builtin.zig\"</span>));\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@sqrt</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@sin</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cos</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@tan</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@exp</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@exp2</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@log</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@log2</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@log10</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@abs</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@floor</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@ceil</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@trunc</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@round</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@round\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@round</span>(<span class=\"tok-number\">1.4</span>) == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@round</span>(<span class=\"tok-number\">1.5</span>) == <span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@round</span>(-<span class=\"tok-number\">1.4</span>) == -<span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@round</span>(-<span class=\"tok-number\">2.5</span>) == -<span class=\"tok-number\">3</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@subWithOverflow</span>(a: <span class=\"tok-kw\">anytype</span>, b: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">struct</span> { <span class=\"tok-builtin\">@TypeOf</span>(a, b), <span class=\"tok-type\">u1</span> }",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@tagName</span>(value: <span class=\"tok-kw\">anytype</span>) [:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@This</span>() <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@This()\"</span> {\n    <span class=\"tok-kw\">var</span> items = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n    <span class=\"tok-kw\">const</span> list = List(<span class=\"tok-type\">i32</span>){ .items = items[<span class=\"tok-number\">0</span>..] };\n    <span class=\"tok-kw\">try</span> expect(list.length() == <span class=\"tok-number\">4</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">List</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">struct</span> {\n        <span class=\"tok-kw\">const</span> Self = <span class=\"tok-builtin\">@This</span>();\n\n        items: []T,\n\n        <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">length</span>(self: Self) <span class=\"tok-type\">usize</span> {\n            <span class=\"tok-kw\">return</span> self.items.len;\n        }\n    };\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@trap</span>() <span class=\"tok-type\">noreturn</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@truncate</span>(integer: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"integer truncation\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u16</span> = <span class=\"tok-number\">0xabcd</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@truncate</span>(a);\n    <span class=\"tok-kw\">try</span> expect(b == <span class=\"tok-number\">0xcd</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@Type</span>(<span class=\"tok-kw\">comptime</span> info: std.builtin.Type) <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) std.builtin.Type",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@typeName</span>(T: <span class=\"tok-type\">type</span>) *<span class=\"tok-kw\">const</span> [N:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@TypeOf</span>(...) <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"no runtime side effects\"</span> {\n    <span class=\"tok-kw\">var</span> data: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">const</span> T = <span class=\"tok-builtin\">@TypeOf</span>(foo(<span class=\"tok-type\">i32</span>, &data));\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(T == <span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(data == <span class=\"tok-number\">0</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T) T {\n    ptr.* += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">return</span> ptr.*;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@unionInit</span>(<span class=\"tok-kw\">comptime</span> Union: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> active_field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, init_expr) Union",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@Vector</span>(len: <span class=\"tok-type\">comptime_int</span>, Element: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@volatileCast</span>(value: <span class=\"tok-kw\">anytype</span>) DestType",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@workGroupId</span>(<span class=\"tok-kw\">comptime</span> dimension: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@workGroupSize</span>(<span class=\"tok-kw\">comptime</span> dimension: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@workItemId</span>(<span class=\"tok-kw\">comptime</span> dimension: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Builtin Functions § in Zig 0.15.1",
    "context": "",
    "response": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the pointer operand. It is always valid to cast a pointer between the same address spaces. @addWithOverflow § Performs a + b and returns a tuple with the result and a possible overflow bit. @alignCast § ptr can be *T , ?*T , or []T . Changes the alignment of a pointer. The alignment to use is inferred based on the result type. A pointer alignment safety check is added to the generated code to make sure the pointer is aligned as promised. @alignOf § This function returns the number of bytes that this t",
    "metadata": {
      "version": "0.15.1",
      "topic": "Builtin Functions §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Build Mode §",
    "context": "Zig has four build modes: Debug (default) ReleaseFast ReleaseSafe ReleaseSmall To add standard build options to a build.zig file: build.zig This causes these options to be available: -Doptimize=Debug Optimizations off and safety on (default) -Doptimize=ReleaseSafe Optimizations on and safety on -Doptimize=ReleaseFast Optimizations on and safety off -Doptimize=ReleaseSmall Size optimizations on and safety off Debug § Shell Fast compilation speed Safety checks enabled Slow runtime performance Larg",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">build</span>(b: *std.Build) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> optimize = b.standardOptimizeOption(.{});\n    <span class=\"tok-kw\">const</span> exe = b.addExecutable(.{\n        .name = <span class=\"tok-str\">\"example\"</span>,\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(<span class=\"tok-str\">\"example.zig\"</span>),\n            .optimize = optimize,\n        }),\n    });\n    b.default_step.dependOn(&exe.step);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Build Mode §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Build Mode § in Zig 0.15.1",
    "context": "",
    "response": "Zig has four build modes: Debug (default) ReleaseFast ReleaseSafe ReleaseSmall To add standard build options to a build.zig file: build.zig This causes these options to be available: -Doptimize=Debug Optimizations off and safety on (default) -Doptimize=ReleaseSafe Optimizations on and safety on -Doptimize=ReleaseFast Optimizations on and safety off -Doptimize=ReleaseSmall Size optimizations on and safety off Debug § Shell Fast compilation speed Safety checks enabled Slow runtime performance Large binary size No reproducible build requirement ReleaseFast § Shell Fast runtime performance Safety checks disabled Slow compilation speed Large binary size Reproducible build ReleaseSafe § Shell Medium runtime performance Safety checks enabled Slow compilation speed Large binary size Reproducible build ReleaseSmall § Shell Medium runtime performance Safety checks disabled Slow compilation speed Small binary size Reproducible build See also: Compile Variables Zig Build System Illegal Behavior",
    "metadata": {
      "version": "0.15.1",
      "topic": "Build Mode §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Single Threaded Builds § in Zig 0.15.1",
    "context": "",
    "response": "Zig has a compile option -fsingle-threaded which has the following effects: All Thread Local Variables are treated as regular Container Level Variables . The overhead of Async Functions becomes equivalent to function call overhead. The @import ( &quot;builtin&quot; ).single_threaded becomes true and therefore various userland APIs which read this variable become more efficient. For example std.Mutex becomes an empty data structure and all of its functions become no-ops.",
    "metadata": {
      "version": "0.15.1",
      "topic": "Single Threaded Builds §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"safety check\"</span> {\n    <span class=\"tok-kw\">unreachable</span>;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    assert(<span class=\"tok-null\">false</span>);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">assert</span>(ok: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (!ok) <span class=\"tok-kw\">unreachable</span>; <span class=\"tok-comment\">// assertion failure</span>\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    std.debug.assert(<span class=\"tok-null\">false</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> array: [<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>.*;\n    <span class=\"tok-kw\">const</span> garbage = array[<span class=\"tok-number\">5</span>];\n    _ = garbage;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> x = foo(<span class=\"tok-str\">\"hello\"</span>);\n    _ = x;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(x: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">return</span> x[<span class=\"tok-number\">5</span>];\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> value: <span class=\"tok-type\">i32</span> = -<span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> unsigned: <span class=\"tok-type\">u32</span> = <span class=\"tok-builtin\">@intCast</span>(value);\n    _ = unsigned;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> value: <span class=\"tok-type\">i32</span> = -<span class=\"tok-number\">1</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &value;\n    <span class=\"tok-kw\">const</span> unsigned: <span class=\"tok-type\">u32</span> = <span class=\"tok-builtin\">@intCast</span>(value);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{unsigned});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> spartan_count: <span class=\"tok-type\">u16</span> = <span class=\"tok-number\">300</span>;\n    <span class=\"tok-kw\">const</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@intCast</span>(spartan_count);\n    _ = byte;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> spartan_count: <span class=\"tok-type\">u16</span> = <span class=\"tok-number\">300</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &spartan_count;\n    <span class=\"tok-kw\">const</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@intCast</span>(spartan_count);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{byte});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">var</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n    byte += <span class=\"tok-number\">1</span>;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n    byte += <span class=\"tok-number\">1</span>;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{byte});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> math = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).math;\n<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n\n    byte = <span class=\"tok-kw\">if</span> (math.add(<span class=\"tok-type\">u8</span>, byte, <span class=\"tok-number\">1</span>)) |result| result <span class=\"tok-kw\">else</span> |err| {\n        print(<span class=\"tok-str\">\"unable to add one: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@errorName</span>(err)});\n        <span class=\"tok-kw\">return</span> err;\n    };\n\n    print(<span class=\"tok-str\">\"result: {}\\n\"</span>, .{byte});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n\n    <span class=\"tok-kw\">const</span> ov = <span class=\"tok-builtin\">@addWithOverflow</span>(byte, <span class=\"tok-number\">10</span>);\n    <span class=\"tok-kw\">if</span> (ov[<span class=\"tok-number\">1</span>] != <span class=\"tok-number\">0</span>) {\n        print(<span class=\"tok-str\">\"overflowed result: {}\\n\"</span>, .{ov[<span class=\"tok-number\">0</span>]});\n    } <span class=\"tok-kw\">else</span> {\n        print(<span class=\"tok-str\">\"result: {}\\n\"</span>, .{ov[<span class=\"tok-number\">0</span>]});\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> minInt = std.math.minInt;\n<span class=\"tok-kw\">const</span> maxInt = std.math.maxInt;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"wraparound addition and subtraction\"</span> {\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">i32</span> = maxInt(<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">const</span> min_val = x +% <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(min_val == minInt(<span class=\"tok-type\">i32</span>));\n    <span class=\"tok-kw\">const</span> max_val = min_val -% <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(max_val == maxInt(<span class=\"tok-type\">i32</span>));\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> x = <span class=\"tok-builtin\">@shlExact</span>(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">0b01010101</span>), <span class=\"tok-number\">2</span>);\n    _ = x;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">0b01010101</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &x;\n    <span class=\"tok-kw\">const</span> y = <span class=\"tok-builtin\">@shlExact</span>(x, <span class=\"tok-number\">2</span>);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{y});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> x = <span class=\"tok-builtin\">@shrExact</span>(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">0b10101010</span>), <span class=\"tok-number\">2</span>);\n    _ = x;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">0b10101010</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &x;\n    <span class=\"tok-kw\">const</span> y = <span class=\"tok-builtin\">@shrExact</span>(x, <span class=\"tok-number\">2</span>);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{y});\n\n    <span class=\"tok-kw\">if</span> (builtin.cpu.arch.isRISCV() <span class=\"tok-kw\">and</span> builtin.zig_backend == .stage2_llvm) <span class=\"tok-builtin\">@panic</span>(<span class=\"tok-str\">\"https://github.com/ziglang/zig/issues/24304\"</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">const</span> c = a / b;\n    _ = c;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">var</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    _ = .{ &a, &b };\n    <span class=\"tok-kw\">const</span> c = a / b;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{c});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">const</span> c = a % b;\n    _ = c;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">var</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    _ = .{ &a, &b };\n    <span class=\"tok-kw\">const</span> c = a % b;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{c});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@divExact</span>(a, b);\n    _ = c;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">var</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">3</span>;\n    _ = .{ &a, &b };\n    <span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@divExact</span>(a, b);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{c});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> optional_number: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n    <span class=\"tok-kw\">const</span> number = optional_number.?;\n    _ = number;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> optional_number: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n    _ = &optional_number;\n    <span class=\"tok-kw\">const</span> number = optional_number.?;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{number});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> optional_number: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-kw\">if</span> (optional_number) |number| {\n        print(<span class=\"tok-str\">\"got number: {}\\n\"</span>, .{number});\n    } <span class=\"tok-kw\">else</span> {\n        print(<span class=\"tok-str\">\"it's null\\n\"</span>, .{});\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> number = getNumberOrFail() <span class=\"tok-kw\">catch</span> <span class=\"tok-kw\">unreachable</span>;\n    _ = number;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">getNumberOrFail</span>() !<span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.UnableToReturnNumber;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> number = getNumberOrFail() <span class=\"tok-kw\">catch</span> <span class=\"tok-kw\">unreachable</span>;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{number});\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">getNumberOrFail</span>() !<span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.UnableToReturnNumber;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> result = getNumberOrFail();\n\n    <span class=\"tok-kw\">if</span> (result) |number| {\n        print(<span class=\"tok-str\">\"got number: {}\\n\"</span>, .{number});\n    } <span class=\"tok-kw\">else</span> |err| {\n        print(<span class=\"tok-str\">\"got error: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@errorName</span>(err)});\n    }\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">getNumberOrFail</span>() !<span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.UnableToReturnNumber;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> err = <span class=\"tok-kw\">error</span>.AnError;\n    <span class=\"tok-kw\">const</span> number = <span class=\"tok-builtin\">@intFromError</span>(err) + <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">const</span> invalid_err = <span class=\"tok-builtin\">@errorFromInt</span>(number);\n    _ = invalid_err;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> err = <span class=\"tok-kw\">error</span>.AnError;\n    <span class=\"tok-kw\">var</span> number = <span class=\"tok-builtin\">@intFromError</span>(err) + <span class=\"tok-number\">500</span>;\n    _ = &number;\n    <span class=\"tok-kw\">const</span> invalid_err = <span class=\"tok-builtin\">@errorFromInt</span>(number);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{invalid_err});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">enum</span> {\n    a,\n    b,\n    c,\n};\n<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u2</span> = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">const</span> b: Foo = <span class=\"tok-builtin\">@enumFromInt</span>(a);\n    _ = b;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">enum</span> {\n    a,\n    b,\n    c,\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">u2</span> = <span class=\"tok-number\">3</span>;\n    _ = &a;\n    <span class=\"tok-kw\">const</span> b: Foo = <span class=\"tok-builtin\">@enumFromInt</span>(a);\n    std.debug.print(<span class=\"tok-str\">\"value: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@tagName</span>(b)});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> Set1 = <span class=\"tok-kw\">error</span>{\n    A,\n    B,\n};\n<span class=\"tok-kw\">const</span> Set2 = <span class=\"tok-kw\">error</span>{\n    A,\n    C,\n};\n<span class=\"tok-kw\">comptime</span> {\n    _ = <span class=\"tok-builtin\">@as</span>(Set2, <span class=\"tok-builtin\">@errorCast</span>(Set1.B));\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Set1 = <span class=\"tok-kw\">error</span>{\n    A,\n    B,\n};\n<span class=\"tok-kw\">const</span> Set2 = <span class=\"tok-kw\">error</span>{\n    A,\n    C,\n};\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    foo(Set1.B);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(set1: Set1) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> x: Set2 = <span class=\"tok-builtin\">@errorCast</span>(set1);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{x});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">1</span>) <span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0x1</span>);\n    <span class=\"tok-kw\">const</span> aligned: *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@alignCast</span>(ptr);\n    _ = aligned;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> array <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) = [_]<span class=\"tok-type\">u32</span>{ <span class=\"tok-number\">0x11111111</span>, <span class=\"tok-number\">0x11111111</span> };\n    <span class=\"tok-kw\">const</span> bytes = mem.sliceAsBytes(array[<span class=\"tok-number\">0</span>..]);\n    <span class=\"tok-kw\">if</span> (foo(bytes) != <span class=\"tok-number\">0x11111111</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.Wrong;\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(bytes: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">const</span> slice4 = bytes[<span class=\"tok-number\">1</span>..<span class=\"tok-number\">5</span>];\n    <span class=\"tok-kw\">const</span> int_slice = mem.bytesAsSlice(<span class=\"tok-type\">u32</span>, <span class=\"tok-builtin\">@as</span>([]<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">u8</span>, <span class=\"tok-builtin\">@alignCast</span>(slice4)));\n    <span class=\"tok-kw\">return</span> int_slice[<span class=\"tok-number\">0</span>];\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">var</span> f = Foo{ .int = <span class=\"tok-number\">42</span> };\n    f.float = <span class=\"tok-number\">12.34</span>;\n}\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">union</span> {\n    float: <span class=\"tok-type\">f32</span>,\n    int: <span class=\"tok-type\">u32</span>,\n};",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">union</span> {\n    float: <span class=\"tok-type\">f32</span>,\n    int: <span class=\"tok-type\">u32</span>,\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> f = Foo{ .int = <span class=\"tok-number\">42</span> };\n    bar(&f);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>(f: *Foo) <span class=\"tok-type\">void</span> {\n    f.float = <span class=\"tok-number\">12.34</span>;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{f.float});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">union</span> {\n    float: <span class=\"tok-type\">f32</span>,\n    int: <span class=\"tok-type\">u32</span>,\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> f = Foo{ .int = <span class=\"tok-number\">42</span> };\n    bar(&f);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>(f: *Foo) <span class=\"tok-type\">void</span> {\n    f.* = Foo{ .float = <span class=\"tok-number\">12.34</span> };\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{f.float});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">union</span> {\n    float: <span class=\"tok-type\">f32</span>,\n    int: <span class=\"tok-type\">u32</span>,\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> f = Foo{ .int = <span class=\"tok-number\">42</span> };\n    f = Foo{ .float = <span class=\"tok-null\">undefined</span> };\n    bar(&f);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{f.float});\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>(f: *Foo) <span class=\"tok-type\">void</span> {\n    f.float = <span class=\"tok-number\">12.34</span>;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> float: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">4294967296</span>;\n    <span class=\"tok-kw\">const</span> int: <span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@intFromFloat</span>(float);\n    _ = int;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> float: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">4294967296</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &float;\n    <span class=\"tok-kw\">const</span> int: <span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@intFromFloat</span>(float);\n    _ = int;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> opt_ptr: ?*<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrCast</span>(opt_ptr);\n    _ = ptr;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> opt_ptr: ?*<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n    _ = &opt_ptr;\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrCast</span>(opt_ptr);\n    _ = ptr;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Illegal Behavior § in Zig 0.15.1",
    "context": "",
    "response": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check \"fails\", which triggers a panic. All other Illegal Behavior is unchecked , meaning the compiler is unable to insert safety checks for it. If Unchecked Illegal Behavior is invoked at runtime, anything can happen: usually that will be some kind of crash, but the optimizer is free to make Unchecked Illegal Behavior do anything, such as calling arbitrary functions or clobbering arbitrary data. This is similar to the concept of \"undefined behavior\" in some other languages. Note that Unchecked Illega",
    "metadata": {
      "version": "0.15.1",
      "topic": "Illegal Behavior §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Memory §",
    "context": "The Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question: Where are the bytes? Like Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - malloc , realloc , ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> Allocator = std.mem.Allocator;\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"using an allocator\"</span> {\n    <span class=\"tok-kw\">var</span> buffer: [<span class=\"tok-number\">100</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">var</span> fba = std.heap.FixedBufferAllocator.init(&buffer);\n    <span class=\"tok-kw\">const</span> allocator = fba.allocator();\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">try</span> concat(allocator, <span class=\"tok-str\">\"foo\"</span>, <span class=\"tok-str\">\"bar\"</span>);\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-str\">\"foobar\"</span>, result));\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">concat</span>(allocator: Allocator, a: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, b: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) ![]<span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">try</span> allocator.alloc(<span class=\"tok-type\">u8</span>, a.len + b.len);\n    <span class=\"tok-builtin\">@memcpy</span>(result[<span class=\"tok-number\">0</span>..a.len], a);\n    <span class=\"tok-builtin\">@memcpy</span>(result[a.len..], b);\n    <span class=\"tok-kw\">return</span> result;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Memory §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Memory §",
    "context": "The Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question: Where are the bytes? Like Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - malloc , realloc , ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    <span class=\"tok-kw\">defer</span> arena.deinit();\n\n    <span class=\"tok-kw\">const</span> allocator = arena.allocator();\n\n    <span class=\"tok-kw\">const</span> ptr = <span class=\"tok-kw\">try</span> allocator.create(<span class=\"tok-type\">i32</span>);\n    std.debug.print(<span class=\"tok-str\">\"ptr={*}\\n\"</span>, .{ptr});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Memory §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Memory §",
    "context": "The Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question: Where are the bytes? Like Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - malloc , realloc , ",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(s: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    _ = s;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"string literal to mutable slice\"</span> {\n    foo(<span class=\"tok-str\">\"hello\"</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Memory §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Memory §",
    "context": "The Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question: Where are the bytes? Like Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - malloc , realloc , ",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(s: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    _ = s;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"string literal to constant slice\"</span> {\n    foo(<span class=\"tok-str\">\"hello\"</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Memory §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Memory § in Zig 0.15.1",
    "context": "",
    "response": "The Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question: Where are the bytes? Like Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - malloc , realloc , and free . When linking against libc, Zig exposes this allocator with std.heap.c_allocator . However, by convention, there is no default allocator in Zig. Instead, functions which need to allocate accept an Allocator parameter. Likewise, some data structures accept an Allocator parameter in their initialization functions: test_allocator.zig Shell In the above example, 100 bytes of stack memory are used to initialize a FixedBufferAllocator , which is then passed to a function. As a convenience th",
    "metadata": {
      "version": "0.15.1",
      "topic": "Memory §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Compile Variables §",
    "context": "Compile variables are accessible by importing the &quot;builtin&quot; package, which the compiler makes available to every Zig source file. It contains compile-time constants such as the current target, endianness, and release mode. compile_variables.zig Example of what is imported with @import ( &quot;builtin&quot; ) : @import(\"builtin\") See also: Build Mode",
    "response": "<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> separator = <span class=\"tok-kw\">if</span> (builtin.os.tag == .windows) <span class=\"tok-str\">'\\\\'</span> <span class=\"tok-kw\">else</span> <span class=\"tok-str\">'/'</span>;",
    "metadata": {
      "version": "0.15.1",
      "topic": "Compile Variables §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Compile Variables §",
    "context": "Compile variables are accessible by importing the &quot;builtin&quot; package, which the compiler makes available to every Zig source file. It contains compile-time constants such as the current target, endianness, and release mode. compile_variables.zig Example of what is imported with @import ( &quot;builtin&quot; ) : @import(\"builtin\") See also: Build Mode",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-comment\">/// Zig version. When writing code that supports multiple versions of Zig, prefer</span>\n<span class=\"tok-comment\">/// feature detection (i.e. with `@hasDecl` or `@hasField`) over version checks.</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> zig_version = std.SemanticVersion.parse(zig_version_string) <span class=\"tok-kw\">catch</span> <span class=\"tok-kw\">unreachable</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> zig_version_string = <span class=\"tok-str\">\"0.16.0-dev.1+cf5f8113c\"</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> zig_backend = std.builtin.CompilerBackend.stage2_x86_64;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> output_mode: std.builtin.OutputMode = .Exe;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> link_mode: std.builtin.LinkMode = .static;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> unwind_tables: std.builtin.UnwindTables = .async;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> is_test = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> single_threaded = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> abi: std.Target.Abi = .gnu;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> cpu: std.Target.Cpu = .{\n    .arch = .x86_64,\n    .model = &std.Target.x86.cpu.znver4,\n    .features = std.Target.x86.featureSet(&.{\n        .@\"64bit\",\n        .adx,\n        .aes,\n        .allow_light_256_bit,\n        .avx,\n        .avx2,\n        .avx512bf16,\n        .avx512bitalg,\n        .avx512bw,\n        .avx512cd,\n        .avx512dq,\n        .avx512f,\n        .avx512ifma,\n        .avx512vbmi,\n        .avx512vbmi2,\n        .avx512vl,\n        .avx512vnni,\n        .avx512vpopcntdq,\n        .bmi,\n        .bmi2,\n        .branchfusion,\n        .clflushopt,\n        .clwb,\n        .clzero,\n        .cmov,\n        .crc32,\n        .cx16,\n        .cx8,\n        .evex512,\n        .f16c,\n        .fast_15bytenop,\n        .fast_bextr,\n        .fast_dpwssd,\n        .fast_imm16,\n        .fast_lzcnt,\n        .fast_movbe,\n        .fast_scalar_fsqrt,\n        .fast_scalar_shift_masks,\n        .fast_variable_perlane_shuffle,\n        .fast_vector_fsqrt,\n        .fma,\n        .fsgsbase,\n        .fsrm,\n        .fxsr,\n        .gfni,\n        .idivq_to_divl,\n        .invpcid,\n        .lzcnt,\n        .macrofusion,\n        .mmx,\n        .movbe,\n        .mwaitx,\n        .nopl,\n        .pclmul,\n        .pku,\n        .popcnt,\n        .prfchw,\n        .rdpid,\n        .rdpru,\n        .rdrnd,\n        .rdseed,\n        .sahf,\n        .sbb_dep_breaking,\n        .sha,\n        .shstk,\n        .slow_shld,\n        .smap,\n        .smep,\n        .sse,\n        .sse2,\n        .sse3,\n        .sse4_1,\n        .sse4_2,\n        .sse4a,\n        .ssse3,\n        .vaes,\n        .vpclmulqdq,\n        .vzeroupper,\n        .wbnoinvd,\n        .x87,\n        .xsave,\n        .xsavec,\n        .xsaveopt,\n        .xsaves,\n    }),\n};\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> os: std.Target.Os = .{\n    .tag = .linux,\n    .version_range = .{ .linux = .{\n        .range = .{\n            .min = .{\n                .major = <span class=\"tok-number\">6</span>,\n                .minor = <span class=\"tok-number\">16</span>,\n                .patch = <span class=\"tok-number\">0</span>,\n            },\n            .max = .{\n                .major = <span class=\"tok-number\">6</span>,\n                .minor = <span class=\"tok-number\">16</span>,\n                .patch = <span class=\"tok-number\">0</span>,\n            },\n        },\n        .glibc = .{\n            .major = <span class=\"tok-number\">2</span>,\n            .minor = <span class=\"tok-number\">39</span>,\n            .patch = <span class=\"tok-number\">0</span>,\n        },\n        .android = <span class=\"tok-number\">29</span>,\n    }},\n};\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> target: std.Target = .{\n    .cpu = cpu,\n    .os = os,\n    .abi = abi,\n    .ofmt = object_format,\n    .dynamic_linker = .init(<span class=\"tok-str\">\"/nix/store/zdpby3l6azi78sl83cpad2qjpfj25aqx-glibc-2.40-66/lib/ld-linux-x86-64.so.2\"</span>),\n};\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> object_format: std.Target.ObjectFormat = .elf;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> mode: std.builtin.OptimizeMode = .Debug;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> link_libc = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> link_libcpp = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> have_error_return_tracing = <span class=\"tok-null\">true</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> valgrind_support = <span class=\"tok-null\">true</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> sanitize_thread = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> fuzz = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> position_independent_code = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> position_independent_executable = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> strip_debug_info = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> code_model: std.builtin.CodeModel = .default;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> omit_frame_pointer = <span class=\"tok-null\">false</span>;",
    "metadata": {
      "version": "0.15.1",
      "topic": "Compile Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Compile Variables § in Zig 0.15.1",
    "context": "",
    "response": "Compile variables are accessible by importing the &quot;builtin&quot; package, which the compiler makes available to every Zig source file. It contains compile-time constants such as the current target, endianness, and release mode. compile_variables.zig Example of what is imported with @import ( &quot;builtin&quot; ) : @import(\"builtin\") See also: Build Mode",
    "metadata": {
      "version": "0.15.1",
      "topic": "Compile Variables §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Compilation Model §",
    "context": "A Zig compilation is separated into modules . Each module is a collection of Zig source files, one of which is the module's root source file . Each module can depend on any number of other modules, forming a directed graph (dependency loops between modules are allowed). If module A depends on module B, then any Zig source file in module A can import the root source file of module B using @import with the module's name. In essence, a module acts as an alias to import a Zig source file (which migh",
    "response": "<span class=\"tok-comment\">//! Because this file contains fields, it is a type which is intended to be instantiated, and so</span>\n<span class=\"tok-comment\">//! is named in TitleCase instead of snake_case by convention.</span>\n\nfoo: <span class=\"tok-type\">u32</span>,\nbar: <span class=\"tok-type\">u64</span>,\n\n<span class=\"tok-comment\">/// `@This()` can be used to refer to this struct type. In files with fields, it is quite common to</span>\n<span class=\"tok-comment\">/// name the type here, so it can be easily referenced by other declarations in this file.</span>\n<span class=\"tok-kw\">const</span> TopLevelFields = <span class=\"tok-builtin\">@This</span>();\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">init</span>(val: <span class=\"tok-type\">u32</span>) TopLevelFields {\n    <span class=\"tok-kw\">return</span> .{\n        .foo = val,\n        .bar = val * <span class=\"tok-number\">10</span>,\n    };\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Compilation Model §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Compilation Model §",
    "context": "A Zig compilation is separated into modules . Each module is a collection of Zig source files, one of which is the module's root source file . Each module can depend on any number of other modules, forming a directed graph (dependency loops between modules are allowed). If module A depends on module B, then any Zig source file in module A can import the root source file of module B using @import with the module's name. In essence, a module acts as an alias to import a Zig source file (which migh",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-comment\">// This will ensure that the file 'api.zig' is always discovered (as long as this file is discovered).</span>\n    <span class=\"tok-comment\">// It is useful if 'api.zig' contains important exported declarations.</span>\n    _ = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"api.zig\"</span>);\n\n    <span class=\"tok-comment\">// We could also have a file which contains declarations we only want to export depending on a comptime</span>\n    <span class=\"tok-comment\">// condition. In that case, we can use an `if` statement here:</span>\n    <span class=\"tok-kw\">if</span> (builtin.os.tag == .windows) {\n        _ = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"windows_api.zig\"</span>);\n    }\n}\n\n<span class=\"tok-kw\">test</span> {\n    <span class=\"tok-comment\">// This will ensure that the file 'tests.zig' is always discovered (as long as this file is discovered),</span>\n    <span class=\"tok-comment\">// if this compilation is a test. It is useful if 'tests.zig' contains tests we want to ensure are run.</span>\n    _ = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"tests.zig\"</span>);\n\n    <span class=\"tok-comment\">// We could also have a file which contains tests we only want to run depending on a comptime condition.</span>\n    <span class=\"tok-comment\">// In that case, we can use an `if` statement here:</span>\n    <span class=\"tok-kw\">if</span> (builtin.os.tag == .windows) {\n        _ = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"windows_tests.zig\"</span>);\n    }\n}\n\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);",
    "metadata": {
      "version": "0.15.1",
      "topic": "Compilation Model §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Compilation Model §",
    "context": "A Zig compilation is separated into modules . Each module is a collection of Zig source files, one of which is the module's root source file . Each module can depend on any number of other modules, forming a directed graph (dependency loops between modules are allowed). If module A depends on module B, then any Zig source file in module A can import the root source file of module B using @import with the module's name. In essence, a module acts as an alias to import a Zig source file (which migh",
    "response": "<span class=\"tok-comment\">/// `std.start` imports this file using `@import(\"root\")`, and uses this declaration as the program's</span>\n<span class=\"tok-comment\">/// user-provided entry point. It can return any of the following types:</span>\n<span class=\"tok-comment\">/// * `void`</span>\n<span class=\"tok-comment\">/// * `E!void`, for any error set `E`</span>\n<span class=\"tok-comment\">/// * `u8`</span>\n<span class=\"tok-comment\">/// * `E!u8`, for any error set `E`</span>\n<span class=\"tok-comment\">/// Returning a `void` value from this function will exit with code 0.</span>\n<span class=\"tok-comment\">/// Returning a `u8` value from this function will exit with the given status code.</span>\n<span class=\"tok-comment\">/// Returning an error value from this function will print an Error Return Trace and exit with code 1.</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    std.debug.print(<span class=\"tok-str\">\"Hello, World!\\n\"</span>, .{});\n}\n\n<span class=\"tok-comment\">// If uncommented, this declaration would suppress the usual std.start logic, causing</span>\n<span class=\"tok-comment\">// the `main` declaration above to be ignored.</span>\n<span class=\"tok-comment\">//pub const _start = {};</span>\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);",
    "metadata": {
      "version": "0.15.1",
      "topic": "Compilation Model §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Compilation Model §",
    "context": "A Zig compilation is separated into modules . Each module is a collection of Zig source files, one of which is the module's root source file . Each module can depend on any number of other modules, forming a directed graph (dependency loops between modules are allowed). If module A depends on module B, then any Zig source file in module A can import the root source file of module B using @import with the module's name. In essence, a module acts as an alias to import a Zig source file (which migh",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>(argc: <span class=\"tok-type\">c_int</span>, argv: [*]<span class=\"tok-kw\">const</span> [*:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">c_int</span> {\n    <span class=\"tok-kw\">const</span> args = argv[<span class=\"tok-number\">0</span>..<span class=\"tok-builtin\">@intCast</span>(argc)];\n    std.debug.print(<span class=\"tok-str\">\"Hello! argv[0] is '{s}'\\n\"</span>, .{args[<span class=\"tok-number\">0</span>]});\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">0</span>;\n}\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);",
    "metadata": {
      "version": "0.15.1",
      "topic": "Compilation Model §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Compilation Model §",
    "context": "A Zig compilation is separated into modules . Each module is a collection of Zig source files, one of which is the module's root source file . Each module can depend on any number of other modules, forming a directed graph (dependency loops between modules are allowed). If module A depends on module B, then any Zig source file in module A can import the root source file of module B using @import with the module's name. In essence, a module acts as an alias to import a Zig source file (which migh",
    "response": "<span class=\"tok-comment\">/// The presence of this declaration allows the program to override certain behaviors of the standard library.</span>\n<span class=\"tok-comment\">/// For a full list of available options, see the documentation for `std.Options`.</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> std_options: std.Options = .{\n    <span class=\"tok-comment\">// By default, in safe build modes, the standard library will attach a segfault handler to the program to</span>\n    <span class=\"tok-comment\">// print a helpful stack trace if a segmentation fault occurs. Here, we can disable this, or even enable</span>\n    <span class=\"tok-comment\">// it in unsafe build modes.</span>\n    .enable_segfault_handler = <span class=\"tok-null\">true</span>,\n    <span class=\"tok-comment\">// This is the logging function used by `std.log`.</span>\n    .logFn = myLogFn,\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">myLogFn</span>(\n    <span class=\"tok-kw\">comptime</span> level: std.log.Level,\n    <span class=\"tok-kw\">comptime</span> scope: <span class=\"tok-builtin\">@Type</span>(.enum_literal),\n    <span class=\"tok-kw\">comptime</span> format: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>,\n    args: <span class=\"tok-kw\">anytype</span>,\n) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-comment\">// We could do anything we want here!</span>\n    <span class=\"tok-comment\">// ...but actually, let's just call the default implementation.</span>\n    std.log.defaultLog(level, scope, format, args);\n}\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);",
    "metadata": {
      "version": "0.15.1",
      "topic": "Compilation Model §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Compilation Model §",
    "context": "A Zig compilation is separated into modules . Each module is a collection of Zig source files, one of which is the module's root source file . Each module can depend on any number of other modules, forming a directed graph (dependency loops between modules are allowed). If module A depends on module B, then any Zig source file in module A can import the root source file of module B using @import with the module's name. In essence, a module acts as an alias to import a Zig source file (which migh",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-builtin\">@setRuntimeSafety</span>(<span class=\"tok-null\">true</span>);\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n    <span class=\"tok-comment\">// Let's overflow this integer!</span>\n    x += <span class=\"tok-number\">1</span>;\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> panic = std.debug.FullPanic(myPanic);\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">myPanic</span>(msg: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, first_trace_addr: ?<span class=\"tok-type\">usize</span>) <span class=\"tok-type\">noreturn</span> {\n    _ = first_trace_addr;\n    std.debug.print(<span class=\"tok-str\">\"Panic! {s}\\n\"</span>, .{msg});\n    std.process.exit(<span class=\"tok-number\">1</span>);\n}\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);",
    "metadata": {
      "version": "0.15.1",
      "topic": "Compilation Model §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Compilation Model § in Zig 0.15.1",
    "context": "",
    "response": "A Zig compilation is separated into modules . Each module is a collection of Zig source files, one of which is the module's root source file . Each module can depend on any number of other modules, forming a directed graph (dependency loops between modules are allowed). If module A depends on module B, then any Zig source file in module A can import the root source file of module B using @import with the module's name. In essence, a module acts as an alias to import a Zig source file (which might exist in a completely separate part of the filesystem). A simple Zig program compiled with zig build-exe has two key modules: the one containing your code, known as the \"main\" or \"root\" module, and the standard library. Your module depends on the standard library module under the name \"std\", which is what allows you to write @import ( &quot;std&quot; ) ! In fact, every single module in a Zig compilation &mdash; including the standard library itself &mdash; implicitly depends on the standard li",
    "metadata": {
      "version": "0.15.1",
      "topic": "Compilation Model §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Zig Build System § in Zig 0.15.1",
    "context": "",
    "response": "The Zig Build System provides a cross-platform, dependency-free way to declare the logic required to build a project. With this system, the logic to build a project is written in a build.zig file, using the Zig Build System API to declare and configure build artifacts and other tasks. Some examples of tasks the build system can help with: Performing tasks in parallel and caching the results. Depending on other projects. Providing a package for other projects to depend on. Creating build artifacts by executing the Zig compiler. This includes building Zig source code as well as C and C++ source code. Capturing user-configured options and using those options to configure the build. Surfacing build configuration as comptime values by providing a file that can be imported by Zig code. Caching build artifacts to avoid unnecessarily repeating steps. Executing build artifacts or system-installed tools. Running tests and verifying the output of executing a build artifact matches the expected va",
    "metadata": {
      "version": "0.15.1",
      "topic": "Zig Build System §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@cImport</span>({\n    <span class=\"tok-comment\">// See https://github.com/ziglang/zig/issues/515</span>\n    <span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"_NO_CRT_STDIO_INLINE\"</span>, <span class=\"tok-str\">\"1\"</span>);\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"stdio.h\"</span>);\n});\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    _ = c.printf(<span class=\"tok-str\">\"hello\\n\"</span>);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n\n<span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@cImport</span>({\n    <span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"NDEBUG\"</span>, builtin.mode == .ReleaseFast);\n    <span class=\"tok-kw\">if</span> (something) {\n        <span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"_GNU_SOURCE\"</span>, {});\n    }\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"stdlib.h\"</span>);\n    <span class=\"tok-kw\">if</span> (something) {\n        <span class=\"tok-builtin\">@cUndef</span>(<span class=\"tok-str\">\"_GNU_SOURCE\"</span>);\n    }\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"soundio.h\"</span>);\n});",
    "metadata": {
      "version": "0.15.1",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "long FOO = __LONG_MAX__;",
    "metadata": {
      "version": "0.15.1",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "enum FOO { BAR };\nint do_something(enum FOO foo);",
    "metadata": {
      "version": "0.15.1",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@cImport</span>({\n    <span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"_NO_CRT_STDIO_INLINE\"</span>, <span class=\"tok-str\">\"1\"</span>);\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"stdio.h\"</span>);\n});\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    _ = c;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "#define MAKELOCAL(NAME, INIT) int NAME = INIT\nint foo(void) {\n   MAKELOCAL(a, 1);\n   MAKELOCAL(b, 2);\n   return a + b;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">c_int</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">c_int</span> = <span class=\"tok-number\">1</span>;\n    _ = &a;\n    <span class=\"tok-kw\">var</span> b: <span class=\"tok-type\">c_int</span> = <span class=\"tok-number\">2</span>;\n    _ = &b;\n    <span class=\"tok-kw\">return</span> a + b;\n}\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> MAKELOCAL = <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"unable to translate C expr: unexpected token .Equal\"</span>); <span class=\"tok-comment\">// macro.c:1:9</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> testing = std.testing;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"c\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">printf</span>(format: [*:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, ...) <span class=\"tok-type\">c_int</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"variadic function\"</span> {\n    <span class=\"tok-kw\">try</span> testing.expect(printf(<span class=\"tok-str\">\"Hello, world!\\n\"</span>) == <span class=\"tok-number\">14</span>);\n    <span class=\"tok-kw\">try</span> testing.expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(printf)).@\"fn\".is_var_args);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> testing = std.testing;\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(count: <span class=\"tok-type\">c_int</span>, ...) <span class=\"tok-kw\">callconv</span>(.c) <span class=\"tok-type\">c_int</span> {\n    <span class=\"tok-kw\">var</span> ap = <span class=\"tok-builtin\">@cVaStart</span>();\n    <span class=\"tok-kw\">defer</span> <span class=\"tok-builtin\">@cVaEnd</span>(&ap);\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">c_int</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">while</span> (i < count) : (i += <span class=\"tok-number\">1</span>) {\n        sum += <span class=\"tok-builtin\">@cVaArg</span>(&ap, <span class=\"tok-type\">c_int</span>);\n    }\n    <span class=\"tok-kw\">return</span> sum;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"defining a variadic function\"</span> {\n    <span class=\"tok-kw\">if</span> (builtin.cpu.arch == .aarch64 <span class=\"tok-kw\">and</span> builtin.os.tag != .macos) {\n        <span class=\"tok-comment\">// https://github.com/ziglang/zig/issues/14096</span>\n        <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.SkipZigTest;\n    }\n    <span class=\"tok-kw\">if</span> (builtin.cpu.arch == .x86_64 <span class=\"tok-kw\">and</span> builtin.os.tag == .windows) {\n        <span class=\"tok-comment\">// https://github.com/ziglang/zig/issues/16961</span>\n        <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.SkipZigTest;\n    }\n\n    <span class=\"tok-kw\">try</span> std.testing.expectEqual(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">0</span>), add(<span class=\"tok-number\">0</span>));\n    <span class=\"tok-kw\">try</span> std.testing.expectEqual(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">1</span>), add(<span class=\"tok-number\">1</span>, <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">1</span>)));\n    <span class=\"tok-kw\">try</span> std.testing.expectEqual(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">3</span>), add(<span class=\"tok-number\">2</span>, <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">1</span>), <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">2</span>)));\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> a + b;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "// This header is generated by zig from mathtest.zig\n#include \"mathtest.h\"\n#include <stdio.h>\n\nint main(int argc, char **argv) {\n    int32_t result = add(42, 1337);\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">build</span>(b: *std.Build) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> lib = b.addLibrary(.{\n        .linkage = .dynamic,\n        .name = <span class=\"tok-str\">\"mathtest\"</span>,\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(<span class=\"tok-str\">\"mathtest.zig\"</span>),\n        }),\n        .version = .{ .major = <span class=\"tok-number\">1</span>, .minor = <span class=\"tok-number\">0</span>, .patch = <span class=\"tok-number\">0</span> },\n    });\n    <span class=\"tok-kw\">const</span> exe = b.addExecutable(.{\n        .name = <span class=\"tok-str\">\"test\"</span>,\n        .root_module = b.createModule(.{\n            .link_libc = <span class=\"tok-null\">true</span>,\n        }),\n    });\n    exe.root_module.addCSourceFile(.{ .file = b.path(<span class=\"tok-str\">\"test.c\"</span>), .flags = &.{<span class=\"tok-str\">\"-std=c99\"</span>} });\n    exe.root_module.linkLibrary(lib);\n\n    b.default_step.dependOn(&exe.step);\n\n    <span class=\"tok-kw\">const</span> run_cmd = exe.run();\n\n    <span class=\"tok-kw\">const</span> test_step = b.step(<span class=\"tok-str\">\"test\"</span>, <span class=\"tok-str\">\"Test the program\"</span>);\n    test_step.dependOn(&run_cmd.step);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> base64 = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).base64;\n\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">decode_base_64</span>(\n    dest_ptr: [*]<span class=\"tok-type\">u8</span>,\n    dest_len: <span class=\"tok-type\">usize</span>,\n    source_ptr: [*]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>,\n    source_len: <span class=\"tok-type\">usize</span>,\n) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">const</span> src = source_ptr[<span class=\"tok-number\">0</span>..source_len];\n    <span class=\"tok-kw\">const</span> dest = dest_ptr[<span class=\"tok-number\">0</span>..dest_len];\n    <span class=\"tok-kw\">const</span> base64_decoder = base64.standard.Decoder;\n    <span class=\"tok-kw\">const</span> decoded_size = base64_decoder.calcSizeForSlice(src) <span class=\"tok-kw\">catch</span> <span class=\"tok-kw\">unreachable</span>;\n    base64_decoder.decode(dest[<span class=\"tok-number\">0</span>..decoded_size], src) <span class=\"tok-kw\">catch</span> <span class=\"tok-kw\">unreachable</span>;\n    <span class=\"tok-kw\">return</span> decoded_size;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "// This header is generated by zig from base64.zig\n#include \"base64.h\"\n\n#include <string.h>\n#include <stdio.h>\n\nint main(int argc, char **argv) {\n    const char *encoded = \"YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz\";\n    char buf[200];\n\n    size_t len = decode_base_64(buf, 200, encoded, strlen(encoded));\n    buf[len] = 0;\n    puts(buf);\n\n    return 0;\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">build</span>(b: *std.Build) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> obj = b.addObject(.{\n        .name = <span class=\"tok-str\">\"base64\"</span>,\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(<span class=\"tok-str\">\"base64.zig\"</span>),\n        }),\n    });\n\n    <span class=\"tok-kw\">const</span> exe = b.addExecutable(.{\n        .name = <span class=\"tok-str\">\"test\"</span>,\n        .root_module = b.createModule(.{\n            .link_libc = <span class=\"tok-null\">true</span>,\n        }),\n    });\n    exe.root_module.addCSourceFile(.{ .file = b.path(<span class=\"tok-str\">\"test.c\"</span>), .flags = &.{<span class=\"tok-str\">\"-std=c99\"</span>} });\n    exe.root_module.addObject(obj);\n    b.installArtifact(exe);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain C § in Zig 0.15.1",
    "context": "",
    "response": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header File § The @cImport builtin function can be used to directly import symbols from .h files: cImport_builtin.zig Shell The @cImport function takes an expression as a parameter. This expression is evaluated at compile-time and is used to control preprocessor directives and include multiple .h files: @cImport Expression See also: @cImport @cInclude @cDefine @cUndef @import C Translation CLI § Zig's C translation capability is available as a CLI tool via zig translate-c . It requires a single filename ",
    "metadata": {
      "version": "0.15.1",
      "topic": "C §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: WebAssembly §",
    "context": "Zig supports building for WebAssembly out of the box. Freestanding § For host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs. math.zig Shell test.js Shell WASI § Zig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments: wasi_args.zig Shell Shell A more interesting exampl",
    "response": "<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">print</span>(<span class=\"tok-type\">i32</span>) <span class=\"tok-type\">void</span>;\n\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">void</span> {\n    print(a + b);\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "WebAssembly §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: WebAssembly §",
    "context": "Zig supports building for WebAssembly out of the box. Freestanding § For host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs. math.zig Shell test.js Shell WASI § Zig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments: wasi_args.zig Shell Shell A more interesting exampl",
    "response": "const fs = require('fs');\nconst source = fs.readFileSync(\"./math.wasm\");\nconst typedArray = new Uint8Array(source);\n\nWebAssembly.instantiate(typedArray, {\n  env: {\n    print: (result) => { console.log(`The result is ${result}`); }\n  }}).then(result => {\n  const add = result.instance.exports.add;\n  add(1, 2);\n});",
    "metadata": {
      "version": "0.15.1",
      "topic": "WebAssembly §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: WebAssembly §",
    "context": "Zig supports building for WebAssembly out of the box. Freestanding § For host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs. math.zig Shell test.js Shell WASI § Zig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments: wasi_args.zig Shell Shell A more interesting exampl",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> general_purpose_allocator: std.heap.GeneralPurposeAllocator(.{}) = .init;\n    <span class=\"tok-kw\">const</span> gpa = general_purpose_allocator.allocator();\n    <span class=\"tok-kw\">const</span> args = <span class=\"tok-kw\">try</span> std.process.argsAlloc(gpa);\n    <span class=\"tok-kw\">defer</span> std.process.argsFree(gpa, args);\n\n    <span class=\"tok-kw\">for</span> (args, <span class=\"tok-number\">0</span>..) |arg, i| {\n        std.debug.print(<span class=\"tok-str\">\"{}: {s}\\n\"</span>, .{ i, arg });\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "WebAssembly §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: WebAssembly §",
    "context": "Zig supports building for WebAssembly out of the box. Freestanding § For host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs. math.zig Shell test.js Shell WASI § Zig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments: wasi_args.zig Shell Shell A more interesting exampl",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> fs = std.fs;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> general_purpose_allocator: std.heap.GeneralPurposeAllocator(.{}) = .init;\n    <span class=\"tok-kw\">const</span> gpa = general_purpose_allocator.allocator();\n\n    <span class=\"tok-kw\">var</span> arena_instance = std.heap.ArenaAllocator.init(gpa);\n    <span class=\"tok-kw\">defer</span> arena_instance.deinit();\n    <span class=\"tok-kw\">const</span> arena = arena_instance.allocator();\n\n    <span class=\"tok-kw\">const</span> preopens = <span class=\"tok-kw\">try</span> fs.wasi.preopensAlloc(arena);\n\n    <span class=\"tok-kw\">for</span> (preopens.names, <span class=\"tok-number\">0</span>..) |preopen, i| {\n        std.debug.print(<span class=\"tok-str\">\"{}: {s}\\n\"</span>, .{ i, preopen });\n    }\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "WebAssembly §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain WebAssembly § in Zig 0.15.1",
    "context": "",
    "response": "Zig supports building for WebAssembly out of the box. Freestanding § For host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs. math.zig Shell test.js Shell WASI § Zig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments: wasi_args.zig Shell Shell A more interesting example would be extracting the list of preopens from the runtime. This is now supported in the standard library via std.fs.wasi.Preopens : wasi_preopens.zig Shell Shell",
    "metadata": {
      "version": "0.15.1",
      "topic": "WebAssembly §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Targets § in Zig 0.15.1",
    "context": "",
    "response": "Target refers to the computer that will be used to run an executable. It is composed of the CPU architecture, the set of enabled CPU features, operating system, minimum and maximum operating system version, ABI, and ABI version. Zig is a general-purpose programming language which means that it is designed to generate optimal code for a large set of targets. The command zig targets provides information about all of the targets the compiler is aware of. When no target option is provided to the compiler, the default choice is to target the host computer , meaning that the resulting executable will be unsuitable for copying to a different computer . In order to copy an executable to another computer, the compiler needs to know about the target requirements via the -target option. The Zig Standard Library ( @import ( &quot;std&quot; ) ) has cross-platform abstractions, making the same source code viable on many targets. Some code is more portable than other code. In general, Zig code is ext",
    "metadata": {
      "version": "0.15.1",
      "topic": "Targets §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Style Guide §",
    "context": "These coding conventions are not enforced by the compiler, but they are shipped in this documentation along with the compiler in order to provide a point of reference, should anyone wish to point to an authority on agreed upon Zig coding style. Avoid Redundancy in Names § Avoid these words in type names: Value Data Context Manager utils, misc, or somebody's initials Everything is a value, all types are data, everything is context, all logic manages state. Nothing is communicated by using a word ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> json = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> JsonValue = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n        number: <span class=\"tok-type\">f64</span>,\n        boolean: <span class=\"tok-type\">bool</span>,\n        <span class=\"tok-comment\">// ...</span>\n    };\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    std.debug.print(<span class=\"tok-str\">\"{s}\\n\"</span>, .{<span class=\"tok-builtin\">@typeName</span>(json.JsonValue)});\n}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Style Guide §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Style Guide §",
    "context": "These coding conventions are not enforced by the compiler, but they are shipped in this documentation along with the compiler in order to provide a point of reference, should anyone wish to point to an authority on agreed upon Zig coding style. Avoid Redundancy in Names § Avoid these words in type names: Value Data Context Manager utils, misc, or somebody's initials Everything is a value, all types are data, everything is context, all logic manages state. Nothing is communicated by using a word ",
    "response": "<span class=\"tok-kw\">const</span> namespace_name = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"dir_name/file_name.zig\"</span>);\n<span class=\"tok-kw\">const</span> TypeName = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"dir_name/TypeName.zig\"</span>);\n<span class=\"tok-kw\">var</span> global_var: <span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n<span class=\"tok-kw\">const</span> const_name = <span class=\"tok-number\">42</span>;\n<span class=\"tok-kw\">const</span> primitive_type_alias = <span class=\"tok-type\">f32</span>;\n<span class=\"tok-kw\">const</span> string_alias = []<span class=\"tok-type\">u8</span>;\n\n<span class=\"tok-kw\">const</span> StructName = <span class=\"tok-kw\">struct</span> {\n    field: <span class=\"tok-type\">i32</span>,\n};\n<span class=\"tok-kw\">const</span> StructAlias = StructName;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">functionName</span>(param_name: TypeName) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> functionPointer = functionName;\n    functionPointer();\n    functionPointer = otherFunction;\n    functionPointer();\n}\n<span class=\"tok-kw\">const</span> functionAlias = functionName;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">ListTemplateFunction</span>(<span class=\"tok-kw\">comptime</span> ChildType: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> fixed_size: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> List(ChildType, fixed_size);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">ShortList</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> n: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">struct</span> {\n        field_name: [n]T,\n        <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">methodName</span>() <span class=\"tok-type\">void</span> {}\n    };\n}\n\n<span class=\"tok-comment\">// The word XML loses its casing when used in Zig identifiers.</span>\n<span class=\"tok-kw\">const</span> xml_document =\n    <span class=\"tok-str\">\\\\<?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n    <span class=\"tok-str\">\\\\<document></span>\n    <span class=\"tok-str\">\\\\</document></span>\n;\n<span class=\"tok-kw\">const</span> XmlParser = <span class=\"tok-kw\">struct</span> {\n    field: <span class=\"tok-type\">i32</span>,\n};\n\n<span class=\"tok-comment\">// The initials BE (Big Endian) are just another word in Zig identifier names.</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">readU32Be</span>() <span class=\"tok-type\">u32</span> {}",
    "metadata": {
      "version": "0.15.1",
      "topic": "Style Guide §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Style Guide § in Zig 0.15.1",
    "context": "",
    "response": "These coding conventions are not enforced by the compiler, but they are shipped in this documentation along with the compiler in order to provide a point of reference, should anyone wish to point to an authority on agreed upon Zig coding style. Avoid Redundancy in Names § Avoid these words in type names: Value Data Context Manager utils, misc, or somebody's initials Everything is a value, all types are data, everything is context, all logic manages state. Nothing is communicated by using a word that applies to all types. Temptation to use \"utilities\", \"miscellaneous\", or somebody's initials is a failure to categorize, or more commonly, overcategorization. Such declarations can live at the root of a module that needs them with no namespace needed. Avoid Redundant Names in Fully-Qualified Namespaces § Every declaration is assigned a fully qualified namespace by the compiler, creating a tree structure. Choose names based on the fully-qualified namespace, and avoid redundant name segments.",
    "metadata": {
      "version": "0.15.1",
      "topic": "Style Guide §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Source Encoding § in Zig 0.15.1",
    "context": "",
    "response": "Zig source code is encoded in UTF-8. An invalid UTF-8 byte sequence results in a compile error. Throughout all zig source code (including in comments), some code points are never allowed: Ascii control characters, except for U+000a (LF), U+000d (CR), and U+0009 (HT): U+0000 - U+0008, U+000b - U+000c, U+000e - U+0001f, U+007f. Non-Ascii Unicode line endings: U+0085 (NEL), U+2028 (LS), U+2029 (PS). LF (byte value 0x0a, code point U+000a, '\\n' ) is the line terminator in Zig source code. This byte value terminates every line of zig source code except the last line of the file. It is recommended that non-empty source files end with an empty line, which means the last byte would be 0x0a (LF). Each LF may be immediately preceded by a single CR (byte value 0x0d, code point U+000d, '\\r' ) to form a Windows style line ending, but this is discouraged. Note that in multiline strings, CRLF sequences will be encoded as LF when compiled into a zig program. A CR in any other context is not allowed. H",
    "metadata": {
      "version": "0.15.1",
      "topic": "Source Encoding §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">addrspace</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">align</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">allowzero</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">and</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">anyframe</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">asm</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">break</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">callconv</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">catch</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">comptime</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">const</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">continue</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">defer</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">else</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">enum</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">errdefer</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">error</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">export</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">extern</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">fn</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">for</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">if</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">inline</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">linksection</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">noalias</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">noinline</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">nosuspend</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">opaque</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">or</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">orelse</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">packed</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">pub</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">resume</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">return</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">struct</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">suspend</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">switch</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">test</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">threadlocal</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">try</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">union</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">unreachable</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">var</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">volatile</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">while</span>",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Keyword Reference § in Zig 0.15.1",
    "context": "",
    "response": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function frames. See also Async Functions Function parameters can be declared with anytype in place of the type. The type will be inferred where the function is called. See also Function Parameter Type Inference asm begins an inline assembly expression. This allows for directly controlling the machine code generated on compilation. See also Assembly break can be used with a block label to return a value from the block. It can also be used to exit a loop before iteration completes naturally. See also Blocks ",
    "metadata": {
      "version": "0.15.1",
      "topic": "Keyword Reference §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.15.1 code for: Appendix §",
    "context": "Containers § A container in Zig is any syntactical construct that acts as a namespace to hold variable and function declarations. Containers are also type definitions which can be instantiated. Structs , enums , unions , opaques , and even Zig source files themselves are containers. Although containers (except Zig source files) use curly braces to surround their definition, they should not be confused with blocks or functions. Containers do not contain statements. Grammar § grammar.y Zen § Commu",
    "response": "Root <- skip container_doc_comment? ContainerMembers eof\n\n# *** Top level ***\nContainerMembers <- ContainerDeclaration* (ContainerField COMMA)* (ContainerField / ContainerDeclaration*)\n\nContainerDeclaration <- TestDecl / ComptimeDecl / doc_comment? KEYWORD_pub? Decl\n\nTestDecl <- KEYWORD_test (STRINGLITERALSINGLE / IDENTIFIER)? Block\n\nComptimeDecl <- KEYWORD_comptime Block\n\nDecl\n    <- (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE? / KEYWORD_inline / KEYWORD_noinline)? FnProto (SEMICOLON / Block)\n     / (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE?)? KEYWORD_threadlocal? GlobalVarDecl\n\nFnProto <- KEYWORD_fn IDENTIFIER? LPAREN ParamDeclList RPAREN ByteAlign? AddrSpace? LinkSection? CallConv? EXCLAMATIONMARK? TypeExpr\n\nVarDeclProto <- (KEYWORD_const / KEYWORD_var) IDENTIFIER (COLON TypeExpr)? ByteAlign? AddrSpace? LinkSection?\n\nGlobalVarDecl <- VarDeclProto (EQUAL Expr)? SEMICOLON\n\nContainerField <- doc_comment? KEYWORD_comptime? !KEYWORD_fn (IDENTIFIER COLON)? TypeExpr ByteAlign? (EQUAL Expr)?\n\n# *** Block Level ***\nStatement\n    <- KEYWORD_comptime ComptimeStatement\n     / KEYWORD_nosuspend BlockExprStatement\n     / KEYWORD_suspend BlockExprStatement\n     / KEYWORD_defer BlockExprStatement\n     / KEYWORD_errdefer Payload? BlockExprStatement\n     / IfStatement\n     / LabeledStatement\n     / SwitchExpr\n     / VarDeclExprStatement\n\nComptimeStatement\n    <- BlockExpr\n     / VarDeclExprStatement\n\nIfStatement\n    <- IfPrefix BlockExpr ( KEYWORD_else Payload? Statement )?\n     / IfPrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )\n\nLabeledStatement <- BlockLabel? (Block / LoopStatement)\n\nLoopStatement <- KEYWORD_inline? (ForStatement / WhileStatement)\n\nForStatement\n    <- ForPrefix BlockExpr ( KEYWORD_else Statement )?\n     / ForPrefix AssignExpr ( SEMICOLON / KEYWORD_else Statement )\n\nWhileStatement\n    <- WhilePrefix BlockExpr ( KEYWORD_else Payload? Statement )?\n     / WhilePrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )\n\nBlockExprStatement\n    <- BlockExpr\n     / AssignExpr SEMICOLON\n\nBlockExpr <- BlockLabel? Block\n\n# An expression, assignment, or any destructure, as a statement.\nVarDeclExprStatement\n    <- VarDeclProto (COMMA (VarDeclProto / Expr))* EQUAL Expr SEMICOLON\n     / Expr (AssignOp Expr / (COMMA (VarDeclProto / Expr))+ EQUAL Expr)? SEMICOLON\n\n# *** Expression Level ***\n\n# An assignment or a destructure whose LHS are all lvalue expressions.\nAssignExpr <- Expr (AssignOp Expr / (COMMA Expr)+ EQUAL Expr)?\n\nSingleAssignExpr <- Expr (AssignOp Expr)?\n\nExpr <- BoolOrExpr\n\nBoolOrExpr <- BoolAndExpr (KEYWORD_or BoolAndExpr)*\n\nBoolAndExpr <- CompareExpr (KEYWORD_and CompareExpr)*\n\nCompareExpr <- BitwiseExpr (CompareOp BitwiseExpr)?\n\nBitwiseExpr <- BitShiftExpr (BitwiseOp BitShiftExpr)*\n\nBitShiftExpr <- AdditionExpr (BitShiftOp AdditionExpr)*\n\nAdditionExpr <- MultiplyExpr (AdditionOp MultiplyExpr)*\n\nMultiplyExpr <- PrefixExpr (MultiplyOp PrefixExpr)*\n\nPrefixExpr <- PrefixOp* PrimaryExpr\n\nPrimaryExpr\n    <- AsmExpr\n     / IfExpr\n     / KEYWORD_break BreakLabel? Expr?\n     / KEYWORD_comptime Expr\n     / KEYWORD_nosuspend Expr\n     / KEYWORD_continue BreakLabel?\n     / KEYWORD_resume Expr\n     / KEYWORD_return Expr?\n     / BlockLabel? LoopExpr\n     / Block\n     / CurlySuffixExpr\n\nIfExpr <- IfPrefix Expr (KEYWORD_else Payload? Expr)?\n\nBlock <- LBRACE Statement* RBRACE\n\nLoopExpr <- KEYWORD_inline? (ForExpr / WhileExpr)\n\nForExpr <- ForPrefix Expr (KEYWORD_else Expr)?\n\nWhileExpr <- WhilePrefix Expr (KEYWORD_else Payload? Expr)?\n\nCurlySuffixExpr <- TypeExpr InitList?\n\nInitList\n    <- LBRACE FieldInit (COMMA FieldInit)* COMMA? RBRACE\n     / LBRACE Expr (COMMA Expr)* COMMA? RBRACE\n     / LBRACE RBRACE\n\nTypeExpr <- PrefixTypeOp* ErrorUnionExpr\n\nErrorUnionExpr <- SuffixExpr (EXCLAMATIONMARK TypeExpr)?\n\nSuffixExpr\n    <- PrimaryTypeExpr (SuffixOp / FnCallArguments)*\n\nPrimaryTypeExpr\n    <- BUILTINIDENTIFIER FnCallArguments\n     / CHAR_LITERAL\n     / ContainerDecl\n     / DOT IDENTIFIER\n     / DOT InitList\n     / ErrorSetDecl\n     / FLOAT\n     / FnProto\n     / GroupedExpr\n     / LabeledTypeExpr\n     / IDENTIFIER\n     / IfTypeExpr\n     / INTEGER\n     / KEYWORD_comptime TypeExpr\n     / KEYWORD_error DOT IDENTIFIER\n     / KEYWORD_anyframe\n     / KEYWORD_unreachable\n     / STRINGLITERAL\n     / SwitchExpr\n\nContainerDecl <- (KEYWORD_extern / KEYWORD_packed)? ContainerDeclAuto\n\nErrorSetDecl <- KEYWORD_error LBRACE IdentifierList RBRACE\n\nGroupedExpr <- LPAREN Expr RPAREN\n\nIfTypeExpr <- IfPrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?\n\nLabeledTypeExpr\n    <- BlockLabel Block\n     / BlockLabel? LoopTypeExpr\n\nLoopTypeExpr <- KEYWORD_inline? (ForTypeExpr / WhileTypeExpr)\n\nForTypeExpr <- ForPrefix TypeExpr (KEYWORD_else TypeExpr)?\n\nWhileTypeExpr <- WhilePrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?\n\nSwitchExpr <- KEYWORD_switch LPAREN Expr RPAREN LBRACE SwitchProngList RBRACE\n\n# *** Assembly ***\nAsmExpr <- KEYWORD_asm KEYWORD_volatile? LPAREN Expr AsmOutput? RPAREN\n\nAsmOutput <- COLON AsmOutputList AsmInput?\n\nAsmOutputItem <- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN (MINUSRARROW TypeExpr / IDENTIFIER) RPAREN\n\nAsmInput <- COLON AsmInputList AsmClobbers?\n\nAsmInputItem <- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN Expr RPAREN\n\nAsmClobbers <- COLON Expr\n\n# *** Helper grammar ***\nBreakLabel <- COLON IDENTIFIER\n\nBlockLabel <- IDENTIFIER COLON\n\nFieldInit <- DOT IDENTIFIER EQUAL Expr\n\nWhileContinueExpr <- COLON LPAREN AssignExpr RPAREN\n\nLinkSection <- KEYWORD_linksection LPAREN Expr RPAREN\n\nAddrSpace <- KEYWORD_addrspace LPAREN Expr RPAREN\n\n# Fn specific\nCallConv <- KEYWORD_callconv LPAREN Expr RPAREN\n\nParamDecl\n    <- doc_comment? (KEYWORD_noalias / KEYWORD_comptime)? (IDENTIFIER COLON)? ParamType\n     / DOT3\n\nParamType\n    <- KEYWORD_anytype\n     / TypeExpr\n\n# Control flow prefixes\nIfPrefix <- KEYWORD_if LPAREN Expr RPAREN PtrPayload?\n\nWhilePrefix <- KEYWORD_while LPAREN Expr RPAREN PtrPayload? WhileContinueExpr?\n\nForPrefix <- KEYWORD_for LPAREN ForArgumentsList RPAREN PtrListPayload\n\n# Payloads\nPayload <- PIPE IDENTIFIER PIPE\n\nPtrPayload <- PIPE ASTERISK? IDENTIFIER PIPE\n\nPtrIndexPayload <- PIPE ASTERISK? IDENTIFIER (COMMA IDENTIFIER)? PIPE\n\nPtrListPayload <- PIPE ASTERISK? IDENTIFIER (COMMA ASTERISK? IDENTIFIER)* COMMA? PIPE\n\n# Switch specific\nSwitchProng <- KEYWORD_inline? SwitchCase EQUALRARROW PtrIndexPayload? SingleAssignExpr\n\nSwitchCase\n    <- SwitchItem (COMMA SwitchItem)* COMMA?\n     / KEYWORD_else\n\nSwitchItem <- Expr (DOT3 Expr)?\n\n# For specific\nForArgumentsList <- ForItem (COMMA ForItem)* COMMA?\n\nForItem <- Expr (DOT2 Expr?)?\n\n# Operators\nAssignOp\n    <- ASTERISKEQUAL\n     / ASTERISKPIPEEQUAL\n     / SLASHEQUAL\n     / PERCENTEQUAL\n     / PLUSEQUAL\n     / PLUSPIPEEQUAL\n     / MINUSEQUAL\n     / MINUSPIPEEQUAL\n     / LARROW2EQUAL\n     / LARROW2PIPEEQUAL\n     / RARROW2EQUAL\n     / AMPERSANDEQUAL\n     / CARETEQUAL\n     / PIPEEQUAL\n     / ASTERISKPERCENTEQUAL\n     / PLUSPERCENTEQUAL\n     / MINUSPERCENTEQUAL\n     / EQUAL\n\nCompareOp\n    <- EQUALEQUAL\n     / EXCLAMATIONMARKEQUAL\n     / LARROW\n     / RARROW\n     / LARROWEQUAL\n     / RARROWEQUAL\n\nBitwiseOp\n    <- AMPERSAND\n     / CARET\n     / PIPE\n     / KEYWORD_orelse\n     / KEYWORD_catch Payload?\n\nBitShiftOp\n    <- LARROW2\n     / RARROW2\n     / LARROW2PIPE\n\nAdditionOp\n    <- PLUS\n     / MINUS\n     / PLUS2\n     / PLUSPERCENT\n     / MINUSPERCENT\n     / PLUSPIPE\n     / MINUSPIPE\n\nMultiplyOp\n    <- PIPE2\n     / ASTERISK\n     / SLASH\n     / PERCENT\n     / ASTERISK2\n     / ASTERISKPERCENT\n     / ASTERISKPIPE\n\nPrefixOp\n    <- EXCLAMATIONMARK\n     / MINUS\n     / TILDE\n     / MINUSPERCENT\n     / AMPERSAND\n     / KEYWORD_try\n\nPrefixTypeOp\n    <- QUESTIONMARK\n     / KEYWORD_anyframe MINUSRARROW\n     / SliceTypeStart (ByteAlign / AddrSpace / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*\n     / PtrTypeStart (AddrSpace / KEYWORD_align LPAREN Expr (COLON Expr COLON Expr)? RPAREN / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*\n     / ArrayTypeStart\n\nSuffixOp\n    <- LBRACKET Expr (DOT2 (Expr? (COLON Expr)?)?)? RBRACKET\n     / DOT IDENTIFIER\n     / DOTASTERISK\n     / DOTQUESTIONMARK\n\nFnCallArguments <- LPAREN ExprList RPAREN\n\n# Ptr specific\nSliceTypeStart <- LBRACKET (COLON Expr)? RBRACKET\n\nPtrTypeStart\n    <- ASTERISK\n     / ASTERISK2\n     / LBRACKET ASTERISK (LETTERC / COLON Expr)? RBRACKET\n\nArrayTypeStart <- LBRACKET Expr (COLON Expr)? RBRACKET\n\n# ContainerDecl specific\nContainerDeclAuto <- ContainerDeclType LBRACE container_doc_comment? ContainerMembers RBRACE\n\nContainerDeclType\n    <- KEYWORD_struct (LPAREN Expr RPAREN)?\n     / KEYWORD_opaque\n     / KEYWORD_enum (LPAREN Expr RPAREN)?\n     / KEYWORD_union (LPAREN (KEYWORD_enum (LPAREN Expr RPAREN)? / Expr) RPAREN)?\n\n# Alignment\nByteAlign <- KEYWORD_align LPAREN Expr RPAREN\n\n# Lists\nIdentifierList <- (doc_comment? IDENTIFIER COMMA)* (doc_comment? IDENTIFIER)?\n\nSwitchProngList <- (SwitchProng COMMA)* SwitchProng?\n\nAsmOutputList <- (AsmOutputItem COMMA)* AsmOutputItem?\n\nAsmInputList <- (AsmInputItem COMMA)* AsmInputItem?\n\nStringList <- (STRINGLITERAL COMMA)* STRINGLITERAL?\n\nParamDeclList <- (ParamDecl COMMA)* ParamDecl?\n\nExprList <- (Expr COMMA)* Expr?\n\n# *** Tokens ***\neof <- !.\nbin <- [01]\nbin_ <- '_'? bin\noct <- [0-7]\noct_ <- '_'? oct\nhex <- [0-9a-fA-F]\nhex_ <- '_'? hex\ndec <- [0-9]\ndec_ <- '_'? dec\n\nbin_int <- bin bin_*\noct_int <- oct oct_*\ndec_int <- dec dec_*\nhex_int <- hex hex_*\n\nox80_oxBF <- [\\200-\\277]\noxF4 <- '\\364'\nox80_ox8F <- [\\200-\\217]\noxF1_oxF3 <- [\\361-\\363]\noxF0 <- '\\360'\nox90_0xBF <- [\\220-\\277]\noxEE_oxEF <- [\\356-\\357]\noxED <- '\\355'\nox80_ox9F <- [\\200-\\237]\noxE1_oxEC <- [\\341-\\354]\noxE0 <- '\\340'\noxA0_oxBF <- [\\240-\\277]\noxC2_oxDF <- [\\302-\\337]\n\n# From https://lemire.me/blog/2018/05/09/how-quickly-can-you-check-that-a-string-is-valid-unicode-utf-8/\n# First Byte      Second Byte     Third Byte      Fourth Byte\n# [0x00,0x7F]\n# [0xC2,0xDF]     [0x80,0xBF]\n#    0xE0         [0xA0,0xBF]     [0x80,0xBF]\n# [0xE1,0xEC]     [0x80,0xBF]     [0x80,0xBF]\n#    0xED         [0x80,0x9F]     [0x80,0xBF]\n# [0xEE,0xEF]     [0x80,0xBF]     [0x80,0xBF]\n#    0xF0         [0x90,0xBF]     [0x80,0xBF]     [0x80,0xBF]\n# [0xF1,0xF3]     [0x80,0xBF]     [0x80,0xBF]     [0x80,0xBF]\n#    0xF4         [0x80,0x8F]     [0x80,0xBF]     [0x80,0xBF]\n\nmb_utf8_literal <-\n       oxF4      ox80_ox8F ox80_oxBF ox80_oxBF\n     / oxF1_oxF3 ox80_oxBF ox80_oxBF ox80_oxBF\n     / oxF0      ox90_0xBF ox80_oxBF ox80_oxBF\n     / oxEE_oxEF ox80_oxBF ox80_oxBF\n     / oxED      ox80_ox9F ox80_oxBF\n     / oxE1_oxEC ox80_oxBF ox80_oxBF\n     / oxE0      oxA0_oxBF ox80_oxBF\n     / oxC2_oxDF ox80_oxBF\n\nascii_char_not_nl_slash_squote <- [\\000-\\011\\013-\\046\\050-\\133\\135-\\177]\n\nchar_escape\n    <- \"\\\\x\" hex hex\n     / \"\\\\u{\" hex+ \"}\"\n     / \"\\\\\" [nr\\\\t'\"]\nchar_char\n    <- mb_utf8_literal\n     / char_escape\n     / ascii_char_not_nl_slash_squote\n\nstring_char\n    <- char_escape\n     / [^\\\\\"\\n]\n\ncontainer_doc_comment <- ('//!' [^\\n]* [ \\n]* skip)+\ndoc_comment <- ('///' [^\\n]* [ \\n]* skip)+\nline_comment <- '//' ![!/][^\\n]* / '////' [^\\n]*\nline_string <- (\"\\\\\\\\\" [^\\n]* [ \\n]*)+\nskip <- ([ \\n] / line_comment)*\n\nCHAR_LITERAL <- \"'\" char_char \"'\" skip\nFLOAT\n    <- \"0x\" hex_int \".\" hex_int ([pP] [-+]? dec_int)? skip\n     /      dec_int \".\" dec_int ([eE] [-+]? dec_int)? skip\n     / \"0x\" hex_int [pP] [-+]? dec_int skip\n     /      dec_int [eE] [-+]? dec_int skip\nINTEGER\n    <- \"0b\" bin_int skip\n     / \"0o\" oct_int skip\n     / \"0x\" hex_int skip\n     /      dec_int   skip\nSTRINGLITERALSINGLE <- \"\\\"\" string_char* \"\\\"\" skip\nSTRINGLITERAL\n    <- STRINGLITERALSINGLE\n     / (line_string                 skip)+\nIDENTIFIER\n    <- !keyword [A-Za-z_] [A-Za-z0-9_]* skip\n     / \"@\" STRINGLITERALSINGLE\nBUILTINIDENTIFIER <- \"@\"[A-Za-z_][A-Za-z0-9_]* skip\n\n\nAMPERSAND            <- '&'      ![=]      skip\nAMPERSANDEQUAL       <- '&='               skip\nASTERISK             <- '*'      ![*%=|]   skip\nASTERISK2            <- '**'               skip\nASTERISKEQUAL        <- '*='               skip\nASTERISKPERCENT      <- '*%'     ![=]      skip\nASTERISKPERCENTEQUAL <- '*%='              skip\nASTERISKPIPE         <- '*|'     ![=]      skip\nASTERISKPIPEEQUAL    <- '*|='              skip\nCARET                <- '^'      ![=]      skip\nCARETEQUAL           <- '^='               skip\nCOLON                <- ':'                skip\nCOMMA                <- ','                skip\nDOT                  <- '.'      ![*.?]    skip\nDOT2                 <- '..'     ![.]      skip\nDOT3                 <- '...'              skip\nDOTASTERISK          <- '.*'               skip\nDOTQUESTIONMARK      <- '.?'               skip\nEQUAL                <- '='      ![>=]     skip\nEQUALEQUAL           <- '=='               skip\nEQUALRARROW          <- '=>'               skip\nEXCLAMATIONMARK      <- '!'      ![=]      skip\nEXCLAMATIONMARKEQUAL <- '!='               skip\nLARROW               <- '<'      ![<=]     skip\nLARROW2              <- '<<'     ![=|]     skip\nLARROW2EQUAL         <- '<<='              skip\nLARROW2PIPE          <- '<<|'    ![=]      skip\nLARROW2PIPEEQUAL     <- '<<|='             skip\nLARROWEQUAL          <- '<='               skip\nLBRACE               <- '{'                skip\nLBRACKET             <- '['                skip\nLPAREN               <- '('                skip\nMINUS                <- '-'      ![%=>|]   skip\nMINUSEQUAL           <- '-='               skip\nMINUSPERCENT         <- '-%'     ![=]      skip\nMINUSPERCENTEQUAL    <- '-%='              skip\nMINUSPIPE            <- '-|'     ![=]      skip\nMINUSPIPEEQUAL       <- '-|='              skip\nMINUSRARROW          <- '->'               skip\nPERCENT              <- '%'      ![=]      skip\nPERCENTEQUAL         <- '%='               skip\nPIPE                 <- '|'      ![|=]     skip\nPIPE2                <- '||'               skip\nPIPEEQUAL            <- '|='               skip\nPLUS                 <- '+'      ![%+=|]   skip\nPLUS2                <- '++'               skip\nPLUSEQUAL            <- '+='               skip\nPLUSPERCENT          <- '+%'     ![=]      skip\nPLUSPERCENTEQUAL     <- '+%='              skip\nPLUSPIPE             <- '+|'     ![=]      skip\nPLUSPIPEEQUAL        <- '+|='              skip\nLETTERC              <- 'c'                skip\nQUESTIONMARK         <- '?'                skip\nRARROW               <- '>'      ![>=]     skip\nRARROW2              <- '>>'     ![=]      skip\nRARROW2EQUAL         <- '>>='              skip\nRARROWEQUAL          <- '>='               skip\nRBRACE               <- '}'                skip\nRBRACKET             <- ']'                skip\nRPAREN               <- ')'                skip\nSEMICOLON            <- ';'                skip\nSLASH                <- '/'      ![=]      skip\nSLASHEQUAL           <- '/='               skip\nTILDE                <- '~'                skip\n\nend_of_word <- ![a-zA-Z0-9_] skip\nKEYWORD_addrspace   <- 'addrspace'   end_of_word\nKEYWORD_align       <- 'align'       end_of_word\nKEYWORD_allowzero   <- 'allowzero'   end_of_word\nKEYWORD_and         <- 'and'         end_of_word\nKEYWORD_anyframe    <- 'anyframe'    end_of_word\nKEYWORD_anytype     <- 'anytype'     end_of_word\nKEYWORD_asm         <- 'asm'         end_of_word\nKEYWORD_break       <- 'break'       end_of_word\nKEYWORD_callconv    <- 'callconv'    end_of_word\nKEYWORD_catch       <- 'catch'       end_of_word\nKEYWORD_comptime    <- 'comptime'    end_of_word\nKEYWORD_const       <- 'const'       end_of_word\nKEYWORD_continue    <- 'continue'    end_of_word\nKEYWORD_defer       <- 'defer'       end_of_word\nKEYWORD_else        <- 'else'        end_of_word\nKEYWORD_enum        <- 'enum'        end_of_word\nKEYWORD_errdefer    <- 'errdefer'    end_of_word\nKEYWORD_error       <- 'error'       end_of_word\nKEYWORD_export      <- 'export'      end_of_word\nKEYWORD_extern      <- 'extern'      end_of_word\nKEYWORD_fn          <- 'fn'          end_of_word\nKEYWORD_for         <- 'for'         end_of_word\nKEYWORD_if          <- 'if'          end_of_word\nKEYWORD_inline      <- 'inline'      end_of_word\nKEYWORD_noalias     <- 'noalias'     end_of_word\nKEYWORD_nosuspend   <- 'nosuspend'   end_of_word\nKEYWORD_noinline    <- 'noinline'    end_of_word\nKEYWORD_opaque      <- 'opaque'      end_of_word\nKEYWORD_or          <- 'or'          end_of_word\nKEYWORD_orelse      <- 'orelse'      end_of_word\nKEYWORD_packed      <- 'packed'      end_of_word\nKEYWORD_pub         <- 'pub'         end_of_word\nKEYWORD_resume      <- 'resume'      end_of_word\nKEYWORD_return      <- 'return'      end_of_word\nKEYWORD_linksection <- 'linksection' end_of_word\nKEYWORD_struct      <- 'struct'      end_of_word\nKEYWORD_suspend     <- 'suspend'     end_of_word\nKEYWORD_switch      <- 'switch'      end_of_word\nKEYWORD_test        <- 'test'        end_of_word\nKEYWORD_threadlocal <- 'threadlocal' end_of_word\nKEYWORD_try         <- 'try'         end_of_word\nKEYWORD_union       <- 'union'       end_of_word\nKEYWORD_unreachable <- 'unreachable' end_of_word\nKEYWORD_var         <- 'var'         end_of_word\nKEYWORD_volatile    <- 'volatile'    end_of_word\nKEYWORD_while       <- 'while'       end_of_word\n\nkeyword <- KEYWORD_addrspace / KEYWORD_align / KEYWORD_allowzero / KEYWORD_and\n         / KEYWORD_anyframe / KEYWORD_anytype / KEYWORD_asm\n         / KEYWORD_break / KEYWORD_callconv / KEYWORD_catch\n         / KEYWORD_comptime / KEYWORD_const / KEYWORD_continue / KEYWORD_defer\n         / KEYWORD_else / KEYWORD_enum / KEYWORD_errdefer / KEYWORD_error / KEYWORD_export\n         / KEYWORD_extern / KEYWORD_fn / KEYWORD_for / KEYWORD_if\n         / KEYWORD_inline / KEYWORD_noalias / KEYWORD_nosuspend / KEYWORD_noinline\n         / KEYWORD_opaque / KEYWORD_or / KEYWORD_orelse / KEYWORD_packed\n         / KEYWORD_pub / KEYWORD_resume / KEYWORD_return / KEYWORD_linksection\n         / KEYWORD_struct / KEYWORD_suspend / KEYWORD_switch / KEYWORD_test\n         / KEYWORD_threadlocal / KEYWORD_try / KEYWORD_union / KEYWORD_unreachable\n         / KEYWORD_var / KEYWORD_volatile / KEYWORD_while",
    "metadata": {
      "version": "0.15.1",
      "topic": "Appendix §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Appendix § in Zig 0.15.1",
    "context": "",
    "response": "Containers § A container in Zig is any syntactical construct that acts as a namespace to hold variable and function declarations. Containers are also type definitions which can be instantiated. Structs , enums , unions , opaques , and even Zig source files themselves are containers. Although containers (except Zig source files) use curly braces to surround their definition, they should not be confused with blocks or functions. Containers do not contain statements. Grammar § grammar.y Zen § Communicate intent precisely. Edge cases matter. Favor reading code over writing code. Only one obvious way to do things. Runtime crashes are better than bugs. Compile errors are better than runtime crashes. Incremental improvements. Avoid local maximums. Reduce the amount one must remember. Focus on code rather than style. Resource allocation may fail; resource deallocation must succeed. Memory is a resource. Together we serve the users.",
    "metadata": {
      "version": "0.15.1",
      "topic": "Appendix §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Zig Version in Zig 0.14.1",
    "context": "",
    "response": "0.1.1 | 0.2.0 | 0.3.0 | 0.4.0 | 0.5.0 | 0.6.0 | 0.7.1 | 0.8.1 | 0.9.1 | 0.10.1 | 0.11.0 | 0.12.1 | 0.13.0 | 0.14.1 | 0.15.2 | master",
    "metadata": {
      "version": "0.14.1",
      "topic": "Zig Version",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Table of Contents in Zig 0.14.1",
    "context": "",
    "response": "Introduction Zig Standard Library Hello World Comments Doc Comments Top-Level Doc Comments Values Primitive Types Primitive Values String Literals and Unicode Code Point Literals Escape Sequences Multiline String Literals Assignment undefined Destructuring Zig Test Test Declarations Doctests Test Failure Skip Tests Report Memory Leaks Detecting Test Build Test Output and Logging The Testing Namespace Test Tool Documentation Variables Identifiers Container Level Variables Static Local Variables Thread Local Variables Local Variables Integers Integer Literals Runtime Integer Values Floats Float Literals Floating Point Operations Operators Table of Operators Precedence Arrays Multidimensional Arrays Sentinel-Terminated Arrays Destructuring Arrays Vectors Destructuring Vectors Pointers volatile Alignment allowzero Sentinel-Terminated Pointers Slices Sentinel-Terminated Slices struct Default Field Values Faulty Default Field Values extern struct packed struct Struct Naming Anonymous Struct ",
    "metadata": {
      "version": "0.14.1",
      "topic": "Table of Contents",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Introduction § in Zig 0.14.1",
    "context": "",
    "response": "Zig is a general-purpose programming language and toolchain for maintaining robust , optimal , and reusable software. Robust Behavior is correct even for edge cases such as out of memory. Optimal Write programs the best way they can behave and perform. Reusable The same code works in many environments which have different constraints. Maintainable Precisely communicate intent to the compiler and other programmers. The language imposes a low overhead to reading code and is resilient to changing requirements and environments. Often the most efficient way to learn something new is to see examples, so this documentation shows how to use each of Zig's features. It is all on one page so you can search with your browser's search tool. The code samples in this document are compiled and tested as part of the main test suite of Zig. This HTML document depends on no external files, so you can use it offline.",
    "metadata": {
      "version": "0.14.1",
      "topic": "Introduction §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Zig Standard Library § in Zig 0.14.1",
    "context": "",
    "response": "The Zig Standard Library has its own documentation. Zig's Standard Library contains commonly used algorithms, data structures, and definitions to help you build programs or libraries. You will see many examples of Zig's Standard Library used in this documentation. To learn more about the Zig Standard Library, visit the link above. Alternatively, the Zig Standard Library documentation is provided with each Zig distribution. It can be rendered via a local webserver with: Shell",
    "metadata": {
      "version": "0.14.1",
      "topic": "Zig Standard Library §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Hello World §",
    "context": "hello.zig Shell Most of the time, it is more appropriate to write to stderr rather than stdout, and whether or not the message is successfully written to the stream is irrelevant. For this common case, there is a simpler API: hello_again.zig Shell In this case, the ! may be omitted from the return type of main because no errors are returned from the function. See also: Values Tuples @import Errors Entry Point Source Encoding try",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> stdout = std.io.getStdOut().writer();\n    <span class=\"tok-kw\">try</span> stdout.print(<span class=\"tok-str\">\"Hello, {s}!\\n\"</span>, .{<span class=\"tok-str\">\"world\"</span>});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Hello World §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Hello World §",
    "context": "hello.zig Shell Most of the time, it is more appropriate to write to stderr rather than stdout, and whether or not the message is successfully written to the stream is irrelevant. For this common case, there is a simpler API: hello_again.zig Shell In this case, the ! may be omitted from the return type of main because no errors are returned from the function. See also: Values Tuples @import Errors Entry Point Source Encoding try",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    std.debug.print(<span class=\"tok-str\">\"Hello, world!\\n\"</span>, .{});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Hello World §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Hello World § in Zig 0.14.1",
    "context": "",
    "response": "hello.zig Shell Most of the time, it is more appropriate to write to stderr rather than stdout, and whether or not the message is successfully written to the stream is irrelevant. For this common case, there is a simpler API: hello_again.zig Shell In this case, the ! may be omitted from the return type of main because no errors are returned from the function. See also: Values Tuples @import Errors Entry Point Source Encoding try",
    "metadata": {
      "version": "0.14.1",
      "topic": "Hello World §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Comments §",
    "context": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly t",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-comment\">// Comments in Zig start with \"//\" and end at the next LF byte (end of line).</span>\n    <span class=\"tok-comment\">// The line below is a comment and won't be executed.</span>\n\n    <span class=\"tok-comment\">//print(\"Hello?\", .{});</span>\n\n    print(<span class=\"tok-str\">\"Hello, world!\\n\"</span>, .{}); <span class=\"tok-comment\">// another comment</span>\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Comments §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Comments §",
    "context": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly t",
    "response": "<span class=\"tok-comment\">/// A structure for storing a timestamp, with nanosecond precision (this is a</span>\n<span class=\"tok-comment\">/// multiline doc comment).</span>\n<span class=\"tok-kw\">const</span> Timestamp = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-comment\">/// The number of seconds since the epoch (this is also a doc comment).</span>\n    seconds: <span class=\"tok-type\">i64</span>, <span class=\"tok-comment\">// signed so we can represent pre-1970 (not a doc comment)</span>\n    <span class=\"tok-comment\">/// The number of nanoseconds past the second (doc comment again).</span>\n    nanos: <span class=\"tok-type\">u32</span>,\n\n    <span class=\"tok-comment\">/// Returns a `Timestamp` struct representing the Unix epoch; that is, the</span>\n    <span class=\"tok-comment\">/// moment of 1970 Jan 1 00:00:00 UTC (this is a doc comment too).</span>\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">unixEpoch</span>() Timestamp {\n        <span class=\"tok-kw\">return</span> Timestamp{\n            .seconds = <span class=\"tok-number\">0</span>,\n            .nanos = <span class=\"tok-number\">0</span>,\n        };\n    }\n};",
    "metadata": {
      "version": "0.14.1",
      "topic": "Comments §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Comments §",
    "context": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly t",
    "response": "<span class=\"tok-comment\">/// doc-comment</span>\n<span class=\"tok-comment\">//! top-level doc-comment</span>\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);",
    "metadata": {
      "version": "0.14.1",
      "topic": "Comments §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Comments §",
    "context": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly t",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {}\n\n<span class=\"tok-comment\">/// End of file</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Comments §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Comments §",
    "context": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly t",
    "response": "<span class=\"tok-comment\">//! This module provides functions for retrieving the current date and</span>\n<span class=\"tok-comment\">//! time with varying degrees of precision and accuracy. It does not</span>\n<span class=\"tok-comment\">//! depend on libc, but will use functions from it if available.</span>\n\n<span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-comment\">//! Top level comments are allowed inside a container other than a module,</span>\n    <span class=\"tok-comment\">//! but it is not very useful.  Currently, when producing the package</span>\n    <span class=\"tok-comment\">//! documentation, these comments are ignored.</span>\n};",
    "metadata": {
      "version": "0.14.1",
      "topic": "Comments §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Comments § in Zig 0.14.1",
    "context": "",
    "response": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly three slashes (i.e. /// but not //// ); multiple doc comments in a row are merged together to form a multiline doc comment. The doc comment documents whatever immediately follows it. doc_comments.zig Doc comments are only allowed in certain places; it is a compile error to have a doc comment in an unexpected place, such as in the middle of an expression, or just before a non-doc comment. invalid_doc-comment.zig Shell unattached_doc-comment.zig Shell Doc comments can be interleaved with normal com",
    "metadata": {
      "version": "0.14.1",
      "topic": "Comments §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-comment\">// Top-level declarations are order-independent:</span>\n<span class=\"tok-kw\">const</span> print = std.debug.print;\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> os = std.os;\n<span class=\"tok-kw\">const</span> assert = std.debug.assert;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-comment\">// integers</span>\n    <span class=\"tok-kw\">const</span> one_plus_one: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span> + <span class=\"tok-number\">1</span>;\n    print(<span class=\"tok-str\">\"1 + 1 = {}\\n\"</span>, .{one_plus_one});\n\n    <span class=\"tok-comment\">// floats</span>\n    <span class=\"tok-kw\">const</span> seven_div_three: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">7.0</span> / <span class=\"tok-number\">3.0</span>;\n    print(<span class=\"tok-str\">\"7.0 / 3.0 = {}\\n\"</span>, .{seven_div_three});\n\n    <span class=\"tok-comment\">// boolean</span>\n    print(<span class=\"tok-str\">\"{}\\n{}\\n{}\\n\"</span>, .{\n        <span class=\"tok-null\">true</span> <span class=\"tok-kw\">and</span> <span class=\"tok-null\">false</span>,\n        <span class=\"tok-null\">true</span> <span class=\"tok-kw\">or</span> <span class=\"tok-null\">false</span>,\n        !<span class=\"tok-null\">true</span>,\n    });\n\n    <span class=\"tok-comment\">// optional</span>\n    <span class=\"tok-kw\">var</span> optional_value: ?[]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-null\">null</span>;\n    assert(optional_value == <span class=\"tok-null\">null</span>);\n\n    print(<span class=\"tok-str\">\"\\noptional 1\\ntype: {}\\nvalue: {?s}\\n\"</span>, .{\n        <span class=\"tok-builtin\">@TypeOf</span>(optional_value), optional_value,\n    });\n\n    optional_value = <span class=\"tok-str\">\"hi\"</span>;\n    assert(optional_value != <span class=\"tok-null\">null</span>);\n\n    print(<span class=\"tok-str\">\"\\noptional 2\\ntype: {}\\nvalue: {?s}\\n\"</span>, .{\n        <span class=\"tok-builtin\">@TypeOf</span>(optional_value), optional_value,\n    });\n\n    <span class=\"tok-comment\">// error union</span>\n    <span class=\"tok-kw\">var</span> number_or_error: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">i32</span> = <span class=\"tok-kw\">error</span>.ArgNotFound;\n\n    print(<span class=\"tok-str\">\"\\nerror union 1\\ntype: {}\\nvalue: {!}\\n\"</span>, .{\n        <span class=\"tok-builtin\">@TypeOf</span>(number_or_error),\n        number_or_error,\n    });\n\n    number_or_error = <span class=\"tok-number\">1234</span>;\n\n    print(<span class=\"tok-str\">\"\\nerror union 2\\ntype: {}\\nvalue: {!}\\n\"</span>, .{\n        <span class=\"tok-builtin\">@TypeOf</span>(number_or_error), number_or_error,\n    });\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Values §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem; <span class=\"tok-comment\">// will be used to compare bytes</span>\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> bytes = <span class=\"tok-str\">\"hello\"</span>;\n    print(<span class=\"tok-str\">\"{}\\n\"</span>, .{<span class=\"tok-builtin\">@TypeOf</span>(bytes)}); <span class=\"tok-comment\">// *const [5:0]u8</span>\n    print(<span class=\"tok-str\">\"{d}\\n\"</span>, .{bytes.len}); <span class=\"tok-comment\">// 5</span>\n    print(<span class=\"tok-str\">\"{c}\\n\"</span>, .{bytes[<span class=\"tok-number\">1</span>]}); <span class=\"tok-comment\">// 'e'</span>\n    print(<span class=\"tok-str\">\"{d}\\n\"</span>, .{bytes[<span class=\"tok-number\">5</span>]}); <span class=\"tok-comment\">// 0</span>\n    print(<span class=\"tok-str\">\"{}\\n\"</span>, .{<span class=\"tok-str\">'e'</span> == <span class=\"tok-str\">'\\x65'</span>}); <span class=\"tok-comment\">// true</span>\n    print(<span class=\"tok-str\">\"{d}\\n\"</span>, .{<span class=\"tok-str\">'\\u{1f4a9}'</span>}); <span class=\"tok-comment\">// 128169</span>\n    print(<span class=\"tok-str\">\"{d}\\n\"</span>, .{<span class=\"tok-str\">'💯'</span>}); <span class=\"tok-comment\">// 128175</span>\n    print(<span class=\"tok-str\">\"{u}\\n\"</span>, .{<span class=\"tok-str\">'⚡'</span>});\n    print(<span class=\"tok-str\">\"{}\\n\"</span>, .{mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-str\">\"hello\"</span>, <span class=\"tok-str\">\"h\\x65llo\"</span>)}); <span class=\"tok-comment\">// true</span>\n    print(<span class=\"tok-str\">\"{}\\n\"</span>, .{mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-str\">\"💯\"</span>, <span class=\"tok-str\">\"\\xf0\\x9f\\x92\\xaf\"</span>)}); <span class=\"tok-comment\">// also true</span>\n    <span class=\"tok-kw\">const</span> invalid_utf8 = <span class=\"tok-str\">\"\\xff\\xfe\"</span>; <span class=\"tok-comment\">// non-UTF-8 strings are possible with \\xNN notation.</span>\n    print(<span class=\"tok-str\">\"0x{x}\\n\"</span>, .{invalid_utf8[<span class=\"tok-number\">1</span>]}); <span class=\"tok-comment\">// indexing them returns individual bytes...</span>\n    print(<span class=\"tok-str\">\"0x{x}\\n\"</span>, .{<span class=\"tok-str\">\"💯\"</span>[<span class=\"tok-number\">1</span>]}); <span class=\"tok-comment\">// ...as does indexing part-way through non-ASCII characters</span>\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Values §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> hello_world_in_c =\n    <span class=\"tok-str\">\\\\#include <stdio.h></span>\n    <span class=\"tok-str\">\\\\</span>\n    <span class=\"tok-str\">\\\\int main(int argc, char **argv) {</span>\n    <span class=\"tok-str\">\\\\    printf(\"hello world\\n\");</span>\n    <span class=\"tok-str\">\\\\    return 0;</span>\n    <span class=\"tok-str\">\\\\}</span>\n;",
    "metadata": {
      "version": "0.14.1",
      "topic": "Values §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> x = <span class=\"tok-number\">1234</span>;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-comment\">// It works at file scope as well as inside functions.</span>\n    <span class=\"tok-kw\">const</span> y = <span class=\"tok-number\">5678</span>;\n\n    <span class=\"tok-comment\">// Once assigned, an identifier cannot be changed.</span>\n    y += <span class=\"tok-number\">1</span>;\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    foo();\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Values §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">5678</span>;\n\n    y += <span class=\"tok-number\">1</span>;\n\n    print(<span class=\"tok-str\">\"{d}\"</span>, .{y});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Values §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span>;\n\n    x = <span class=\"tok-number\">1</span>;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Values §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n    x = <span class=\"tok-number\">1</span>;\n    print(<span class=\"tok-str\">\"{d}\"</span>, .{x});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Values §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u32</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">u32</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">var</span> z: <span class=\"tok-type\">u32</span> = <span class=\"tok-null\">undefined</span>;\n\n    <span class=\"tok-kw\">const</span> tuple = .{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span> };\n\n    x, y, z = tuple;\n\n    print(<span class=\"tok-str\">\"tuple: x = {}, y = {}, z = {}\\n\"</span>, .{x, y, z});\n\n    <span class=\"tok-kw\">const</span> array = [_]<span class=\"tok-type\">u32</span>{ <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span> };\n\n    x, y, z = array;\n\n    print(<span class=\"tok-str\">\"array: x = {}, y = {}, z = {}\\n\"</span>, .{x, y, z});\n\n    <span class=\"tok-kw\">const</span> vector: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">3</span>, <span class=\"tok-type\">u32</span>) = .{ <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span>, <span class=\"tok-number\">9</span> };\n\n    x, y, z = vector;\n\n    print(<span class=\"tok-str\">\"vector: x = {}, y = {}, z = {}\\n\"</span>, .{x, y, z});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Values §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u32</span> = <span class=\"tok-null\">undefined</span>;\n\n    <span class=\"tok-kw\">const</span> tuple = .{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span> };\n\n    x, <span class=\"tok-kw\">var</span> y : <span class=\"tok-type\">u32</span>, <span class=\"tok-kw\">const</span> z = tuple;\n\n    print(<span class=\"tok-str\">\"x = {}, y = {}, z = {}\\n\"</span>, .{x, y, z});\n\n    <span class=\"tok-comment\">// y is mutable</span>\n    y = <span class=\"tok-number\">100</span>;\n\n    <span class=\"tok-comment\">// You can use _ to throw away unwanted values.</span>\n    _, x, _ = tuple;\n\n    print(<span class=\"tok-str\">\"x = {}\"</span>, .{x});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Values §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Values § in Zig 0.14.1",
    "context": "",
    "response": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintptr_t , size_t unsigned pointer sized integer. Also see #5185 c_char char for ABI compatibility with C c_short short for ABI compatibility with C c_ushort unsigned short for ABI compatibility with C c_int int for ABI compatibility with C c_uint unsigned int for ABI compatibility with C c_long long for ABI compatibility with C c_ulong unsigned long for ABI compatibility with C c_longlong long long for ABI compatibility with C c_ulonglong unsigned long long for ABI compatibility with C c_longdouble ",
    "metadata": {
      "version": "0.14.1",
      "topic": "Values §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"expect addOne adds one to 41\"</span> {\n\n    <span class=\"tok-comment\">// The Standard Library contains useful functions to help create tests.</span>\n    <span class=\"tok-comment\">// `expect` is a function that verifies its argument is true.</span>\n    <span class=\"tok-comment\">// It will return an error if its argument is false to indicate a failure.</span>\n    <span class=\"tok-comment\">// `try` is used to return an error to the test runner to notify it that the test failed.</span>\n    <span class=\"tok-kw\">try</span> std.testing.expect(addOne(<span class=\"tok-number\">41</span>) == <span class=\"tok-number\">42</span>);\n}\n\n<span class=\"tok-kw\">test</span> addOne {\n    <span class=\"tok-comment\">// A test name can also be written using an identifier.</span>\n    <span class=\"tok-comment\">// This is a doctest, and serves as documentation for `addOne`.</span>\n    <span class=\"tok-kw\">try</span> std.testing.expect(addOne(<span class=\"tok-number\">41</span>) == <span class=\"tok-number\">42</span>);\n}\n\n<span class=\"tok-comment\">/// The function `addOne` adds one to the number given as its argument.</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">addOne</span>(number: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> number + <span class=\"tok-number\">1</span>;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"expect this to fail\"</span> {\n    <span class=\"tok-kw\">try</span> std.testing.expect(<span class=\"tok-null\">false</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"expect this to succeed\"</span> {\n    <span class=\"tok-kw\">try</span> std.testing.expect(<span class=\"tok-null\">true</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"this will be skipped\"</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.SkipZigTest;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"detect leak\"</span> {\n    <span class=\"tok-kw\">var</span> list = std.ArrayList(<span class=\"tok-type\">u21</span>).init(std.testing.allocator);\n    <span class=\"tok-comment\">// missing `defer list.deinit();`</span>\n    <span class=\"tok-kw\">try</span> list.append(<span class=\"tok-str\">'☔'</span>);\n\n    <span class=\"tok-kw\">try</span> std.testing.expect(list.items.len == <span class=\"tok-number\">1</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"builtin.is_test\"</span> {\n    <span class=\"tok-kw\">try</span> expect(isATest());\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">isATest</span>() <span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">return</span> builtin.is_test;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"expectEqual demo\"</span> {\n    <span class=\"tok-kw\">const</span> expected: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">42</span>;\n    <span class=\"tok-kw\">const</span> actual = <span class=\"tok-number\">42</span>;\n\n    <span class=\"tok-comment\">// The first argument to `expectEqual` is the known, expected, result.</span>\n    <span class=\"tok-comment\">// The second argument is the result of some expression.</span>\n    <span class=\"tok-comment\">// The actual's type is casted to the type of expected.</span>\n    <span class=\"tok-kw\">try</span> std.testing.expectEqual(expected, actual);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"expectError demo\"</span> {\n    <span class=\"tok-kw\">const</span> expected_error = <span class=\"tok-kw\">error</span>.DemoError;\n    <span class=\"tok-kw\">const</span> actual_error_union: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">void</span> = <span class=\"tok-kw\">error</span>.DemoError;\n\n    <span class=\"tok-comment\">// `expectError` will fail when the actual error is different than</span>\n    <span class=\"tok-comment\">// the expected error.</span>\n    <span class=\"tok-kw\">try</span> std.testing.expectError(expected_error, actual_error_union);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Zig Test § in Zig 0.14.1",
    "context": "",
    "response": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Library as its main entry point. During the build, test declarations found while resolving the given Zig source file are included for the default test runner to run and report on. This documentation discusses the features of the default test runner as provided by the Zig Standard Library. Its source code is located in lib/compiler/test_runner.zig . The shell output shown above displays two lines after the zig test command. These lines are printed to standard error by the default test runner: 1/2 t",
    "metadata": {
      "version": "0.14.1",
      "topic": "Zig Test §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">const</span> @\"identifier with spaces in it\" = <span class=\"tok-number\">0xff</span>;\n<span class=\"tok-kw\">const</span> @\"1SmallStep4Man\" = <span class=\"tok-number\">112358</span>;\n\n<span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).c;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"c\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">@\"error\"</span>() <span class=\"tok-type\">void</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"c\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">@\"fstat$INODE64\"</span>(fd: c.fd_t, buf: *c.Stat) <span class=\"tok-type\">c_int</span>;\n\n<span class=\"tok-kw\">const</span> Color = <span class=\"tok-kw\">enum</span> {\n    red,\n    @\"really red\",\n};\n<span class=\"tok-kw\">const</span> color: Color = .@\"really red\";",
    "metadata": {
      "version": "0.14.1",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">i32</span> = add(<span class=\"tok-number\">10</span>, x);\n<span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">i32</span> = add(<span class=\"tok-number\">12</span>, <span class=\"tok-number\">34</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"container level variables\"</span> {\n    <span class=\"tok-kw\">try</span> expect(x == <span class=\"tok-number\">46</span>);\n    <span class=\"tok-kw\">try</span> expect(y == <span class=\"tok-number\">56</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> a + b;\n}\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;",
    "metadata": {
      "version": "0.14.1",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"namespaced container level variable\"</span> {\n    <span class=\"tok-kw\">try</span> expect(foo() == <span class=\"tok-number\">1235</span>);\n    <span class=\"tok-kw\">try</span> expect(foo() == <span class=\"tok-number\">1236</span>);\n}\n\n<span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">i32</span> {\n    S.x += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">return</span> S.x;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"static local variable\"</span> {\n    <span class=\"tok-kw\">try</span> expect(foo() == <span class=\"tok-number\">1235</span>);\n    <span class=\"tok-kw\">try</span> expect(foo() == <span class=\"tok-number\">1236</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> {\n        <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    };\n    S.x += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">return</span> S.x;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> assert = std.debug.assert;\n\n<span class=\"tok-kw\">threadlocal</span> <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"thread local storage\"</span> {\n    <span class=\"tok-kw\">const</span> thread1 = <span class=\"tok-kw\">try</span> std.Thread.spawn(.{}, testTls, .{});\n    <span class=\"tok-kw\">const</span> thread2 = <span class=\"tok-kw\">try</span> std.Thread.spawn(.{}, testTls, .{});\n    testTls();\n    thread1.join();\n    thread2.join();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">testTls</span>() <span class=\"tok-type\">void</span> {\n    assert(x == <span class=\"tok-number\">1234</span>);\n    x += <span class=\"tok-number\">1</span>;\n    assert(x == <span class=\"tok-number\">1235</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"comptime vars\"</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n\n    x += <span class=\"tok-number\">1</span>;\n    y += <span class=\"tok-number\">1</span>;\n\n    <span class=\"tok-kw\">try</span> expect(x == <span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">try</span> expect(y == <span class=\"tok-number\">2</span>);\n\n    <span class=\"tok-kw\">if</span> (y != <span class=\"tok-number\">2</span>) {\n        <span class=\"tok-comment\">// This compile error never triggers because y is a comptime variable,</span>\n        <span class=\"tok-comment\">// and so `y != 2` is a comptime value, and this if is statically evaluated.</span>\n        <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"wrong y value\"</span>);\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Variables § in Zig 0.14.1",
    "context": "",
    "response": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both cases, the type of the variable must be C ABI compatible. See also: Exporting a C Library Identifiers § Variable identifiers are never allowed to shadow identifiers from an outer scope. Identifiers must start with an alphabetic character or underscore and may be followed by any number of alphanumeric characters or underscores. They must not overlap with any keywords. See Keyword Reference . If a name that does not fit these requirements is needed, such as for linking with external libraries, the @&q",
    "metadata": {
      "version": "0.14.1",
      "topic": "Variables §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Integers §",
    "context": "Integer Literals § integer_literals.zig Runtime Integer Values § Integer literals have no size limitation, and if any Illegal Behavior occurs, the compiler catches it. However, once an integer value is no longer known at compile-time, it must have a known size, and is vulnerable to safety-checked Illegal Behavior . runtime_vs_comptime.zig In this function, values a and b are known only at runtime, and thus this division operation is vulnerable to both Integer Overflow and Division by Zero . Oper",
    "response": "<span class=\"tok-kw\">const</span> decimal_int = <span class=\"tok-number\">98222</span>;\n<span class=\"tok-kw\">const</span> hex_int = <span class=\"tok-number\">0xff</span>;\n<span class=\"tok-kw\">const</span> another_hex_int = <span class=\"tok-number\">0xFF</span>;\n<span class=\"tok-kw\">const</span> octal_int = <span class=\"tok-number\">0o755</span>;\n<span class=\"tok-kw\">const</span> binary_int = <span class=\"tok-number\">0b11110000</span>;\n\n<span class=\"tok-comment\">// underscores may be placed between two digits as a visual separator</span>\n<span class=\"tok-kw\">const</span> one_billion = <span class=\"tok-number\">1_000_000_000</span>;\n<span class=\"tok-kw\">const</span> binary_mask = <span class=\"tok-number\">0b1_1111_1111</span>;\n<span class=\"tok-kw\">const</span> permissions = <span class=\"tok-number\">0o7_5_5</span>;\n<span class=\"tok-kw\">const</span> big_address = <span class=\"tok-number\">0xFF80_0000_0000_0000</span>;",
    "metadata": {
      "version": "0.14.1",
      "topic": "Integers §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Integers §",
    "context": "Integer Literals § integer_literals.zig Runtime Integer Values § Integer literals have no size limitation, and if any Illegal Behavior occurs, the compiler catches it. However, once an integer value is no longer known at compile-time, it must have a known size, and is vulnerable to safety-checked Illegal Behavior . runtime_vs_comptime.zig In this function, values a and b are known only at runtime, and thus this division operation is vulnerable to both Integer Overflow and Division by Zero . Oper",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">divide</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> a / b;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Integers §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Integers § in Zig 0.14.1",
    "context": "",
    "response": "Integer Literals § integer_literals.zig Runtime Integer Values § Integer literals have no size limitation, and if any Illegal Behavior occurs, the compiler catches it. However, once an integer value is no longer known at compile-time, it must have a known size, and is vulnerable to safety-checked Illegal Behavior . runtime_vs_comptime.zig In this function, values a and b are known only at runtime, and thus this division operation is vulnerable to both Integer Overflow and Division by Zero . Operators such as + and - cause Illegal Behavior on integer overflow. Alternative operators are provided for wrapping and saturating arithmetic on all targets. +% and -% perform wrapping arithmetic while +| and -| perform saturating arithmetic. Zig supports arbitrary bit-width integers, referenced by using an identifier of i or u followed by digits. For example, the identifier i7 refers to a signed 7-bit integer. The maximum allowed bit-width of an integer type is 65535 . For signed integer types, Z",
    "metadata": {
      "version": "0.14.1",
      "topic": "Integers §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Floats §",
    "context": "Zig has the following floating point types: f16 - IEEE-754-2008 binary16 f32 - IEEE-754-2008 binary32 f64 - IEEE-754-2008 binary64 f80 - IEEE-754-2008 80-bit extended precision f128 - IEEE-754-2008 binary128 c_longdouble - matches long double for the target C ABI Float Literals § Float literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128 . Float literals coerce to any floating point type, and to an",
    "response": "<span class=\"tok-kw\">const</span> floating_point = <span class=\"tok-number\">123.0E+77</span>;\n<span class=\"tok-kw\">const</span> another_float = <span class=\"tok-number\">123.0</span>;\n<span class=\"tok-kw\">const</span> yet_another = <span class=\"tok-number\">123.0e+77</span>;\n\n<span class=\"tok-kw\">const</span> hex_floating_point = <span class=\"tok-number\">0x103.70p-5</span>;\n<span class=\"tok-kw\">const</span> another_hex_float = <span class=\"tok-number\">0x103.70</span>;\n<span class=\"tok-kw\">const</span> yet_another_hex_float = <span class=\"tok-number\">0x103.70P-5</span>;\n\n<span class=\"tok-comment\">// underscores may be placed between two digits as a visual separator</span>\n<span class=\"tok-kw\">const</span> lightspeed = <span class=\"tok-number\">299_792_458.000_000</span>;\n<span class=\"tok-kw\">const</span> nanosecond = <span class=\"tok-number\">0.000_000_001</span>;\n<span class=\"tok-kw\">const</span> more_hex = <span class=\"tok-number\">0x1234_5678.9ABC_CDEFp-10</span>;",
    "metadata": {
      "version": "0.14.1",
      "topic": "Floats §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Floats §",
    "context": "Zig has the following floating point types: f16 - IEEE-754-2008 binary16 f32 - IEEE-754-2008 binary32 f64 - IEEE-754-2008 binary64 f80 - IEEE-754-2008 80-bit extended precision f128 - IEEE-754-2008 binary128 c_longdouble - matches long double for the target C ABI Float Literals § Float literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128 . Float literals coerce to any floating point type, and to an",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> inf = std.math.inf(<span class=\"tok-type\">f32</span>);\n<span class=\"tok-kw\">const</span> negative_inf = -std.math.inf(<span class=\"tok-type\">f64</span>);\n<span class=\"tok-kw\">const</span> nan = std.math.nan(<span class=\"tok-type\">f128</span>);",
    "metadata": {
      "version": "0.14.1",
      "topic": "Floats §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Floats §",
    "context": "Zig has the following floating point types: f16 - IEEE-754-2008 binary16 f32 - IEEE-754-2008 binary32 f64 - IEEE-754-2008 binary64 f80 - IEEE-754-2008 80-bit extended precision f128 - IEEE-754-2008 binary128 c_longdouble - matches long double for the target C ABI Float Literals § Float literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128 . Float literals coerce to any floating point type, and to an",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> big = <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">f64</span>, <span class=\"tok-number\">1</span> << <span class=\"tok-number\">40</span>);\n\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo_strict</span>(x: <span class=\"tok-type\">f64</span>) <span class=\"tok-type\">f64</span> {\n    <span class=\"tok-kw\">return</span> x + big - big;\n}\n\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo_optimized</span>(x: <span class=\"tok-type\">f64</span>) <span class=\"tok-type\">f64</span> {\n    <span class=\"tok-builtin\">@setFloatMode</span>(.optimized);\n    <span class=\"tok-kw\">return</span> x + big - big;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Floats §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Floats §",
    "context": "Zig has the following floating point types: f16 - IEEE-754-2008 binary16 f32 - IEEE-754-2008 binary32 f64 - IEEE-754-2008 binary64 f80 - IEEE-754-2008 80-bit extended precision f128 - IEEE-754-2008 binary128 c_longdouble - matches long double for the target C ABI Float Literals § Float literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128 . Float literals coerce to any floating point type, and to an",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo_strict</span>(x: <span class=\"tok-type\">f64</span>) <span class=\"tok-type\">f64</span>;\n<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo_optimized</span>(x: <span class=\"tok-type\">f64</span>) <span class=\"tok-type\">f64</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> x = <span class=\"tok-number\">0.001</span>;\n    print(<span class=\"tok-str\">\"optimized = {}\\n\"</span>, .{foo_optimized(x)});\n    print(<span class=\"tok-str\">\"strict = {}\\n\"</span>, .{foo_strict(x)});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Floats §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Floats § in Zig 0.14.1",
    "context": "",
    "response": "Zig has the following floating point types: f16 - IEEE-754-2008 binary16 f32 - IEEE-754-2008 binary32 f64 - IEEE-754-2008 binary64 f80 - IEEE-754-2008 80-bit extended precision f128 - IEEE-754-2008 binary128 c_longdouble - matches long double for the target C ABI Float Literals § Float literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128 . Float literals coerce to any floating point type, and to any integer type when there is no fractional component. float_literals.zig There is no syntax for NaN, infinity, or negative infinity. For these special values, one must use the standard library: float_special_values.zig Floating Point Operations § By default floating point operations use Strict mode, but you can switch to Optimized mode on a per-block basis: float_mode_obj.zig Shell For this test we have to separate code into two object files - otherwise the optimizer figures out all the values a",
    "metadata": {
      "version": "0.14.1",
      "topic": "Floats §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a + b\na += b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">2</span> + <span class=\"tok-number\">5</span> == <span class=\"tok-number\">7</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a +% b\na +%= b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-number\">0xffffffff</span>) +% <span class=\"tok-number\">1</span> == <span class=\"tok-number\">0</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a +| b\na +|= b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">255</span>) +| <span class=\"tok-number\">1</span> == <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">255</span>)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a - b\na -= b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">2</span> - <span class=\"tok-number\">5</span> == -<span class=\"tok-number\">3</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a -% b\na -%= b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">0</span>) -% <span class=\"tok-number\">1</span> == <span class=\"tok-number\">255</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a -| b\na -|= b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-number\">0</span>) -| <span class=\"tok-number\">1</span> == <span class=\"tok-number\">0</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "-<span class=\"tok-number\">1</span> == <span class=\"tok-number\">0</span> - <span class=\"tok-number\">1</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "-%<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">i8</span>, -<span class=\"tok-number\">128</span>) == -<span class=\"tok-number\">128</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a * b\na *= b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">2</span> * <span class=\"tok-number\">5</span> == <span class=\"tok-number\">10</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a *% b\na *%= b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">200</span>) *% <span class=\"tok-number\">2</span> == <span class=\"tok-number\">144</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a *| b\na *|= b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">200</span>) *| <span class=\"tok-number\">2</span> == <span class=\"tok-number\">255</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a / b\na /= b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">10</span> / <span class=\"tok-number\">5</span> == <span class=\"tok-number\">2</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a % b\na %= b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">10</span> % <span class=\"tok-number\">3</span> == <span class=\"tok-number\">1</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a << b\na <<= b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">0b1</span> << <span class=\"tok-number\">8</span> == <span class=\"tok-number\">0b100000000</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <<| b\na <<|= b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">1</span>) <<| <span class=\"tok-number\">8</span> == <span class=\"tok-number\">255</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a >> b\na >>= b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">0b1010</span> >> <span class=\"tok-number\">1</span> == <span class=\"tok-number\">0b101</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a & b\na &= b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">0b011</span> & <span class=\"tok-number\">0b101</span> == <span class=\"tok-number\">0b001</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a | b\na |= b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">0b010</span> | <span class=\"tok-number\">0b100</span> == <span class=\"tok-number\">0b110</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a ^ b\na ^= b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">0b011</span> ^ <span class=\"tok-number\">0b101</span> == <span class=\"tok-number\">0b110</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "~<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">0b10101111</span>) == <span class=\"tok-number\">0b01010000</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <span class=\"tok-kw\">orelse</span> b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> value: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-null\">null</span>;\n<span class=\"tok-kw\">const</span> unwrapped = value <span class=\"tok-kw\">orelse</span> <span class=\"tok-number\">1234</span>;\nunwrapped == <span class=\"tok-number\">1234</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <span class=\"tok-kw\">orelse</span> <span class=\"tok-kw\">unreachable</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> value: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">5678</span>;\nvalue.? == <span class=\"tok-number\">5678</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <span class=\"tok-kw\">catch</span> b\na <span class=\"tok-kw\">catch</span> |err| b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> value: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> = <span class=\"tok-kw\">error</span>.Broken;\n<span class=\"tok-kw\">const</span> unwrapped = value <span class=\"tok-kw\">catch</span> <span class=\"tok-number\">1234</span>;\nunwrapped == <span class=\"tok-number\">1234</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <span class=\"tok-kw\">and</span> b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-null\">false</span> <span class=\"tok-kw\">and</span> <span class=\"tok-null\">true</span>) == <span class=\"tok-null\">false</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <span class=\"tok-kw\">or</span> b",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-null\">false</span> <span class=\"tok-kw\">or</span> <span class=\"tok-null\">true</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "!<span class=\"tok-null\">false</span> == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">1</span> == <span class=\"tok-number\">1</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a == <span class=\"tok-null\">null</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> value: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-null\">null</span>;\n(value == <span class=\"tok-null\">null</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">1</span> != <span class=\"tok-number\">1</span>) == <span class=\"tok-null\">false</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a != <span class=\"tok-null\">null</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> value: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-null\">null</span>;\n(value != <span class=\"tok-null\">null</span>) == <span class=\"tok-null\">false</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">2</span> > <span class=\"tok-number\">1</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">2</span> >= <span class=\"tok-number\">1</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">1</span> < <span class=\"tok-number\">2</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">1</span> <= <span class=\"tok-number\">2</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem;\n<span class=\"tok-kw\">const</span> array1 = [_]<span class=\"tok-type\">u32</span>{<span class=\"tok-number\">1</span>,<span class=\"tok-number\">2</span>};\n<span class=\"tok-kw\">const</span> array2 = [_]<span class=\"tok-type\">u32</span>{<span class=\"tok-number\">3</span>,<span class=\"tok-number\">4</span>};\n<span class=\"tok-kw\">const</span> together = array1 ++ array2;\nmem.eql(<span class=\"tok-type\">u32</span>, &together, &[_]<span class=\"tok-type\">u32</span>{<span class=\"tok-number\">1</span>,<span class=\"tok-number\">2</span>,<span class=\"tok-number\">3</span>,<span class=\"tok-number\">4</span>})",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem;\n<span class=\"tok-kw\">const</span> pattern = <span class=\"tok-str\">\"ab\"</span> ** <span class=\"tok-number\">3</span>;\nmem.eql(<span class=\"tok-type\">u8</span>, pattern, <span class=\"tok-str\">\"ababab\"</span>)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">1234</span>;\n<span class=\"tok-kw\">const</span> ptr = &x;\nptr.* == <span class=\"tok-number\">1234</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">1234</span>;\n<span class=\"tok-kw\">const</span> ptr = &x;\nptr.* == <span class=\"tok-number\">1234</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> A = <span class=\"tok-kw\">error</span>{One};\n<span class=\"tok-kw\">const</span> B = <span class=\"tok-kw\">error</span>{Two};\n(A || B) == <span class=\"tok-kw\">error</span>{One, Two}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "x() x[] x.y x.* x.?\na!b\nx{}\n!x -x -%x ~x &x ?x\n* / % ** *% *| ||\n+ - ++ +% -% +| -|\n<< >> <<|\n& ^ | <span class=\"tok-kw\">orelse</span> <span class=\"tok-kw\">catch</span>\n== != < > <= >=\n<span class=\"tok-kw\">and</span>\n<span class=\"tok-kw\">or</span>\n= *= *%= *|= /= %= += +%= +|= -= -%= -|= <<= <<|= >>= &= ^= |=",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Operators § in Zig 0.14.1",
    "context": "",
    "response": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes Peer Type Resolution for the operands. Subtraction Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @subWithOverflow . Wrapping Subtraction Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @subWithOverflow . Saturating Subtraction Integers Invokes Peer Type Resolution for the operands. Negation Integers Floats Can cause overflow for integers. Wrapping Negation Integers Twos-complement wrapp",
    "metadata": {
      "version": "0.14.1",
      "topic": "Operators §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Arrays §",
    "context": "test_arrays.zig Shell See also: for Slices Multidimensional Arrays § Multidimensional arrays can be created by nesting arrays: test_multidimensional_arrays.zig Shell Sentinel-Terminated Arrays § The syntax [N:x]T describes an array which has a sentinel element of value x at the index corresponding to the length N . test_null_terminated_array.zig Shell See also: Sentinel-Terminated Pointers Sentinel-Terminated Slices Destructuring Arrays § Arrays can be destructured: destructuring_arrays.zig Shel",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n<span class=\"tok-kw\">const</span> assert = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.assert;\n<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem;\n\n<span class=\"tok-comment\">// array literal</span>\n<span class=\"tok-kw\">const</span> message = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'o'</span> };\n\n<span class=\"tok-comment\">// alternative initialization using result location</span>\n<span class=\"tok-kw\">const</span> alt_message: [<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span> = .{ <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'o'</span> };\n\n<span class=\"tok-kw\">comptime</span> {\n    assert(mem.eql(<span class=\"tok-type\">u8</span>, &message, &alt_message));\n}\n\n<span class=\"tok-comment\">// get the size of an array</span>\n<span class=\"tok-kw\">comptime</span> {\n    assert(message.len == <span class=\"tok-number\">5</span>);\n}\n\n<span class=\"tok-comment\">// A string literal is a single-item pointer to an array.</span>\n<span class=\"tok-kw\">const</span> same_message = <span class=\"tok-str\">\"hello\"</span>;\n\n<span class=\"tok-kw\">comptime</span> {\n    assert(mem.eql(<span class=\"tok-type\">u8</span>, &message, same_message));\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"iterate over an array\"</span> {\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">for</span> (message) |byte| {\n        sum += byte;\n    }\n    <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-str\">'h'</span> + <span class=\"tok-str\">'e'</span> + <span class=\"tok-str\">'l'</span> * <span class=\"tok-number\">2</span> + <span class=\"tok-str\">'o'</span>);\n}\n\n<span class=\"tok-comment\">// modifiable array</span>\n<span class=\"tok-kw\">var</span> some_integers: [<span class=\"tok-number\">100</span>]<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"modify an array\"</span> {\n    <span class=\"tok-kw\">for</span> (&some_integers, <span class=\"tok-number\">0</span>..) |*item, i| {\n        item.* = <span class=\"tok-builtin\">@intCast</span>(i);\n    }\n    <span class=\"tok-kw\">try</span> expect(some_integers[<span class=\"tok-number\">10</span>] == <span class=\"tok-number\">10</span>);\n    <span class=\"tok-kw\">try</span> expect(some_integers[<span class=\"tok-number\">99</span>] == <span class=\"tok-number\">99</span>);\n}\n\n<span class=\"tok-comment\">// array concatenation works if the values are known</span>\n<span class=\"tok-comment\">// at compile time</span>\n<span class=\"tok-kw\">const</span> part_one = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n<span class=\"tok-kw\">const</span> part_two = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span> };\n<span class=\"tok-kw\">const</span> all_of_it = part_one ++ part_two;\n<span class=\"tok-kw\">comptime</span> {\n    assert(mem.eql(<span class=\"tok-type\">i32</span>, &all_of_it, &[_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span> }));\n}\n\n<span class=\"tok-comment\">// remember that string literals are arrays</span>\n<span class=\"tok-kw\">const</span> hello = <span class=\"tok-str\">\"hello\"</span>;\n<span class=\"tok-kw\">const</span> world = <span class=\"tok-str\">\"world\"</span>;\n<span class=\"tok-kw\">const</span> hello_world = hello ++ <span class=\"tok-str\">\" \"</span> ++ world;\n<span class=\"tok-kw\">comptime</span> {\n    assert(mem.eql(<span class=\"tok-type\">u8</span>, hello_world, <span class=\"tok-str\">\"hello world\"</span>));\n}\n\n<span class=\"tok-comment\">// ** does repeating patterns</span>\n<span class=\"tok-kw\">const</span> pattern = <span class=\"tok-str\">\"ab\"</span> ** <span class=\"tok-number\">3</span>;\n<span class=\"tok-kw\">comptime</span> {\n    assert(mem.eql(<span class=\"tok-type\">u8</span>, pattern, <span class=\"tok-str\">\"ababab\"</span>));\n}\n\n<span class=\"tok-comment\">// initialize an array to zero</span>\n<span class=\"tok-kw\">const</span> all_zero = [_]<span class=\"tok-type\">u16</span>{<span class=\"tok-number\">0</span>} ** <span class=\"tok-number\">10</span>;\n\n<span class=\"tok-kw\">comptime</span> {\n    assert(all_zero.len == <span class=\"tok-number\">10</span>);\n    assert(all_zero[<span class=\"tok-number\">5</span>] == <span class=\"tok-number\">0</span>);\n}\n\n<span class=\"tok-comment\">// use compile-time code to initialize an array</span>\n<span class=\"tok-kw\">var</span> fancy_array = init: {\n    <span class=\"tok-kw\">var</span> initial_value: [<span class=\"tok-number\">10</span>]Point = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">for</span> (&initial_value, <span class=\"tok-number\">0</span>..) |*pt, i| {\n        pt.* = Point{\n            .x = <span class=\"tok-builtin\">@intCast</span>(i),\n            .y = <span class=\"tok-builtin\">@intCast</span>(i * <span class=\"tok-number\">2</span>),\n        };\n    }\n    <span class=\"tok-kw\">break</span> :init initial_value;\n};\n<span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> {\n    x: <span class=\"tok-type\">i32</span>,\n    y: <span class=\"tok-type\">i32</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"compile-time array initialization\"</span> {\n    <span class=\"tok-kw\">try</span> expect(fancy_array[<span class=\"tok-number\">4</span>].x == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(fancy_array[<span class=\"tok-number\">4</span>].y == <span class=\"tok-number\">8</span>);\n}\n\n<span class=\"tok-comment\">// call a function to initialize an array</span>\n<span class=\"tok-kw\">var</span> more_points = [_]Point{makePoint(<span class=\"tok-number\">3</span>)} ** <span class=\"tok-number\">10</span>;\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">makePoint</span>(x: <span class=\"tok-type\">i32</span>) Point {\n    <span class=\"tok-kw\">return</span> Point{\n        .x = x,\n        .y = x * <span class=\"tok-number\">2</span>,\n    };\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"array initialization with function calls\"</span> {\n    <span class=\"tok-kw\">try</span> expect(more_points[<span class=\"tok-number\">4</span>].x == <span class=\"tok-number\">3</span>);\n    <span class=\"tok-kw\">try</span> expect(more_points[<span class=\"tok-number\">4</span>].y == <span class=\"tok-number\">6</span>);\n    <span class=\"tok-kw\">try</span> expect(more_points.len == <span class=\"tok-number\">10</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Arrays §",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Arrays §",
    "context": "test_arrays.zig Shell See also: for Slices Multidimensional Arrays § Multidimensional arrays can be created by nesting arrays: test_multidimensional_arrays.zig Shell Sentinel-Terminated Arrays § The syntax [N:x]T describes an array which has a sentinel element of value x at the index corresponding to the length N . test_null_terminated_array.zig Shell See also: Sentinel-Terminated Pointers Sentinel-Terminated Slices Destructuring Arrays § Arrays can be destructured: destructuring_arrays.zig Shel",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> expectEqual = std.testing.expectEqual;\n\n<span class=\"tok-kw\">const</span> mat4x5 = [<span class=\"tok-number\">4</span>][<span class=\"tok-number\">5</span>]<span class=\"tok-type\">f32</span>{\n    [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span> },\n    [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span> },\n    [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span> },\n    [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">9.9</span> },\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"multidimensional arrays\"</span> {\n    <span class=\"tok-comment\">// mat4x5 itself is a one-dimensional array of arrays.</span>\n    <span class=\"tok-kw\">try</span> expectEqual(mat4x5[<span class=\"tok-number\">1</span>], [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span> });\n\n    <span class=\"tok-comment\">// Access the 2D array by indexing the outer array, and then the inner array.</span>\n    <span class=\"tok-kw\">try</span> expect(mat4x5[<span class=\"tok-number\">3</span>][<span class=\"tok-number\">4</span>] == <span class=\"tok-number\">9.9</span>);\n\n    <span class=\"tok-comment\">// Here we iterate with for loops.</span>\n    <span class=\"tok-kw\">for</span> (mat4x5, <span class=\"tok-number\">0</span>..) |row, row_index| {\n        <span class=\"tok-kw\">for</span> (row, <span class=\"tok-number\">0</span>..) |cell, column_index| {\n            <span class=\"tok-kw\">if</span> (row_index == column_index) {\n                <span class=\"tok-kw\">try</span> expect(cell == <span class=\"tok-number\">1.0</span>);\n            }\n        }\n    }\n\n    <span class=\"tok-comment\">// Initialize a multidimensional array to zeros.</span>\n    <span class=\"tok-kw\">const</span> all_zero: [<span class=\"tok-number\">4</span>][<span class=\"tok-number\">5</span>]<span class=\"tok-type\">f32</span> = .{.{<span class=\"tok-number\">0</span>} ** <span class=\"tok-number\">5</span>} ** <span class=\"tok-number\">4</span>;\n    <span class=\"tok-kw\">try</span> expect(all_zero[<span class=\"tok-number\">0</span>][<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">0</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Arrays §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Arrays §",
    "context": "test_arrays.zig Shell See also: for Slices Multidimensional Arrays § Multidimensional arrays can be created by nesting arrays: test_multidimensional_arrays.zig Shell Sentinel-Terminated Arrays § The syntax [N:x]T describes an array which has a sentinel element of value x at the index corresponding to the length N . test_null_terminated_array.zig Shell See also: Sentinel-Terminated Pointers Sentinel-Terminated Slices Destructuring Arrays § Arrays can be destructured: destructuring_arrays.zig Shel",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"0-terminated sentinel array\"</span> {\n    <span class=\"tok-kw\">const</span> array = [_:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(array) == [<span class=\"tok-number\">4</span>:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>);\n    <span class=\"tok-kw\">try</span> expect(array.len == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">4</span>] == <span class=\"tok-number\">0</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"extra 0s in 0-terminated sentinel array\"</span> {\n    <span class=\"tok-comment\">// The sentinel value may appear earlier, but does not influence the compile-time 'len'.</span>\n    <span class=\"tok-kw\">const</span> array = [_:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span>, <span class=\"tok-number\">0</span>, <span class=\"tok-number\">4</span> };\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(array) == [<span class=\"tok-number\">4</span>:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>);\n    <span class=\"tok-kw\">try</span> expect(array.len == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">4</span>] == <span class=\"tok-number\">0</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Arrays §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Arrays §",
    "context": "test_arrays.zig Shell See also: for Slices Multidimensional Arrays § Multidimensional arrays can be created by nesting arrays: test_multidimensional_arrays.zig Shell Sentinel-Terminated Arrays § The syntax [N:x]T describes an array which has a sentinel element of value x at the index corresponding to the length N . test_null_terminated_array.zig Shell See also: Sentinel-Terminated Pointers Sentinel-Terminated Slices Destructuring Arrays § Arrays can be destructured: destructuring_arrays.zig Shel",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">swizzleRgbaToBgra</span>(rgba: [<span class=\"tok-number\">4</span>]<span class=\"tok-type\">u8</span>) [<span class=\"tok-number\">4</span>]<span class=\"tok-type\">u8</span> {\n    <span class=\"tok-comment\">// readable swizzling by destructuring</span>\n    <span class=\"tok-kw\">const</span> r, <span class=\"tok-kw\">const</span> g, <span class=\"tok-kw\">const</span> b, <span class=\"tok-kw\">const</span> a = rgba;\n    <span class=\"tok-kw\">return</span> .{ b, g, r, a };\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> pos = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span> };\n    <span class=\"tok-kw\">const</span> x, <span class=\"tok-kw\">const</span> y = pos;\n    print(<span class=\"tok-str\">\"x = {}, y = {}\\n\"</span>, .{x, y});\n\n    <span class=\"tok-kw\">const</span> orange: [<span class=\"tok-number\">4</span>]<span class=\"tok-type\">u8</span> = .{ <span class=\"tok-number\">255</span>, <span class=\"tok-number\">165</span>, <span class=\"tok-number\">0</span>, <span class=\"tok-number\">255</span> };\n    print(<span class=\"tok-str\">\"{any}\\n\"</span>, .{swizzleRgbaToBgra(orange)});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Arrays §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Arrays § in Zig 0.14.1",
    "context": "",
    "response": "test_arrays.zig Shell See also: for Slices Multidimensional Arrays § Multidimensional arrays can be created by nesting arrays: test_multidimensional_arrays.zig Shell Sentinel-Terminated Arrays § The syntax [N:x]T describes an array which has a sentinel element of value x at the index corresponding to the length N . test_null_terminated_array.zig Shell See also: Sentinel-Terminated Pointers Sentinel-Terminated Slices Destructuring Arrays § Arrays can be destructured: destructuring_arrays.zig Shell See also: Destructuring Destructuring Tuples Destructuring Vectors",
    "metadata": {
      "version": "0.14.1",
      "topic": "Arrays §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Vectors §",
    "context": "A vector is a group of booleans, Integers , Floats , or Pointers which are operated on in parallel, using SIMD instructions if possible. Vector types are created with the builtin function @Vector . Vectors support the same builtin operators as their underlying base types. These operations are performed element-wise, and return a vector of the same length as the input vectors. This includes: Arithmetic ( + , - , / , * , @divFloor , @sqrt , @ceil , @log , etc.) Bitwise operators ( &gt;&gt; , &lt;&",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expectEqual = std.testing.expectEqual;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"Basic vector usage\"</span> {\n    <span class=\"tok-comment\">// Vectors have a compile-time known length and base type.</span>\n    <span class=\"tok-kw\">const</span> a = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">i32</span>){ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">i32</span>){ <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span> };\n\n    <span class=\"tok-comment\">// Math operations take place element-wise.</span>\n    <span class=\"tok-kw\">const</span> c = a + b;\n\n    <span class=\"tok-comment\">// Individual vector elements can be accessed using array indexing syntax.</span>\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">6</span>, c[<span class=\"tok-number\">0</span>]);\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">8</span>, c[<span class=\"tok-number\">1</span>]);\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">10</span>, c[<span class=\"tok-number\">2</span>]);\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">12</span>, c[<span class=\"tok-number\">3</span>]);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"Conversion between vectors, arrays, and slices\"</span> {\n    <span class=\"tok-comment\">// Vectors and fixed-length arrays can be automatically assigned back and forth</span>\n    <span class=\"tok-kw\">const</span> arr1: [<span class=\"tok-number\">4</span>]<span class=\"tok-type\">f32</span> = [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.1</span>, <span class=\"tok-number\">3.2</span>, <span class=\"tok-number\">4.5</span>, <span class=\"tok-number\">5.6</span> };\n    <span class=\"tok-kw\">const</span> vec: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">f32</span>) = arr1;\n    <span class=\"tok-kw\">const</span> arr2: [<span class=\"tok-number\">4</span>]<span class=\"tok-type\">f32</span> = vec;\n    <span class=\"tok-kw\">try</span> expectEqual(arr1, arr2);\n\n    <span class=\"tok-comment\">// You can also assign from a slice with comptime-known length to a vector using .*</span>\n    <span class=\"tok-kw\">const</span> vec2: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">2</span>, <span class=\"tok-type\">f32</span>) = arr1[<span class=\"tok-number\">1</span>..<span class=\"tok-number\">3</span>].*;\n\n    <span class=\"tok-kw\">const</span> slice: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">f32</span> = &arr1;\n    <span class=\"tok-kw\">var</span> offset: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">1</span>; <span class=\"tok-comment\">// var to make it runtime-known</span>\n    _ = &offset; <span class=\"tok-comment\">// suppress 'var is never mutated' error</span>\n    <span class=\"tok-comment\">// To extract a comptime-known length from a runtime-known offset,</span>\n    <span class=\"tok-comment\">// first extract a new slice from the starting offset, then an array of</span>\n    <span class=\"tok-comment\">// comptime-known length</span>\n    <span class=\"tok-kw\">const</span> vec3: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">2</span>, <span class=\"tok-type\">f32</span>) = slice[offset..][<span class=\"tok-number\">0</span>..<span class=\"tok-number\">2</span>].*;\n    <span class=\"tok-kw\">try</span> expectEqual(slice[offset], vec2[<span class=\"tok-number\">0</span>]);\n    <span class=\"tok-kw\">try</span> expectEqual(slice[offset + <span class=\"tok-number\">1</span>], vec2[<span class=\"tok-number\">1</span>]);\n    <span class=\"tok-kw\">try</span> expectEqual(vec2, vec3);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Vectors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Vectors §",
    "context": "A vector is a group of booleans, Integers , Floats , or Pointers which are operated on in parallel, using SIMD instructions if possible. Vector types are created with the builtin function @Vector . Vectors support the same builtin operators as their underlying base types. These operations are performed element-wise, and return a vector of the same length as the input vectors. This includes: Arithmetic ( + , - , / , * , @divFloor , @sqrt , @ceil , @log , etc.) Bitwise operators ( &gt;&gt; , &lt;&",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-comment\">// emulate punpckldq</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">unpack</span>(x: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">f32</span>), y: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">f32</span>)) <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">f32</span>) {\n    <span class=\"tok-kw\">const</span> a, <span class=\"tok-kw\">const</span> c, _, _ = x;\n    <span class=\"tok-kw\">const</span> b, <span class=\"tok-kw\">const</span> d, _, _ = y;\n    <span class=\"tok-kw\">return</span> .{ a, b, c, d };\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">f32</span>) = .{ <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">2.0</span>, <span class=\"tok-number\">3.0</span>, <span class=\"tok-number\">4.0</span> };\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">f32</span>) = .{ <span class=\"tok-number\">5.0</span>, <span class=\"tok-number\">6.0</span>, <span class=\"tok-number\">7.0</span>, <span class=\"tok-number\">8.0</span> };\n    print(<span class=\"tok-str\">\"{}\"</span>, .{unpack(x, y)});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Vectors §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Vectors § in Zig 0.14.1",
    "context": "",
    "response": "A vector is a group of booleans, Integers , Floats , or Pointers which are operated on in parallel, using SIMD instructions if possible. Vector types are created with the builtin function @Vector . Vectors support the same builtin operators as their underlying base types. These operations are performed element-wise, and return a vector of the same length as the input vectors. This includes: Arithmetic ( + , - , / , * , @divFloor , @sqrt , @ceil , @log , etc.) Bitwise operators ( &gt;&gt; , &lt;&lt; , &amp; , | , ~ , etc.) Comparison operators ( &lt; , &gt; , == , etc.) It is prohibited to use a math operator on a mixture of scalars (individual numbers) and vectors. Zig provides the @splat builtin to easily convert from scalars to vectors, and it supports @reduce and array indexing syntax to convert from vectors to scalars. Vectors also support assignment to and from fixed-length arrays with comptime-known length. For rearranging elements within and between vectors, Zig provides the @sh",
    "metadata": {
      "version": "0.14.1",
      "topic": "Vectors §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"address of syntax\"</span> {\n    <span class=\"tok-comment\">// Get the address of a variable:</span>\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> x_ptr = &x;\n\n    <span class=\"tok-comment\">// Dereference a pointer:</span>\n    <span class=\"tok-kw\">try</span> expect(x_ptr.* == <span class=\"tok-number\">1234</span>);\n\n    <span class=\"tok-comment\">// When you get the address of a const variable, you get a const single-item pointer.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(x_ptr) == *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span>);\n\n    <span class=\"tok-comment\">// If you want to mutate the value, you'd need an address of a mutable variable:</span>\n    <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">5678</span>;\n    <span class=\"tok-kw\">const</span> y_ptr = &y;\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(y_ptr) == *<span class=\"tok-type\">i32</span>);\n    y_ptr.* += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(y_ptr.* == <span class=\"tok-number\">5679</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer array access\"</span> {\n    <span class=\"tok-comment\">// Taking an address of an individual element gives a</span>\n    <span class=\"tok-comment\">// single-item pointer. This kind of pointer</span>\n    <span class=\"tok-comment\">// does not support pointer arithmetic.</span>\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span>, <span class=\"tok-number\">9</span>, <span class=\"tok-number\">10</span> };\n    <span class=\"tok-kw\">const</span> ptr = &array[<span class=\"tok-number\">2</span>];\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(ptr) == *<span class=\"tok-type\">u8</span>);\n\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">2</span>] == <span class=\"tok-number\">3</span>);\n    ptr.* += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">2</span>] == <span class=\"tok-number\">4</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"slice syntax\"</span> {\n    <span class=\"tok-comment\">// Get a pointer to a variable:</span>\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> x_ptr = &x;\n\n    <span class=\"tok-comment\">// Convert to array pointer using slice syntax:</span>\n    <span class=\"tok-kw\">const</span> x_array_ptr = x_ptr[<span class=\"tok-number\">0</span>..<span class=\"tok-number\">1</span>];\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(x_array_ptr) == *[<span class=\"tok-number\">1</span>]<span class=\"tok-type\">i32</span>);\n\n    <span class=\"tok-comment\">// Coerce to many-item pointer:</span>\n    <span class=\"tok-kw\">const</span> x_many_ptr: [*]<span class=\"tok-type\">i32</span> = x_array_ptr;\n    <span class=\"tok-kw\">try</span> expect(x_many_ptr[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1234</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer arithmetic with many-item pointer\"</span> {\n    <span class=\"tok-kw\">const</span> array = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n    <span class=\"tok-kw\">var</span> ptr: [*]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span> = &array;\n\n    <span class=\"tok-kw\">try</span> expect(ptr[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1</span>);\n    ptr += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(ptr[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">2</span>);\n\n    <span class=\"tok-comment\">// slicing a many-item pointer without an end is equivalent to</span>\n    <span class=\"tok-comment\">// pointer arithmetic: `ptr[start..] == ptr + start`</span>\n    <span class=\"tok-kw\">try</span> expect(ptr[<span class=\"tok-number\">1</span>..] == ptr + <span class=\"tok-number\">1</span>);\n\n    <span class=\"tok-comment\">// subtraction between any two pointers except slices based on element size is supported</span>\n    <span class=\"tok-kw\">try</span> expect(&ptr[<span class=\"tok-number\">1</span>] - &ptr[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer arithmetic with slices\"</span> {\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n    <span class=\"tok-kw\">var</span> length: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>; <span class=\"tok-comment\">// var to make it runtime-known</span>\n    _ = &length; <span class=\"tok-comment\">// suppress 'var is never mutated' error</span>\n    <span class=\"tok-kw\">var</span> slice = array[length..array.len];\n\n    <span class=\"tok-kw\">try</span> expect(slice[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(slice.len == <span class=\"tok-number\">4</span>);\n\n    slice.ptr += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-comment\">// now the slice is in an bad state since len has not been updated</span>\n\n    <span class=\"tok-kw\">try</span> expect(slice[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">try</span> expect(slice.len == <span class=\"tok-number\">4</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer slicing\"</span> {\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span>, <span class=\"tok-number\">9</span>, <span class=\"tok-number\">10</span> };\n    <span class=\"tok-kw\">var</span> start: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">2</span>; <span class=\"tok-comment\">// var to make it runtime-known</span>\n    _ = &start; <span class=\"tok-comment\">// suppress 'var is never mutated' error</span>\n    <span class=\"tok-kw\">const</span> slice = array[start..<span class=\"tok-number\">4</span>];\n    <span class=\"tok-kw\">try</span> expect(slice.len == <span class=\"tok-number\">2</span>);\n\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">3</span>] == <span class=\"tok-number\">4</span>);\n    slice[<span class=\"tok-number\">1</span>] += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">3</span>] == <span class=\"tok-number\">5</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"comptime pointers\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">const</span> ptr = &x;\n        ptr.* += <span class=\"tok-number\">1</span>;\n        x += <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">try</span> expect(ptr.* == <span class=\"tok-number\">3</span>);\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@intFromPtr and @ptrFromInt\"</span> {\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0xdeadbee0</span>);\n    <span class=\"tok-kw\">const</span> addr = <span class=\"tok-builtin\">@intFromPtr</span>(ptr);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(addr) == <span class=\"tok-type\">usize</span>);\n    <span class=\"tok-kw\">try</span> expect(addr == <span class=\"tok-number\">0xdeadbee0</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"comptime @ptrFromInt\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-comment\">// Zig is able to do this at compile-time, as long as</span>\n        <span class=\"tok-comment\">// ptr is never dereferenced.</span>\n        <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0xdeadbee0</span>);\n        <span class=\"tok-kw\">const</span> addr = <span class=\"tok-builtin\">@intFromPtr</span>(ptr);\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(addr) == <span class=\"tok-type\">usize</span>);\n        <span class=\"tok-kw\">try</span> expect(addr == <span class=\"tok-number\">0xdeadbee0</span>);\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer casting\"</span> {\n    <span class=\"tok-kw\">const</span> bytes <span class=\"tok-kw\">align</span>(<span class=\"tok-builtin\">@alignOf</span>(<span class=\"tok-type\">u32</span>)) = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">0x12</span>, <span class=\"tok-number\">0x12</span>, <span class=\"tok-number\">0x12</span>, <span class=\"tok-number\">0x12</span> };\n    <span class=\"tok-kw\">const</span> u32_ptr: *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u32</span> = <span class=\"tok-builtin\">@ptrCast</span>(&bytes);\n    <span class=\"tok-kw\">try</span> expect(u32_ptr.* == <span class=\"tok-number\">0x12121212</span>);\n\n    <span class=\"tok-comment\">// Even this example is contrived - there are better ways to do the above than</span>\n    <span class=\"tok-comment\">// pointer casting. For example, using a slice narrowing cast:</span>\n    <span class=\"tok-kw\">const</span> u32_value = std.mem.bytesAsSlice(<span class=\"tok-type\">u32</span>, bytes[<span class=\"tok-number\">0</span>..])[<span class=\"tok-number\">0</span>];\n    <span class=\"tok-kw\">try</span> expect(u32_value == <span class=\"tok-number\">0x12121212</span>);\n\n    <span class=\"tok-comment\">// And even another way, the most straightforward way to do it:</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-builtin\">@bitCast</span>(bytes)) == <span class=\"tok-number\">0x12121212</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer child type\"</span> {\n    <span class=\"tok-comment\">// pointer types have a `child` field which tells you the type they point to.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(*<span class=\"tok-type\">u32</span>).pointer.child == <span class=\"tok-type\">u32</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"volatile\"</span> {\n    <span class=\"tok-kw\">const</span> mmio_ptr: *<span class=\"tok-kw\">volatile</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0x12345678</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(mmio_ptr) == *<span class=\"tok-kw\">volatile</span> <span class=\"tok-type\">u8</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"variable alignment\"</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> align_of_i32 = <span class=\"tok-builtin\">@alignOf</span>(<span class=\"tok-builtin\">@TypeOf</span>(x));\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&x) == *<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(*<span class=\"tok-type\">i32</span> == *<span class=\"tok-kw\">align</span>(align_of_i32) <span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">if</span> (builtin.target.cpu.arch == .x86_64) {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(*<span class=\"tok-type\">i32</span>).pointer.alignment == <span class=\"tok-number\">4</span>);\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">var</span> foo: <span class=\"tok-type\">u8</span> <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) = <span class=\"tok-number\">100</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"global variable alignment\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(&foo)).pointer.alignment == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&foo) == *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">u8</span>);\n    <span class=\"tok-kw\">const</span> as_pointer_to_array: *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) [<span class=\"tok-number\">1</span>]<span class=\"tok-type\">u8</span> = &foo;\n    <span class=\"tok-kw\">const</span> as_slice: []<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">u8</span> = as_pointer_to_array;\n    <span class=\"tok-kw\">const</span> as_unaligned_slice: []<span class=\"tok-type\">u8</span> = as_slice;\n    <span class=\"tok-kw\">try</span> expect(as_unaligned_slice[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">100</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">derp</span>() <span class=\"tok-kw\">align</span>(<span class=\"tok-builtin\">@sizeOf</span>(<span class=\"tok-type\">usize</span>) * <span class=\"tok-number\">2</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">1234</span>;\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">noop1</span>() <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">1</span>) <span class=\"tok-type\">void</span> {}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">noop4</span>() <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">void</span> {}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"function alignment\"</span> {\n    <span class=\"tok-kw\">try</span> expect(derp() == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(derp) == <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&derp) == *<span class=\"tok-kw\">align</span>(<span class=\"tok-builtin\">@sizeOf</span>(<span class=\"tok-type\">usize</span>) * <span class=\"tok-number\">2</span>) <span class=\"tok-kw\">const</span> <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">i32</span>);\n\n    noop1();\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(noop1) == <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">void</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&noop1) == *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">1</span>) <span class=\"tok-kw\">const</span> <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">void</span>);\n\n    noop4();\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(noop4) == <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">void</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&noop4) == *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-kw\">const</span> <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">void</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer alignment safety\"</span> {\n    <span class=\"tok-kw\">var</span> array <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) = [_]<span class=\"tok-type\">u32</span>{ <span class=\"tok-number\">0x11111111</span>, <span class=\"tok-number\">0x11111111</span> };\n    <span class=\"tok-kw\">const</span> bytes = std.mem.sliceAsBytes(array[<span class=\"tok-number\">0</span>..]);\n    <span class=\"tok-kw\">try</span> std.testing.expect(foo(bytes) == <span class=\"tok-number\">0x11111111</span>);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(bytes: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">const</span> slice4 = bytes[<span class=\"tok-number\">1</span>..<span class=\"tok-number\">5</span>];\n    <span class=\"tok-kw\">const</span> int_slice = std.mem.bytesAsSlice(<span class=\"tok-type\">u32</span>, <span class=\"tok-builtin\">@as</span>([]<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">u8</span>, <span class=\"tok-builtin\">@alignCast</span>(slice4)));\n    <span class=\"tok-kw\">return</span> int_slice[<span class=\"tok-number\">0</span>];\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"allowzero\"</span> {\n    <span class=\"tok-kw\">var</span> zero: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>; <span class=\"tok-comment\">// var to make to runtime-known</span>\n    _ = &zero; <span class=\"tok-comment\">// suppress 'var is never mutated' error</span>\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-kw\">allowzero</span> <span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(zero);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromPtr</span>(ptr) == <span class=\"tok-number\">0</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-comment\">// This is also available as `std.c.printf`.</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"c\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">printf</span>(format: [*:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, ...) <span class=\"tok-type\">c_int</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">void</span> {\n    _ = printf(<span class=\"tok-str\">\"Hello, world!\\n\"</span>); <span class=\"tok-comment\">// OK</span>\n\n    <span class=\"tok-kw\">const</span> msg = <span class=\"tok-str\">\"Hello, world!\\n\"</span>;\n    <span class=\"tok-kw\">const</span> non_null_terminated_msg: [msg.len]<span class=\"tok-type\">u8</span> = msg.*;\n    _ = printf(&non_null_terminated_msg);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Pointers § in Zig 0.14.1",
    "context": "",
    "response": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* Supports slice syntax: ptr[ 0 .. 1 ] Supports pointer subtraction: ptr - ptr [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer-integer arithmetic: ptr + int , ptr - int Supports pointer subtraction: ptr - ptr T must have a known size, which means that it cannot be anyopaque or any other opaque type . These types are closely related to Arrays and Slices : *[N]T - pointer to N items, same as single-item pointer to an array. Supports index syntax: array_ptr[i] Supports slice syntax: array_ptr[start..end] Supports len property: array_ptr.len Supports pointer subtraction: array_ptr - array_ptr []T - is a slice (a fat pointer, which contains a pointer of type [*]T and a length). Supports index syntax: slice[i] Supports slice syntax: slice[start..end] Suppor",
    "metadata": {
      "version": "0.14.1",
      "topic": "Pointers §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Slices §",
    "context": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the len field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value at",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n<span class=\"tok-kw\">const</span> expectEqualSlices = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expectEqualSlices;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"basic slices\"</span> {\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n    <span class=\"tok-kw\">var</span> known_at_runtime_zero: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    _ = &known_at_runtime_zero;\n    <span class=\"tok-kw\">const</span> slice = array[known_at_runtime_zero..array.len];\n\n    <span class=\"tok-comment\">// alternative initialization using result location</span>\n    <span class=\"tok-kw\">const</span> alt_slice: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span> = &.{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n\n    <span class=\"tok-kw\">try</span> expectEqualSlices(<span class=\"tok-type\">i32</span>, slice, alt_slice);\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(slice) == []<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(&slice[<span class=\"tok-number\">0</span>] == &array[<span class=\"tok-number\">0</span>]);\n    <span class=\"tok-kw\">try</span> expect(slice.len == array.len);\n\n    <span class=\"tok-comment\">// If you slice with comptime-known start and end positions, the result is</span>\n    <span class=\"tok-comment\">// a pointer to an array, rather than a slice.</span>\n    <span class=\"tok-kw\">const</span> array_ptr = array[<span class=\"tok-number\">0</span>..array.len];\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(array_ptr) == *[array.len]<span class=\"tok-type\">i32</span>);\n\n    <span class=\"tok-comment\">// You can perform a slice-by-length by slicing twice. This allows the compiler</span>\n    <span class=\"tok-comment\">// to perform some optimisations like recognising a comptime-known length when</span>\n    <span class=\"tok-comment\">// the start position is only known at runtime.</span>\n    <span class=\"tok-kw\">var</span> runtime_start: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">1</span>;\n    _ = &runtime_start;\n    <span class=\"tok-kw\">const</span> length = <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">const</span> array_ptr_len = array[runtime_start..][<span class=\"tok-number\">0</span>..length];\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(array_ptr_len) == *[length]<span class=\"tok-type\">i32</span>);\n\n    <span class=\"tok-comment\">// Using the address-of operator on a slice gives a single-item pointer.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&slice[<span class=\"tok-number\">0</span>]) == *<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-comment\">// Using the `ptr` field gives a many-item pointer.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(slice.ptr) == [*]<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromPtr</span>(slice.ptr) == <span class=\"tok-builtin\">@intFromPtr</span>(&slice[<span class=\"tok-number\">0</span>]));\n\n    <span class=\"tok-comment\">// Slices have array bounds checking. If you try to access something out</span>\n    <span class=\"tok-comment\">// of bounds, you'll get a safety check failure:</span>\n    slice[<span class=\"tok-number\">10</span>] += <span class=\"tok-number\">1</span>;\n\n    <span class=\"tok-comment\">// Note that `slice.ptr` does not invoke safety checking, while `&slice[0]`</span>\n    <span class=\"tok-comment\">// asserts that the slice has len > 0.</span>\n\n    <span class=\"tok-comment\">// Empty slices can be created like this:</span>\n    <span class=\"tok-kw\">const</span> empty1 = &[<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>{};\n    <span class=\"tok-comment\">// If the type is known you can use this short hand:</span>\n    <span class=\"tok-kw\">const</span> empty2: []<span class=\"tok-type\">u8</span> = &.{};\n    <span class=\"tok-kw\">try</span> expect(empty1.len == <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(empty2.len == <span class=\"tok-number\">0</span>);\n\n    <span class=\"tok-comment\">// A zero-length initialization can always be used to create an empty slice, even if the slice is mutable.</span>\n    <span class=\"tok-comment\">// This is because the pointed-to data is zero bits long, so its immutability is irrelevant.</span>\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Slices §",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Slices §",
    "context": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the len field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value at",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> mem = std.mem;\n<span class=\"tok-kw\">const</span> fmt = std.fmt;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"using slices for strings\"</span> {\n    <span class=\"tok-comment\">// Zig has no concept of strings. String literals are const pointers</span>\n    <span class=\"tok-comment\">// to null-terminated arrays of u8, and by convention parameters</span>\n    <span class=\"tok-comment\">// that are \"strings\" are expected to be UTF-8 encoded slices of u8.</span>\n    <span class=\"tok-comment\">// Here we coerce *const [5:0]u8 and *const [6:0]u8 to []const u8</span>\n    <span class=\"tok-kw\">const</span> hello: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>;\n    <span class=\"tok-kw\">const</span> world: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"世界\"</span>;\n\n    <span class=\"tok-kw\">var</span> all_together: [<span class=\"tok-number\">100</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-comment\">// You can use slice syntax with at least one runtime-known index on an</span>\n    <span class=\"tok-comment\">// array to convert an array into a slice.</span>\n    <span class=\"tok-kw\">var</span> start: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    _ = &start;\n    <span class=\"tok-kw\">const</span> all_together_slice = all_together[start..];\n    <span class=\"tok-comment\">// String concatenation example.</span>\n    <span class=\"tok-kw\">const</span> hello_world = <span class=\"tok-kw\">try</span> fmt.bufPrint(all_together_slice, <span class=\"tok-str\">\"{s} {s}\"</span>, .{ hello, world });\n\n    <span class=\"tok-comment\">// Generally, you can use UTF-8 and not worry about whether something is a</span>\n    <span class=\"tok-comment\">// string. If you don't need to deal with individual characters, no need</span>\n    <span class=\"tok-comment\">// to decode.</span>\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, hello_world, <span class=\"tok-str\">\"hello 世界\"</span>));\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"slice pointer\"</span> {\n    <span class=\"tok-kw\">var</span> array: [<span class=\"tok-number\">10</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">const</span> ptr = &array;\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(ptr) == *[<span class=\"tok-number\">10</span>]<span class=\"tok-type\">u8</span>);\n\n    <span class=\"tok-comment\">// A pointer to an array can be sliced just like an array:</span>\n    <span class=\"tok-kw\">var</span> start: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">var</span> end: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">5</span>;\n    _ = .{ &start, &end };\n    <span class=\"tok-kw\">const</span> slice = ptr[start..end];\n    <span class=\"tok-comment\">// The slice is mutable because we sliced a mutable pointer.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(slice) == []<span class=\"tok-type\">u8</span>);\n    slice[<span class=\"tok-number\">2</span>] = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">2</span>] == <span class=\"tok-number\">3</span>);\n\n    <span class=\"tok-comment\">// Again, slicing with comptime-known indexes will produce another pointer</span>\n    <span class=\"tok-comment\">// to an array:</span>\n    <span class=\"tok-kw\">const</span> ptr2 = slice[<span class=\"tok-number\">2</span>..<span class=\"tok-number\">3</span>];\n    <span class=\"tok-kw\">try</span> expect(ptr2.len == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(ptr2[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">3</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(ptr2) == *[<span class=\"tok-number\">1</span>]<span class=\"tok-type\">u8</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Slices §",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Slices §",
    "context": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the len field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value at",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"0-terminated slice\"</span> {\n    <span class=\"tok-kw\">const</span> slice: [:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>;\n\n    <span class=\"tok-kw\">try</span> expect(slice.len == <span class=\"tok-number\">5</span>);\n    <span class=\"tok-kw\">try</span> expect(slice[<span class=\"tok-number\">5</span>] == <span class=\"tok-number\">0</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Slices §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Slices §",
    "context": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the len field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value at",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"0-terminated slicing\"</span> {\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">3</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span> };\n    <span class=\"tok-kw\">var</span> runtime_length: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">3</span>;\n    _ = &runtime_length;\n    <span class=\"tok-kw\">const</span> slice = array[<span class=\"tok-number\">0</span>..runtime_length :<span class=\"tok-number\">0</span>];\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(slice) == [:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>);\n    <span class=\"tok-kw\">try</span> expect(slice.len == <span class=\"tok-number\">3</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Slices §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Slices §",
    "context": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the len field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value at",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"sentinel mismatch\"</span> {\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">3</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span> };\n\n    <span class=\"tok-comment\">// Creating a sentinel-terminated slice from the array with a length of 2</span>\n    <span class=\"tok-comment\">// will result in the value `1` occupying the sentinel element position.</span>\n    <span class=\"tok-comment\">// This does not match the indicated sentinel value of `0` and will lead</span>\n    <span class=\"tok-comment\">// to a runtime panic.</span>\n    <span class=\"tok-kw\">var</span> runtime_length: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">2</span>;\n    _ = &runtime_length;\n    <span class=\"tok-kw\">const</span> slice = array[<span class=\"tok-number\">0</span>..runtime_length :<span class=\"tok-number\">0</span>];\n\n    _ = slice;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Slices §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Slices § in Zig 0.14.1",
    "context": "",
    "response": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the len field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value at the element indexed by the length. The type does not guarantee that there are no sentinel elements before that. Sentinel-terminated slices allow element access to the len index. test_null_terminated_slice.zig Shell Sentinel-terminated slices can also be created using a variation of the slice syntax data[start..end :x] , where data is a many-item pointer, array or slice and x is the sentinel value. test_null_terminated_slicing.zig Shell Sentinel-terminated slicing asserts that the element in the",
    "metadata": {
      "version": "0.14.1",
      "topic": "Slices §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-comment\">// Declare a struct.</span>\n<span class=\"tok-comment\">// Zig gives no guarantees about the order of fields and the size of</span>\n<span class=\"tok-comment\">// the struct but the fields are guaranteed to be ABI-aligned.</span>\n<span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> {\n    x: <span class=\"tok-type\">f32</span>,\n    y: <span class=\"tok-type\">f32</span>,\n};\n\n<span class=\"tok-comment\">// Declare an instance of a struct.</span>\n<span class=\"tok-kw\">const</span> p: Point = .{\n    .x = <span class=\"tok-number\">0.12</span>,\n    .y = <span class=\"tok-number\">0.34</span>,\n};\n\n<span class=\"tok-comment\">// Functions in the struct's namespace can be called with dot syntax.</span>\n<span class=\"tok-kw\">const</span> Vec3 = <span class=\"tok-kw\">struct</span> {\n    x: <span class=\"tok-type\">f32</span>,\n    y: <span class=\"tok-type\">f32</span>,\n    z: <span class=\"tok-type\">f32</span>,\n\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">init</span>(x: <span class=\"tok-type\">f32</span>, y: <span class=\"tok-type\">f32</span>, z: <span class=\"tok-type\">f32</span>) Vec3 {\n        <span class=\"tok-kw\">return</span> Vec3{\n            .x = x,\n            .y = y,\n            .z = z,\n        };\n    }\n\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">dot</span>(self: Vec3, other: Vec3) <span class=\"tok-type\">f32</span> {\n        <span class=\"tok-kw\">return</span> self.x * other.x + self.y * other.y + self.z * other.z;\n    }\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"dot product\"</span> {\n    <span class=\"tok-kw\">const</span> v1 = Vec3.init(<span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>);\n    <span class=\"tok-kw\">const</span> v2 = Vec3.init(<span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span>);\n    <span class=\"tok-kw\">try</span> expect(v1.dot(v2) == <span class=\"tok-number\">0.0</span>);\n\n    <span class=\"tok-comment\">// Other than being available to call with dot syntax, struct methods are</span>\n    <span class=\"tok-comment\">// not special. You can reference them as any other declaration inside</span>\n    <span class=\"tok-comment\">// the struct:</span>\n    <span class=\"tok-kw\">try</span> expect(Vec3.dot(v1, v2) == <span class=\"tok-number\">0.0</span>);\n}\n\n<span class=\"tok-comment\">// Structs can have declarations.</span>\n<span class=\"tok-comment\">// Structs can have 0 fields.</span>\n<span class=\"tok-kw\">const</span> Empty = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> PI = <span class=\"tok-number\">3.14</span>;\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"struct namespaced variable\"</span> {\n    <span class=\"tok-kw\">try</span> expect(Empty.PI == <span class=\"tok-number\">3.14</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@sizeOf</span>(Empty) == <span class=\"tok-number\">0</span>);\n\n    <span class=\"tok-comment\">// Empty structs can be instantiated the same as usual.</span>\n    <span class=\"tok-kw\">const</span> does_nothing: Empty = .{};\n\n    _ = does_nothing;\n}\n\n<span class=\"tok-comment\">// Struct field order is determined by the compiler, however, a base pointer</span>\n<span class=\"tok-comment\">// can be computed from a field pointer:</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">setYBasedOnX</span>(x: *<span class=\"tok-type\">f32</span>, y: <span class=\"tok-type\">f32</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> point: *Point = <span class=\"tok-builtin\">@fieldParentPtr</span>(<span class=\"tok-str\">\"x\"</span>, x);\n    point.y = y;\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"field parent pointer\"</span> {\n    <span class=\"tok-kw\">var</span> point = Point{\n        .x = <span class=\"tok-number\">0.1234</span>,\n        .y = <span class=\"tok-number\">0.5678</span>,\n    };\n    setYBasedOnX(&point.x, <span class=\"tok-number\">0.9</span>);\n    <span class=\"tok-kw\">try</span> expect(point.y == <span class=\"tok-number\">0.9</span>);\n}\n\n<span class=\"tok-comment\">// Structs can be returned from functions.</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">LinkedList</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">struct</span> {\n        <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> Node = <span class=\"tok-kw\">struct</span> {\n            prev: ?*Node,\n            next: ?*Node,\n            data: T,\n        };\n\n        first: ?*Node,\n        last: ?*Node,\n        len: <span class=\"tok-type\">usize</span>,\n    };\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"linked list\"</span> {\n    <span class=\"tok-comment\">// Functions called at compile-time are memoized.</span>\n    <span class=\"tok-kw\">try</span> expect(LinkedList(<span class=\"tok-type\">i32</span>) == LinkedList(<span class=\"tok-type\">i32</span>));\n\n    <span class=\"tok-kw\">const</span> list = LinkedList(<span class=\"tok-type\">i32</span>){\n        .first = <span class=\"tok-null\">null</span>,\n        .last = <span class=\"tok-null\">null</span>,\n        .len = <span class=\"tok-number\">0</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(list.len == <span class=\"tok-number\">0</span>);\n\n    <span class=\"tok-comment\">// Since types are first class values you can instantiate the type</span>\n    <span class=\"tok-comment\">// by assigning it to a variable:</span>\n    <span class=\"tok-kw\">const</span> ListOfInts = LinkedList(<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(ListOfInts == LinkedList(<span class=\"tok-type\">i32</span>));\n\n    <span class=\"tok-kw\">var</span> node = ListOfInts.Node{\n        .prev = <span class=\"tok-null\">null</span>,\n        .next = <span class=\"tok-null\">null</span>,\n        .data = <span class=\"tok-number\">1234</span>,\n    };\n    <span class=\"tok-kw\">const</span> list2 = LinkedList(<span class=\"tok-type\">i32</span>){\n        .first = &node,\n        .last = &node,\n        .len = <span class=\"tok-number\">1</span>,\n    };\n\n    <span class=\"tok-comment\">// When using a pointer to a struct, fields can be accessed directly,</span>\n    <span class=\"tok-comment\">// without explicitly dereferencing the pointer.</span>\n    <span class=\"tok-comment\">// So you can do</span>\n    <span class=\"tok-kw\">try</span> expect(list2.first.?.data == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-comment\">// instead of try expect(list2.first.?.*.data == 1234);</span>\n}\n\n<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>,\n    b: <span class=\"tok-type\">i32</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"default struct initialization fields\"</span> {\n    <span class=\"tok-kw\">const</span> x: Foo = .{\n        .b = <span class=\"tok-number\">5</span>,\n    };\n    <span class=\"tok-kw\">if</span> (x.a + x.b != <span class=\"tok-number\">1239</span>) {\n        <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">unreachable</span>;\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> Threshold = <span class=\"tok-kw\">struct</span> {\n    minimum: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">0.25</span>,\n    maximum: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">0.75</span>,\n\n    <span class=\"tok-kw\">const</span> Category = <span class=\"tok-kw\">enum</span> { low, medium, high };\n\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">categorize</span>(t: Threshold, value: <span class=\"tok-type\">f32</span>) Category {\n        assert(t.maximum >= t.minimum);\n        <span class=\"tok-kw\">if</span> (value < t.minimum) <span class=\"tok-kw\">return</span> .low;\n        <span class=\"tok-kw\">if</span> (value > t.maximum) <span class=\"tok-kw\">return</span> .high;\n        <span class=\"tok-kw\">return</span> .medium;\n    }\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> threshold: Threshold = .{\n        .maximum = <span class=\"tok-number\">0.20</span>,\n    };\n    <span class=\"tok-kw\">const</span> category = threshold.categorize(<span class=\"tok-number\">0.90</span>);\n    <span class=\"tok-kw\">try</span> std.io.getStdOut().writeAll(<span class=\"tok-builtin\">@tagName</span>(category));\n}\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> assert = std.debug.assert;",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> Threshold = <span class=\"tok-kw\">struct</span> {\n    minimum: <span class=\"tok-type\">f32</span>,\n    maximum: <span class=\"tok-type\">f32</span>,\n\n    <span class=\"tok-kw\">const</span> default: Threshold = .{\n        .minimum = <span class=\"tok-number\">0.25</span>,\n        .maximum = <span class=\"tok-number\">0.75</span>,\n    };\n};",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> native_endian = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>).target.cpu.arch.endian();\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Full = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    number: <span class=\"tok-type\">u16</span>,\n};\n<span class=\"tok-kw\">const</span> Divided = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    half1: <span class=\"tok-type\">u8</span>,\n    quarter3: <span class=\"tok-type\">u4</span>,\n    quarter4: <span class=\"tok-type\">u4</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@bitCast between packed structs\"</span> {\n    <span class=\"tok-kw\">try</span> doTheTest();\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> doTheTest();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doTheTest</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@sizeOf</span>(Full) == <span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@sizeOf</span>(Divided) == <span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">const</span> full = Full{ .number = <span class=\"tok-number\">0x1234</span> };\n    <span class=\"tok-kw\">const</span> divided: Divided = <span class=\"tok-builtin\">@bitCast</span>(full);\n    <span class=\"tok-kw\">try</span> expect(divided.half1 == <span class=\"tok-number\">0x34</span>);\n    <span class=\"tok-kw\">try</span> expect(divided.quarter3 == <span class=\"tok-number\">0x2</span>);\n    <span class=\"tok-kw\">try</span> expect(divided.quarter4 == <span class=\"tok-number\">0x1</span>);\n\n    <span class=\"tok-kw\">const</span> ordered: [<span class=\"tok-number\">2</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@bitCast</span>(full);\n    <span class=\"tok-kw\">switch</span> (native_endian) {\n        .big => {\n            <span class=\"tok-kw\">try</span> expect(ordered[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">0x12</span>);\n            <span class=\"tok-kw\">try</span> expect(ordered[<span class=\"tok-number\">1</span>] == <span class=\"tok-number\">0x34</span>);\n        },\n        .little => {\n            <span class=\"tok-kw\">try</span> expect(ordered[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">0x34</span>);\n            <span class=\"tok-kw\">try</span> expect(ordered[<span class=\"tok-number\">1</span>] == <span class=\"tok-number\">0x12</span>);\n        },\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"missized packed struct\"</span> {\n    <span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span>(<span class=\"tok-type\">u32</span>) { a: <span class=\"tok-type\">u16</span>, b: <span class=\"tok-type\">u8</span> };\n    _ = S{ .a = <span class=\"tok-number\">4</span>, .b = <span class=\"tok-number\">2</span> };\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> BitField = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">u3</span>,\n    b: <span class=\"tok-type\">u3</span>,\n    c: <span class=\"tok-type\">u2</span>,\n};\n\n<span class=\"tok-kw\">var</span> foo = BitField{\n    .a = <span class=\"tok-number\">1</span>,\n    .b = <span class=\"tok-number\">2</span>,\n    .c = <span class=\"tok-number\">3</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer to non-byte-aligned field\"</span> {\n    <span class=\"tok-kw\">const</span> ptr = &foo.b;\n    <span class=\"tok-kw\">try</span> expect(ptr.* == <span class=\"tok-number\">2</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> BitField = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">u3</span>,\n    b: <span class=\"tok-type\">u3</span>,\n    c: <span class=\"tok-type\">u2</span>,\n};\n\n<span class=\"tok-kw\">var</span> bit_field = BitField{\n    .a = <span class=\"tok-number\">1</span>,\n    .b = <span class=\"tok-number\">2</span>,\n    .c = <span class=\"tok-number\">3</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer to non-byte-aligned field\"</span> {\n    <span class=\"tok-kw\">try</span> expect(bar(&bit_field.b) == <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>(x: *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u3</span>) <span class=\"tok-type\">u3</span> {\n    <span class=\"tok-kw\">return</span> x.*;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> BitField = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">u3</span>,\n    b: <span class=\"tok-type\">u3</span>,\n    c: <span class=\"tok-type\">u2</span>,\n};\n\n<span class=\"tok-kw\">var</span> bit_field = BitField{\n    .a = <span class=\"tok-number\">1</span>,\n    .b = <span class=\"tok-number\">2</span>,\n    .c = <span class=\"tok-number\">3</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointers of sub-byte-aligned fields share addresses\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromPtr</span>(&bit_field.a) == <span class=\"tok-builtin\">@intFromPtr</span>(&bit_field.b));\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromPtr</span>(&bit_field.a) == <span class=\"tok-builtin\">@intFromPtr</span>(&bit_field.c));\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> BitField = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">u3</span>,\n    b: <span class=\"tok-type\">u3</span>,\n    c: <span class=\"tok-type\">u2</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"offsets of non-byte-aligned fields\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@bitOffsetOf</span>(BitField, <span class=\"tok-str\">\"a\"</span>) == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@bitOffsetOf</span>(BitField, <span class=\"tok-str\">\"b\"</span>) == <span class=\"tok-number\">3</span>);\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@bitOffsetOf</span>(BitField, <span class=\"tok-str\">\"c\"</span>) == <span class=\"tok-number\">6</span>);\n\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@offsetOf</span>(BitField, <span class=\"tok-str\">\"a\"</span>) == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@offsetOf</span>(BitField, <span class=\"tok-str\">\"b\"</span>) == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@offsetOf</span>(BitField, <span class=\"tok-str\">\"c\"</span>) == <span class=\"tok-number\">0</span>);\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">u32</span>,\n    b: <span class=\"tok-type\">u32</span>,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"overaligned pointer to packed struct\"</span> {\n    <span class=\"tok-kw\">var</span> foo: S <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) = .{ .a = <span class=\"tok-number\">1</span>, .b = <span class=\"tok-number\">2</span> };\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) S = &foo;\n    <span class=\"tok-kw\">const</span> ptr_to_b: *<span class=\"tok-type\">u32</span> = &ptr.b;\n    <span class=\"tok-kw\">try</span> expect(ptr_to_b.* == <span class=\"tok-number\">2</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expectEqual = std.testing.expectEqual;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"aligned struct fields\"</span> {\n    <span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> {\n        a: <span class=\"tok-type\">u32</span> <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">2</span>),\n        b: <span class=\"tok-type\">u32</span> <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">64</span>),\n    };\n    <span class=\"tok-kw\">var</span> foo = S{ .a = <span class=\"tok-number\">1</span>, .b = <span class=\"tok-number\">2</span> };\n\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">64</span>, <span class=\"tok-builtin\">@alignOf</span>(S));\n    <span class=\"tok-kw\">try</span> expectEqual(*<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">2</span>) <span class=\"tok-type\">u32</span>, <span class=\"tok-builtin\">@TypeOf</span>(&foo.a));\n    <span class=\"tok-kw\">try</span> expectEqual(*<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">64</span>) <span class=\"tok-type\">u32</span>, <span class=\"tok-builtin\">@TypeOf</span>(&foo.b));\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"packed struct equality\"</span> {\n    <span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n        a: <span class=\"tok-type\">u4</span>,\n        b: <span class=\"tok-type\">u4</span>,\n    };\n    <span class=\"tok-kw\">const</span> x: S = .{ .a = <span class=\"tok-number\">1</span>, .b = <span class=\"tok-number\">2</span> };\n    <span class=\"tok-kw\">const</span> y: S = .{ .b = <span class=\"tok-number\">2</span>, .a = <span class=\"tok-number\">1</span> };\n    <span class=\"tok-kw\">try</span> expect(x == y);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">struct</span> {};\n    std.debug.print(<span class=\"tok-str\">\"variable: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@typeName</span>(Foo)});\n    std.debug.print(<span class=\"tok-str\">\"anonymous: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@typeName</span>(<span class=\"tok-kw\">struct</span> {})});\n    std.debug.print(<span class=\"tok-str\">\"function: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@typeName</span>(List(<span class=\"tok-type\">i32</span>))});\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">List</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">struct</span> {\n        x: T,\n    };\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> { x: <span class=\"tok-type\">i32</span>, y: <span class=\"tok-type\">i32</span> };\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"anonymous struct literal\"</span> {\n    <span class=\"tok-kw\">const</span> pt: Point = .{\n        .x = <span class=\"tok-number\">13</span>,\n        .y = <span class=\"tok-number\">67</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(pt.x == <span class=\"tok-number\">13</span>);\n    <span class=\"tok-kw\">try</span> expect(pt.y == <span class=\"tok-number\">67</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fully anonymous struct\"</span> {\n    <span class=\"tok-kw\">try</span> check(.{\n        .int = <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-number\">1234</span>),\n        .float = <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">f64</span>, <span class=\"tok-number\">12.34</span>),\n        .b = <span class=\"tok-null\">true</span>,\n        .s = <span class=\"tok-str\">\"hi\"</span>,\n    });\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">check</span>(args: <span class=\"tok-kw\">anytype</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> expect(args.int == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> expect(args.float == <span class=\"tok-number\">12.34</span>);\n    <span class=\"tok-kw\">try</span> expect(args.b);\n    <span class=\"tok-kw\">try</span> expect(args.s[<span class=\"tok-number\">0</span>] == <span class=\"tok-str\">'h'</span>);\n    <span class=\"tok-kw\">try</span> expect(args.s[<span class=\"tok-number\">1</span>] == <span class=\"tok-str\">'i'</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"tuple\"</span> {\n    <span class=\"tok-kw\">const</span> values = .{\n        <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-number\">1234</span>),\n        <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">f64</span>, <span class=\"tok-number\">12.34</span>),\n        <span class=\"tok-null\">true</span>,\n        <span class=\"tok-str\">\"hi\"</span>,\n    } ++ .{<span class=\"tok-null\">false</span>} ** <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">try</span> expect(values[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> expect(values[<span class=\"tok-number\">4</span>] == <span class=\"tok-null\">false</span>);\n    <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">for</span> (values, <span class=\"tok-number\">0</span>..) |v, i| {\n        <span class=\"tok-kw\">if</span> (i != <span class=\"tok-number\">2</span>) <span class=\"tok-kw\">continue</span>;\n        <span class=\"tok-kw\">try</span> expect(v);\n    }\n    <span class=\"tok-kw\">try</span> expect(values.len == <span class=\"tok-number\">6</span>);\n    <span class=\"tok-kw\">try</span> expect(values.@\"3\"[<span class=\"tok-number\">0</span>] == <span class=\"tok-str\">'h'</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> digits = [_]<span class=\"tok-type\">i8</span> { <span class=\"tok-number\">3</span>, <span class=\"tok-number\">8</span>, <span class=\"tok-number\">9</span>, <span class=\"tok-number\">0</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">1</span> };\n\n    <span class=\"tok-kw\">const</span> min, <span class=\"tok-kw\">const</span> max = blk: {\n        <span class=\"tok-kw\">var</span> min: <span class=\"tok-type\">i8</span> = <span class=\"tok-number\">127</span>;\n        <span class=\"tok-kw\">var</span> max: <span class=\"tok-type\">i8</span> = -<span class=\"tok-number\">128</span>;\n\n        <span class=\"tok-kw\">for</span> (digits) |digit| {\n            <span class=\"tok-kw\">if</span> (digit < min) min = digit;\n            <span class=\"tok-kw\">if</span> (digit > max) max = digit;\n        }\n\n        <span class=\"tok-kw\">break</span> :blk .{ min, max };\n    };\n\n    print(<span class=\"tok-str\">\"min = {}\"</span>, .{ min });\n    print(<span class=\"tok-str\">\"max = {}\"</span>, .{ max });\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default s",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">divmod</span>(numerator: <span class=\"tok-type\">u32</span>, denominator: <span class=\"tok-type\">u32</span>) <span class=\"tok-kw\">struct</span> { <span class=\"tok-type\">u32</span>, <span class=\"tok-type\">u32</span> } {\n    <span class=\"tok-kw\">return</span> .{ numerator / denominator, numerator % denominator };\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> div, <span class=\"tok-kw\">const</span> mod = divmod(<span class=\"tok-number\">10</span>, <span class=\"tok-number\">3</span>);\n\n    print(<span class=\"tok-str\">\"10 / 3 = {}\\n\"</span>, .{div});\n    print(<span class=\"tok-str\">\"10 % 3 = {}\\n\"</span>, .{mod});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain struct § in Zig 0.14.1",
    "context": "",
    "response": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Faulty Default Field Values § Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: bad_default_value.zig Shell Above you can see the danger of ignoring this principle. The default field values caused the data invariant to be violated, causing illegal behavior. To fix this, remove the default values from all the struct fields, and provide a named default value: struct_default_value.zig If a struct value requires a runtime-known value in order to be initialized without violating data invariants, then use an initialization method that accepts those run",
    "metadata": {
      "version": "0.14.1",
      "topic": "struct §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: enum §",
    "context": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum mus",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem;\n\n<span class=\"tok-comment\">// Declare an enum.</span>\n<span class=\"tok-kw\">const</span> Type = <span class=\"tok-kw\">enum</span> {\n    ok,\n    not_ok,\n};\n\n<span class=\"tok-comment\">// Declare a specific enum field.</span>\n<span class=\"tok-kw\">const</span> c = Type.ok;\n\n<span class=\"tok-comment\">// If you want access to the ordinal value of an enum, you</span>\n<span class=\"tok-comment\">// can specify the tag type.</span>\n<span class=\"tok-kw\">const</span> Value = <span class=\"tok-kw\">enum</span>(<span class=\"tok-type\">u2</span>) {\n    zero,\n    one,\n    two,\n};\n<span class=\"tok-comment\">// Now you can cast between u2 and Value.</span>\n<span class=\"tok-comment\">// The ordinal value starts from 0, counting up by 1 from the previous member.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum ordinal value\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value.zero) == <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value.one) == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value.two) == <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-comment\">// You can override the ordinal value for an enum.</span>\n<span class=\"tok-kw\">const</span> Value2 = <span class=\"tok-kw\">enum</span>(<span class=\"tok-type\">u32</span>) {\n    hundred = <span class=\"tok-number\">100</span>,\n    thousand = <span class=\"tok-number\">1000</span>,\n    million = <span class=\"tok-number\">1000000</span>,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"set enum ordinal value\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value2.hundred) == <span class=\"tok-number\">100</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value2.thousand) == <span class=\"tok-number\">1000</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value2.million) == <span class=\"tok-number\">1000000</span>);\n}\n\n<span class=\"tok-comment\">// You can also override only some values.</span>\n<span class=\"tok-kw\">const</span> Value3 = <span class=\"tok-kw\">enum</span>(<span class=\"tok-type\">u4</span>) {\n    a,\n    b = <span class=\"tok-number\">8</span>,\n    c,\n    d = <span class=\"tok-number\">4</span>,\n    e,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum implicit ordinal values and overridden values\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value3.a) == <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value3.b) == <span class=\"tok-number\">8</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value3.c) == <span class=\"tok-number\">9</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value3.d) == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value3.e) == <span class=\"tok-number\">5</span>);\n}\n\n<span class=\"tok-comment\">// Enums can have methods, the same as structs and unions.</span>\n<span class=\"tok-comment\">// Enum methods are not special, they are only namespaced</span>\n<span class=\"tok-comment\">// functions that you can call with dot syntax.</span>\n<span class=\"tok-kw\">const</span> Suit = <span class=\"tok-kw\">enum</span> {\n    clubs,\n    spades,\n    diamonds,\n    hearts,\n\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">isClubs</span>(self: Suit) <span class=\"tok-type\">bool</span> {\n        <span class=\"tok-kw\">return</span> self == Suit.clubs;\n    }\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum method\"</span> {\n    <span class=\"tok-kw\">const</span> p = Suit.spades;\n    <span class=\"tok-kw\">try</span> expect(!p.isClubs());\n}\n\n<span class=\"tok-comment\">// An enum can be switched upon.</span>\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">enum</span> {\n    string,\n    number,\n    none,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum switch\"</span> {\n    <span class=\"tok-kw\">const</span> p = Foo.number;\n    <span class=\"tok-kw\">const</span> what_is_it = <span class=\"tok-kw\">switch</span> (p) {\n        Foo.string => <span class=\"tok-str\">\"this is a string\"</span>,\n        Foo.number => <span class=\"tok-str\">\"this is a number\"</span>,\n        Foo.none => <span class=\"tok-str\">\"this is a none\"</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, what_is_it, <span class=\"tok-str\">\"this is a number\"</span>));\n}\n\n<span class=\"tok-comment\">// @typeInfo can be used to access the integer tag type of an enum.</span>\n<span class=\"tok-kw\">const</span> Small = <span class=\"tok-kw\">enum</span> {\n    one,\n    two,\n    three,\n    four,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"std.meta.Tag\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(Small).@\"enum\".tag_type == <span class=\"tok-type\">u2</span>);\n}\n\n<span class=\"tok-comment\">// @typeInfo tells us the field count and the fields names:</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@typeInfo\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(Small).@\"enum\".fields.len == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-builtin\">@typeInfo</span>(Small).@\"enum\".fields[<span class=\"tok-number\">1</span>].name, <span class=\"tok-str\">\"two\"</span>));\n}\n\n<span class=\"tok-comment\">// @tagName gives a [:0]const u8 representation of an enum value:</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@tagName\"</span> {\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-builtin\">@tagName</span>(Small.three), <span class=\"tok-str\">\"three\"</span>));\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "enum §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: enum §",
    "context": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum mus",
    "response": "<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">enum</span> { a, b, c };\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">entry</span>(foo: Foo) <span class=\"tok-type\">void</span> {\n    _ = foo;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "enum §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: enum §",
    "context": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum mus",
    "response": "<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">enum</span>(<span class=\"tok-type\">c_int</span>) { a, b, c };\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">entry</span>(foo: Foo) <span class=\"tok-type\">void</span> {\n    _ = foo;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "enum §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: enum §",
    "context": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum mus",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Color = <span class=\"tok-kw\">enum</span> {\n    auto,\n    off,\n    on,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum literals\"</span> {\n    <span class=\"tok-kw\">const</span> color1: Color = .auto;\n    <span class=\"tok-kw\">const</span> color2 = Color.auto;\n    <span class=\"tok-kw\">try</span> expect(color1 == color2);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch using enum literals\"</span> {\n    <span class=\"tok-kw\">const</span> color = Color.on;\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">switch</span> (color) {\n        .auto => <span class=\"tok-null\">false</span>,\n        .on => <span class=\"tok-null\">true</span>,\n        .off => <span class=\"tok-null\">false</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(result);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "enum §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: enum §",
    "context": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum mus",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Number = <span class=\"tok-kw\">enum</span>(<span class=\"tok-type\">u8</span>) {\n    one,\n    two,\n    three,\n    _,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch on non-exhaustive enum\"</span> {\n    <span class=\"tok-kw\">const</span> number = Number.one;\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">switch</span> (number) {\n        .one => <span class=\"tok-null\">true</span>,\n        .two, .three => <span class=\"tok-null\">false</span>,\n        _ => <span class=\"tok-null\">false</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(result);\n    <span class=\"tok-kw\">const</span> is_one = <span class=\"tok-kw\">switch</span> (number) {\n        .one => <span class=\"tok-null\">true</span>,\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-null\">false</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(is_one);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "enum §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain enum § in Zig 0.14.1",
    "context": "",
    "response": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum must specify a tag type and cannot consume every enumeration value. @enumFromInt on a non-exhaustive enum involves the safety semantics of @intCast to the integer tag type, but beyond that always results in a well-defined enum value. A switch on a non-exhaustive enum can include a _ prong as an alternative to an else prong. With a _ prong the compiler errors if all the known tag names are not handled by the switch. test_switch_non-exhaustive.zig Shell",
    "metadata": {
      "version": "0.14.1",
      "topic": "enum §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entir",
    "response": "<span class=\"tok-kw\">const</span> Payload = <span class=\"tok-kw\">union</span> {\n    int: <span class=\"tok-type\">i64</span>,\n    float: <span class=\"tok-type\">f64</span>,\n    boolean: <span class=\"tok-type\">bool</span>,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"simple union\"</span> {\n    <span class=\"tok-kw\">var</span> payload = Payload{ .int = <span class=\"tok-number\">1234</span> };\n    payload.float = <span class=\"tok-number\">12.34</span>;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "union §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entir",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Payload = <span class=\"tok-kw\">union</span> {\n    int: <span class=\"tok-type\">i64</span>,\n    float: <span class=\"tok-type\">f64</span>,\n    boolean: <span class=\"tok-type\">bool</span>,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"simple union\"</span> {\n    <span class=\"tok-kw\">var</span> payload = Payload{ .int = <span class=\"tok-number\">1234</span> };\n    <span class=\"tok-kw\">try</span> expect(payload.int == <span class=\"tok-number\">1234</span>);\n    payload = Payload{ .float = <span class=\"tok-number\">12.34</span> };\n    <span class=\"tok-kw\">try</span> expect(payload.float == <span class=\"tok-number\">12.34</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entir",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> ComplexTypeTag = <span class=\"tok-kw\">enum</span> {\n    ok,\n    not_ok,\n};\n<span class=\"tok-kw\">const</span> ComplexType = <span class=\"tok-kw\">union</span>(ComplexTypeTag) {\n    ok: <span class=\"tok-type\">u8</span>,\n    not_ok: <span class=\"tok-type\">void</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch on tagged union\"</span> {\n    <span class=\"tok-kw\">const</span> c = ComplexType{ .ok = <span class=\"tok-number\">42</span> };\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@as</span>(ComplexTypeTag, c) == ComplexTypeTag.ok);\n\n    <span class=\"tok-kw\">switch</span> (c) {\n        .ok => |value| <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">42</span>),\n        .not_ok => <span class=\"tok-kw\">unreachable</span>,\n    }\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"get tag type\"</span> {\n    <span class=\"tok-kw\">try</span> expect(std.meta.Tag(ComplexType) == ComplexTypeTag);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entir",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> ComplexTypeTag = <span class=\"tok-kw\">enum</span> {\n    ok,\n    not_ok,\n};\n<span class=\"tok-kw\">const</span> ComplexType = <span class=\"tok-kw\">union</span>(ComplexTypeTag) {\n    ok: <span class=\"tok-type\">u8</span>,\n    not_ok: <span class=\"tok-type\">void</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"modify tagged union in switch\"</span> {\n    <span class=\"tok-kw\">var</span> c = ComplexType{ .ok = <span class=\"tok-number\">42</span> };\n\n    <span class=\"tok-kw\">switch</span> (c) {\n        ComplexTypeTag.ok => |*value| value.* += <span class=\"tok-number\">1</span>,\n        ComplexTypeTag.not_ok => <span class=\"tok-kw\">unreachable</span>,\n    }\n\n    <span class=\"tok-kw\">try</span> expect(c.ok == <span class=\"tok-number\">43</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entir",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Variant = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n    int: <span class=\"tok-type\">i32</span>,\n    boolean: <span class=\"tok-type\">bool</span>,\n\n    <span class=\"tok-comment\">// void can be omitted when inferring enum tag type.</span>\n    none,\n\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">truthy</span>(self: Variant) <span class=\"tok-type\">bool</span> {\n        <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (self) {\n            Variant.int => |x_int| x_int != <span class=\"tok-number\">0</span>,\n            Variant.boolean => |x_bool| x_bool,\n            Variant.none => <span class=\"tok-null\">false</span>,\n        };\n    }\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"union method\"</span> {\n    <span class=\"tok-kw\">var</span> v1: Variant = .{ .int = <span class=\"tok-number\">1</span> };\n    <span class=\"tok-kw\">var</span> v2: Variant = .{ .boolean = <span class=\"tok-null\">false</span> };\n    <span class=\"tok-kw\">var</span> v3: Variant = .none;\n\n    <span class=\"tok-kw\">try</span> expect(v1.truthy());\n    <span class=\"tok-kw\">try</span> expect(!v2.truthy());\n    <span class=\"tok-kw\">try</span> expect(!v3.truthy());\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entir",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Small2 = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n    a: <span class=\"tok-type\">i32</span>,\n    b: <span class=\"tok-type\">bool</span>,\n    c: <span class=\"tok-type\">u8</span>,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@tagName\"</span> {\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-builtin\">@tagName</span>(Small2.a), <span class=\"tok-str\">\"a\"</span>));\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entir",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Number = <span class=\"tok-kw\">union</span> {\n    int: <span class=\"tok-type\">i32</span>,\n    float: <span class=\"tok-type\">f64</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"anonymous union literal syntax\"</span> {\n    <span class=\"tok-kw\">const</span> i: Number = .{ .int = <span class=\"tok-number\">42</span> };\n    <span class=\"tok-kw\">const</span> f = makeNumber();\n    <span class=\"tok-kw\">try</span> expect(i.int == <span class=\"tok-number\">42</span>);\n    <span class=\"tok-kw\">try</span> expect(f.float == <span class=\"tok-number\">12.34</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">makeNumber</span>() Number {\n    <span class=\"tok-kw\">return</span> .{ .float = <span class=\"tok-number\">12.34</span> };\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain union § in Zig 0.14.1",
    "context": "",
    "response": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Illegal Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entire union: test_simple_union.zig Shell In order to use switch with a union, it must be a Tagged union . To initialize a union when the tag is a comptime -known name, see @unionInit . Tagged union § Unions can be declared with an enum tag type. This turns the union into a tagged union, which makes it eligible to use with switch expressions. Tagged unions coerce to their tag type: Type Coercion: Unions and Enums . test_tagged_union.zig Shell In order to modify the payload of a tagged union in a swit",
    "metadata": {
      "version": "0.14.1",
      "topic": "union §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: opaque §",
    "context": "opaque {} declares a new type with an unknown (but non-zero) size and alignment. It can contain declarations the same as structs , unions , and enums . This is typically used for type safety when interacting with C code that does not expose struct details. Example: test_opaque.zig Shell",
    "response": "<span class=\"tok-kw\">const</span> Derp = <span class=\"tok-kw\">opaque</span> {};\n<span class=\"tok-kw\">const</span> Wat = <span class=\"tok-kw\">opaque</span> {};\n\n<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>(d: *Derp) <span class=\"tok-type\">void</span>;\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(w: *Wat) <span class=\"tok-kw\">callconv</span>(.C) <span class=\"tok-type\">void</span> {\n    bar(w);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"call foo\"</span> {\n    foo(<span class=\"tok-null\">undefined</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "opaque §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain opaque § in Zig 0.14.1",
    "context": "",
    "response": "opaque {} declares a new type with an unknown (but non-zero) size and alignment. It can contain declarations the same as structs , unions , and enums . This is typically used for type safety when interacting with C code that does not expose struct details. Example: test_opaque.zig Shell",
    "metadata": {
      "version": "0.14.1",
      "topic": "opaque §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Blocks §",
    "context": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing wit",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"access variable after block scope\"</span> {\n    {\n        <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n        _ = &x;\n    }\n    x += <span class=\"tok-number\">1</span>;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Blocks §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Blocks §",
    "context": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing wit",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"labeled break from labeled block expression\"</span> {\n    <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">123</span>;\n\n    <span class=\"tok-kw\">const</span> x = blk: {\n        y += <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">break</span> :blk y;\n    };\n    <span class=\"tok-kw\">try</span> expect(x == <span class=\"tok-number\">124</span>);\n    <span class=\"tok-kw\">try</span> expect(y == <span class=\"tok-number\">124</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Blocks §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Blocks §",
    "context": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing wit",
    "response": "<span class=\"tok-kw\">const</span> pi = <span class=\"tok-number\">3.14</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inside test block\"</span> {\n    <span class=\"tok-comment\">// Let's even go inside another block</span>\n    {\n        <span class=\"tok-kw\">var</span> pi: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Blocks §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Blocks §",
    "context": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing wit",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"separate scopes\"</span> {\n    {\n        <span class=\"tok-kw\">const</span> pi = <span class=\"tok-number\">3.14</span>;\n        _ = pi;\n    }\n    {\n        <span class=\"tok-kw\">var</span> pi: <span class=\"tok-type\">bool</span> = <span class=\"tok-null\">true</span>;\n        _ = &pi;\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Blocks §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Blocks §",
    "context": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing wit",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> {\n    <span class=\"tok-kw\">const</span> a = {};\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-type\">void</span>{};\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(a) == <span class=\"tok-type\">void</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(b) == <span class=\"tok-type\">void</span>);\n    <span class=\"tok-kw\">try</span> expect(a == b);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Blocks §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Blocks § in Zig 0.14.1",
    "context": "",
    "response": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing within the scope it is defined. Note that you can, however, use the same name if the scopes are separate: test_scopes.zig Shell Empty Blocks § An empty block is equivalent to void {} : test_empty_block.zig Shell",
    "metadata": {
      "version": "0.14.1",
      "topic": "Blocks §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch simple\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">const</span> zz: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">103</span>;\n\n    <span class=\"tok-comment\">// All branches of a switch expression must be able to be coerced to a</span>\n    <span class=\"tok-comment\">// common type.</span>\n    <span class=\"tok-comment\">//</span>\n    <span class=\"tok-comment\">// Branches cannot fallthrough. If fallthrough behavior is desired, combine</span>\n    <span class=\"tok-comment\">// the cases and use an if.</span>\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-kw\">switch</span> (a) {\n        <span class=\"tok-comment\">// Multiple cases can be combined via a ','</span>\n        <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span> => <span class=\"tok-number\">0</span>,\n\n        <span class=\"tok-comment\">// Ranges can be specified using the ... syntax. These are inclusive</span>\n        <span class=\"tok-comment\">// of both ends.</span>\n        <span class=\"tok-number\">5</span>...<span class=\"tok-number\">100</span> => <span class=\"tok-number\">1</span>,\n\n        <span class=\"tok-comment\">// Branches can be arbitrarily complex.</span>\n        <span class=\"tok-number\">101</span> => blk: {\n            <span class=\"tok-kw\">const</span> c: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">5</span>;\n            <span class=\"tok-kw\">break</span> :blk c * <span class=\"tok-number\">2</span> + <span class=\"tok-number\">1</span>;\n        },\n\n        <span class=\"tok-comment\">// Switching on arbitrary expressions is allowed as long as the</span>\n        <span class=\"tok-comment\">// expression is known at compile-time.</span>\n        zz => zz,\n        blk: {\n            <span class=\"tok-kw\">const</span> d: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">5</span>;\n            <span class=\"tok-kw\">const</span> e: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">100</span>;\n            <span class=\"tok-kw\">break</span> :blk d + e;\n        } => <span class=\"tok-number\">107</span>,\n\n        <span class=\"tok-comment\">// The else branch catches everything not already captured.</span>\n        <span class=\"tok-comment\">// Else branches are mandatory unless the entire range of values</span>\n        <span class=\"tok-comment\">// is handled.</span>\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-number\">9</span>,\n    };\n\n    <span class=\"tok-kw\">try</span> expect(b == <span class=\"tok-number\">1</span>);\n}\n\n<span class=\"tok-comment\">// Switch expressions can be used outside a function:</span>\n<span class=\"tok-kw\">const</span> os_msg = <span class=\"tok-kw\">switch</span> (builtin.target.os.tag) {\n    .linux => <span class=\"tok-str\">\"we found a linux user\"</span>,\n    <span class=\"tok-kw\">else</span> => <span class=\"tok-str\">\"not a linux user\"</span>,\n};\n\n<span class=\"tok-comment\">// Inside a function, switch statements implicitly are compile-time</span>\n<span class=\"tok-comment\">// evaluated if the target expression is compile-time known.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch inside function\"</span> {\n    <span class=\"tok-kw\">switch</span> (builtin.target.os.tag) {\n        .fuchsia => {\n            <span class=\"tok-comment\">// On an OS other than fuchsia, block is not even analyzed,</span>\n            <span class=\"tok-comment\">// so this compile error is not triggered.</span>\n            <span class=\"tok-comment\">// On fuchsia this compile error would be triggered.</span>\n            <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"fuchsia not supported\"</span>);\n        },\n        <span class=\"tok-kw\">else</span> => {},\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch on tagged union\"</span> {\n    <span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> {\n        x: <span class=\"tok-type\">u8</span>,\n        y: <span class=\"tok-type\">u8</span>,\n    };\n    <span class=\"tok-kw\">const</span> Item = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n        a: <span class=\"tok-type\">u32</span>,\n        c: Point,\n        d,\n        e: <span class=\"tok-type\">u32</span>,\n    };\n\n    <span class=\"tok-kw\">var</span> a = Item{ .c = Point{ .x = <span class=\"tok-number\">1</span>, .y = <span class=\"tok-number\">2</span> } };\n\n    <span class=\"tok-comment\">// Switching on more complex enums is allowed.</span>\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-kw\">switch</span> (a) {\n        <span class=\"tok-comment\">// A capture group is allowed on a match, and will return the enum</span>\n        <span class=\"tok-comment\">// value matched. If the payload types of both cases are the same</span>\n        <span class=\"tok-comment\">// they can be put into the same switch prong.</span>\n        Item.a, Item.e => |item| item,\n\n        <span class=\"tok-comment\">// A reference to the matched value can be obtained using `*` syntax.</span>\n        Item.c => |*item| blk: {\n            item.*.x += <span class=\"tok-number\">1</span>;\n            <span class=\"tok-kw\">break</span> :blk <span class=\"tok-number\">6</span>;\n        },\n\n        <span class=\"tok-comment\">// No else is required if the types cases was exhaustively handled</span>\n        Item.d => <span class=\"tok-number\">8</span>,\n    };\n\n    <span class=\"tok-kw\">try</span> expect(b == <span class=\"tok-number\">6</span>);\n    <span class=\"tok-kw\">try</span> expect(a.c.x == <span class=\"tok-number\">2</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> Color = <span class=\"tok-kw\">enum</span> {\n    auto,\n    off,\n    on,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"exhaustive switching\"</span> {\n    <span class=\"tok-kw\">const</span> color = Color.off;\n    <span class=\"tok-kw\">switch</span> (color) {\n        Color.auto => {},\n        Color.on => {},\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "switch §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Color = <span class=\"tok-kw\">enum</span> {\n    auto,\n    off,\n    on,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum literals with switch\"</span> {\n    <span class=\"tok-kw\">const</span> color = Color.off;\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">switch</span> (color) {\n        .auto => <span class=\"tok-null\">false</span>,\n        .on => <span class=\"tok-null\">false</span>,\n        .off => <span class=\"tok-null\">true</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(result);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch continue\"</span> {\n    sw: <span class=\"tok-kw\">switch</span> (<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">i32</span>, <span class=\"tok-number\">5</span>)) {\n        <span class=\"tok-number\">5</span> => <span class=\"tok-kw\">continue</span> :sw <span class=\"tok-number\">4</span>,\n\n        <span class=\"tok-comment\">// `continue` can occur multiple times within a single switch prong.</span>\n        <span class=\"tok-number\">2</span>...<span class=\"tok-number\">4</span> => |v| {\n            <span class=\"tok-kw\">if</span> (v > <span class=\"tok-number\">3</span>) {\n                <span class=\"tok-kw\">continue</span> :sw <span class=\"tok-number\">2</span>;\n            } <span class=\"tok-kw\">else</span> <span class=\"tok-kw\">if</span> (v == <span class=\"tok-number\">3</span>) {\n\n                <span class=\"tok-comment\">// `break` can target labeled loops.</span>\n                <span class=\"tok-kw\">break</span> :sw;\n            }\n\n            <span class=\"tok-kw\">continue</span> :sw <span class=\"tok-number\">1</span>;\n        },\n\n        <span class=\"tok-number\">1</span> => <span class=\"tok-kw\">return</span>,\n\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">unreachable</span>,\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "switch §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch continue, equivalent loop\"</span> {\n    <span class=\"tok-kw\">var</span> sw: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">5</span>;\n    <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n        <span class=\"tok-kw\">switch</span> (sw) {\n            <span class=\"tok-number\">5</span> => {\n                sw = <span class=\"tok-number\">4</span>;\n                <span class=\"tok-kw\">continue</span>;\n            },\n            <span class=\"tok-number\">2</span>...<span class=\"tok-number\">4</span> => |v| {\n                <span class=\"tok-kw\">if</span> (v > <span class=\"tok-number\">3</span>) {\n                    sw = <span class=\"tok-number\">2</span>;\n                    <span class=\"tok-kw\">continue</span>;\n                } <span class=\"tok-kw\">else</span> <span class=\"tok-kw\">if</span> (v == <span class=\"tok-number\">3</span>) {\n                    <span class=\"tok-kw\">break</span>;\n                }\n\n                sw = <span class=\"tok-number\">1</span>;\n                <span class=\"tok-kw\">continue</span>;\n            },\n            <span class=\"tok-number\">1</span> => <span class=\"tok-kw\">return</span>,\n            <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">unreachable</span>,\n        }\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "switch §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expectEqual = std.testing.expectEqual;\n\n<span class=\"tok-kw\">const</span> Instruction = <span class=\"tok-kw\">enum</span> {\n    add,\n    mul,\n    end,\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">evaluate</span>(initial_stack: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span>, code: []<span class=\"tok-kw\">const</span> Instruction) !<span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> stack = <span class=\"tok-kw\">try</span> std.BoundedArray(<span class=\"tok-type\">i32</span>, <span class=\"tok-number\">8</span>).fromSlice(initial_stack);\n    <span class=\"tok-kw\">var</span> ip: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n\n    <span class=\"tok-kw\">return</span> vm: <span class=\"tok-kw\">switch</span> (code[ip]) {\n        <span class=\"tok-comment\">// Because all code after `continue` is unreachable, this branch does</span>\n        <span class=\"tok-comment\">// not provide a result.</span>\n        .add => {\n            <span class=\"tok-kw\">try</span> stack.append(stack.pop().? + stack.pop().?);\n\n            ip += <span class=\"tok-number\">1</span>;\n            <span class=\"tok-kw\">continue</span> :vm code[ip];\n        },\n        .mul => {\n            <span class=\"tok-kw\">try</span> stack.append(stack.pop().? * stack.pop().?);\n\n            ip += <span class=\"tok-number\">1</span>;\n            <span class=\"tok-kw\">continue</span> :vm code[ip];\n        },\n        .end => stack.pop().?,\n    };\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"evaluate\"</span> {\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">try</span> evaluate(&.{ <span class=\"tok-number\">7</span>, <span class=\"tok-number\">2</span>, -<span class=\"tok-number\">3</span> }, &.{ .mul, .add, .end });\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">1</span>, result);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> expectError = std.testing.expectError;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">isFieldOptional</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, field_index: <span class=\"tok-type\">usize</span>) !<span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">const</span> fields = <span class=\"tok-builtin\">@typeInfo</span>(T).@\"struct\".fields;\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (field_index) {\n        <span class=\"tok-comment\">// This prong is analyzed twice with `idx` being a</span>\n        <span class=\"tok-comment\">// comptime-known value each time.</span>\n        <span class=\"tok-kw\">inline</span> <span class=\"tok-number\">0</span>, <span class=\"tok-number\">1</span> => |idx| <span class=\"tok-builtin\">@typeInfo</span>(fields[idx].<span class=\"tok-type\">type</span>) == .optional,\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.IndexOutOfBounds,\n    };\n}\n\n<span class=\"tok-kw\">const</span> Struct1 = <span class=\"tok-kw\">struct</span> { a: <span class=\"tok-type\">u32</span>, b: ?<span class=\"tok-type\">u32</span> };\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"using @typeInfo with runtime values\"</span> {\n    <span class=\"tok-kw\">var</span> index: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">try</span> expect(!<span class=\"tok-kw\">try</span> isFieldOptional(Struct1, index));\n    index += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-kw\">try</span> isFieldOptional(Struct1, index));\n    index += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expectError(<span class=\"tok-kw\">error</span>.IndexOutOfBounds, isFieldOptional(Struct1, index));\n}\n\n<span class=\"tok-comment\">// Calls to `isFieldOptional` on `Struct1` get unrolled to an equivalent</span>\n<span class=\"tok-comment\">// of this function:</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">isFieldOptionalUnrolled</span>(field_index: <span class=\"tok-type\">usize</span>) !<span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (field_index) {\n        <span class=\"tok-number\">0</span> => <span class=\"tok-null\">false</span>,\n        <span class=\"tok-number\">1</span> => <span class=\"tok-null\">true</span>,\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.IndexOutOfBounds,\n    };\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">isFieldOptional</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, field_index: <span class=\"tok-type\">usize</span>) !<span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">const</span> fields = <span class=\"tok-builtin\">@typeInfo</span>(T).@\"struct\".fields;\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (field_index) {\n        <span class=\"tok-kw\">inline</span> <span class=\"tok-number\">0</span>...fields.len - <span class=\"tok-number\">1</span> => |idx| <span class=\"tok-builtin\">@typeInfo</span>(fields[idx].<span class=\"tok-type\">type</span>) == .optional,\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.IndexOutOfBounds,\n    };\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> SliceTypeA = <span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">struct</span> {\n    len: <span class=\"tok-type\">usize</span>,\n    ptr: [*]<span class=\"tok-type\">u32</span>,\n};\n<span class=\"tok-kw\">const</span> SliceTypeB = <span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">struct</span> {\n    ptr: [*]SliceTypeA,\n    len: <span class=\"tok-type\">usize</span>,\n};\n<span class=\"tok-kw\">const</span> AnySlice = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n    a: SliceTypeA,\n    b: SliceTypeB,\n    c: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>,\n    d: []AnySlice,\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">withFor</span>(any: AnySlice) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">const</span> Tag = <span class=\"tok-builtin\">@typeInfo</span>(AnySlice).@\"union\".tag_type.?;\n    <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">for</span> (<span class=\"tok-builtin\">@typeInfo</span>(Tag).@\"enum\".fields) |field| {\n        <span class=\"tok-comment\">// With `inline for` the function gets generated as</span>\n        <span class=\"tok-comment\">// a series of `if` statements relying on the optimizer</span>\n        <span class=\"tok-comment\">// to convert it to a switch.</span>\n        <span class=\"tok-kw\">if</span> (field.value == <span class=\"tok-builtin\">@intFromEnum</span>(any)) {\n            <span class=\"tok-kw\">return</span> <span class=\"tok-builtin\">@field</span>(any, field.name).len;\n        }\n    }\n    <span class=\"tok-comment\">// When using `inline for` the compiler doesn't know that every</span>\n    <span class=\"tok-comment\">// possible case has been handled requiring an explicit `unreachable`.</span>\n    <span class=\"tok-kw\">unreachable</span>;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">withSwitch</span>(any: AnySlice) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (any) {\n        <span class=\"tok-comment\">// With `inline else` the function is explicitly generated</span>\n        <span class=\"tok-comment\">// as the desired switch and the compiler can check that</span>\n        <span class=\"tok-comment\">// every possible case is handled.</span>\n        <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">else</span> => |slice| slice.len,\n    };\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inline for and inline else similarity\"</span> {\n    <span class=\"tok-kw\">const</span> any = AnySlice{ .c = <span class=\"tok-str\">\"hello\"</span> };\n    <span class=\"tok-kw\">try</span> expect(withFor(any) == <span class=\"tok-number\">5</span>);\n    <span class=\"tok-kw\">try</span> expect(withSwitch(any) == <span class=\"tok-number\">5</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> U = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n    a: <span class=\"tok-type\">u32</span>,\n    b: <span class=\"tok-type\">f32</span>,\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">getNum</span>(u: U) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">switch</span> (u) {\n        <span class=\"tok-comment\">// Here `num` is a runtime-known value that is either</span>\n        <span class=\"tok-comment\">// `u.a` or `u.b` and `tag` is `u`'s comptime-known tag value.</span>\n        <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">else</span> => |num, tag| {\n            <span class=\"tok-kw\">if</span> (tag == .b) {\n                <span class=\"tok-kw\">return</span> <span class=\"tok-builtin\">@intFromFloat</span>(num);\n            }\n            <span class=\"tok-kw\">return</span> num;\n        },\n    }\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"test\"</span> {\n    <span class=\"tok-kw\">const</span> u = U{ .b = <span class=\"tok-number\">42</span> };\n    <span class=\"tok-kw\">try</span> expect(getNum(u) == <span class=\"tok-number\">42</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain switch § in Zig 0.14.1",
    "context": "",
    "response": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value.zig Shell Switching with Enum Literals § Enum Literals can be useful to use with switch to avoid repetitively specifying enum or union types: test_exhaustive_switch.zig Shell Labeled switch § When a switch statement is labeled, it can be referenced from a break or continue . break will return a value from the switch . A continue targeting a switch must have an operand. When executed, it will jump to the matching prong, as if the switch were executed again with the continue 's operand replacing ",
    "metadata": {
      "version": "0.14.1",
      "topic": "switch §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while basic\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">10</span>) {\n        i += <span class=\"tok-number\">1</span>;\n    }\n    <span class=\"tok-kw\">try</span> expect(i == <span class=\"tok-number\">10</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while break\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n        <span class=\"tok-kw\">if</span> (i == <span class=\"tok-number\">10</span>)\n            <span class=\"tok-kw\">break</span>;\n        i += <span class=\"tok-number\">1</span>;\n    }\n    <span class=\"tok-kw\">try</span> expect(i == <span class=\"tok-number\">10</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while continue\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n        i += <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">if</span> (i < <span class=\"tok-number\">10</span>)\n            <span class=\"tok-kw\">continue</span>;\n        <span class=\"tok-kw\">break</span>;\n    }\n    <span class=\"tok-kw\">try</span> expect(i == <span class=\"tok-number\">10</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while loop continue expression\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">10</span>) : (i += <span class=\"tok-number\">1</span>) {}\n    <span class=\"tok-kw\">try</span> expect(i == <span class=\"tok-number\">10</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while loop continue expression, more complicated\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">var</span> j: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">while</span> (i * j < <span class=\"tok-number\">2000</span>) : ({\n        i *= <span class=\"tok-number\">2</span>;\n        j *= <span class=\"tok-number\">3</span>;\n    }) {\n        <span class=\"tok-kw\">const</span> my_ij = i * j;\n        <span class=\"tok-kw\">try</span> expect(my_ij < <span class=\"tok-number\">2000</span>);\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while else\"</span> {\n    <span class=\"tok-kw\">try</span> expect(rangeHasNumber(<span class=\"tok-number\">0</span>, <span class=\"tok-number\">10</span>, <span class=\"tok-number\">5</span>));\n    <span class=\"tok-kw\">try</span> expect(!rangeHasNumber(<span class=\"tok-number\">0</span>, <span class=\"tok-number\">10</span>, <span class=\"tok-number\">15</span>));\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">rangeHasNumber</span>(begin: <span class=\"tok-type\">usize</span>, end: <span class=\"tok-type\">usize</span>, number: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">var</span> i = begin;\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">while</span> (i < end) : (i += <span class=\"tok-number\">1</span>) {\n        <span class=\"tok-kw\">if</span> (i == number) {\n            <span class=\"tok-kw\">break</span> <span class=\"tok-null\">true</span>;\n        }\n    } <span class=\"tok-kw\">else</span> <span class=\"tok-null\">false</span>;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"nested break\"</span> {\n    outer: <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n        <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n            <span class=\"tok-kw\">break</span> :outer;\n        }\n    }\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"nested continue\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    outer: <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">10</span>) : (i += <span class=\"tok-number\">1</span>) {\n        <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n            <span class=\"tok-kw\">continue</span> :outer;\n        }\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "while §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while null capture\"</span> {\n    <span class=\"tok-kw\">var</span> sum1: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    numbers_left = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">while</span> (eventuallyNullSequence()) |value| {\n        sum1 += value;\n    }\n    <span class=\"tok-kw\">try</span> expect(sum1 == <span class=\"tok-number\">3</span>);\n\n    <span class=\"tok-comment\">// null capture with an else block</span>\n    <span class=\"tok-kw\">var</span> sum2: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    numbers_left = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">while</span> (eventuallyNullSequence()) |value| {\n        sum2 += value;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">try</span> expect(sum2 == <span class=\"tok-number\">3</span>);\n    }\n\n    <span class=\"tok-comment\">// null capture with a continue expression</span>\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">var</span> sum3: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    numbers_left = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">while</span> (eventuallyNullSequence()) |value| : (i += <span class=\"tok-number\">1</span>) {\n        sum3 += value;\n    }\n    <span class=\"tok-kw\">try</span> expect(i == <span class=\"tok-number\">3</span>);\n}\n\n<span class=\"tok-kw\">var</span> numbers_left: <span class=\"tok-type\">u32</span> = <span class=\"tok-null\">undefined</span>;\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">eventuallyNullSequence</span>() ?<span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (numbers_left == <span class=\"tok-number\">0</span>) <span class=\"tok-null\">null</span> <span class=\"tok-kw\">else</span> blk: {\n        numbers_left -= <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">break</span> :blk numbers_left;\n    };\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while error union capture\"</span> {\n    <span class=\"tok-kw\">var</span> sum1: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    numbers_left = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">while</span> (eventuallyErrorSequence()) |value| {\n        sum1 += value;\n    } <span class=\"tok-kw\">else</span> |err| {\n        <span class=\"tok-kw\">try</span> expect(err == <span class=\"tok-kw\">error</span>.ReachedZero);\n    }\n}\n\n<span class=\"tok-kw\">var</span> numbers_left: <span class=\"tok-type\">u32</span> = <span class=\"tok-null\">undefined</span>;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">eventuallyErrorSequence</span>() <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (numbers_left == <span class=\"tok-number\">0</span>) <span class=\"tok-kw\">error</span>.ReachedZero <span class=\"tok-kw\">else</span> blk: {\n        numbers_left -= <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">break</span> :blk numbers_left;\n    };\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inline while loop\"</span> {\n    <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> i = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">3</span>) : (i += <span class=\"tok-number\">1</span>) {\n        <span class=\"tok-kw\">const</span> T = <span class=\"tok-kw\">switch</span> (i) {\n            <span class=\"tok-number\">0</span> => <span class=\"tok-type\">f32</span>,\n            <span class=\"tok-number\">1</span> => <span class=\"tok-type\">i8</span>,\n            <span class=\"tok-number\">2</span> => <span class=\"tok-type\">bool</span>,\n            <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">unreachable</span>,\n        };\n        sum += typeNameLength(T);\n    }\n    <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-number\">9</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">typeNameLength</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-builtin\">@typeName</span>(T).len;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain while § in Zig 0.14.1",
    "context": "",
    "response": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expression is the result of the else clause of a while loop, which is executed when the condition of the while loop is tested as false. break , like return , accepts a value parameter. This is the result of the while expression. When you break from a while loop, the else branch is not evaluated. test_while_else.zig Shell Labeled while § When a while loop is labeled, it can be referenced from a break or continue from within a nested loop: test_while_nested_break.zig Shell while with Optionals § Just like",
    "metadata": {
      "version": "0.14.1",
      "topic": "while §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: for §",
    "context": "test_for.zig Shell Labeled for § When a for loop is labeled, it can be referenced from a break or continue from within a nested loop: test_for_nested_break.zig Shell inline for § For loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known. test_inline_for.zig Shell It is recommended to use inline loop",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"for basics\"</span> {\n    <span class=\"tok-kw\">const</span> items = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">0</span> };\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n\n    <span class=\"tok-comment\">// For loops iterate over slices and arrays.</span>\n    <span class=\"tok-kw\">for</span> (items) |value| {\n        <span class=\"tok-comment\">// Break and continue are supported.</span>\n        <span class=\"tok-kw\">if</span> (value == <span class=\"tok-number\">0</span>) {\n            <span class=\"tok-kw\">continue</span>;\n        }\n        sum += value;\n    }\n    <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-number\">16</span>);\n\n    <span class=\"tok-comment\">// To iterate over a portion of a slice, reslice.</span>\n    <span class=\"tok-kw\">for</span> (items[<span class=\"tok-number\">0</span>..<span class=\"tok-number\">1</span>]) |value| {\n        sum += value;\n    }\n    <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-number\">20</span>);\n\n    <span class=\"tok-comment\">// To access the index of iteration, specify a second condition as well</span>\n    <span class=\"tok-comment\">// as a second capture value.</span>\n    <span class=\"tok-kw\">var</span> sum2: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">for</span> (items, <span class=\"tok-number\">0</span>..) |_, i| {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(i) == <span class=\"tok-type\">usize</span>);\n        sum2 += <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">i32</span>, <span class=\"tok-builtin\">@intCast</span>(i));\n    }\n    <span class=\"tok-kw\">try</span> expect(sum2 == <span class=\"tok-number\">10</span>);\n\n    <span class=\"tok-comment\">// To iterate over consecutive integers, use the range syntax.</span>\n    <span class=\"tok-comment\">// Unbounded range is always a compile error.</span>\n    <span class=\"tok-kw\">var</span> sum3: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">for</span> (<span class=\"tok-number\">0</span>..<span class=\"tok-number\">5</span>) |i| {\n        sum3 += i;\n    }\n    <span class=\"tok-kw\">try</span> expect(sum3 == <span class=\"tok-number\">10</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"multi object for\"</span> {\n    <span class=\"tok-kw\">const</span> items = [_]<span class=\"tok-type\">usize</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span> };\n    <span class=\"tok-kw\">const</span> items2 = [_]<span class=\"tok-type\">usize</span>{ <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span> };\n    <span class=\"tok-kw\">var</span> count: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n\n    <span class=\"tok-comment\">// Iterate over multiple objects.</span>\n    <span class=\"tok-comment\">// All lengths must be equal at the start of the loop, otherwise detectable</span>\n    <span class=\"tok-comment\">// illegal behavior occurs.</span>\n    <span class=\"tok-kw\">for</span> (items, items2) |i, j| {\n        count += i + j;\n    }\n\n    <span class=\"tok-kw\">try</span> expect(count == <span class=\"tok-number\">21</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"for reference\"</span> {\n    <span class=\"tok-kw\">var</span> items = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">2</span> };\n\n    <span class=\"tok-comment\">// Iterate over the slice by reference by</span>\n    <span class=\"tok-comment\">// specifying that the capture value is a pointer.</span>\n    <span class=\"tok-kw\">for</span> (&items) |*value| {\n        value.* += <span class=\"tok-number\">1</span>;\n    }\n\n    <span class=\"tok-kw\">try</span> expect(items[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(items[<span class=\"tok-number\">1</span>] == <span class=\"tok-number\">5</span>);\n    <span class=\"tok-kw\">try</span> expect(items[<span class=\"tok-number\">2</span>] == <span class=\"tok-number\">3</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"for else\"</span> {\n    <span class=\"tok-comment\">// For allows an else attached to it, the same as a while loop.</span>\n    <span class=\"tok-kw\">const</span> items = [_]?<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-null\">null</span>, <span class=\"tok-number\">5</span> };\n\n    <span class=\"tok-comment\">// For loops can also be used as expressions.</span>\n    <span class=\"tok-comment\">// Similar to while loops, when you break from a for loop, the else branch is not evaluated.</span>\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">for</span> (items) |value| {\n        <span class=\"tok-kw\">if</span> (value != <span class=\"tok-null\">null</span>) {\n            sum += value.?;\n        }\n    } <span class=\"tok-kw\">else</span> blk: {\n        <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-number\">12</span>);\n        <span class=\"tok-kw\">break</span> :blk sum;\n    };\n    <span class=\"tok-kw\">try</span> expect(result == <span class=\"tok-number\">12</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "for §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: for §",
    "context": "test_for.zig Shell Labeled for § When a for loop is labeled, it can be referenced from a break or continue from within a nested loop: test_for_nested_break.zig Shell inline for § For loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known. test_inline_for.zig Shell It is recommended to use inline loop",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"nested break\"</span> {\n    <span class=\"tok-kw\">var</span> count: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    outer: <span class=\"tok-kw\">for</span> (<span class=\"tok-number\">1</span>..<span class=\"tok-number\">6</span>) |_| {\n        <span class=\"tok-kw\">for</span> (<span class=\"tok-number\">1</span>..<span class=\"tok-number\">6</span>) |_| {\n            count += <span class=\"tok-number\">1</span>;\n            <span class=\"tok-kw\">break</span> :outer;\n        }\n    }\n    <span class=\"tok-kw\">try</span> expect(count == <span class=\"tok-number\">1</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"nested continue\"</span> {\n    <span class=\"tok-kw\">var</span> count: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    outer: <span class=\"tok-kw\">for</span> (<span class=\"tok-number\">1</span>..<span class=\"tok-number\">9</span>) |_| {\n        <span class=\"tok-kw\">for</span> (<span class=\"tok-number\">1</span>..<span class=\"tok-number\">6</span>) |_| {\n            count += <span class=\"tok-number\">1</span>;\n            <span class=\"tok-kw\">continue</span> :outer;\n        }\n    }\n\n    <span class=\"tok-kw\">try</span> expect(count == <span class=\"tok-number\">8</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "for §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: for §",
    "context": "test_for.zig Shell Labeled for § When a for loop is labeled, it can be referenced from a break or continue from within a nested loop: test_for_nested_break.zig Shell inline for § For loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known. test_inline_for.zig Shell It is recommended to use inline loop",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inline for loop\"</span> {\n    <span class=\"tok-kw\">const</span> nums = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">2</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">6</span> };\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">for</span> (nums) |i| {\n        <span class=\"tok-kw\">const</span> T = <span class=\"tok-kw\">switch</span> (i) {\n            <span class=\"tok-number\">2</span> => <span class=\"tok-type\">f32</span>,\n            <span class=\"tok-number\">4</span> => <span class=\"tok-type\">i8</span>,\n            <span class=\"tok-number\">6</span> => <span class=\"tok-type\">bool</span>,\n            <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">unreachable</span>,\n        };\n        sum += typeNameLength(T);\n    }\n    <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-number\">9</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">typeNameLength</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-builtin\">@typeName</span>(T).len;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "for §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain for § in Zig 0.14.1",
    "context": "",
    "response": "test_for.zig Shell Labeled for § When a for loop is labeled, it can be referenced from a break or continue from within a nested loop: test_for_nested_break.zig Shell inline for § For loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known. test_inline_for.zig Shell It is recommended to use inline loops only for one of these reasons: You need the loop to execute at comptime for the semantics to work. You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster. See also: while comptime Arrays Slices",
    "metadata": {
      "version": "0.14.1",
      "topic": "for §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: if §",
    "context": "test_if.zig Shell if with Optionals § test_if_optionals.zig Shell See also: Optionals Errors",
    "response": "<span class=\"tok-comment\">// If expressions have three uses, corresponding to the three types:</span>\n<span class=\"tok-comment\">// * bool</span>\n<span class=\"tok-comment\">// * ?T</span>\n<span class=\"tok-comment\">// * anyerror!T</span>\n\n<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"if expression\"</span> {\n    <span class=\"tok-comment\">// If expressions are used instead of a ternary expression.</span>\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">5</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">4</span>;\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">if</span> (a != b) <span class=\"tok-number\">47</span> <span class=\"tok-kw\">else</span> <span class=\"tok-number\">3089</span>;\n    <span class=\"tok-kw\">try</span> expect(result == <span class=\"tok-number\">47</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"if boolean\"</span> {\n    <span class=\"tok-comment\">// If expressions test boolean conditions.</span>\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">5</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">4</span>;\n    <span class=\"tok-kw\">if</span> (a != b) {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-null\">true</span>);\n    } <span class=\"tok-kw\">else</span> <span class=\"tok-kw\">if</span> (a == <span class=\"tok-number\">9</span>) {\n        <span class=\"tok-kw\">unreachable</span>;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"if error union\"</span> {\n    <span class=\"tok-comment\">// If expressions test for errors.</span>\n    <span class=\"tok-comment\">// Note the |err| capture on the else.</span>\n\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">if</span> (a) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">0</span>);\n    } <span class=\"tok-kw\">else</span> |err| {\n        _ = err;\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> = <span class=\"tok-kw\">error</span>.BadValue;\n    <span class=\"tok-kw\">if</span> (b) |value| {\n        _ = value;\n        <span class=\"tok-kw\">unreachable</span>;\n    } <span class=\"tok-kw\">else</span> |err| {\n        <span class=\"tok-kw\">try</span> expect(err == <span class=\"tok-kw\">error</span>.BadValue);\n    }\n\n    <span class=\"tok-comment\">// The else and |err| capture is strictly required.</span>\n    <span class=\"tok-kw\">if</span> (a) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">0</span>);\n    } <span class=\"tok-kw\">else</span> |_| {}\n\n    <span class=\"tok-comment\">// To check only the error value, use an empty block expression.</span>\n    <span class=\"tok-kw\">if</span> (b) |_| {} <span class=\"tok-kw\">else</span> |err| {\n        <span class=\"tok-kw\">try</span> expect(err == <span class=\"tok-kw\">error</span>.BadValue);\n    }\n\n    <span class=\"tok-comment\">// Access the value by reference using a pointer capture.</span>\n    <span class=\"tok-kw\">var</span> c: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">if</span> (c) |*value| {\n        value.* = <span class=\"tok-number\">9</span>;\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">if</span> (c) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">9</span>);\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "if §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: if §",
    "context": "test_if.zig Shell if with Optionals § test_if_optionals.zig Shell See also: Optionals Errors",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"if optional\"</span> {\n    <span class=\"tok-comment\">// If expressions test for null.</span>\n\n    <span class=\"tok-kw\">const</span> a: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">if</span> (a) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">0</span>);\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">const</span> b: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-null\">null</span>;\n    <span class=\"tok-kw\">if</span> (b) |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-null\">true</span>);\n    }\n\n    <span class=\"tok-comment\">// The else is not required.</span>\n    <span class=\"tok-kw\">if</span> (a) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">0</span>);\n    }\n\n    <span class=\"tok-comment\">// To test against null only, use the binary equality operator.</span>\n    <span class=\"tok-kw\">if</span> (b == <span class=\"tok-null\">null</span>) {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-null\">true</span>);\n    }\n\n    <span class=\"tok-comment\">// Access the value by reference using a pointer capture.</span>\n    <span class=\"tok-kw\">var</span> c: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">if</span> (c) |*value| {\n        value.* = <span class=\"tok-number\">2</span>;\n    }\n\n    <span class=\"tok-kw\">if</span> (c) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">2</span>);\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"if error union with optional\"</span> {\n    <span class=\"tok-comment\">// If expressions test for errors before unwrapping optionals.</span>\n    <span class=\"tok-comment\">// The |optional_value| capture's type is ?u32.</span>\n\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">if</span> (a) |optional_value| {\n        <span class=\"tok-kw\">try</span> expect(optional_value.? == <span class=\"tok-number\">0</span>);\n    } <span class=\"tok-kw\">else</span> |err| {\n        _ = err;\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">u32</span> = <span class=\"tok-null\">null</span>;\n    <span class=\"tok-kw\">if</span> (b) |optional_value| {\n        <span class=\"tok-kw\">try</span> expect(optional_value == <span class=\"tok-null\">null</span>);\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">const</span> c: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">u32</span> = <span class=\"tok-kw\">error</span>.BadValue;\n    <span class=\"tok-kw\">if</span> (c) |optional_value| {\n        _ = optional_value;\n        <span class=\"tok-kw\">unreachable</span>;\n    } <span class=\"tok-kw\">else</span> |err| {\n        <span class=\"tok-kw\">try</span> expect(err == <span class=\"tok-kw\">error</span>.BadValue);\n    }\n\n    <span class=\"tok-comment\">// Access the value by reference by using a pointer capture each time.</span>\n    <span class=\"tok-kw\">var</span> d: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">if</span> (d) |*optional_value| {\n        <span class=\"tok-kw\">if</span> (optional_value.*) |*value| {\n            value.* = <span class=\"tok-number\">9</span>;\n        }\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">if</span> (d) |optional_value| {\n        <span class=\"tok-kw\">try</span> expect(optional_value.? == <span class=\"tok-number\">9</span>);\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "if §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: defer §",
    "context": "Executes an expression unconditionally at scope exit. test_defer.zig Shell Defer expressions are evaluated in reverse order. defer_unwind.zig Shell Inside a defer expression the return statement is not allowed. test_invalid_defer.zig Shell See also: Errors",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> print = std.debug.print;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">deferExample</span>() !<span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">1</span>;\n\n    {\n        <span class=\"tok-kw\">defer</span> a = <span class=\"tok-number\">2</span>;\n        a = <span class=\"tok-number\">1</span>;\n    }\n    <span class=\"tok-kw\">try</span> expect(a == <span class=\"tok-number\">2</span>);\n\n    a = <span class=\"tok-number\">5</span>;\n    <span class=\"tok-kw\">return</span> a;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"defer basics\"</span> {\n    <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> deferExample()) == <span class=\"tok-number\">5</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "defer §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: defer §",
    "context": "Executes an expression unconditionally at scope exit. test_defer.zig Shell Defer expressions are evaluated in reverse order. defer_unwind.zig Shell Inside a defer expression the return statement is not allowed. test_invalid_defer.zig Shell See also: Errors",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> print = std.debug.print;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"defer unwinding\"</span> {\n    print(<span class=\"tok-str\">\"\\n\"</span>, .{});\n\n    <span class=\"tok-kw\">defer</span> {\n        print(<span class=\"tok-str\">\"1 \"</span>, .{});\n    }\n    <span class=\"tok-kw\">defer</span> {\n        print(<span class=\"tok-str\">\"2 \"</span>, .{});\n    }\n    <span class=\"tok-kw\">if</span> (<span class=\"tok-null\">false</span>) {\n        <span class=\"tok-comment\">// defers are not run if they are never executed.</span>\n        <span class=\"tok-kw\">defer</span> {\n            print(<span class=\"tok-str\">\"3 \"</span>, .{});\n        }\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "defer §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: defer §",
    "context": "Executes an expression unconditionally at scope exit. test_defer.zig Shell Defer expressions are evaluated in reverse order. defer_unwind.zig Shell Inside a defer expression the return statement is not allowed. test_invalid_defer.zig Shell See also: Errors",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">deferInvalidExample</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">defer</span> {\n        <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.DeferError;\n    }\n\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.DeferError;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "defer §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain defer § in Zig 0.14.1",
    "context": "",
    "response": "Executes an expression unconditionally at scope exit. test_defer.zig Shell Defer expressions are evaluated in reverse order. defer_unwind.zig Shell Inside a defer expression the return statement is not allowed. test_invalid_defer.zig Shell See also: Errors",
    "metadata": {
      "version": "0.14.1",
      "topic": "defer §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: unreachable §",
    "context": "In Debug and ReleaseSafe mode unreachable emits a call to panic with the message reached unreachable code . In ReleaseFast and ReleaseSmall mode, the optimizer uses the assumption that unreachable code will never be hit to perform optimizations. Basics § test_unreachable.zig Shell In fact, this is how std.debug.assert is implemented: test_assertion_failure.zig Shell At Compile-Time § test_comptime_unreachable.zig Shell See also: Zig Test Build Mode comptime",
    "response": "<span class=\"tok-comment\">// unreachable is used to assert that control flow will never reach a</span>\n<span class=\"tok-comment\">// particular location:</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"basic math\"</span> {\n    <span class=\"tok-kw\">const</span> x = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> y = <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">if</span> (x + y != <span class=\"tok-number\">3</span>) {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "unreachable §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: unreachable §",
    "context": "In Debug and ReleaseSafe mode unreachable emits a call to panic with the message reached unreachable code . In ReleaseFast and ReleaseSmall mode, the optimizer uses the assumption that unreachable code will never be hit to perform optimizations. Basics § test_unreachable.zig Shell In fact, this is how std.debug.assert is implemented: test_assertion_failure.zig Shell At Compile-Time § test_comptime_unreachable.zig Shell See also: Zig Test Build Mode comptime",
    "response": "<span class=\"tok-comment\">// This is how std.debug.assert is implemented</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">assert</span>(ok: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (!ok) <span class=\"tok-kw\">unreachable</span>; <span class=\"tok-comment\">// assertion failure</span>\n}\n\n<span class=\"tok-comment\">// This test will fail because we hit unreachable.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"this will fail\"</span> {\n    assert(<span class=\"tok-null\">false</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "unreachable §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: unreachable §",
    "context": "In Debug and ReleaseSafe mode unreachable emits a call to panic with the message reached unreachable code . In ReleaseFast and ReleaseSmall mode, the optimizer uses the assumption that unreachable code will never be hit to perform optimizations. Basics § test_unreachable.zig Shell In fact, this is how std.debug.assert is implemented: test_assertion_failure.zig Shell At Compile-Time § test_comptime_unreachable.zig Shell See also: Zig Test Build Mode comptime",
    "response": "<span class=\"tok-kw\">const</span> assert = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.assert;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"type of unreachable\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-comment\">// The type of unreachable is noreturn.</span>\n\n        <span class=\"tok-comment\">// However this assertion will still fail to compile because</span>\n        <span class=\"tok-comment\">// unreachable expressions are compile errors.</span>\n\n        assert(<span class=\"tok-builtin\">@TypeOf</span>(<span class=\"tok-kw\">unreachable</span>) == <span class=\"tok-type\">noreturn</span>);\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "unreachable §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain unreachable § in Zig 0.14.1",
    "context": "",
    "response": "In Debug and ReleaseSafe mode unreachable emits a call to panic with the message reached unreachable code . In ReleaseFast and ReleaseSmall mode, the optimizer uses the assumption that unreachable code will never be hit to perform optimizations. Basics § test_unreachable.zig Shell In fact, this is how std.debug.assert is implemented: test_assertion_failure.zig Shell At Compile-Time § test_comptime_unreachable.zig Shell See also: Zig Test Build Mode comptime",
    "metadata": {
      "version": "0.14.1",
      "topic": "unreachable §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: noreturn §",
    "context": "noreturn is the type of: break continue return unreachable while ( true ) {} When resolving types together, such as if clauses or switch prongs, the noreturn type is compatible with every other type. Consider: test_noreturn.zig Shell Another use case for noreturn is the exit function: test_noreturn_from_exit.zig Shell",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(condition: <span class=\"tok-type\">bool</span>, b: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> a = <span class=\"tok-kw\">if</span> (condition) b <span class=\"tok-kw\">else</span> <span class=\"tok-kw\">return</span>;\n    _ = a;\n    <span class=\"tok-builtin\">@panic</span>(<span class=\"tok-str\">\"do something with a\"</span>);\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"noreturn\"</span> {\n    foo(<span class=\"tok-null\">false</span>, <span class=\"tok-number\">1</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "noreturn §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: noreturn §",
    "context": "noreturn is the type of: break continue return unreachable while ( true ) {} When resolving types together, such as if clauses or switch prongs, the noreturn type is compatible with every other type. Consider: test_noreturn.zig Shell Another use case for noreturn is the exit function: test_noreturn_from_exit.zig Shell",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> native_arch = builtin.cpu.arch;\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> WINAPI: std.builtin.CallingConvention = <span class=\"tok-kw\">if</span> (native_arch == .x86) .Stdcall <span class=\"tok-kw\">else</span> .C;\n<span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"kernel32\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">ExitProcess</span>(exit_code: <span class=\"tok-type\">c_uint</span>) <span class=\"tok-kw\">callconv</span>(WINAPI) <span class=\"tok-type\">noreturn</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"foo\"</span> {\n    <span class=\"tok-kw\">const</span> value = bar() <span class=\"tok-kw\">catch</span> ExitProcess(<span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">1234</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>() <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">1234</span>;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "noreturn §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain noreturn § in Zig 0.14.1",
    "context": "",
    "response": "noreturn is the type of: break continue return unreachable while ( true ) {} When resolving types together, such as if clauses or switch prongs, the noreturn type is compatible with every other type. Consider: test_noreturn.zig Shell Another use case for noreturn is the exit function: test_noreturn_from_exit.zig Shell",
    "metadata": {
      "version": "0.14.1",
      "topic": "noreturn §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Functions §",
    "context": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, an",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> native_arch = builtin.cpu.arch;\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-comment\">// Functions are declared like this</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(a: <span class=\"tok-type\">i8</span>, b: <span class=\"tok-type\">i8</span>) <span class=\"tok-type\">i8</span> {\n    <span class=\"tok-kw\">if</span> (a == <span class=\"tok-number\">0</span>) {\n        <span class=\"tok-kw\">return</span> b;\n    }\n\n    <span class=\"tok-kw\">return</span> a + b;\n}\n\n<span class=\"tok-comment\">// The export specifier makes a function externally visible in the generated</span>\n<span class=\"tok-comment\">// object file, and makes it use the C ABI.</span>\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">sub</span>(a: <span class=\"tok-type\">i8</span>, b: <span class=\"tok-type\">i8</span>) <span class=\"tok-type\">i8</span> {\n    <span class=\"tok-kw\">return</span> a - b;\n}\n\n<span class=\"tok-comment\">// The extern specifier is used to declare a function that will be resolved</span>\n<span class=\"tok-comment\">// at link time, when linking statically, or at runtime, when linking</span>\n<span class=\"tok-comment\">// dynamically. The quoted identifier after the extern keyword specifies</span>\n<span class=\"tok-comment\">// the library that has the function. (e.g. \"c\" -> libc.so)</span>\n<span class=\"tok-comment\">// The callconv specifier changes the calling convention of the function.</span>\n<span class=\"tok-kw\">const</span> WINAPI: std.builtin.CallingConvention = <span class=\"tok-kw\">if</span> (native_arch == .x86) .Stdcall <span class=\"tok-kw\">else</span> .C;\n<span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"kernel32\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">ExitProcess</span>(exit_code: <span class=\"tok-type\">u32</span>) <span class=\"tok-kw\">callconv</span>(WINAPI) <span class=\"tok-type\">noreturn</span>;\n<span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"c\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">atan2</span>(a: <span class=\"tok-type\">f64</span>, b: <span class=\"tok-type\">f64</span>) <span class=\"tok-type\">f64</span>;\n\n<span class=\"tok-comment\">// The @branchHint builtin can be used to tell the optimizer that a function is rarely called (\"cold\").</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">abort</span>() <span class=\"tok-type\">noreturn</span> {\n    <span class=\"tok-builtin\">@branchHint</span>(.cold);\n    <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {}\n}\n\n<span class=\"tok-comment\">// The naked calling convention makes a function not have any function prologue or epilogue.</span>\n<span class=\"tok-comment\">// This can be useful when integrating with assembly.</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">_start</span>() <span class=\"tok-kw\">callconv</span>(.Naked) <span class=\"tok-type\">noreturn</span> {\n    abort();\n}\n\n<span class=\"tok-comment\">// The inline calling convention forces a function to be inlined at all call sites.</span>\n<span class=\"tok-comment\">// If the function cannot be inlined, it is a compile-time error.</span>\n<span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">shiftLeftOne</span>(a: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">return</span> a << <span class=\"tok-number\">1</span>;\n}\n\n<span class=\"tok-comment\">// The pub specifier allows the function to be visible when importing.</span>\n<span class=\"tok-comment\">// Another file can use @import and call sub2</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">sub2</span>(a: <span class=\"tok-type\">i8</span>, b: <span class=\"tok-type\">i8</span>) <span class=\"tok-type\">i8</span> {\n    <span class=\"tok-kw\">return</span> a - b;\n}\n\n<span class=\"tok-comment\">// Function pointers are prefixed with `*const `.</span>\n<span class=\"tok-kw\">const</span> Call2Op = *<span class=\"tok-kw\">const</span> <span class=\"tok-kw\">fn</span> (a: <span class=\"tok-type\">i8</span>, b: <span class=\"tok-type\">i8</span>) <span class=\"tok-type\">i8</span>;\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doOp</span>(fnCall: Call2Op, op1: <span class=\"tok-type\">i8</span>, op2: <span class=\"tok-type\">i8</span>) <span class=\"tok-type\">i8</span> {\n    <span class=\"tok-kw\">return</span> fnCall(op1, op2);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"function\"</span> {\n    <span class=\"tok-kw\">try</span> expect(doOp(add, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>) == <span class=\"tok-number\">11</span>);\n    <span class=\"tok-kw\">try</span> expect(doOp(sub2, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>) == -<span class=\"tok-number\">1</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Functions §",
    "context": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, an",
    "response": "<span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> {\n    x: <span class=\"tok-type\">i32</span>,\n    y: <span class=\"tok-type\">i32</span>,\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(point: Point) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-comment\">// Here, `point` could be a reference, or a copy. The function body</span>\n    <span class=\"tok-comment\">// can ignore the difference and treat it as a value. Be very careful</span>\n    <span class=\"tok-comment\">// taking the address of the parameter - it should be treated as if</span>\n    <span class=\"tok-comment\">// the address will become invalid when the function returns.</span>\n    <span class=\"tok-kw\">return</span> point.x + point.y;\n}\n\n<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pass struct to function\"</span> {\n    <span class=\"tok-kw\">try</span> expect(foo(Point{ .x = <span class=\"tok-number\">1</span>, .y = <span class=\"tok-number\">2</span> }) == <span class=\"tok-number\">3</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Functions §",
    "context": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, an",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">addFortyTwo</span>(x: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(x) {\n    <span class=\"tok-kw\">return</span> x + <span class=\"tok-number\">42</span>;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fn type inference\"</span> {\n    <span class=\"tok-kw\">try</span> expect(addFortyTwo(<span class=\"tok-number\">1</span>) == <span class=\"tok-number\">43</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(addFortyTwo(<span class=\"tok-number\">1</span>)) == <span class=\"tok-type\">comptime_int</span>);\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-type\">i64</span> = <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">try</span> expect(addFortyTwo(y) == <span class=\"tok-number\">44</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(addFortyTwo(y)) == <span class=\"tok-type\">i64</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Functions §",
    "context": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, an",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inline function call\"</span> {\n    <span class=\"tok-kw\">if</span> (foo(<span class=\"tok-number\">1200</span>, <span class=\"tok-number\">34</span>) != <span class=\"tok-number\">1234</span>) {\n        <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"bad\"</span>);\n    }\n}\n\n<span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> a + b;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Functions §",
    "context": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, an",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> math = std.math;\n<span class=\"tok-kw\">const</span> testing = std.testing;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fn reflection\"</span> {\n    <span class=\"tok-kw\">try</span> testing.expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(testing.expect)).@\"fn\".params[<span class=\"tok-number\">0</span>].<span class=\"tok-type\">type</span>.? == <span class=\"tok-type\">bool</span>);\n    <span class=\"tok-kw\">try</span> testing.expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(testing.tmpDir)).@\"fn\".return_type.? == testing.TmpDir);\n\n    <span class=\"tok-kw\">try</span> testing.expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(math.Log2Int)).@\"fn\".is_generic);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Functions § in Zig 0.14.1",
    "context": "",
    "response": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, and arrays can sometimes be more efficiently passed as a reference, since a copy could be arbitrarily expensive depending on the size. When these types are passed as parameters, Zig may choose to copy and pass by value, or pass by reference, whichever way Zig decides will be faster. This is made possible, in part, by the fact that parameters are immutable. test_pass_by_reference_or_value.zig Shell For extern functions, Zig follows the C ABI for passing structs and unions by value. Function Paramet",
    "metadata": {
      "version": "0.14.1",
      "topic": "Functions §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> FileOpenError = <span class=\"tok-kw\">error</span>{\n    AccessDenied,\n    OutOfMemory,\n    FileNotFound,\n};\n\n<span class=\"tok-kw\">const</span> AllocationError = <span class=\"tok-kw\">error</span>{\n    OutOfMemory,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coerce subset to superset\"</span> {\n    <span class=\"tok-kw\">const</span> err = foo(AllocationError.OutOfMemory);\n    <span class=\"tok-kw\">try</span> std.testing.expect(err == FileOpenError.OutOfMemory);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(err: AllocationError) FileOpenError {\n    <span class=\"tok-kw\">return</span> err;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> FileOpenError = <span class=\"tok-kw\">error</span>{\n    AccessDenied,\n    OutOfMemory,\n    FileNotFound,\n};\n\n<span class=\"tok-kw\">const</span> AllocationError = <span class=\"tok-kw\">error</span>{\n    OutOfMemory,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coerce superset to subset\"</span> {\n    foo(FileOpenError.OutOfMemory) <span class=\"tok-kw\">catch</span> {};\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(err: FileOpenError) AllocationError {\n    <span class=\"tok-kw\">return</span> err;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> err = <span class=\"tok-kw\">error</span>.FileNotFound;",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> err = (<span class=\"tok-kw\">error</span>{FileNotFound}).FileNotFound;",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> maxInt = std.math.maxInt;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">parseU64</span>(buf: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, radix: <span class=\"tok-type\">u8</span>) !<span class=\"tok-type\">u64</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">0</span>;\n\n    <span class=\"tok-kw\">for</span> (buf) |c| {\n        <span class=\"tok-kw\">const</span> digit = charToDigit(c);\n\n        <span class=\"tok-kw\">if</span> (digit >= radix) {\n            <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.InvalidChar;\n        }\n\n        <span class=\"tok-comment\">// x *= radix</span>\n        <span class=\"tok-kw\">var</span> ov = <span class=\"tok-builtin\">@mulWithOverflow</span>(x, radix);\n        <span class=\"tok-kw\">if</span> (ov[<span class=\"tok-number\">1</span>] != <span class=\"tok-number\">0</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.OverFlow;\n\n        <span class=\"tok-comment\">// x += digit</span>\n        ov = <span class=\"tok-builtin\">@addWithOverflow</span>(ov[<span class=\"tok-number\">0</span>], digit);\n        <span class=\"tok-kw\">if</span> (ov[<span class=\"tok-number\">1</span>] != <span class=\"tok-number\">0</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.OverFlow;\n        x = ov[<span class=\"tok-number\">0</span>];\n    }\n\n    <span class=\"tok-kw\">return</span> x;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">charToDigit</span>(c: <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (c) {\n        <span class=\"tok-str\">'0'</span>...<span class=\"tok-str\">'9'</span> => c - <span class=\"tok-str\">'0'</span>,\n        <span class=\"tok-str\">'A'</span>...<span class=\"tok-str\">'Z'</span> => c - <span class=\"tok-str\">'A'</span> + <span class=\"tok-number\">10</span>,\n        <span class=\"tok-str\">'a'</span>...<span class=\"tok-str\">'z'</span> => c - <span class=\"tok-str\">'a'</span> + <span class=\"tok-number\">10</span>,\n        <span class=\"tok-kw\">else</span> => maxInt(<span class=\"tok-type\">u8</span>),\n    };\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"parse u64\"</span> {\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">try</span> parseU64(<span class=\"tok-str\">\"1234\"</span>, <span class=\"tok-number\">10</span>);\n    <span class=\"tok-kw\">try</span> std.testing.expect(result == <span class=\"tok-number\">1234</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> parseU64 = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"error_union_parsing_u64.zig\"</span>).parseU64;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(str: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> number = parseU64(str, <span class=\"tok-number\">10</span>) <span class=\"tok-kw\">catch</span> <span class=\"tok-number\">13</span>;\n    _ = number; <span class=\"tok-comment\">// ...</span>\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> parseU64 = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"error_union_parsing_u64.zig\"</span>).parseU64;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(str: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> number = parseU64(str, <span class=\"tok-number\">10</span>) <span class=\"tok-kw\">catch</span> blk: {\n        <span class=\"tok-comment\">// do things</span>\n        <span class=\"tok-kw\">break</span> :blk <span class=\"tok-number\">13</span>;\n    };\n    _ = number; <span class=\"tok-comment\">// number is now initialized</span>\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> parseU64 = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"error_union_parsing_u64.zig\"</span>).parseU64;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(str: []<span class=\"tok-type\">u8</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> number = parseU64(str, <span class=\"tok-number\">10</span>) <span class=\"tok-kw\">catch</span> |err| <span class=\"tok-kw\">return</span> err;\n    _ = number; <span class=\"tok-comment\">// ...</span>\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> parseU64 = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"error_union_parsing_u64.zig\"</span>).parseU64;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(str: []<span class=\"tok-type\">u8</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> number = <span class=\"tok-kw\">try</span> parseU64(str, <span class=\"tok-number\">10</span>);\n    _ = number; <span class=\"tok-comment\">// ...</span>\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(str: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (parseU64(str, <span class=\"tok-number\">10</span>)) |number| {\n        doSomethingWithNumber(number);\n    } <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.Overflow => {\n            <span class=\"tok-comment\">// handle overflow...</span>\n        },\n        <span class=\"tok-comment\">// we promise that InvalidChar won't happen (or crash in debug mode if it does)</span>\n        <span class=\"tok-kw\">error</span>.InvalidChar => <span class=\"tok-kw\">unreachable</span>,\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAnotherThing</span>(str: []<span class=\"tok-type\">u8</span>) <span class=\"tok-kw\">error</span>{InvalidChar}!<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (parseU64(str, <span class=\"tok-number\">10</span>)) |number| {\n        doSomethingWithNumber(number);\n    } <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.Overflow => {\n            <span class=\"tok-comment\">// handle overflow...</span>\n        },\n        <span class=\"tok-kw\">else</span> => |leftover_err| <span class=\"tok-kw\">return</span> leftover_err,\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doADifferentThing</span>(str: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (parseU64(str, <span class=\"tok-number\">10</span>)) |number| {\n        doSomethingWithNumber(number);\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-comment\">// do as you'd like</span>\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">createFoo</span>(param: <span class=\"tok-type\">i32</span>) !Foo {\n    <span class=\"tok-kw\">const</span> foo = <span class=\"tok-kw\">try</span> tryToAllocateFoo();\n    <span class=\"tok-comment\">// now we have allocated foo. we need to free it if the function fails.</span>\n    <span class=\"tok-comment\">// but we want to return it if the function succeeds.</span>\n    <span class=\"tok-kw\">errdefer</span> deallocateFoo(foo);\n\n    <span class=\"tok-kw\">const</span> tmp_buf = allocateTmpBuffer() <span class=\"tok-kw\">orelse</span> <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.OutOfMemory;\n    <span class=\"tok-comment\">// tmp_buf is truly a temporary resource, and we for sure want to clean it up</span>\n    <span class=\"tok-comment\">// before this block leaves scope</span>\n    <span class=\"tok-kw\">defer</span> deallocateTmpBuffer(tmp_buf);\n\n    <span class=\"tok-kw\">if</span> (param > <span class=\"tok-number\">1337</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.InvalidParam;\n\n    <span class=\"tok-comment\">// here the errdefer will not run since we're returning success from the function.</span>\n    <span class=\"tok-comment\">// but the defer will run!</span>\n    <span class=\"tok-kw\">return</span> foo;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">captureError</span>(captured: *?<span class=\"tok-type\">anyerror</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">errdefer</span> |err| {\n        captured.* = err;\n    }\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.GeneralFailure;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"errdefer capture\"</span> {\n    <span class=\"tok-kw\">var</span> captured: ?<span class=\"tok-type\">anyerror</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-kw\">if</span> (captureError(&captured)) <span class=\"tok-kw\">unreachable</span> <span class=\"tok-kw\">else</span> |err| {\n        <span class=\"tok-kw\">try</span> std.testing.expectEqual(<span class=\"tok-kw\">error</span>.GeneralFailure, captured.?);\n        <span class=\"tok-kw\">try</span> std.testing.expectEqual(<span class=\"tok-kw\">error</span>.GeneralFailure, err);\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"error union\"</span> {\n    <span class=\"tok-kw\">var</span> foo: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n\n    <span class=\"tok-comment\">// Coerce from child type of an error union:</span>\n    foo = <span class=\"tok-number\">1234</span>;\n\n    <span class=\"tok-comment\">// Coerce from an error set:</span>\n    foo = <span class=\"tok-kw\">error</span>.SomeError;\n\n    <span class=\"tok-comment\">// Use compile-time reflection to access the payload type of an error union:</span>\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(foo)).error_union.payload == <span class=\"tok-type\">i32</span>);\n\n    <span class=\"tok-comment\">// Use compile-time reflection to access the error set type of an error union:</span>\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(foo)).error_union.error_set == <span class=\"tok-type\">anyerror</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> A = <span class=\"tok-kw\">error</span>{\n    NotDir,\n\n    <span class=\"tok-comment\">/// A doc comment</span>\n    PathNotFound,\n};\n<span class=\"tok-kw\">const</span> B = <span class=\"tok-kw\">error</span>{\n    OutOfMemory,\n\n    <span class=\"tok-comment\">/// B doc comment</span>\n    PathNotFound,\n};\n\n<span class=\"tok-kw\">const</span> C = A || B;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() C!<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.NotDir;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"merge error sets\"</span> {\n    <span class=\"tok-kw\">if</span> (foo()) {\n        <span class=\"tok-builtin\">@panic</span>(<span class=\"tok-str\">\"unexpected\"</span>);\n    } <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.OutOfMemory => <span class=\"tok-builtin\">@panic</span>(<span class=\"tok-str\">\"unexpected\"</span>),\n        <span class=\"tok-kw\">error</span>.PathNotFound => <span class=\"tok-builtin\">@panic</span>(<span class=\"tok-str\">\"unexpected\"</span>),\n        <span class=\"tok-kw\">error</span>.NotDir => {},\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-comment\">// With an inferred error set</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add_inferred</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) !T {\n    <span class=\"tok-kw\">const</span> ov = <span class=\"tok-builtin\">@addWithOverflow</span>(a, b);\n    <span class=\"tok-kw\">if</span> (ov[<span class=\"tok-number\">1</span>] != <span class=\"tok-number\">0</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.Overflow;\n    <span class=\"tok-kw\">return</span> ov[<span class=\"tok-number\">0</span>];\n}\n\n<span class=\"tok-comment\">// With an explicit error set</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add_explicit</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) Error!T {\n    <span class=\"tok-kw\">const</span> ov = <span class=\"tok-builtin\">@addWithOverflow</span>(a, b);\n    <span class=\"tok-kw\">if</span> (ov[<span class=\"tok-number\">1</span>] != <span class=\"tok-number\">0</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.Overflow;\n    <span class=\"tok-kw\">return</span> ov[<span class=\"tok-number\">0</span>];\n}\n\n<span class=\"tok-kw\">const</span> Error = <span class=\"tok-kw\">error</span>{\n    Overflow,\n};\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inferred error set\"</span> {\n    <span class=\"tok-kw\">if</span> (add_inferred(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">255</span>, <span class=\"tok-number\">1</span>)) |_| <span class=\"tok-kw\">unreachable</span> <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.Overflow => {}, <span class=\"tok-comment\">// ok</span>\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> foo(<span class=\"tok-number\">12</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(x: <span class=\"tok-type\">i32</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (x >= <span class=\"tok-number\">5</span>) {\n        <span class=\"tok-kw\">try</span> bar();\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">try</span> bang2();\n    }\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (baz()) {\n        <span class=\"tok-kw\">try</span> quux();\n    } <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.FileNotFound => <span class=\"tok-kw\">try</span> hello(),\n    }\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">baz</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> bang1();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">quux</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> bang2();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">hello</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> bang2();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bang1</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.FileNotFound;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bang2</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.PermissionDenied;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    foo(<span class=\"tok-number\">12</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(x: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (x >= <span class=\"tok-number\">5</span>) {\n        bar();\n    } <span class=\"tok-kw\">else</span> {\n        bang2();\n    }\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (baz()) {\n        quux();\n    } <span class=\"tok-kw\">else</span> {\n        hello();\n    }\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">baz</span>() <span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">return</span> bang1();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">quux</span>() <span class=\"tok-type\">void</span> {\n    bang2();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">hello</span>() <span class=\"tok-type\">void</span> {\n    bang2();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bang1</span>() <span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-null\">false</span>;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bang2</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-builtin\">@panic</span>(<span class=\"tok-str\">\"PermissionDenied\"</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> StackTrace = <span class=\"tok-kw\">struct</span> {\n    index: <span class=\"tok-type\">usize</span>,\n    instruction_addresses: [N]<span class=\"tok-type\">usize</span>,\n};",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-comment\">// marked as \"no-inline\" in LLVM IR</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">__zig_return_error</span>(stack_trace: *StackTrace) <span class=\"tok-type\">void</span> {\n    stack_trace.instruction_addresses[stack_trace.index] = <span class=\"tok-builtin\">@returnAddress</span>();\n    stack_trace.index = (stack_trace.index + <span class=\"tok-number\">1</span>) % N;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Errors § in Zig 0.14.1",
    "context": "",
    "response": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent all of the error values will be used. You can coerce an error from a subset to a superset: test_coerce_error_subset_to_superset.zig Shell But you cannot coerce an error from a superset to a subset: test_coerce_error_superset_to_subset.zig Shell There is a shortcut for declaring an error set with only 1 value, and then getting that value: single_value_error_set_shortcut.zig This is equivalent to: single_value_error_set.zig This becomes useful when using Inferred Error Sets . The Global Error Set § ",
    "metadata": {
      "version": "0.14.1",
      "topic": "Errors §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-comment\">// normal integer</span>\n<span class=\"tok-kw\">const</span> normal_int: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n\n<span class=\"tok-comment\">// optional integer</span>\n<span class=\"tok-kw\">const</span> optional_int: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-number\">5678</span>;",
    "metadata": {
      "version": "0.14.1",
      "topic": "Optionals §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "// malloc prototype included for reference\nvoid *malloc(size_t size);\n\nstruct Foo *do_a_thing(void) {\n    char *ptr = malloc(1234);\n    if (!ptr) return NULL;\n    // ...\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Optionals §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-comment\">// malloc prototype included for reference</span>\n<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">malloc</span>(size: <span class=\"tok-type\">usize</span>) ?[*]<span class=\"tok-type\">u8</span>;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>() ?*Foo {\n    <span class=\"tok-kw\">const</span> ptr = malloc(<span class=\"tok-number\">1234</span>) <span class=\"tok-kw\">orelse</span> <span class=\"tok-kw\">return</span> <span class=\"tok-null\">null</span>;\n    _ = ptr; <span class=\"tok-comment\">// ...</span>\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Optionals §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "void do_a_thing(struct Foo *foo) {\n    // do some stuff\n\n    if (foo) {\n        do_something_with_foo(foo);\n    }\n\n    // do some stuff\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Optionals §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">struct</span> {};\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doSomethingWithFoo</span>(foo: *Foo) <span class=\"tok-type\">void</span> {\n    _ = foo;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(optional_foo: ?*Foo) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-comment\">// do some stuff</span>\n\n    <span class=\"tok-kw\">if</span> (optional_foo) |foo| {\n        doSomethingWithFoo(foo);\n    }\n\n    <span class=\"tok-comment\">// do some stuff</span>\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Optionals §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"optional type\"</span> {\n    <span class=\"tok-comment\">// Declare an optional and coerce from null:</span>\n    <span class=\"tok-kw\">var</span> foo: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-comment\">// Coerce from child type of an optional</span>\n    foo = <span class=\"tok-number\">1234</span>;\n\n    <span class=\"tok-comment\">// Use compile-time reflection to access the child type of the optional:</span>\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(foo)).optional.child == <span class=\"tok-type\">i32</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Optionals §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-kw\">const</span> optional_value: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;",
    "metadata": {
      "version": "0.14.1",
      "topic": "Optionals §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"optional pointers\"</span> {\n    <span class=\"tok-comment\">// Pointers cannot be null. If you want a null pointer, use the optional</span>\n    <span class=\"tok-comment\">// prefix `?` to make the pointer type optional.</span>\n    <span class=\"tok-kw\">var</span> ptr: ?*<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n    ptr = &x;\n\n    <span class=\"tok-kw\">try</span> expect(ptr.?.* == <span class=\"tok-number\">1</span>);\n\n    <span class=\"tok-comment\">// Optional pointers are the same size as normal pointers, because pointer</span>\n    <span class=\"tok-comment\">// value 0 is used as the null value.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@sizeOf</span>(?*<span class=\"tok-type\">i32</span>) == <span class=\"tok-builtin\">@sizeOf</span>(*<span class=\"tok-type\">i32</span>));\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Optionals §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Optionals § in Zig 0.14.1",
    "context": "",
    "response": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer science . Zig does not have them. Instead, you can use an optional pointer. This secretly compiles down to a normal pointer, since we know we can use 0 as the null value for the optional type. But the compiler can check your work and make sure you don't assign null to something that can't be null. Typically the downside of not having null is that it makes the code more verbose to write. But, let's compare some equivalent C code and Zig code. Task: call malloc, if the result is null, return null",
    "metadata": {
      "version": "0.14.1",
      "topic": "Optionals §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"type coercion - variable declaration\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u16</span> = a;\n    _ = b;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"type coercion - function call\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">1</span>;\n    foo(a);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(b: <span class=\"tok-type\">u16</span>) <span class=\"tok-type\">void</span> {\n    _ = b;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"type coercion - @as builtin\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u16</span>, a);\n    _ = b;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Casting §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"type coercion - const qualification\"</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> b: *<span class=\"tok-type\">i32</span> = &a;\n    foo(b);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(_: *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">void</span> {}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Casting §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> mem = std.mem;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"cast *[1][*:0]const u8 to []const ?[*:0]const u8\"</span> {\n    <span class=\"tok-kw\">const</span> window_name = [<span class=\"tok-number\">1</span>][*:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>{<span class=\"tok-str\">\"window name\"</span>};\n    <span class=\"tok-kw\">const</span> x: []<span class=\"tok-kw\">const</span> ?[*:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = &window_name;\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, mem.span(x[<span class=\"tok-number\">0</span>].?), <span class=\"tok-str\">\"window name\"</span>));\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> mem = std.mem;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"integer widening\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">250</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u16</span> = a;\n    <span class=\"tok-kw\">const</span> c: <span class=\"tok-type\">u32</span> = b;\n    <span class=\"tok-kw\">const</span> d: <span class=\"tok-type\">u64</span> = c;\n    <span class=\"tok-kw\">const</span> e: <span class=\"tok-type\">u64</span> = d;\n    <span class=\"tok-kw\">const</span> f: <span class=\"tok-type\">u128</span> = e;\n    <span class=\"tok-kw\">try</span> expect(f == a);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"implicit unsigned integer to signed integer\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">250</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">i16</span> = a;\n    <span class=\"tok-kw\">try</span> expect(b == <span class=\"tok-number\">250</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"float widening\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">f16</span> = <span class=\"tok-number\">12.34</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">f32</span> = a;\n    <span class=\"tok-kw\">const</span> c: <span class=\"tok-type\">f64</span> = b;\n    <span class=\"tok-kw\">const</span> d: <span class=\"tok-type\">f128</span> = c;\n    <span class=\"tok-kw\">try</span> expect(d == a);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-comment\">// Compile time coercion of float to int</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"implicit cast to comptime_int\"</span> {\n    <span class=\"tok-kw\">const</span> f: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">54.0</span> / <span class=\"tok-number\">5</span>;\n    _ = f;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-comment\">// You can assign constant pointers to arrays to a slice with</span>\n<span class=\"tok-comment\">// const modifier on the element type. Useful in particular for</span>\n<span class=\"tok-comment\">// String literals.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*const [N]T to []const T\"</span> {\n    <span class=\"tok-kw\">const</span> x1: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>;\n    <span class=\"tok-kw\">const</span> x2: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = &[<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span>{ <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-number\">111</span> };\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, x1, x2));\n\n    <span class=\"tok-kw\">const</span> y: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">f32</span> = &[<span class=\"tok-number\">2</span>]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.2</span>, <span class=\"tok-number\">3.4</span> };\n    <span class=\"tok-kw\">try</span> expect(y[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1.2</span>);\n}\n\n<span class=\"tok-comment\">// Likewise, it works when the destination type is an error union.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*const [N]T to E![]const T\"</span> {\n    <span class=\"tok-kw\">const</span> x1: <span class=\"tok-type\">anyerror</span>![]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>;\n    <span class=\"tok-kw\">const</span> x2: <span class=\"tok-type\">anyerror</span>![]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = &[<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span>{ <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-number\">111</span> };\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-kw\">try</span> x1, <span class=\"tok-kw\">try</span> x2));\n\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-type\">anyerror</span>![]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">f32</span> = &[<span class=\"tok-number\">2</span>]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.2</span>, <span class=\"tok-number\">3.4</span> };\n    <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> y)[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1.2</span>);\n}\n\n<span class=\"tok-comment\">// Likewise, it works when the destination type is an optional.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*const [N]T to ?[]const T\"</span> {\n    <span class=\"tok-kw\">const</span> x1: ?[]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>;\n    <span class=\"tok-kw\">const</span> x2: ?[]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = &[<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span>{ <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-number\">111</span> };\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, x1.?, x2.?));\n\n    <span class=\"tok-kw\">const</span> y: ?[]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">f32</span> = &[<span class=\"tok-number\">2</span>]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.2</span>, <span class=\"tok-number\">3.4</span> };\n    <span class=\"tok-kw\">try</span> expect(y.?[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1.2</span>);\n}\n\n<span class=\"tok-comment\">// In this cast, the array length becomes the slice length.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*[N]T to []T\"</span> {\n    <span class=\"tok-kw\">var</span> buf: [<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>.*;\n    <span class=\"tok-kw\">const</span> x: []<span class=\"tok-type\">u8</span> = &buf;\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, x, <span class=\"tok-str\">\"hello\"</span>));\n\n    <span class=\"tok-kw\">const</span> buf2 = [<span class=\"tok-number\">2</span>]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.2</span>, <span class=\"tok-number\">3.4</span> };\n    <span class=\"tok-kw\">const</span> x2: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">f32</span> = &buf2;\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">f32</span>, x2, &[<span class=\"tok-number\">2</span>]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.2</span>, <span class=\"tok-number\">3.4</span> }));\n}\n\n<span class=\"tok-comment\">// Single-item pointers to arrays can be coerced to many-item pointers.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*[N]T to [*]T\"</span> {\n    <span class=\"tok-kw\">var</span> buf: [<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>.*;\n    <span class=\"tok-kw\">const</span> x: [*]<span class=\"tok-type\">u8</span> = &buf;\n    <span class=\"tok-kw\">try</span> expect(x[<span class=\"tok-number\">4</span>] == <span class=\"tok-str\">'o'</span>);\n    <span class=\"tok-comment\">// x[5] would be an uncaught out of bounds pointer dereference!</span>\n}\n\n<span class=\"tok-comment\">// Likewise, it works when the destination type is an optional.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*[N]T to ?[*]T\"</span> {\n    <span class=\"tok-kw\">var</span> buf: [<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>.*;\n    <span class=\"tok-kw\">const</span> x: ?[*]<span class=\"tok-type\">u8</span> = &buf;\n    <span class=\"tok-kw\">try</span> expect(x.?[<span class=\"tok-number\">4</span>] == <span class=\"tok-str\">'o'</span>);\n}\n\n<span class=\"tok-comment\">// Single-item pointers can be cast to len-1 single-item arrays.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*T to *[1]T\"</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> y: *[<span class=\"tok-number\">1</span>]<span class=\"tok-type\">i32</span> = &x;\n    <span class=\"tok-kw\">const</span> z: [*]<span class=\"tok-type\">i32</span> = y;\n    <span class=\"tok-kw\">try</span> expect(z[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1234</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coerce to optionals\"</span> {\n    <span class=\"tok-kw\">const</span> x: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> y: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-kw\">try</span> expect(x.? == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> expect(y == <span class=\"tok-null\">null</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coerce to optionals wrapped in error union\"</span> {\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> x).? == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> y) == <span class=\"tok-null\">null</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coercion to error unions\"</span> {\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">i32</span> = <span class=\"tok-kw\">error</span>.Failure;\n\n    <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> x) == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> std.testing.expectError(<span class=\"tok-kw\">error</span>.Failure, y);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coercing large integer type to smaller one when value is comptime-known to fit\"</span> {\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">255</span>;\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-type\">u8</span> = x;\n    <span class=\"tok-kw\">try</span> expect(y == <span class=\"tok-number\">255</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> E = <span class=\"tok-kw\">enum</span> {\n    one,\n    two,\n    three,\n};\n\n<span class=\"tok-kw\">const</span> U = <span class=\"tok-kw\">union</span>(E) {\n    one: <span class=\"tok-type\">i32</span>,\n    two: <span class=\"tok-type\">f32</span>,\n    three,\n};\n\n<span class=\"tok-kw\">const</span> U2 = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n    a: <span class=\"tok-type\">void</span>,\n    b: <span class=\"tok-type\">f32</span>,\n\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">tag</span>(self: U2) <span class=\"tok-type\">usize</span> {\n        <span class=\"tok-kw\">switch</span> (self) {\n            .a => <span class=\"tok-kw\">return</span> <span class=\"tok-number\">1</span>,\n            .b => <span class=\"tok-kw\">return</span> <span class=\"tok-number\">2</span>,\n        }\n    }\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coercion between unions and enums\"</span> {\n    <span class=\"tok-kw\">const</span> u = U{ .two = <span class=\"tok-number\">12.34</span> };\n    <span class=\"tok-kw\">const</span> e: E = u; <span class=\"tok-comment\">// coerce union to enum</span>\n    <span class=\"tok-kw\">try</span> expect(e == E.two);\n\n    <span class=\"tok-kw\">const</span> three = E.three;\n    <span class=\"tok-kw\">const</span> u_2: U = three; <span class=\"tok-comment\">// coerce enum to union</span>\n    <span class=\"tok-kw\">try</span> expect(u_2 == E.three);\n\n    <span class=\"tok-kw\">const</span> u_3: U = .three; <span class=\"tok-comment\">// coerce enum literal to union</span>\n    <span class=\"tok-kw\">try</span> expect(u_3 == E.three);\n\n    <span class=\"tok-kw\">const</span> u_4: U2 = .a; <span class=\"tok-comment\">// coerce enum literal to union with inferred enum tag type.</span>\n    <span class=\"tok-kw\">try</span> expect(u_4.tag() == <span class=\"tok-number\">1</span>);\n\n    <span class=\"tok-comment\">// The following example is invalid.</span>\n    <span class=\"tok-comment\">// error: coercion from enum '@TypeOf(.enum_literal)' to union 'test_coerce_unions_enum.U2' must initialize 'f32' field 'b'</span>\n    <span class=\"tok-comment\">//var u_5: U2 = .b;</span>\n    <span class=\"tok-comment\">//try expect(u_5.tag() == 2);</span>\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Tuple = <span class=\"tok-kw\">struct</span> { <span class=\"tok-type\">u8</span>, <span class=\"tok-type\">u8</span> };\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coercion from homogeneous tuple to array\"</span> {\n    <span class=\"tok-kw\">const</span> tuple: Tuple = .{ <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span> };\n    <span class=\"tok-kw\">const</span> array: [<span class=\"tok-number\">2</span>]<span class=\"tok-type\">u8</span> = tuple;\n    _ = array;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Casting §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> mem = std.mem;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer resolve int widening\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">i8</span> = <span class=\"tok-number\">12</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">i16</span> = <span class=\"tok-number\">34</span>;\n    <span class=\"tok-kw\">const</span> c = a + b;\n    <span class=\"tok-kw\">try</span> expect(c == <span class=\"tok-number\">46</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(c) == <span class=\"tok-type\">i16</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer resolve arrays of different size to const slice\"</span> {\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, boolToStr(<span class=\"tok-null\">true</span>), <span class=\"tok-str\">\"true\"</span>));\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, boolToStr(<span class=\"tok-null\">false</span>), <span class=\"tok-str\">\"false\"</span>));\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, boolToStr(<span class=\"tok-null\">true</span>), <span class=\"tok-str\">\"true\"</span>));\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, boolToStr(<span class=\"tok-null\">false</span>), <span class=\"tok-str\">\"false\"</span>));\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">boolToStr</span>(b: <span class=\"tok-type\">bool</span>) []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (b) <span class=\"tok-str\">\"true\"</span> <span class=\"tok-kw\">else</span> <span class=\"tok-str\">\"false\"</span>;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer resolve array and const slice\"</span> {\n    <span class=\"tok-kw\">try</span> testPeerResolveArrayConstSlice(<span class=\"tok-null\">true</span>);\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> testPeerResolveArrayConstSlice(<span class=\"tok-null\">true</span>);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">testPeerResolveArrayConstSlice</span>(b: <span class=\"tok-type\">bool</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> value1 = <span class=\"tok-kw\">if</span> (b) <span class=\"tok-str\">\"aoeu\"</span> <span class=\"tok-kw\">else</span> <span class=\"tok-builtin\">@as</span>([]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, <span class=\"tok-str\">\"zz\"</span>);\n    <span class=\"tok-kw\">const</span> value2 = <span class=\"tok-kw\">if</span> (b) <span class=\"tok-builtin\">@as</span>([]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, <span class=\"tok-str\">\"zz\"</span>) <span class=\"tok-kw\">else</span> <span class=\"tok-str\">\"aoeu\"</span>;\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, value1, <span class=\"tok-str\">\"aoeu\"</span>));\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, value2, <span class=\"tok-str\">\"zz\"</span>));\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer type resolution: ?T and T\"</span> {\n    <span class=\"tok-kw\">try</span> expect(peerTypeTAndOptionalT(<span class=\"tok-null\">true</span>, <span class=\"tok-null\">false</span>).? == <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(peerTypeTAndOptionalT(<span class=\"tok-null\">false</span>, <span class=\"tok-null\">false</span>).? == <span class=\"tok-number\">3</span>);\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">try</span> expect(peerTypeTAndOptionalT(<span class=\"tok-null\">true</span>, <span class=\"tok-null\">false</span>).? == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect(peerTypeTAndOptionalT(<span class=\"tok-null\">false</span>, <span class=\"tok-null\">false</span>).? == <span class=\"tok-number\">3</span>);\n    }\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">peerTypeTAndOptionalT</span>(c: <span class=\"tok-type\">bool</span>, b: <span class=\"tok-type\">bool</span>) ?<span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">if</span> (c) {\n        <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (b) <span class=\"tok-null\">null</span> <span class=\"tok-kw\">else</span> <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">usize</span>, <span class=\"tok-number\">0</span>);\n    }\n\n    <span class=\"tok-kw\">return</span> <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">usize</span>, <span class=\"tok-number\">3</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer type resolution: *[0]u8 and []const u8\"</span> {\n    <span class=\"tok-kw\">try</span> expect(peerTypeEmptyArrayAndSlice(<span class=\"tok-null\">true</span>, <span class=\"tok-str\">\"hi\"</span>).len == <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(peerTypeEmptyArrayAndSlice(<span class=\"tok-null\">false</span>, <span class=\"tok-str\">\"hi\"</span>).len == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">try</span> expect(peerTypeEmptyArrayAndSlice(<span class=\"tok-null\">true</span>, <span class=\"tok-str\">\"hi\"</span>).len == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect(peerTypeEmptyArrayAndSlice(<span class=\"tok-null\">false</span>, <span class=\"tok-str\">\"hi\"</span>).len == <span class=\"tok-number\">1</span>);\n    }\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">peerTypeEmptyArrayAndSlice</span>(a: <span class=\"tok-type\">bool</span>, slice: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">if</span> (a) {\n        <span class=\"tok-kw\">return</span> &[_]<span class=\"tok-type\">u8</span>{};\n    }\n\n    <span class=\"tok-kw\">return</span> slice[<span class=\"tok-number\">0</span>..<span class=\"tok-number\">1</span>];\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer type resolution: *[0]u8, []const u8, and anyerror![]u8\"</span> {\n    {\n        <span class=\"tok-kw\">var</span> data = <span class=\"tok-str\">\"hi\"</span>.*;\n        <span class=\"tok-kw\">const</span> slice = data[<span class=\"tok-number\">0</span>..];\n        <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> peerTypeEmptyArrayAndSliceAndError(<span class=\"tok-null\">true</span>, slice)).len == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> peerTypeEmptyArrayAndSliceAndError(<span class=\"tok-null\">false</span>, slice)).len == <span class=\"tok-number\">1</span>);\n    }\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">var</span> data = <span class=\"tok-str\">\"hi\"</span>.*;\n        <span class=\"tok-kw\">const</span> slice = data[<span class=\"tok-number\">0</span>..];\n        <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> peerTypeEmptyArrayAndSliceAndError(<span class=\"tok-null\">true</span>, slice)).len == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> peerTypeEmptyArrayAndSliceAndError(<span class=\"tok-null\">false</span>, slice)).len == <span class=\"tok-number\">1</span>);\n    }\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">peerTypeEmptyArrayAndSliceAndError</span>(a: <span class=\"tok-type\">bool</span>, slice: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">anyerror</span>![]<span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">if</span> (a) {\n        <span class=\"tok-kw\">return</span> &[_]<span class=\"tok-type\">u8</span>{};\n    }\n\n    <span class=\"tok-kw\">return</span> slice[<span class=\"tok-number\">0</span>..<span class=\"tok-number\">1</span>];\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer type resolution: *const T and ?*T\"</span> {\n    <span class=\"tok-kw\">const</span> a: *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">usize</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0x123456780</span>);\n    <span class=\"tok-kw\">const</span> b: ?*<span class=\"tok-type\">usize</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0x123456780</span>);\n    <span class=\"tok-kw\">try</span> expect(a == b);\n    <span class=\"tok-kw\">try</span> expect(b == a);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer type resolution: error union switch\"</span> {\n    <span class=\"tok-comment\">// The non-error and error cases are only peers if the error case is just a switch expression;</span>\n    <span class=\"tok-comment\">// the pattern `if (x) {...} else |err| blk: { switch (err) {...} }` does not consider the</span>\n    <span class=\"tok-comment\">// non-error and error case to be peers.</span>\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-kw\">error</span>{ A, B, C }!<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    _ = &a;\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-kw\">if</span> (a) |x|\n        x + <span class=\"tok-number\">3</span>\n    <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.A => <span class=\"tok-number\">0</span>,\n        <span class=\"tok-kw\">error</span>.B => <span class=\"tok-number\">1</span>,\n        <span class=\"tok-kw\">error</span>.C => <span class=\"tok-null\">null</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(b) == ?<span class=\"tok-type\">u32</span>);\n\n    <span class=\"tok-comment\">// The non-error and error cases are only peers if the error case is just a switch expression;</span>\n    <span class=\"tok-comment\">// the pattern `x catch |err| blk: { switch (err) {...} }` does not consider the unwrapped `x`</span>\n    <span class=\"tok-comment\">// and error case to be peers.</span>\n    <span class=\"tok-kw\">const</span> c = a <span class=\"tok-kw\">catch</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.A => <span class=\"tok-number\">0</span>,\n        <span class=\"tok-kw\">error</span>.B => <span class=\"tok-number\">1</span>,\n        <span class=\"tok-kw\">error</span>.C => <span class=\"tok-null\">null</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(c) == ?<span class=\"tok-type\">u32</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Casting §",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Explain Casting § in Zig 0.14.1",
    "context": "",
    "response": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Shell Type coercions are only allowed when it is completely unambiguous how to get from one type to another, and the transformation is guaranteed to be safe. There is one exception, which is C Pointers . Type Coercion: Stricter Qualification § Values which have the same representation at runtime can be cast to increase the strictness of the qualifiers, no matter how nested the qualifiers are: const - non-const to const is allowed volatile - non-volatile to volatile is allowed align - bigger to sma",
    "metadata": {
      "version": "0.14.1",
      "topic": "Casting §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Zero Bit Types §",
    "context": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no c",
    "response": "<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">entry</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">void</span> = {};\n    <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">void</span> = {};\n    x = y;\n    y = x;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Zero Bit Types §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Zero Bit Types §",
    "context": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no c",
    "response": "0000000000000010 <entry>:\n  10:\t55                   \tpush   %rbp\n  11:\t48 89 e5             \tmov    %rsp,%rbp\n  14:\t5d                   \tpop    %rbp\n  15:\tc3                   \tretq",
    "metadata": {
      "version": "0.14.1",
      "topic": "Zero Bit Types §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Zero Bit Types §",
    "context": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no c",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"turn HashMap into a set with void\"</span> {\n    <span class=\"tok-kw\">var</span> map = std.AutoHashMap(<span class=\"tok-type\">i32</span>, <span class=\"tok-type\">void</span>).init(std.testing.allocator);\n    <span class=\"tok-kw\">defer</span> map.deinit();\n\n    <span class=\"tok-kw\">try</span> map.put(<span class=\"tok-number\">1</span>, {});\n    <span class=\"tok-kw\">try</span> map.put(<span class=\"tok-number\">2</span>, {});\n\n    <span class=\"tok-kw\">try</span> expect(map.contains(<span class=\"tok-number\">2</span>));\n    <span class=\"tok-kw\">try</span> expect(!map.contains(<span class=\"tok-number\">3</span>));\n\n    _ = map.remove(<span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">try</span> expect(!map.contains(<span class=\"tok-number\">2</span>));\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Zero Bit Types §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Zero Bit Types §",
    "context": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no c",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"ignoring expression value\"</span> {\n    foo();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">1234</span>;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Zero Bit Types §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Zero Bit Types §",
    "context": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no c",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"void is ignored\"</span> {\n    returnsVoid();\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"explicitly ignoring expression value\"</span> {\n    _ = foo();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">returnsVoid</span>() <span class=\"tok-type\">void</span> {}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">1234</span>;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Zero Bit Types §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Zero Bit Types § in Zig 0.14.1",
    "context": "",
    "response": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no code generated in the body of entry , even in Debug mode. For example, on x86_64: These assembly instructions do not have any code associated with the void values - they only perform the function call prologue and epilogue. void § void can be useful for instantiating generic types. For example, given a Map(Key, Value) , one can pass void for the Value type to make it into a Set : test_void_in_hashmap.zig Shell Note that this is different from using a dummy value for the hash map value. By using v",
    "metadata": {
      "version": "0.14.1",
      "topic": "Zero Bit Types §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Result Location Semantics §",
    "context": "During compilation, every Zig expression and sub-expression is assigned optional result location information. This information dictates what type the expression should have (its result type), and where the resulting value should be placed in memory (its result location). The information is optional in the sense that not every expression has this information: assignment to _ , for instance, does not provide any information about the type of an expression, nor does it provide a concrete memory loc",
    "response": "<span class=\"tok-kw\">const</span> expectEqual = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expectEqual;\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"result type propagates through struct initializer\"</span> {\n    <span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> { x: <span class=\"tok-type\">u32</span> };\n    <span class=\"tok-kw\">const</span> val: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">123</span>;\n    <span class=\"tok-kw\">const</span> s: S = .{ .x = <span class=\"tok-builtin\">@intCast</span>(val) };\n    <span class=\"tok-comment\">// .{ .x = @intCast(val) }   has result type `S` due to the type annotation</span>\n    <span class=\"tok-comment\">//         @intCast(val)     has result type `u32` due to the type of the field `S.x`</span>\n    <span class=\"tok-comment\">//                  val      has no result type, as it is permitted to be any integer type</span>\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-number\">123</span>), s.x);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Result Location Semantics §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Result Location Semantics §",
    "context": "During compilation, every Zig expression and sub-expression is assigned optional result location information. This information dictates what type the expression should have (its result type), and where the resulting value should be placed in memory (its result location). The information is optional in the sense that not every expression has this information: assignment to _ , for instance, does not provide any information about the type of an expression, nor does it provide a concrete memory loc",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"attempt to swap array elements with array initializer\"</span> {\n    <span class=\"tok-kw\">var</span> arr: [<span class=\"tok-number\">2</span>]<span class=\"tok-type\">u32</span> = .{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span> };\n    arr = .{ arr[<span class=\"tok-number\">1</span>], arr[<span class=\"tok-number\">0</span>] };\n    <span class=\"tok-comment\">// The previous line is equivalent to the following two lines:</span>\n    <span class=\"tok-comment\">//   arr[0] = arr[1];</span>\n    <span class=\"tok-comment\">//   arr[1] = arr[0];</span>\n    <span class=\"tok-comment\">// So this fails!</span>\n    <span class=\"tok-kw\">try</span> expect(arr[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">2</span>); <span class=\"tok-comment\">// succeeds</span>\n    <span class=\"tok-kw\">try</span> expect(arr[<span class=\"tok-number\">1</span>] == <span class=\"tok-number\">1</span>); <span class=\"tok-comment\">// fails</span>\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Result Location Semantics §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Result Location Semantics § in Zig 0.14.1",
    "context": "",
    "response": "During compilation, every Zig expression and sub-expression is assigned optional result location information. This information dictates what type the expression should have (its result type), and where the resulting value should be placed in memory (its result location). The information is optional in the sense that not every expression has this information: assignment to _ , for instance, does not provide any information about the type of an expression, nor does it provide a concrete memory location to place it in. As a motivating example, consider the statement const x: u32 = 42 ; . The type annotation here provides a result type of u32 to the initialization expression 42 , instructing the compiler to coerce this integer (initially of type comptime_int ) to this type. We will see more examples shortly. This is not an implementation detail: the logic outlined above is codified into the Zig language specification, and is the primary mechanism of type inference in the language. This sys",
    "metadata": {
      "version": "0.14.1",
      "topic": "Result Location Semantics §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: usingnamespace §",
    "context": "usingnamespace is a declaration that mixes all the public declarations of the operand, which must be a struct , union , enum , or opaque , into the namespace: test_usingnamespace.zig Shell usingnamespace has an important use case when organizing the public API of a file or package. For example, one might have c.zig with all of the C imports : c.zig The above example demonstrates using pub to qualify the usingnamespace additionally makes the imported declarations pub . This can be used to forward",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"using std namespace\"</span> {\n    <span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> {\n        <span class=\"tok-kw\">usingnamespace</span> <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n    };\n    <span class=\"tok-kw\">try</span> S.testing.expect(<span class=\"tok-null\">true</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "usingnamespace §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: usingnamespace §",
    "context": "usingnamespace is a declaration that mixes all the public declarations of the operand, which must be a struct , union , enum , or opaque , into the namespace: test_usingnamespace.zig Shell usingnamespace has an important use case when organizing the public API of a file or package. For example, one might have c.zig with all of the C imports : c.zig The above example demonstrates using pub to qualify the usingnamespace additionally makes the imported declarations pub . This can be used to forward",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">usingnamespace</span> <span class=\"tok-builtin\">@cImport</span>({\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"epoxy/gl.h\"</span>);\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"GLFW/glfw3.h\"</span>);\n    <span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"STBI_ONLY_PNG\"</span>, <span class=\"tok-str\">\"\"</span>);\n    <span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"STBI_NO_STDIO\"</span>, <span class=\"tok-str\">\"\"</span>);\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"stb_image.h\"</span>);\n});",
    "metadata": {
      "version": "0.14.1",
      "topic": "usingnamespace §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain usingnamespace § in Zig 0.14.1",
    "context": "",
    "response": "usingnamespace is a declaration that mixes all the public declarations of the operand, which must be a struct , union , enum , or opaque , into the namespace: test_usingnamespace.zig Shell usingnamespace has an important use case when organizing the public API of a file or package. For example, one might have c.zig with all of the C imports : c.zig The above example demonstrates using pub to qualify the usingnamespace additionally makes the imported declarations pub . This can be used to forward declarations, giving precise control over what declarations a given file exposes.",
    "metadata": {
      "version": "0.14.1",
      "topic": "usingnamespace §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">max</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) T {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (a > b) a <span class=\"tok-kw\">else</span> b;\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">gimmeTheBiggerFloat</span>(a: <span class=\"tok-type\">f32</span>, b: <span class=\"tok-type\">f32</span>) <span class=\"tok-type\">f32</span> {\n    <span class=\"tok-kw\">return</span> max(<span class=\"tok-type\">f32</span>, a, b);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">gimmeTheBiggerInteger</span>(a: <span class=\"tok-type\">u64</span>, b: <span class=\"tok-type\">u64</span>) <span class=\"tok-type\">u64</span> {\n    <span class=\"tok-kw\">return</span> max(<span class=\"tok-type\">u64</span>, a, b);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">max</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) T {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (a > b) a <span class=\"tok-kw\">else</span> b;\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"try to pass a runtime type\"</span> {\n    foo(<span class=\"tok-null\">false</span>);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(condition: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> result = max(<span class=\"tok-kw\">if</span> (condition) <span class=\"tok-type\">f32</span> <span class=\"tok-kw\">else</span> <span class=\"tok-type\">u64</span>, <span class=\"tok-number\">1234</span>, <span class=\"tok-number\">5678</span>);\n    _ = result;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">max</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) T {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (a > b) a <span class=\"tok-kw\">else</span> b;\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"try to compare bools\"</span> {\n    _ = max(<span class=\"tok-type\">bool</span>, <span class=\"tok-null\">true</span>, <span class=\"tok-null\">false</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">max</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) T {\n    <span class=\"tok-kw\">if</span> (T == <span class=\"tok-type\">bool</span>) {\n        <span class=\"tok-kw\">return</span> a <span class=\"tok-kw\">or</span> b;\n    } <span class=\"tok-kw\">else</span> <span class=\"tok-kw\">if</span> (a > b) {\n        <span class=\"tok-kw\">return</span> a;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">return</span> b;\n    }\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"try to compare bools\"</span> {\n    <span class=\"tok-kw\">try</span> <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect(max(<span class=\"tok-type\">bool</span>, <span class=\"tok-null\">false</span>, <span class=\"tok-null\">true</span>) == <span class=\"tok-null\">true</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">max</span>(a: <span class=\"tok-type\">bool</span>, b: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">bool</span> {\n    {\n        <span class=\"tok-kw\">return</span> a <span class=\"tok-kw\">or</span> b;\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">const</span> CmdFn = <span class=\"tok-kw\">struct</span> {\n    name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>,\n    func: <span class=\"tok-kw\">fn</span> (<span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span>,\n};\n\n<span class=\"tok-kw\">const</span> cmd_fns = [_]CmdFn{\n    CmdFn{ .name = <span class=\"tok-str\">\"one\"</span>, .func = one },\n    CmdFn{ .name = <span class=\"tok-str\">\"two\"</span>, .func = two },\n    CmdFn{ .name = <span class=\"tok-str\">\"three\"</span>, .func = three },\n};\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">one</span>(value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> value + <span class=\"tok-number\">1</span>;\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">two</span>(value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> value + <span class=\"tok-number\">2</span>;\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">three</span>(value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> value + <span class=\"tok-number\">3</span>;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">performFn</span>(<span class=\"tok-kw\">comptime</span> prefix_char: <span class=\"tok-type\">u8</span>, start_value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> result: <span class=\"tok-type\">i32</span> = start_value;\n    <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> i = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">while</span> (i < cmd_fns.len) : (i += <span class=\"tok-number\">1</span>) {\n        <span class=\"tok-kw\">if</span> (cmd_fns[i].name[<span class=\"tok-number\">0</span>] == prefix_char) {\n            result = cmd_fns[i].func(result);\n        }\n    }\n    <span class=\"tok-kw\">return</span> result;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"perform fn\"</span> {\n    <span class=\"tok-kw\">try</span> expect(performFn(<span class=\"tok-str\">'t'</span>, <span class=\"tok-number\">1</span>) == <span class=\"tok-number\">6</span>);\n    <span class=\"tok-kw\">try</span> expect(performFn(<span class=\"tok-str\">'o'</span>, <span class=\"tok-number\">0</span>) == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(performFn(<span class=\"tok-str\">'w'</span>, <span class=\"tok-number\">99</span>) == <span class=\"tok-number\">99</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-comment\">// From the line:</span>\n<span class=\"tok-comment\">// expect(performFn('t', 1) == 6);</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">performFn</span>(start_value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> result: <span class=\"tok-type\">i32</span> = start_value;\n    result = two(result);\n    result = three(result);\n    <span class=\"tok-kw\">return</span> result;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-comment\">// From the line:</span>\n<span class=\"tok-comment\">// expect(performFn('o', 0) == 1);</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">performFn</span>(start_value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> result: <span class=\"tok-type\">i32</span> = start_value;\n    result = one(result);\n    <span class=\"tok-kw\">return</span> result;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-comment\">// From the line:</span>\n<span class=\"tok-comment\">// expect(performFn('w', 99) == 99);</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">performFn</span>(start_value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> result: <span class=\"tok-type\">i32</span> = start_value;\n    _ = &result;\n    <span class=\"tok-kw\">return</span> result;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">exit</span>() <span class=\"tok-type\">noreturn</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"foo\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        exit();\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">fibonacci</span>(index: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">if</span> (index < <span class=\"tok-number\">2</span>) <span class=\"tok-kw\">return</span> index;\n    <span class=\"tok-kw\">return</span> fibonacci(index - <span class=\"tok-number\">1</span>) + fibonacci(index - <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fibonacci\"</span> {\n    <span class=\"tok-comment\">// test fibonacci at run-time</span>\n    <span class=\"tok-kw\">try</span> expect(fibonacci(<span class=\"tok-number\">7</span>) == <span class=\"tok-number\">13</span>);\n\n    <span class=\"tok-comment\">// test fibonacci at compile-time</span>\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(fibonacci(<span class=\"tok-number\">7</span>) == <span class=\"tok-number\">13</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">fibonacci</span>(index: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-comment\">//if (index < 2) return index;</span>\n    <span class=\"tok-kw\">return</span> fibonacci(index - <span class=\"tok-number\">1</span>) + fibonacci(index - <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fibonacci\"</span> {\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(fibonacci(<span class=\"tok-number\">7</span>) == <span class=\"tok-number\">13</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> assert = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.assert;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">fibonacci</span>(index: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-comment\">//if (index < 2) return index;</span>\n    <span class=\"tok-kw\">return</span> fibonacci(index - <span class=\"tok-number\">1</span>) + fibonacci(index - <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fibonacci\"</span> {\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> assert(fibonacci(<span class=\"tok-number\">7</span>) == <span class=\"tok-number\">13</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> assert = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.assert;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">fibonacci</span>(index: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">if</span> (index < <span class=\"tok-number\">2</span>) <span class=\"tok-kw\">return</span> index;\n    <span class=\"tok-kw\">return</span> fibonacci(index - <span class=\"tok-number\">1</span>) + fibonacci(index - <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fibonacci\"</span> {\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> assert(fibonacci(<span class=\"tok-number\">7</span>) == <span class=\"tok-number\">99999</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> first_25_primes = firstNPrimes(<span class=\"tok-number\">25</span>);\n<span class=\"tok-kw\">const</span> sum_of_first_25_primes = sum(&first_25_primes);\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">firstNPrimes</span>(<span class=\"tok-kw\">comptime</span> n: <span class=\"tok-type\">usize</span>) [n]<span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> prime_list: [n]<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">var</span> next_index: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">var</span> test_number: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">while</span> (next_index < prime_list.len) : (test_number += <span class=\"tok-number\">1</span>) {\n        <span class=\"tok-kw\">var</span> test_prime_index: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n        <span class=\"tok-kw\">var</span> is_prime = <span class=\"tok-null\">true</span>;\n        <span class=\"tok-kw\">while</span> (test_prime_index < next_index) : (test_prime_index += <span class=\"tok-number\">1</span>) {\n            <span class=\"tok-kw\">if</span> (test_number % prime_list[test_prime_index] == <span class=\"tok-number\">0</span>) {\n                is_prime = <span class=\"tok-null\">false</span>;\n                <span class=\"tok-kw\">break</span>;\n            }\n        }\n        <span class=\"tok-kw\">if</span> (is_prime) {\n            prime_list[next_index] = test_number;\n            next_index += <span class=\"tok-number\">1</span>;\n        }\n    }\n    <span class=\"tok-kw\">return</span> prime_list;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">sum</span>(numbers: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> result: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">for</span> (numbers) |x| {\n        result += x;\n    }\n    <span class=\"tok-kw\">return</span> result;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"variable values\"</span> {\n    <span class=\"tok-kw\">try</span> <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect(sum_of_first_25_primes == <span class=\"tok-number\">1060</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "@0 = internal unnamed_addr constant [25 x i32] [i32 2, i32 3, i32 5, i32 7, i32 11, i32 13, i32 17, i32 19, i32 23, i32 29, i32 31, i32 37, i32 41, i32 43, i32 47, i32 53, i32 59, i32 61, i32 67, i32 71, i32 73, i32 79, i32 83, i32 89, i32 97]\n@1 = internal unnamed_addr constant i32 1060",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">List</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">struct</span> {\n        items: []T,\n        len: <span class=\"tok-type\">usize</span>,\n    };\n}\n\n<span class=\"tok-comment\">// The generic List data structure can be instantiated by passing in a type:</span>\n<span class=\"tok-kw\">var</span> buffer: [<span class=\"tok-number\">10</span>]<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n<span class=\"tok-kw\">var</span> list = List(<span class=\"tok-type\">i32</span>){\n    .items = &buffer,\n    .len = <span class=\"tok-number\">0</span>,\n};",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> Node = <span class=\"tok-kw\">struct</span> {\n    next: ?*Node,\n    name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>,\n};\n\n<span class=\"tok-kw\">var</span> node_a = Node{\n    .next = <span class=\"tok-null\">null</span>,\n    .name = <span class=\"tok-str\">\"Node A\"</span>,\n};\n\n<span class=\"tok-kw\">var</span> node_b = Node{\n    .next = &node_a,\n    .name = <span class=\"tok-str\">\"Node B\"</span>,\n};",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">const</span> a_number: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n<span class=\"tok-kw\">const</span> a_string = <span class=\"tok-str\">\"foobar\"</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    print(<span class=\"tok-str\">\"here is a string: '{s}' here is a number: {}\\n\"</span>, .{ a_string, a_number });\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> Writer = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-comment\">/// Calls print and then flushes the buffer.</span>\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">print</span>(self: *Writer, <span class=\"tok-kw\">comptime</span> format: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, args: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">void</span> {\n        <span class=\"tok-kw\">const</span> State = <span class=\"tok-kw\">enum</span> {\n            start,\n            open_brace,\n            close_brace,\n        };\n\n        <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> start_index: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n        <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> state = State.start;\n        <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> next_arg: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n\n        <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">for</span> (format, <span class=\"tok-number\">0</span>..) |c, i| {\n            <span class=\"tok-kw\">switch</span> (state) {\n                State.start => <span class=\"tok-kw\">switch</span> (c) {\n                    <span class=\"tok-str\">'{'</span> => {\n                        <span class=\"tok-kw\">if</span> (start_index < i) <span class=\"tok-kw\">try</span> self.write(format[start_index..i]);\n                        state = State.open_brace;\n                    },\n                    <span class=\"tok-str\">'}'</span> => {\n                        <span class=\"tok-kw\">if</span> (start_index < i) <span class=\"tok-kw\">try</span> self.write(format[start_index..i]);\n                        state = State.close_brace;\n                    },\n                    <span class=\"tok-kw\">else</span> => {},\n                },\n                State.open_brace => <span class=\"tok-kw\">switch</span> (c) {\n                    <span class=\"tok-str\">'{'</span> => {\n                        state = State.start;\n                        start_index = i;\n                    },\n                    <span class=\"tok-str\">'}'</span> => {\n                        <span class=\"tok-kw\">try</span> self.printValue(args[next_arg]);\n                        next_arg += <span class=\"tok-number\">1</span>;\n                        state = State.start;\n                        start_index = i + <span class=\"tok-number\">1</span>;\n                    },\n                    <span class=\"tok-str\">'s'</span> => {\n                        <span class=\"tok-kw\">continue</span>;\n                    },\n                    <span class=\"tok-kw\">else</span> => <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"Unknown format character: \"</span> ++ [<span class=\"tok-number\">1</span>]<span class=\"tok-type\">u8</span>{c}),\n                },\n                State.close_brace => <span class=\"tok-kw\">switch</span> (c) {\n                    <span class=\"tok-str\">'}'</span> => {\n                        state = State.start;\n                        start_index = i;\n                    },\n                    <span class=\"tok-kw\">else</span> => <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"Single '}' encountered in format string\"</span>),\n                },\n            }\n        }\n        <span class=\"tok-kw\">comptime</span> {\n            <span class=\"tok-kw\">if</span> (args.len != next_arg) {\n                <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"Unused arguments\"</span>);\n            }\n            <span class=\"tok-kw\">if</span> (state != State.start) {\n                <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"Incomplete format string: \"</span> ++ format);\n            }\n        }\n        <span class=\"tok-kw\">if</span> (start_index < format.len) {\n            <span class=\"tok-kw\">try</span> self.write(format[start_index..format.len]);\n        }\n        <span class=\"tok-kw\">try</span> self.flush();\n    }\n\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">write</span>(self: *Writer, value: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) !<span class=\"tok-type\">void</span> {\n        _ = self;\n        _ = value;\n    }\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">printValue</span>(self: *Writer, value: <span class=\"tok-kw\">anytype</span>) !<span class=\"tok-type\">void</span> {\n        _ = self;\n        _ = value;\n    }\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">flush</span>(self: *Writer) !<span class=\"tok-type\">void</span> {\n        _ = self;\n    }\n};",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">print</span>(self: *Writer, arg0: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, arg1: <span class=\"tok-type\">i32</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> self.write(<span class=\"tok-str\">\"here is a string: '\"</span>);\n    <span class=\"tok-kw\">try</span> self.printValue(arg0);\n    <span class=\"tok-kw\">try</span> self.write(<span class=\"tok-str\">\"' here is a number: \"</span>);\n    <span class=\"tok-kw\">try</span> self.printValue(arg1);\n    <span class=\"tok-kw\">try</span> self.write(<span class=\"tok-str\">\"\\n\"</span>);\n    <span class=\"tok-kw\">try</span> self.flush();\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> Writer = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">printValue</span>(self: *Writer, value: <span class=\"tok-kw\">anytype</span>) !<span class=\"tok-type\">void</span> {\n        <span class=\"tok-kw\">switch</span> (<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(value))) {\n            .int => {\n                <span class=\"tok-kw\">return</span> self.writeInt(value);\n            },\n            .float => {\n                <span class=\"tok-kw\">return</span> self.writeFloat(value);\n            },\n            .pointer => {\n                <span class=\"tok-kw\">return</span> self.write(value);\n            },\n            <span class=\"tok-kw\">else</span> => {\n                <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"Unable to print type '\"</span> ++ <span class=\"tok-builtin\">@typeName</span>(<span class=\"tok-builtin\">@TypeOf</span>(value)) ++ <span class=\"tok-str\">\"'\"</span>);\n            },\n        }\n    }\n\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">write</span>(self: *Writer, value: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) !<span class=\"tok-type\">void</span> {\n        _ = self;\n        _ = value;\n    }\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">writeInt</span>(self: *Writer, value: <span class=\"tok-kw\">anytype</span>) !<span class=\"tok-type\">void</span> {\n        _ = self;\n        _ = value;\n    }\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">writeFloat</span>(self: *Writer, value: <span class=\"tok-kw\">anytype</span>) !<span class=\"tok-type\">void</span> {\n        _ = self;\n        _ = value;\n    }\n};",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">const</span> a_number: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n<span class=\"tok-kw\">const</span> a_string = <span class=\"tok-str\">\"foobar\"</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"print too many arguments\"</span> {\n    print(<span class=\"tok-str\">\"here is a string: '{s}' here is a number: {}\\n\"</span>, .{\n        a_string,\n        a_number,\n        a_number,\n    });\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">const</span> a_number: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n<span class=\"tok-kw\">const</span> a_string = <span class=\"tok-str\">\"foobar\"</span>;\n<span class=\"tok-kw\">const</span> fmt = <span class=\"tok-str\">\"here is a string: '{s}' here is a number: {}\\n\"</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    print(fmt, .{ a_string, a_number });\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain comptime § in Zig 0.14.1",
    "context": "",
    "response": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as parameters to functions, and returned from functions. However, they can only be used in expressions which are known at compile-time , which is why the parameter T in the above snippet must be marked with comptime . A comptime parameter means that: At the callsite, the value must be known at compile-time, or it is a compile error. In the function definition, the value is known at compile-time. For example, if we were to introduce another function to the above snippet: test_unresolved_comptime_value.",
    "metadata": {
      "version": "0.14.1",
      "topic": "comptime §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Assembly §",
    "context": "For some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly: inline_assembly.zig Shell Dissecting the syntax: Assembly Syntax Explained.zig For x86 and x86_64 targets, the syntax is AT&amp;T syntax, rather than the more popular Intel syntax. This is due to technical constraints",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">noreturn</span> {\n    <span class=\"tok-kw\">const</span> msg = <span class=\"tok-str\">\"hello world\\n\"</span>;\n    _ = syscall3(SYS_write, STDOUT_FILENO, <span class=\"tok-builtin\">@intFromPtr</span>(msg), msg.len);\n    _ = syscall1(SYS_exit, <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">unreachable</span>;\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> SYS_write = <span class=\"tok-number\">1</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> SYS_exit = <span class=\"tok-number\">60</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> STDOUT_FILENO = <span class=\"tok-number\">1</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">syscall1</span>(number: <span class=\"tok-type\">usize</span>, arg1: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">asm</span> <span class=\"tok-kw\">volatile</span> (<span class=\"tok-str\">\"syscall\"</span>\n        : [ret] <span class=\"tok-str\">\"={rax}\"</span> (-> <span class=\"tok-type\">usize</span>),\n        : [number] <span class=\"tok-str\">\"{rax}\"</span> (number),\n          [arg1] <span class=\"tok-str\">\"{rdi}\"</span> (arg1),\n        : <span class=\"tok-str\">\"rcx\"</span>, <span class=\"tok-str\">\"r11\"</span>\n    );\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">syscall3</span>(number: <span class=\"tok-type\">usize</span>, arg1: <span class=\"tok-type\">usize</span>, arg2: <span class=\"tok-type\">usize</span>, arg3: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">asm</span> <span class=\"tok-kw\">volatile</span> (<span class=\"tok-str\">\"syscall\"</span>\n        : [ret] <span class=\"tok-str\">\"={rax}\"</span> (-> <span class=\"tok-type\">usize</span>),\n        : [number] <span class=\"tok-str\">\"{rax}\"</span> (number),\n          [arg1] <span class=\"tok-str\">\"{rdi}\"</span> (arg1),\n          [arg2] <span class=\"tok-str\">\"{rsi}\"</span> (arg2),\n          [arg3] <span class=\"tok-str\">\"{rdx}\"</span> (arg3),\n        : <span class=\"tok-str\">\"rcx\"</span>, <span class=\"tok-str\">\"r11\"</span>\n    );\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Assembly §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Assembly §",
    "context": "For some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly: inline_assembly.zig Shell Dissecting the syntax: Assembly Syntax Explained.zig For x86 and x86_64 targets, the syntax is AT&amp;T syntax, rather than the more popular Intel syntax. This is due to technical constraints",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">syscall1</span>(number: <span class=\"tok-type\">usize</span>, arg1: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-comment\">// Inline assembly is an expression which returns a value.</span>\n    <span class=\"tok-comment\">// the `asm` keyword begins the expression.</span>\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">asm</span>\n    <span class=\"tok-comment\">// `volatile` is an optional modifier that tells Zig this</span>\n    <span class=\"tok-comment\">// inline assembly expression has side-effects. Without</span>\n    <span class=\"tok-comment\">// `volatile`, Zig is allowed to delete the inline assembly</span>\n    <span class=\"tok-comment\">// code if the result is unused.</span>\n    <span class=\"tok-kw\">volatile</span> (\n    <span class=\"tok-comment\">// Next is a comptime string which is the assembly code.</span>\n    <span class=\"tok-comment\">// Inside this string one may use `%[ret]`, `%[number]`,</span>\n    <span class=\"tok-comment\">// or `%[arg1]` where a register is expected, to specify</span>\n    <span class=\"tok-comment\">// the register that Zig uses for the argument or return value,</span>\n    <span class=\"tok-comment\">// if the register constraint strings are used. However in</span>\n    <span class=\"tok-comment\">// the below code, this is not used. A literal `%` can be</span>\n    <span class=\"tok-comment\">// obtained by escaping it with a double percent: `%%`.</span>\n    <span class=\"tok-comment\">// Often multiline string syntax comes in handy here.</span>\n        <span class=\"tok-str\">\\\\syscall</span>\n        <span class=\"tok-comment\">// Next is the output. It is possible in the future Zig will</span>\n        <span class=\"tok-comment\">// support multiple outputs, depending on how</span>\n        <span class=\"tok-comment\">// https://github.com/ziglang/zig/issues/215 is resolved.</span>\n        <span class=\"tok-comment\">// It is allowed for there to be no outputs, in which case</span>\n        <span class=\"tok-comment\">// this colon would be directly followed by the colon for the inputs.</span>\n        :\n        <span class=\"tok-comment\">// This specifies the name to be used in `%[ret]` syntax in</span>\n        <span class=\"tok-comment\">// the above assembly string. This example does not use it,</span>\n        <span class=\"tok-comment\">// but the syntax is mandatory.</span>\n          [ret]\n          <span class=\"tok-comment\">// Next is the output constraint string. This feature is still</span>\n          <span class=\"tok-comment\">// considered unstable in Zig, and so LLVM/GCC documentation</span>\n          <span class=\"tok-comment\">// must be used to understand the semantics.</span>\n          <span class=\"tok-comment\">// http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string</span>\n          <span class=\"tok-comment\">// https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html</span>\n          <span class=\"tok-comment\">// In this example, the constraint string means \"the result value of</span>\n          <span class=\"tok-comment\">// this inline assembly instruction is whatever is in $rax\".</span>\n          <span class=\"tok-str\">\"={rax}\"</span>\n          <span class=\"tok-comment\">// Next is either a value binding, or `->` and then a type. The</span>\n          <span class=\"tok-comment\">// type is the result type of the inline assembly expression.</span>\n          <span class=\"tok-comment\">// If it is a value binding, then `%[ret]` syntax would be used</span>\n          <span class=\"tok-comment\">// to refer to the register bound to the value.</span>\n          (-> <span class=\"tok-type\">usize</span>),\n          <span class=\"tok-comment\">// Next is the list of inputs.</span>\n          <span class=\"tok-comment\">// The constraint for these inputs means, \"when the assembly code is</span>\n          <span class=\"tok-comment\">// executed, $rax shall have the value of `number` and $rdi shall have</span>\n          <span class=\"tok-comment\">// the value of `arg1`\". Any number of input parameters is allowed,</span>\n          <span class=\"tok-comment\">// including none.</span>\n        : [number] <span class=\"tok-str\">\"{rax}\"</span> (number),\n          [arg1] <span class=\"tok-str\">\"{rdi}\"</span> (arg1),\n          <span class=\"tok-comment\">// Next is the list of clobbers. These declare a set of registers whose</span>\n          <span class=\"tok-comment\">// values will not be preserved by the execution of this assembly code.</span>\n          <span class=\"tok-comment\">// These do not include output or input registers. The special clobber</span>\n          <span class=\"tok-comment\">// value of \"memory\" means that the assembly writes to arbitrary undeclared</span>\n          <span class=\"tok-comment\">// memory locations - not only the memory pointed to by a declared indirect</span>\n          <span class=\"tok-comment\">// output. In this example we list $rcx and $r11 because it is known the</span>\n          <span class=\"tok-comment\">// kernel syscall does not preserve these registers.</span>\n        : <span class=\"tok-str\">\"rcx\"</span>, <span class=\"tok-str\">\"r11\"</span>\n    );\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Assembly §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Assembly §",
    "context": "For some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly: inline_assembly.zig Shell Dissecting the syntax: Assembly Syntax Explained.zig For x86 and x86_64 targets, the syntax is AT&amp;T syntax, rather than the more popular Intel syntax. This is due to technical constraints",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">asm</span> (\n        <span class=\"tok-str\">\\\\.global my_func;</span>\n        <span class=\"tok-str\">\\\\.type my_func, @function;</span>\n        <span class=\"tok-str\">\\\\my_func:</span>\n        <span class=\"tok-str\">\\\\  lea (%rdi,%rsi,1),%eax</span>\n        <span class=\"tok-str\">\\\\  retq</span>\n    );\n}\n\n<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">my_func</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"global assembly\"</span> {\n    <span class=\"tok-kw\">try</span> expect(my_func(<span class=\"tok-number\">12</span>, <span class=\"tok-number\">34</span>) == <span class=\"tok-number\">46</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Assembly §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Assembly § in Zig 0.14.1",
    "context": "",
    "response": "For some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly: inline_assembly.zig Shell Dissecting the syntax: Assembly Syntax Explained.zig For x86 and x86_64 targets, the syntax is AT&amp;T syntax, rather than the more popular Intel syntax. This is due to technical constraints; assembly parsing is provided by LLVM and its support for Intel syntax is buggy and not well tested. Some day Zig may have its own assembler. This would allow it to integrate more seamlessly into the language, as well as be compatible with the popular NASM syntax. This documentation section will be updated before 1.0.0 is released, with a conclusive statement about the status of AT&amp;T vs Intel/NASM syntax. Output Constraints § Output constraints are still considered to be unstable in Zig, an",
    "metadata": {
      "version": "0.14.1",
      "topic": "Assembly §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Atomics § in Zig 0.14.1",
    "context": "",
    "response": "TODO: @atomic rmw TODO: builtin atomic memory ordering enum See also: @atomicLoad @atomicStore @atomicRmw @cmpxchgWeak @cmpxchgStrong",
    "metadata": {
      "version": "0.14.1",
      "topic": "Atomics §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Async Functions § in Zig 0.14.1",
    "context": "",
    "response": "Async functions regressed with the release of 0.11.0. Their future in the Zig language is unclear due to multiple unsolved problems: LLVM's lack of ability to optimize them. Third-party debuggers' lack of ability to debug them. The cancellation problem . Async function pointers preventing the stack size from being known. These problems are surmountable, but it will take time. The Zig team is currently focused on other priorities.",
    "metadata": {
      "version": "0.14.1",
      "topic": "Async Functions §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@addrSpaceCast</span>(ptr: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@addWithOverflow</span>(a: <span class=\"tok-kw\">anytype</span>, b: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">struct</span> { <span class=\"tok-builtin\">@TypeOf</span>(a, b), <span class=\"tok-type\">u1</span> }",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@alignCast</span>(ptr: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@alignOf</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">comptime_int</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> assert = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.assert;\n<span class=\"tok-kw\">comptime</span> {\n    assert(*<span class=\"tok-type\">u32</span> == *<span class=\"tok-kw\">align</span>(<span class=\"tok-builtin\">@alignOf</span>(<span class=\"tok-type\">u32</span>)) <span class=\"tok-type\">u32</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, expression) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@atomicLoad</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *<span class=\"tok-kw\">const</span> T, <span class=\"tok-kw\">comptime</span> ordering: AtomicOrder) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@atomicRmw</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, <span class=\"tok-kw\">comptime</span> op: AtomicRmwOp, operand: T, <span class=\"tok-kw\">comptime</span> ordering: AtomicOrder) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@atomicStore</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, value: T, <span class=\"tok-kw\">comptime</span> ordering: AtomicOrder) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@bitCast</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@bitOffsetOf</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">comptime_int</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@bitSizeOf</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">comptime_int</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@branchHint</span>(hint: BranchHint) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@breakpoint</span>() <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@mulAdd</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T, c: T) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@byteSwap</span>(operand: <span class=\"tok-kw\">anytype</span>) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@bitReverse</span>(integer: <span class=\"tok-kw\">anytype</span>) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@offsetOf</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">comptime_int</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@call</span>(modifier: std.builtin.CallModifier, function: <span class=\"tok-kw\">anytype</span>, args: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"noinline function call\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@call</span>(.auto, add, .{ <span class=\"tok-number\">3</span>, <span class=\"tok-number\">9</span> }) == <span class=\"tok-number\">12</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> a + b;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> CallModifier = <span class=\"tok-kw\">enum</span> {\n    <span class=\"tok-comment\">/// Equivalent to function call syntax.</span>\n    auto,\n\n    <span class=\"tok-comment\">/// Equivalent to async keyword used with function call syntax.</span>\n    async_kw,\n\n    <span class=\"tok-comment\">/// Prevents tail call optimization. This guarantees that the return</span>\n    <span class=\"tok-comment\">/// address will point to the callsite, as opposed to the callsite's</span>\n    <span class=\"tok-comment\">/// callsite. If the call is otherwise required to be tail-called</span>\n    <span class=\"tok-comment\">/// or inlined, a compile error is emitted instead.</span>\n    never_tail,\n\n    <span class=\"tok-comment\">/// Guarantees that the call will not be inlined. If the call is</span>\n    <span class=\"tok-comment\">/// otherwise required to be inlined, a compile error is emitted instead.</span>\n    never_inline,\n\n    <span class=\"tok-comment\">/// Asserts that the function call will not suspend. This allows a</span>\n    <span class=\"tok-comment\">/// non-async function to call an async function.</span>\n    no_async,\n\n    <span class=\"tok-comment\">/// Guarantees that the call will be generated with tail call optimization.</span>\n    <span class=\"tok-comment\">/// If this is not possible, a compile error is emitted instead.</span>\n    always_tail,\n\n    <span class=\"tok-comment\">/// Guarantees that the call will be inlined at the callsite.</span>\n    <span class=\"tok-comment\">/// If this is not possible, a compile error is emitted instead.</span>\n    always_inline,\n\n    <span class=\"tok-comment\">/// Evaluates the call at compile-time. If the call cannot be completed at</span>\n    <span class=\"tok-comment\">/// compile-time, a compile error is emitted instead.</span>\n    compile_time,\n};",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-kw\">comptime</span> name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, value) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "#define _GNU_SOURCE",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"_GNU_SOURCE\"</span>, {})",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cImport</span>(expression) <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-kw\">comptime</span> path: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@clz</span>(operand: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cmpxchgStrong</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">cmpxchgStrongButNotAtomic</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, expected_value: T, new_value: T) ?T {\n    <span class=\"tok-kw\">const</span> old_value = ptr.*;\n    <span class=\"tok-kw\">if</span> (old_value == expected_value) {\n        ptr.* = new_value;\n        <span class=\"tok-kw\">return</span> <span class=\"tok-null\">null</span>;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">return</span> old_value;\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cmpxchgWeak</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">cmpxchgWeakButNotAtomic</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, expected_value: T, new_value: T) ?T {\n    <span class=\"tok-kw\">const</span> old_value = ptr.*;\n    <span class=\"tok-kw\">if</span> (old_value == expected_value <span class=\"tok-kw\">and</span> usuallyTrueButSometimesFalse()) {\n        ptr.* = new_value;\n        <span class=\"tok-kw\">return</span> <span class=\"tok-null\">null</span>;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">return</span> old_value;\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-kw\">comptime</span> msg: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">noreturn</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@compileLog</span>(...) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">const</span> num1 = blk: {\n    <span class=\"tok-kw\">var</span> val1: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">99</span>;\n    <span class=\"tok-builtin\">@compileLog</span>(<span class=\"tok-str\">\"comptime val1 = \"</span>, val1);\n    val1 = val1 + <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">break</span> :blk val1;\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"main\"</span> {\n    <span class=\"tok-builtin\">@compileLog</span>(<span class=\"tok-str\">\"comptime in main\"</span>);\n\n    print(<span class=\"tok-str\">\"Runtime in main, num1 = {}.\\n\"</span>, .{num1});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@constCast</span>(value: <span class=\"tok-kw\">anytype</span>) DestType",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@ctz</span>(operand: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cUndef</span>(<span class=\"tok-kw\">comptime</span> name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cVaArg</span>(operand: *std.builtin.VaList, <span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cVaCopy</span>(src: *std.builtin.VaList) std.builtin.VaList",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cVaEnd</span>(src: *std.builtin.VaList) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cVaStart</span>() std.builtin.VaList",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@divExact</span>(numerator: T, denominator: T) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@divFloor</span>(numerator: T, denominator: T) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@divTrunc</span>(numerator: T, denominator: T) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@embedFile</span>(<span class=\"tok-kw\">comptime</span> path: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) *<span class=\"tok-kw\">const</span> [N:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@enumFromInt</span>(integer: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@errorFromInt</span>(value: std.meta.Int(.unsigned, <span class=\"tok-builtin\">@bitSizeOf</span>(<span class=\"tok-type\">anyerror</span>))) <span class=\"tok-type\">anyerror</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@errorName</span>(err: <span class=\"tok-type\">anyerror</span>) [:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@errorReturnTrace</span>() ?*builtin.StackTrace",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@errorCast</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@export</span>(<span class=\"tok-kw\">comptime</span> ptr: *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">anyopaque</span>, <span class=\"tok-kw\">comptime</span> options: std.builtin.ExportOptions) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-builtin\">@export</span>(&internalName, .{ .name = <span class=\"tok-str\">\"foo\"</span>, .linkage = .strong });\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">internalName</span>() <span class=\"tok-kw\">callconv</span>(.C) <span class=\"tok-type\">void</span> {}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">void</span> {}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">@\"A function name that is a complete sentence.\"</span>() <span class=\"tok-type\">void</span> {}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "00000000000001f0 T A function name that is a complete sentence.",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@extern</span>(T: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> options: std.builtin.ExternOptions) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@field</span>(lhs: <span class=\"tok-kw\">anytype</span>, <span class=\"tok-kw\">comptime</span> field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) (field)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> {\n    x: <span class=\"tok-type\">u32</span>,\n    y: <span class=\"tok-type\">u32</span>,\n\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">var</span> z: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">1</span>;\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"field access by string\"</span> {\n    <span class=\"tok-kw\">const</span> expect = std.testing.expect;\n    <span class=\"tok-kw\">var</span> p = Point{ .x = <span class=\"tok-number\">0</span>, .y = <span class=\"tok-number\">0</span> };\n\n    <span class=\"tok-builtin\">@field</span>(p, <span class=\"tok-str\">\"x\"</span>) = <span class=\"tok-number\">4</span>;\n    <span class=\"tok-builtin\">@field</span>(p, <span class=\"tok-str\">\"y\"</span>) = <span class=\"tok-builtin\">@field</span>(p, <span class=\"tok-str\">\"x\"</span>) + <span class=\"tok-number\">1</span>;\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@field</span>(p, <span class=\"tok-str\">\"x\"</span>) == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@field</span>(p, <span class=\"tok-str\">\"y\"</span>) == <span class=\"tok-number\">5</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"decl access by string\"</span> {\n    <span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@field</span>(Point, <span class=\"tok-str\">\"z\"</span>) == <span class=\"tok-number\">1</span>);\n\n    <span class=\"tok-builtin\">@field</span>(Point, <span class=\"tok-str\">\"z\"</span>) = <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@field</span>(Point, <span class=\"tok-str\">\"z\"</span>) == <span class=\"tok-number\">2</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@fieldParentPtr</span>(<span class=\"tok-kw\">comptime</span> field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, field_ptr: *T) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@FieldType</span>(<span class=\"tok-kw\">comptime</span> Type: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@floatCast</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@floatFromInt</span>(int: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@frameAddress</span>() <span class=\"tok-type\">usize</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@hasDecl</span>(<span class=\"tok-kw\">comptime</span> Container: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">bool</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">struct</span> {\n    nope: <span class=\"tok-type\">i32</span>,\n\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">var</span> blah = <span class=\"tok-str\">\"xxx\"</span>;\n    <span class=\"tok-kw\">const</span> hi = <span class=\"tok-number\">1</span>;\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@hasDecl\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@hasDecl</span>(Foo, <span class=\"tok-str\">\"blah\"</span>));\n\n    <span class=\"tok-comment\">// Even though `hi` is private, @hasDecl returns true because this test is</span>\n    <span class=\"tok-comment\">// in the same file scope as Foo. It would return false if Foo was declared</span>\n    <span class=\"tok-comment\">// in a different file.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@hasDecl</span>(Foo, <span class=\"tok-str\">\"hi\"</span>));\n\n    <span class=\"tok-comment\">// @hasDecl is for declarations; not fields.</span>\n    <span class=\"tok-kw\">try</span> expect(!<span class=\"tok-builtin\">@hasDecl</span>(Foo, <span class=\"tok-str\">\"nope\"</span>));\n    <span class=\"tok-kw\">try</span> expect(!<span class=\"tok-builtin\">@hasDecl</span>(Foo, <span class=\"tok-str\">\"nope1234\"</span>));\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@hasField</span>(<span class=\"tok-kw\">comptime</span> Container: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">bool</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@import</span>(<span class=\"tok-kw\">comptime</span> path: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@inComptime</span>() <span class=\"tok-type\">bool</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intCast</span>(int: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"integer cast panic\"</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">u16</span> = <span class=\"tok-number\">0xabcd</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &a;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@intCast</span>(a);\n    _ = b;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intFromBool</span>(value: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">u1</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intFromEnum</span>(enum_or_tagged_union: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intFromError</span>(err: <span class=\"tok-kw\">anytype</span>) std.meta.Int(.unsigned, <span class=\"tok-builtin\">@bitSizeOf</span>(<span class=\"tok-type\">anyerror</span>))",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intFromFloat</span>(float: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intFromPtr</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-type\">usize</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@max</span>(...) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@memcpy</span>(<span class=\"tok-kw\">noalias</span> dest, <span class=\"tok-kw\">noalias</span> source) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@memset</span>(dest, elem) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@min</span>(...) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@wasmMemorySize</span>(index: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">usize</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@wasmMemoryGrow</span>(index: <span class=\"tok-type\">u32</span>, delta: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">isize</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> native_arch = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>).target.cpu.arch;\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@wasmMemoryGrow\"</span> {\n    <span class=\"tok-kw\">if</span> (native_arch != .wasm32) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.SkipZigTest;\n\n    <span class=\"tok-kw\">const</span> prev = <span class=\"tok-builtin\">@wasmMemorySize</span>(<span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(prev == <span class=\"tok-builtin\">@wasmMemoryGrow</span>(<span class=\"tok-number\">0</span>, <span class=\"tok-number\">1</span>));\n    <span class=\"tok-kw\">try</span> expect(prev + <span class=\"tok-number\">1</span> == <span class=\"tok-builtin\">@wasmMemorySize</span>(<span class=\"tok-number\">0</span>));\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@mod</span>(numerator: T, denominator: T) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@mulWithOverflow</span>(a: <span class=\"tok-kw\">anytype</span>, b: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">struct</span> { <span class=\"tok-builtin\">@TypeOf</span>(a, b), <span class=\"tok-type\">u1</span> }",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@panic</span>(message: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">noreturn</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@popCount</span>(operand: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@prefetch</span>(ptr: <span class=\"tok-kw\">anytype</span>, <span class=\"tok-kw\">comptime</span> options: PrefetchOptions) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@ptrCast</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@ptrFromInt</span>(address: <span class=\"tok-type\">usize</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@rem</span>(numerator: T, denominator: T) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@returnAddress</span>() <span class=\"tok-type\">usize</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@select</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, pred: <span class=\"tok-builtin\">@Vector</span>(len, <span class=\"tok-type\">bool</span>), a: <span class=\"tok-builtin\">@Vector</span>(len, T), b: <span class=\"tok-builtin\">@Vector</span>(len, T)) <span class=\"tok-builtin\">@Vector</span>(len, T)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@setEvalBranchQuota</span>(<span class=\"tok-kw\">comptime</span> new_quota: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"foo\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">var</span> i = <span class=\"tok-number\">0</span>;\n        <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">1001</span>) : (i += <span class=\"tok-number\">1</span>) {}\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"foo\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-builtin\">@setEvalBranchQuota</span>(<span class=\"tok-number\">1001</span>);\n        <span class=\"tok-kw\">var</span> i = <span class=\"tok-number\">0</span>;\n        <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">1001</span>) : (i += <span class=\"tok-number\">1</span>) {}\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@setFloatMode</span>(<span class=\"tok-kw\">comptime</span> mode: FloatMode) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@setRuntimeSafety</span>(<span class=\"tok-kw\">comptime</span> safety_on: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@setRuntimeSafety\"</span> {\n    <span class=\"tok-comment\">// The builtin applies to the scope that it is called in. So here, integer overflow</span>\n    <span class=\"tok-comment\">// will not be caught in ReleaseFast and ReleaseSmall modes:</span>\n    <span class=\"tok-comment\">// var x: u8 = 255;</span>\n    <span class=\"tok-comment\">// x += 1; // Unchecked Illegal Behavior in ReleaseFast/ReleaseSmall modes.</span>\n    {\n        <span class=\"tok-comment\">// However this block has safety enabled, so safety checks happen here,</span>\n        <span class=\"tok-comment\">// even in ReleaseFast and ReleaseSmall modes.</span>\n        <span class=\"tok-builtin\">@setRuntimeSafety</span>(<span class=\"tok-null\">true</span>);\n        <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n        x += <span class=\"tok-number\">1</span>;\n\n        {\n            <span class=\"tok-comment\">// The value can be overridden at any scope. So here integer overflow</span>\n            <span class=\"tok-comment\">// would not be caught in any build mode.</span>\n            <span class=\"tok-builtin\">@setRuntimeSafety</span>(<span class=\"tok-null\">false</span>);\n            <span class=\"tok-comment\">// var x: u8 = 255;</span>\n            <span class=\"tok-comment\">// x += 1; // Unchecked Illegal Behavior in all build modes.</span>\n        }\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@shlExact</span>(value: T, shift_amt: Log2T) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@shlWithOverflow</span>(a: <span class=\"tok-kw\">anytype</span>, shift_amt: Log2T) <span class=\"tok-kw\">struct</span> { <span class=\"tok-builtin\">@TypeOf</span>(a), <span class=\"tok-type\">u1</span> }",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@shrExact</span>(value: T, shift_amt: Log2T) T",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@shuffle</span>(<span class=\"tok-kw\">comptime</span> E: <span class=\"tok-type\">type</span>, a: <span class=\"tok-builtin\">@Vector</span>(a_len, E), b: <span class=\"tok-builtin\">@Vector</span>(b_len, E), <span class=\"tok-kw\">comptime</span> mask: <span class=\"tok-builtin\">@Vector</span>(mask_len, <span class=\"tok-type\">i32</span>)) <span class=\"tok-builtin\">@Vector</span>(mask_len, E)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"vector @shuffle\"</span> {\n    <span class=\"tok-kw\">const</span> a = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">7</span>, <span class=\"tok-type\">u8</span>){ <span class=\"tok-str\">'o'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'r'</span>, <span class=\"tok-str\">'z'</span>, <span class=\"tok-str\">'w'</span> };\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">u8</span>){ <span class=\"tok-str\">'w'</span>, <span class=\"tok-str\">'d'</span>, <span class=\"tok-str\">'!'</span>, <span class=\"tok-str\">'x'</span> };\n\n    <span class=\"tok-comment\">// To shuffle within a single vector, pass undefined as the second argument.</span>\n    <span class=\"tok-comment\">// Notice that we can re-order, duplicate, or omit elements of the input vector</span>\n    <span class=\"tok-kw\">const</span> mask1 = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">5</span>, <span class=\"tok-type\">i32</span>){ <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">1</span>, <span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span> };\n    <span class=\"tok-kw\">const</span> res1: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">5</span>, <span class=\"tok-type\">u8</span>) = <span class=\"tok-builtin\">@shuffle</span>(<span class=\"tok-type\">u8</span>, a, <span class=\"tok-null\">undefined</span>, mask1);\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, &<span class=\"tok-builtin\">@as</span>([<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span>, res1), <span class=\"tok-str\">\"hello\"</span>));\n\n    <span class=\"tok-comment\">// Combining two vectors</span>\n    <span class=\"tok-kw\">const</span> mask2 = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">6</span>, <span class=\"tok-type\">i32</span>){ -<span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">1</span>, -<span class=\"tok-number\">2</span>, -<span class=\"tok-number\">3</span> };\n    <span class=\"tok-kw\">const</span> res2: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">6</span>, <span class=\"tok-type\">u8</span>) = <span class=\"tok-builtin\">@shuffle</span>(<span class=\"tok-type\">u8</span>, a, b, mask2);\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, &<span class=\"tok-builtin\">@as</span>([<span class=\"tok-number\">6</span>]<span class=\"tok-type\">u8</span>, res2), <span class=\"tok-str\">\"world!\"</span>));\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@sizeOf</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">comptime_int</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@splat</span>(scalar: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"vector @splat\"</span> {\n    <span class=\"tok-kw\">const</span> scalar: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">5</span>;\n    <span class=\"tok-kw\">const</span> result: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">u32</span>) = <span class=\"tok-builtin\">@splat</span>(scalar);\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u32</span>, &<span class=\"tok-builtin\">@as</span>([<span class=\"tok-number\">4</span>]<span class=\"tok-type\">u32</span>, result), &[_]<span class=\"tok-type\">u32</span>{ <span class=\"tok-number\">5</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">5</span> }));\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@reduce</span>(<span class=\"tok-kw\">comptime</span> op: std.builtin.ReduceOp, value: <span class=\"tok-kw\">anytype</span>) E",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"vector @reduce\"</span> {\n    <span class=\"tok-kw\">const</span> V = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">const</span> value = V{ <span class=\"tok-number\">1</span>, -<span class=\"tok-number\">1</span>, <span class=\"tok-number\">1</span>, -<span class=\"tok-number\">1</span> };\n    <span class=\"tok-kw\">const</span> result = value > <span class=\"tok-builtin\">@as</span>(V, <span class=\"tok-builtin\">@splat</span>(<span class=\"tok-number\">0</span>));\n    <span class=\"tok-comment\">// result is { true, false, true, false };</span>\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(result) == <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">bool</span>));\n    <span class=\"tok-kw\">const</span> is_all_true = <span class=\"tok-builtin\">@reduce</span>(.And, result);\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(is_all_true) == <span class=\"tok-type\">bool</span>);\n    <span class=\"tok-kw\">try</span> expect(is_all_true == <span class=\"tok-null\">false</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@src</span>() std.builtin.SourceLocation",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@src\"</span> {\n    <span class=\"tok-kw\">try</span> doTheTest();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doTheTest</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> src = <span class=\"tok-builtin\">@src</span>();\n\n    <span class=\"tok-kw\">try</span> expect(src.line == <span class=\"tok-number\">9</span>);\n    <span class=\"tok-kw\">try</span> expect(src.column == <span class=\"tok-number\">17</span>);\n    <span class=\"tok-kw\">try</span> expect(std.mem.endsWith(<span class=\"tok-type\">u8</span>, src.fn_name, <span class=\"tok-str\">\"doTheTest\"</span>));\n    <span class=\"tok-kw\">try</span> expect(std.mem.endsWith(<span class=\"tok-type\">u8</span>, src.file, <span class=\"tok-str\">\"test_src_builtin.zig\"</span>));\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@sqrt</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@sin</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cos</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@tan</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@exp</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@exp2</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@log</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@log2</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@log10</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@abs</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@floor</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@ceil</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@trunc</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@round</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@round\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@round</span>(<span class=\"tok-number\">1.4</span>) == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@round</span>(<span class=\"tok-number\">1.5</span>) == <span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@round</span>(-<span class=\"tok-number\">1.4</span>) == -<span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@round</span>(-<span class=\"tok-number\">2.5</span>) == -<span class=\"tok-number\">3</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@subWithOverflow</span>(a: <span class=\"tok-kw\">anytype</span>, b: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">struct</span> { <span class=\"tok-builtin\">@TypeOf</span>(a, b), <span class=\"tok-type\">u1</span> }",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@tagName</span>(value: <span class=\"tok-kw\">anytype</span>) [:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@This</span>() <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@This()\"</span> {\n    <span class=\"tok-kw\">var</span> items = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n    <span class=\"tok-kw\">const</span> list = List(<span class=\"tok-type\">i32</span>){ .items = items[<span class=\"tok-number\">0</span>..] };\n    <span class=\"tok-kw\">try</span> expect(list.length() == <span class=\"tok-number\">4</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">List</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">struct</span> {\n        <span class=\"tok-kw\">const</span> Self = <span class=\"tok-builtin\">@This</span>();\n\n        items: []T,\n\n        <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">length</span>(self: Self) <span class=\"tok-type\">usize</span> {\n            <span class=\"tok-kw\">return</span> self.items.len;\n        }\n    };\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@trap</span>() <span class=\"tok-type\">noreturn</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@truncate</span>(integer: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"integer truncation\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u16</span> = <span class=\"tok-number\">0xabcd</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@truncate</span>(a);\n    <span class=\"tok-kw\">try</span> expect(b == <span class=\"tok-number\">0xcd</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@Type</span>(<span class=\"tok-kw\">comptime</span> info: std.builtin.Type) <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) std.builtin.Type",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@typeName</span>(T: <span class=\"tok-type\">type</span>) *<span class=\"tok-kw\">const</span> [N:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@TypeOf</span>(...) <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"no runtime side effects\"</span> {\n    <span class=\"tok-kw\">var</span> data: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">const</span> T = <span class=\"tok-builtin\">@TypeOf</span>(foo(<span class=\"tok-type\">i32</span>, &data));\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(T == <span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(data == <span class=\"tok-number\">0</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T) T {\n    ptr.* += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">return</span> ptr.*;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@unionInit</span>(<span class=\"tok-kw\">comptime</span> Union: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> active_field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, init_expr) Union",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@Vector</span>(len: <span class=\"tok-type\">comptime_int</span>, Element: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@volatileCast</span>(value: <span class=\"tok-kw\">anytype</span>) DestType",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@workGroupId</span>(<span class=\"tok-kw\">comptime</span> dimension: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@workGroupSize</span>(<span class=\"tok-kw\">comptime</span> dimension: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@workItemId</span>(<span class=\"tok-kw\">comptime</span> dimension: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Builtin Functions § in Zig 0.14.1",
    "context": "",
    "response": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the pointer operand. It is always valid to cast a pointer between the same address spaces. @addWithOverflow § Performs a + b and returns a tuple with the result and a possible overflow bit. @alignCast § ptr can be *T , ?*T , or []T . Changes the alignment of a pointer. The alignment to use is inferred based on the result type. A pointer alignment safety check is added to the generated code to make sure the pointer is aligned as promised. @alignOf § This function returns the number of bytes that this t",
    "metadata": {
      "version": "0.14.1",
      "topic": "Builtin Functions §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Build Mode §",
    "context": "Zig has four build modes: Debug (default) ReleaseFast ReleaseSafe ReleaseSmall To add standard build options to a build.zig file: build.zig This causes these options to be available: -Doptimize=Debug Optimizations off and safety on (default) -Doptimize=ReleaseSafe Optimizations on and safety on -Doptimize=ReleaseFast Optimizations on and safety off -Doptimize=ReleaseSmall Size optimizations on and safety off Debug § Shell Fast compilation speed Safety checks enabled Slow runtime performance Larg",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">build</span>(b: *std.Build) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> optimize = b.standardOptimizeOption(.{});\n    <span class=\"tok-kw\">const</span> exe = b.addExecutable(.{\n        .name = <span class=\"tok-str\">\"example\"</span>,\n        .root_source_file = b.path(<span class=\"tok-str\">\"example.zig\"</span>),\n        .optimize = optimize,\n    });\n    b.default_step.dependOn(&exe.step);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Build Mode §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Build Mode § in Zig 0.14.1",
    "context": "",
    "response": "Zig has four build modes: Debug (default) ReleaseFast ReleaseSafe ReleaseSmall To add standard build options to a build.zig file: build.zig This causes these options to be available: -Doptimize=Debug Optimizations off and safety on (default) -Doptimize=ReleaseSafe Optimizations on and safety on -Doptimize=ReleaseFast Optimizations on and safety off -Doptimize=ReleaseSmall Size optimizations on and safety off Debug § Shell Fast compilation speed Safety checks enabled Slow runtime performance Large binary size No reproducible build requirement ReleaseFast § Shell Fast runtime performance Safety checks disabled Slow compilation speed Large binary size Reproducible build ReleaseSafe § Shell Medium runtime performance Safety checks enabled Slow compilation speed Large binary size Reproducible build ReleaseSmall § Shell Medium runtime performance Safety checks disabled Slow compilation speed Small binary size Reproducible build See also: Compile Variables Zig Build System Illegal Behavior",
    "metadata": {
      "version": "0.14.1",
      "topic": "Build Mode §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Single Threaded Builds § in Zig 0.14.1",
    "context": "",
    "response": "Zig has a compile option -fsingle-threaded which has the following effects: All Thread Local Variables are treated as regular Container Level Variables . The overhead of Async Functions becomes equivalent to function call overhead. The @import ( &quot;builtin&quot; ).single_threaded becomes true and therefore various userland APIs which read this variable become more efficient. For example std.Mutex becomes an empty data structure and all of its functions become no-ops.",
    "metadata": {
      "version": "0.14.1",
      "topic": "Single Threaded Builds §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"safety check\"</span> {\n    <span class=\"tok-kw\">unreachable</span>;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    assert(<span class=\"tok-null\">false</span>);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">assert</span>(ok: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (!ok) <span class=\"tok-kw\">unreachable</span>; <span class=\"tok-comment\">// assertion failure</span>\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    std.debug.assert(<span class=\"tok-null\">false</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> array: [<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>.*;\n    <span class=\"tok-kw\">const</span> garbage = array[<span class=\"tok-number\">5</span>];\n    _ = garbage;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> x = foo(<span class=\"tok-str\">\"hello\"</span>);\n    _ = x;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(x: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">return</span> x[<span class=\"tok-number\">5</span>];\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> value: <span class=\"tok-type\">i32</span> = -<span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> unsigned: <span class=\"tok-type\">u32</span> = <span class=\"tok-builtin\">@intCast</span>(value);\n    _ = unsigned;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> value: <span class=\"tok-type\">i32</span> = -<span class=\"tok-number\">1</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &value;\n    <span class=\"tok-kw\">const</span> unsigned: <span class=\"tok-type\">u32</span> = <span class=\"tok-builtin\">@intCast</span>(value);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{unsigned});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> spartan_count: <span class=\"tok-type\">u16</span> = <span class=\"tok-number\">300</span>;\n    <span class=\"tok-kw\">const</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@intCast</span>(spartan_count);\n    _ = byte;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> spartan_count: <span class=\"tok-type\">u16</span> = <span class=\"tok-number\">300</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &spartan_count;\n    <span class=\"tok-kw\">const</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@intCast</span>(spartan_count);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{byte});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">var</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n    byte += <span class=\"tok-number\">1</span>;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n    byte += <span class=\"tok-number\">1</span>;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{byte});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> math = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).math;\n<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n\n    byte = <span class=\"tok-kw\">if</span> (math.add(<span class=\"tok-type\">u8</span>, byte, <span class=\"tok-number\">1</span>)) |result| result <span class=\"tok-kw\">else</span> |err| {\n        print(<span class=\"tok-str\">\"unable to add one: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@errorName</span>(err)});\n        <span class=\"tok-kw\">return</span> err;\n    };\n\n    print(<span class=\"tok-str\">\"result: {}\\n\"</span>, .{byte});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n\n    <span class=\"tok-kw\">const</span> ov = <span class=\"tok-builtin\">@addWithOverflow</span>(byte, <span class=\"tok-number\">10</span>);\n    <span class=\"tok-kw\">if</span> (ov[<span class=\"tok-number\">1</span>] != <span class=\"tok-number\">0</span>) {\n        print(<span class=\"tok-str\">\"overflowed result: {}\\n\"</span>, .{ov[<span class=\"tok-number\">0</span>]});\n    } <span class=\"tok-kw\">else</span> {\n        print(<span class=\"tok-str\">\"result: {}\\n\"</span>, .{ov[<span class=\"tok-number\">0</span>]});\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> minInt = std.math.minInt;\n<span class=\"tok-kw\">const</span> maxInt = std.math.maxInt;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"wraparound addition and subtraction\"</span> {\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">i32</span> = maxInt(<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">const</span> min_val = x +% <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(min_val == minInt(<span class=\"tok-type\">i32</span>));\n    <span class=\"tok-kw\">const</span> max_val = min_val -% <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(max_val == maxInt(<span class=\"tok-type\">i32</span>));\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> x = <span class=\"tok-builtin\">@shlExact</span>(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">0b01010101</span>), <span class=\"tok-number\">2</span>);\n    _ = x;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">0b01010101</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &x;\n    <span class=\"tok-kw\">const</span> y = <span class=\"tok-builtin\">@shlExact</span>(x, <span class=\"tok-number\">2</span>);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{y});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> x = <span class=\"tok-builtin\">@shrExact</span>(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">0b10101010</span>), <span class=\"tok-number\">2</span>);\n    _ = x;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">0b10101010</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &x;\n    <span class=\"tok-kw\">const</span> y = <span class=\"tok-builtin\">@shrExact</span>(x, <span class=\"tok-number\">2</span>);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{y});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">const</span> c = a / b;\n    _ = c;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">var</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    _ = .{ &a, &b };\n    <span class=\"tok-kw\">const</span> c = a / b;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{c});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">const</span> c = a % b;\n    _ = c;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">var</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    _ = .{ &a, &b };\n    <span class=\"tok-kw\">const</span> c = a % b;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{c});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@divExact</span>(a, b);\n    _ = c;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">var</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">3</span>;\n    _ = .{ &a, &b };\n    <span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@divExact</span>(a, b);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{c});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> optional_number: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n    <span class=\"tok-kw\">const</span> number = optional_number.?;\n    _ = number;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> optional_number: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n    _ = &optional_number;\n    <span class=\"tok-kw\">const</span> number = optional_number.?;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{number});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> optional_number: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-kw\">if</span> (optional_number) |number| {\n        print(<span class=\"tok-str\">\"got number: {}\\n\"</span>, .{number});\n    } <span class=\"tok-kw\">else</span> {\n        print(<span class=\"tok-str\">\"it's null\\n\"</span>, .{});\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> number = getNumberOrFail() <span class=\"tok-kw\">catch</span> <span class=\"tok-kw\">unreachable</span>;\n    _ = number;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">getNumberOrFail</span>() !<span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.UnableToReturnNumber;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> number = getNumberOrFail() <span class=\"tok-kw\">catch</span> <span class=\"tok-kw\">unreachable</span>;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{number});\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">getNumberOrFail</span>() !<span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.UnableToReturnNumber;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> result = getNumberOrFail();\n\n    <span class=\"tok-kw\">if</span> (result) |number| {\n        print(<span class=\"tok-str\">\"got number: {}\\n\"</span>, .{number});\n    } <span class=\"tok-kw\">else</span> |err| {\n        print(<span class=\"tok-str\">\"got error: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@errorName</span>(err)});\n    }\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">getNumberOrFail</span>() !<span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.UnableToReturnNumber;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> err = <span class=\"tok-kw\">error</span>.AnError;\n    <span class=\"tok-kw\">const</span> number = <span class=\"tok-builtin\">@intFromError</span>(err) + <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">const</span> invalid_err = <span class=\"tok-builtin\">@errorFromInt</span>(number);\n    _ = invalid_err;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> err = <span class=\"tok-kw\">error</span>.AnError;\n    <span class=\"tok-kw\">var</span> number = <span class=\"tok-builtin\">@intFromError</span>(err) + <span class=\"tok-number\">500</span>;\n    _ = &number;\n    <span class=\"tok-kw\">const</span> invalid_err = <span class=\"tok-builtin\">@errorFromInt</span>(number);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{invalid_err});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">enum</span> {\n    a,\n    b,\n    c,\n};\n<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u2</span> = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">const</span> b: Foo = <span class=\"tok-builtin\">@enumFromInt</span>(a);\n    _ = b;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">enum</span> {\n    a,\n    b,\n    c,\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">u2</span> = <span class=\"tok-number\">3</span>;\n    _ = &a;\n    <span class=\"tok-kw\">const</span> b: Foo = <span class=\"tok-builtin\">@enumFromInt</span>(a);\n    std.debug.print(<span class=\"tok-str\">\"value: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@tagName</span>(b)});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> Set1 = <span class=\"tok-kw\">error</span>{\n    A,\n    B,\n};\n<span class=\"tok-kw\">const</span> Set2 = <span class=\"tok-kw\">error</span>{\n    A,\n    C,\n};\n<span class=\"tok-kw\">comptime</span> {\n    _ = <span class=\"tok-builtin\">@as</span>(Set2, <span class=\"tok-builtin\">@errorCast</span>(Set1.B));\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Set1 = <span class=\"tok-kw\">error</span>{\n    A,\n    B,\n};\n<span class=\"tok-kw\">const</span> Set2 = <span class=\"tok-kw\">error</span>{\n    A,\n    C,\n};\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    foo(Set1.B);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(set1: Set1) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> x: Set2 = <span class=\"tok-builtin\">@errorCast</span>(set1);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{x});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">1</span>) <span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0x1</span>);\n    <span class=\"tok-kw\">const</span> aligned: *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@alignCast</span>(ptr);\n    _ = aligned;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> array <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) = [_]<span class=\"tok-type\">u32</span>{ <span class=\"tok-number\">0x11111111</span>, <span class=\"tok-number\">0x11111111</span> };\n    <span class=\"tok-kw\">const</span> bytes = mem.sliceAsBytes(array[<span class=\"tok-number\">0</span>..]);\n    <span class=\"tok-kw\">if</span> (foo(bytes) != <span class=\"tok-number\">0x11111111</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.Wrong;\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(bytes: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">const</span> slice4 = bytes[<span class=\"tok-number\">1</span>..<span class=\"tok-number\">5</span>];\n    <span class=\"tok-kw\">const</span> int_slice = mem.bytesAsSlice(<span class=\"tok-type\">u32</span>, <span class=\"tok-builtin\">@as</span>([]<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">u8</span>, <span class=\"tok-builtin\">@alignCast</span>(slice4)));\n    <span class=\"tok-kw\">return</span> int_slice[<span class=\"tok-number\">0</span>];\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">var</span> f = Foo{ .int = <span class=\"tok-number\">42</span> };\n    f.float = <span class=\"tok-number\">12.34</span>;\n}\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">union</span> {\n    float: <span class=\"tok-type\">f32</span>,\n    int: <span class=\"tok-type\">u32</span>,\n};",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">union</span> {\n    float: <span class=\"tok-type\">f32</span>,\n    int: <span class=\"tok-type\">u32</span>,\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> f = Foo{ .int = <span class=\"tok-number\">42</span> };\n    bar(&f);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>(f: *Foo) <span class=\"tok-type\">void</span> {\n    f.float = <span class=\"tok-number\">12.34</span>;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{f.float});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">union</span> {\n    float: <span class=\"tok-type\">f32</span>,\n    int: <span class=\"tok-type\">u32</span>,\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> f = Foo{ .int = <span class=\"tok-number\">42</span> };\n    bar(&f);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>(f: *Foo) <span class=\"tok-type\">void</span> {\n    f.* = Foo{ .float = <span class=\"tok-number\">12.34</span> };\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{f.float});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">union</span> {\n    float: <span class=\"tok-type\">f32</span>,\n    int: <span class=\"tok-type\">u32</span>,\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> f = Foo{ .int = <span class=\"tok-number\">42</span> };\n    f = Foo{ .float = <span class=\"tok-null\">undefined</span> };\n    bar(&f);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{f.float});\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>(f: *Foo) <span class=\"tok-type\">void</span> {\n    f.float = <span class=\"tok-number\">12.34</span>;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> float: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">4294967296</span>;\n    <span class=\"tok-kw\">const</span> int: <span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@intFromFloat</span>(float);\n    _ = int;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> float: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">4294967296</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &float;\n    <span class=\"tok-kw\">const</span> int: <span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@intFromFloat</span>(float);\n    _ = int;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> opt_ptr: ?*<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrCast</span>(opt_ptr);\n    _ = ptr;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Illegal Behavior §",
    "context": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> opt_ptr: ?*<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n    _ = &opt_ptr;\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrCast</span>(opt_ptr);\n    _ = ptr;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Illegal Behavior § in Zig 0.14.1",
    "context": "",
    "response": "Many operations in Zig trigger what is known as \"Illegal Behavior\" (IB). If Illegal Behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught at compile-time, it falls into one of two categories. Some Illegal Behavior is safety-checked : this means that the compiler will insert \"safety checks\" anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it is, the safety check \"fails\", which triggers a panic. All other Illegal Behavior is unchecked , meaning the compiler is unable to insert safety checks for it. If Unchecked Illegal Behavior is invoked at runtime, anything can happen: usually that will be some kind of crash, but the optimizer is free to make Unchecked Illegal Behavior do anything, such as calling arbitrary functions or clobbering arbitrary data. This is similar to the concept of \"undefined behavior\" in some other languages. Note that Unchecked Illega",
    "metadata": {
      "version": "0.14.1",
      "topic": "Illegal Behavior §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Memory §",
    "context": "The Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question: Where are the bytes? Like Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - malloc , realloc , ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> Allocator = std.mem.Allocator;\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"using an allocator\"</span> {\n    <span class=\"tok-kw\">var</span> buffer: [<span class=\"tok-number\">100</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">var</span> fba = std.heap.FixedBufferAllocator.init(&buffer);\n    <span class=\"tok-kw\">const</span> allocator = fba.allocator();\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">try</span> concat(allocator, <span class=\"tok-str\">\"foo\"</span>, <span class=\"tok-str\">\"bar\"</span>);\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-str\">\"foobar\"</span>, result));\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">concat</span>(allocator: Allocator, a: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, b: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) ![]<span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">try</span> allocator.alloc(<span class=\"tok-type\">u8</span>, a.len + b.len);\n    <span class=\"tok-builtin\">@memcpy</span>(result[<span class=\"tok-number\">0</span>..a.len], a);\n    <span class=\"tok-builtin\">@memcpy</span>(result[a.len..], b);\n    <span class=\"tok-kw\">return</span> result;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Memory §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Memory §",
    "context": "The Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question: Where are the bytes? Like Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - malloc , realloc , ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    <span class=\"tok-kw\">defer</span> arena.deinit();\n\n    <span class=\"tok-kw\">const</span> allocator = arena.allocator();\n\n    <span class=\"tok-kw\">const</span> ptr = <span class=\"tok-kw\">try</span> allocator.create(<span class=\"tok-type\">i32</span>);\n    std.debug.print(<span class=\"tok-str\">\"ptr={*}\\n\"</span>, .{ptr});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Memory §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Memory §",
    "context": "The Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question: Where are the bytes? Like Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - malloc , realloc , ",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(s: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    _ = s;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"string literal to mutable slice\"</span> {\n    foo(<span class=\"tok-str\">\"hello\"</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Memory §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Memory §",
    "context": "The Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question: Where are the bytes? Like Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - malloc , realloc , ",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(s: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    _ = s;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"string literal to constant slice\"</span> {\n    foo(<span class=\"tok-str\">\"hello\"</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Memory §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Memory § in Zig 0.14.1",
    "context": "",
    "response": "The Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question: Where are the bytes? Like Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - malloc , realloc , and free . When linking against libc, Zig exposes this allocator with std.heap.c_allocator . However, by convention, there is no default allocator in Zig. Instead, functions which need to allocate accept an Allocator parameter. Likewise, data structures such as std.ArrayList accept an Allocator parameter in their initialization functions: test_allocator.zig Shell In the above example, 100 bytes of stack memory are used to initialize a FixedBufferAllocator , which is then passed to a function. As",
    "metadata": {
      "version": "0.14.1",
      "topic": "Memory §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Compile Variables §",
    "context": "Compile variables are accessible by importing the &quot;builtin&quot; package, which the compiler makes available to every Zig source file. It contains compile-time constants such as the current target, endianness, and release mode. compile_variables.zig Example of what is imported with @import ( &quot;builtin&quot; ) : @import(\"builtin\") See also: Build Mode",
    "response": "<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> separator = <span class=\"tok-kw\">if</span> (builtin.os.tag == .windows) <span class=\"tok-str\">'\\\\'</span> <span class=\"tok-kw\">else</span> <span class=\"tok-str\">'/'</span>;",
    "metadata": {
      "version": "0.14.1",
      "topic": "Compile Variables §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Compile Variables §",
    "context": "Compile variables are accessible by importing the &quot;builtin&quot; package, which the compiler makes available to every Zig source file. It contains compile-time constants such as the current target, endianness, and release mode. compile_variables.zig Example of what is imported with @import ( &quot;builtin&quot; ) : @import(\"builtin\") See also: Build Mode",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-comment\">/// Zig version. When writing code that supports multiple versions of Zig, prefer</span>\n<span class=\"tok-comment\">/// feature detection (i.e. with `@hasDecl` or `@hasField`) over version checks.</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> zig_version = std.SemanticVersion.parse(zig_version_string) <span class=\"tok-kw\">catch</span> <span class=\"tok-kw\">unreachable</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> zig_version_string = <span class=\"tok-str\">\"0.14.1\"</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> zig_backend = std.builtin.CompilerBackend.stage2_llvm;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> output_mode: std.builtin.OutputMode = .Exe;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> link_mode: std.builtin.LinkMode = .static;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> unwind_tables: std.builtin.UnwindTables = .@\"async\";\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> is_test = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> single_threaded = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> abi: std.Target.Abi = .gnu;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> cpu: std.Target.Cpu = .{\n    .arch = .x86_64,\n    .model = &std.Target.x86.cpu.znver4,\n    .features = std.Target.x86.featureSet(&.{\n        .@\"64bit\",\n        .adx,\n        .aes,\n        .allow_light_256_bit,\n        .avx,\n        .avx2,\n        .avx512bf16,\n        .avx512bitalg,\n        .avx512bw,\n        .avx512cd,\n        .avx512dq,\n        .avx512f,\n        .avx512ifma,\n        .avx512vbmi,\n        .avx512vbmi2,\n        .avx512vl,\n        .avx512vnni,\n        .avx512vpopcntdq,\n        .bmi,\n        .bmi2,\n        .branchfusion,\n        .clflushopt,\n        .clwb,\n        .clzero,\n        .cmov,\n        .crc32,\n        .cx16,\n        .cx8,\n        .evex512,\n        .f16c,\n        .fast_15bytenop,\n        .fast_bextr,\n        .fast_dpwssd,\n        .fast_imm16,\n        .fast_lzcnt,\n        .fast_movbe,\n        .fast_scalar_fsqrt,\n        .fast_scalar_shift_masks,\n        .fast_variable_perlane_shuffle,\n        .fast_vector_fsqrt,\n        .fma,\n        .fsgsbase,\n        .fsrm,\n        .fxsr,\n        .gfni,\n        .idivq_to_divl,\n        .invpcid,\n        .lzcnt,\n        .macrofusion,\n        .mmx,\n        .movbe,\n        .mwaitx,\n        .nopl,\n        .pclmul,\n        .pku,\n        .popcnt,\n        .prfchw,\n        .rdpid,\n        .rdpru,\n        .rdrnd,\n        .rdseed,\n        .sahf,\n        .sbb_dep_breaking,\n        .sha,\n        .shstk,\n        .slow_shld,\n        .smap,\n        .smep,\n        .sse,\n        .sse2,\n        .sse3,\n        .sse4_1,\n        .sse4_2,\n        .sse4a,\n        .ssse3,\n        .vaes,\n        .vpclmulqdq,\n        .vzeroupper,\n        .wbnoinvd,\n        .x87,\n        .xsave,\n        .xsavec,\n        .xsaveopt,\n        .xsaves,\n    }),\n};\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> os: std.Target.Os = .{\n    .tag = .linux,\n    .version_range = .{ .linux = .{\n        .range = .{\n            .min = .{\n                .major = <span class=\"tok-number\">6</span>,\n                .minor = <span class=\"tok-number\">14</span>,\n                .patch = <span class=\"tok-number\">5</span>,\n            },\n            .max = .{\n                .major = <span class=\"tok-number\">6</span>,\n                .minor = <span class=\"tok-number\">14</span>,\n                .patch = <span class=\"tok-number\">5</span>,\n            },\n        },\n        .glibc = .{\n            .major = <span class=\"tok-number\">2</span>,\n            .minor = <span class=\"tok-number\">39</span>,\n            .patch = <span class=\"tok-number\">0</span>,\n        },\n        .android = <span class=\"tok-number\">14</span>,\n    }},\n};\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> target: std.Target = .{\n    .cpu = cpu,\n    .os = os,\n    .abi = abi,\n    .ofmt = object_format,\n    .dynamic_linker = .init(<span class=\"tok-str\">\"/nix/store/p9kdj55g5l39nbrxpjyz5wc1m0s7rzsx-glibc-2.40-66/lib/ld-linux-x86-64.so.2\"</span>),\n};\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> object_format: std.Target.ObjectFormat = .elf;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> mode: std.builtin.OptimizeMode = .Debug;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> link_libc = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> link_libcpp = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> have_error_return_tracing = <span class=\"tok-null\">true</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> valgrind_support = <span class=\"tok-null\">true</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> sanitize_thread = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> fuzz = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> position_independent_code = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> position_independent_executable = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> strip_debug_info = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> code_model: std.builtin.CodeModel = .default;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> omit_frame_pointer = <span class=\"tok-null\">false</span>;",
    "metadata": {
      "version": "0.14.1",
      "topic": "Compile Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Compile Variables § in Zig 0.14.1",
    "context": "",
    "response": "Compile variables are accessible by importing the &quot;builtin&quot; package, which the compiler makes available to every Zig source file. It contains compile-time constants such as the current target, endianness, and release mode. compile_variables.zig Example of what is imported with @import ( &quot;builtin&quot; ) : @import(\"builtin\") See also: Build Mode",
    "metadata": {
      "version": "0.14.1",
      "topic": "Compile Variables §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Compilation Model §",
    "context": "A Zig compilation is separated into modules . Each module is a collection of Zig source files, one of which is the module's root source file . Each module can depend on any number of other modules, forming a directed graph (dependency loops between modules are allowed). If module A depends on module B, then any Zig source file in module A can import the root source file of module B using @import with the module's name. In essence, a module acts as an alias to import a Zig source file (which migh",
    "response": "<span class=\"tok-comment\">//! Because this file contains fields, it is a type which is intended to be instantiated, and so</span>\n<span class=\"tok-comment\">//! is named in TitleCase instead of snake_case by convention.</span>\n\nfoo: <span class=\"tok-type\">u32</span>,\nbar: <span class=\"tok-type\">u64</span>,\n\n<span class=\"tok-comment\">/// `@This()` can be used to refer to this struct type. In files with fields, it is quite common to</span>\n<span class=\"tok-comment\">/// name the type here, so it can be easily referenced by other declarations in this file.</span>\n<span class=\"tok-kw\">const</span> TopLevelFields = <span class=\"tok-builtin\">@This</span>();\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">init</span>(val: <span class=\"tok-type\">u32</span>) TopLevelFields {\n    <span class=\"tok-kw\">return</span> .{\n        .foo = val,\n        .bar = val * <span class=\"tok-number\">10</span>,\n    };\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Compilation Model §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Compilation Model §",
    "context": "A Zig compilation is separated into modules . Each module is a collection of Zig source files, one of which is the module's root source file . Each module can depend on any number of other modules, forming a directed graph (dependency loops between modules are allowed). If module A depends on module B, then any Zig source file in module A can import the root source file of module B using @import with the module's name. In essence, a module acts as an alias to import a Zig source file (which migh",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-comment\">// This will ensure that the file 'api.zig' is always discovered (as long as this file is discovered).</span>\n    <span class=\"tok-comment\">// It is useful if 'api.zig' contains important exported declarations.</span>\n    _ = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"api.zig\"</span>);\n\n    <span class=\"tok-comment\">// We could also have a file which contains declarations we only want to export depending on a comptime</span>\n    <span class=\"tok-comment\">// condition. In that case, we can use an `if` statement here:</span>\n    <span class=\"tok-kw\">if</span> (builtin.os.tag == .windows) {\n        _ = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"windows_api.zig\"</span>);\n    }\n}\n\n<span class=\"tok-kw\">test</span> {\n    <span class=\"tok-comment\">// This will ensure that the file 'tests.zig' is always discovered (as long as this file is discovered),</span>\n    <span class=\"tok-comment\">// if this compilation is a test. It is useful if 'tests.zig' contains tests we want to ensure are run.</span>\n    _ = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"tests.zig\"</span>);\n\n    <span class=\"tok-comment\">// We could also have a file which contains tests we only want to run depending on a comptime condition.</span>\n    <span class=\"tok-comment\">// In that case, we can use an `if` statement here:</span>\n    <span class=\"tok-kw\">if</span> (builtin.os.tag == .windows) {\n        _ = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"windows_tests.zig\"</span>);\n    }\n}\n\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);",
    "metadata": {
      "version": "0.14.1",
      "topic": "Compilation Model §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Compilation Model §",
    "context": "A Zig compilation is separated into modules . Each module is a collection of Zig source files, one of which is the module's root source file . Each module can depend on any number of other modules, forming a directed graph (dependency loops between modules are allowed). If module A depends on module B, then any Zig source file in module A can import the root source file of module B using @import with the module's name. In essence, a module acts as an alias to import a Zig source file (which migh",
    "response": "<span class=\"tok-comment\">/// `std.start` imports this file using `@import(\"root\")`, and uses this declaration as the program's</span>\n<span class=\"tok-comment\">/// user-provided entry point. It can return any of the following types:</span>\n<span class=\"tok-comment\">/// * `void`</span>\n<span class=\"tok-comment\">/// * `E!void`, for any error set `E`</span>\n<span class=\"tok-comment\">/// * `u8`</span>\n<span class=\"tok-comment\">/// * `E!u8`, for any error set `E`</span>\n<span class=\"tok-comment\">/// Returning a `void` value from this function will exit with code 0.</span>\n<span class=\"tok-comment\">/// Returning a `u8` value from this function will exit with the given status code.</span>\n<span class=\"tok-comment\">/// Returning an error value from this function will print an Error Return Trace and exit with code 1.</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    std.debug.print(<span class=\"tok-str\">\"Hello, World!\\n\"</span>, .{});\n}\n\n<span class=\"tok-comment\">// If uncommented, this declaration would suppress the usual std.start logic, causing</span>\n<span class=\"tok-comment\">// the `main` declaration above to be ignored.</span>\n<span class=\"tok-comment\">//pub const _start = {};</span>\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);",
    "metadata": {
      "version": "0.14.1",
      "topic": "Compilation Model §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Compilation Model §",
    "context": "A Zig compilation is separated into modules . Each module is a collection of Zig source files, one of which is the module's root source file . Each module can depend on any number of other modules, forming a directed graph (dependency loops between modules are allowed). If module A depends on module B, then any Zig source file in module A can import the root source file of module B using @import with the module's name. In essence, a module acts as an alias to import a Zig source file (which migh",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>(argc: <span class=\"tok-type\">c_int</span>, argv: [*]<span class=\"tok-kw\">const</span> [*:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">c_int</span> {\n    <span class=\"tok-kw\">const</span> args = argv[<span class=\"tok-number\">0</span>..<span class=\"tok-builtin\">@intCast</span>(argc)];\n    std.debug.print(<span class=\"tok-str\">\"Hello! argv[0] is '{s}'\\n\"</span>, .{args[<span class=\"tok-number\">0</span>]});\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">0</span>;\n}\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);",
    "metadata": {
      "version": "0.14.1",
      "topic": "Compilation Model §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Compilation Model §",
    "context": "A Zig compilation is separated into modules . Each module is a collection of Zig source files, one of which is the module's root source file . Each module can depend on any number of other modules, forming a directed graph (dependency loops between modules are allowed). If module A depends on module B, then any Zig source file in module A can import the root source file of module B using @import with the module's name. In essence, a module acts as an alias to import a Zig source file (which migh",
    "response": "<span class=\"tok-comment\">/// The presence of this declaration allows the program to override certain behaviors of the standard library.</span>\n<span class=\"tok-comment\">/// For a full list of available options, see the documentation for `std.Options`.</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> std_options: std.Options = .{\n    <span class=\"tok-comment\">// By default, in safe build modes, the standard library will attach a segfault handler to the program to</span>\n    <span class=\"tok-comment\">// print a helpful stack trace if a segmentation fault occurs. Here, we can disable this, or even enable</span>\n    <span class=\"tok-comment\">// it in unsafe build modes.</span>\n    .enable_segfault_handler = <span class=\"tok-null\">true</span>,\n    <span class=\"tok-comment\">// This is the logging function used by `std.log`.</span>\n    .logFn = myLogFn,\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">myLogFn</span>(\n    <span class=\"tok-kw\">comptime</span> level: std.log.Level,\n    <span class=\"tok-kw\">comptime</span> scope: <span class=\"tok-builtin\">@Type</span>(.enum_literal),\n    <span class=\"tok-kw\">comptime</span> format: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>,\n    args: <span class=\"tok-kw\">anytype</span>,\n) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-comment\">// We could do anything we want here!</span>\n    <span class=\"tok-comment\">// ...but actually, let's just call the default implementation.</span>\n    std.log.defaultLog(level, scope, format, args);\n}\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);",
    "metadata": {
      "version": "0.14.1",
      "topic": "Compilation Model §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Compilation Model §",
    "context": "A Zig compilation is separated into modules . Each module is a collection of Zig source files, one of which is the module's root source file . Each module can depend on any number of other modules, forming a directed graph (dependency loops between modules are allowed). If module A depends on module B, then any Zig source file in module A can import the root source file of module B using @import with the module's name. In essence, a module acts as an alias to import a Zig source file (which migh",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-builtin\">@setRuntimeSafety</span>(<span class=\"tok-null\">true</span>);\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n    <span class=\"tok-comment\">// Let's overflow this integer!</span>\n    x += <span class=\"tok-number\">1</span>;\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> panic = std.debug.FullPanic(myPanic);\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">myPanic</span>(msg: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, first_trace_addr: ?<span class=\"tok-type\">usize</span>) <span class=\"tok-type\">noreturn</span> {\n    _ = first_trace_addr;\n    std.debug.print(<span class=\"tok-str\">\"Panic! {s}\\n\"</span>, .{msg});\n    std.process.exit(<span class=\"tok-number\">1</span>);\n}\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);",
    "metadata": {
      "version": "0.14.1",
      "topic": "Compilation Model §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Compilation Model § in Zig 0.14.1",
    "context": "",
    "response": "A Zig compilation is separated into modules . Each module is a collection of Zig source files, one of which is the module's root source file . Each module can depend on any number of other modules, forming a directed graph (dependency loops between modules are allowed). If module A depends on module B, then any Zig source file in module A can import the root source file of module B using @import with the module's name. In essence, a module acts as an alias to import a Zig source file (which might exist in a completely separate part of the filesystem). A simple Zig program compiled with zig build-exe has two key modules: the one containing your code, known as the \"main\" or \"root\" module, and the standard library. Your module depends on the standard library module under the name \"std\", which is what allows you to write @import ( &quot;std&quot; ) ! In fact, every single module in a Zig compilation &mdash; including the standard library itself &mdash; implicitly depends on the standard li",
    "metadata": {
      "version": "0.14.1",
      "topic": "Compilation Model §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Zig Build System § in Zig 0.14.1",
    "context": "",
    "response": "The Zig Build System provides a cross-platform, dependency-free way to declare the logic required to build a project. With this system, the logic to build a project is written in a build.zig file, using the Zig Build System API to declare and configure build artifacts and other tasks. Some examples of tasks the build system can help with: Performing tasks in parallel and caching the results. Depending on other projects. Providing a package for other projects to depend on. Creating build artifacts by executing the Zig compiler. This includes building Zig source code as well as C and C++ source code. Capturing user-configured options and using those options to configure the build. Surfacing build configuration as comptime values by providing a file that can be imported by Zig code. Caching build artifacts to avoid unnecessarily repeating steps. Executing build artifacts or system-installed tools. Running tests and verifying the output of executing a build artifact matches the expected va",
    "metadata": {
      "version": "0.14.1",
      "topic": "Zig Build System §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@cImport</span>({\n    <span class=\"tok-comment\">// See https://github.com/ziglang/zig/issues/515</span>\n    <span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"_NO_CRT_STDIO_INLINE\"</span>, <span class=\"tok-str\">\"1\"</span>);\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"stdio.h\"</span>);\n});\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    _ = c.printf(<span class=\"tok-str\">\"hello\\n\"</span>);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n\n<span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@cImport</span>({\n    <span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"NDEBUG\"</span>, builtin.mode == .ReleaseFast);\n    <span class=\"tok-kw\">if</span> (something) {\n        <span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"_GNU_SOURCE\"</span>, {});\n    }\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"stdlib.h\"</span>);\n    <span class=\"tok-kw\">if</span> (something) {\n        <span class=\"tok-builtin\">@cUndef</span>(<span class=\"tok-str\">\"_GNU_SOURCE\"</span>);\n    }\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"soundio.h\"</span>);\n});",
    "metadata": {
      "version": "0.14.1",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "long FOO = __LONG_MAX__;",
    "metadata": {
      "version": "0.14.1",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "enum FOO { BAR };\nint do_something(enum FOO foo);",
    "metadata": {
      "version": "0.14.1",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@cImport</span>({\n    <span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"_NO_CRT_STDIO_INLINE\"</span>, <span class=\"tok-str\">\"1\"</span>);\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"stdio.h\"</span>);\n});\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    _ = c;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "#define MAKELOCAL(NAME, INIT) int NAME = INIT\nint foo(void) {\n   MAKELOCAL(a, 1);\n   MAKELOCAL(b, 2);\n   return a + b;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">c_int</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">c_int</span> = <span class=\"tok-number\">1</span>;\n    _ = &a;\n    <span class=\"tok-kw\">var</span> b: <span class=\"tok-type\">c_int</span> = <span class=\"tok-number\">2</span>;\n    _ = &b;\n    <span class=\"tok-kw\">return</span> a + b;\n}\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> MAKELOCAL = <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"unable to translate C expr: unexpected token .Equal\"</span>); <span class=\"tok-comment\">// macro.c:1:9</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> testing = std.testing;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"c\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">printf</span>(format: [*:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, ...) <span class=\"tok-type\">c_int</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"variadic function\"</span> {\n    <span class=\"tok-kw\">try</span> testing.expect(printf(<span class=\"tok-str\">\"Hello, world!\\n\"</span>) == <span class=\"tok-number\">14</span>);\n    <span class=\"tok-kw\">try</span> testing.expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(printf)).@\"fn\".is_var_args);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> testing = std.testing;\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(count: <span class=\"tok-type\">c_int</span>, ...) <span class=\"tok-kw\">callconv</span>(.C) <span class=\"tok-type\">c_int</span> {\n    <span class=\"tok-kw\">var</span> ap = <span class=\"tok-builtin\">@cVaStart</span>();\n    <span class=\"tok-kw\">defer</span> <span class=\"tok-builtin\">@cVaEnd</span>(&ap);\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">c_int</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">while</span> (i < count) : (i += <span class=\"tok-number\">1</span>) {\n        sum += <span class=\"tok-builtin\">@cVaArg</span>(&ap, <span class=\"tok-type\">c_int</span>);\n    }\n    <span class=\"tok-kw\">return</span> sum;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"defining a variadic function\"</span> {\n    <span class=\"tok-kw\">if</span> (builtin.cpu.arch == .aarch64 <span class=\"tok-kw\">and</span> builtin.os.tag != .macos) {\n        <span class=\"tok-comment\">// https://github.com/ziglang/zig/issues/14096</span>\n        <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.SkipZigTest;\n    }\n    <span class=\"tok-kw\">if</span> (builtin.cpu.arch == .x86_64 <span class=\"tok-kw\">and</span> builtin.os.tag == .windows) {\n        <span class=\"tok-comment\">// https://github.com/ziglang/zig/issues/16961</span>\n        <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.SkipZigTest;\n    }\n\n    <span class=\"tok-kw\">try</span> std.testing.expectEqual(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">0</span>), add(<span class=\"tok-number\">0</span>));\n    <span class=\"tok-kw\">try</span> std.testing.expectEqual(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">1</span>), add(<span class=\"tok-number\">1</span>, <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">1</span>)));\n    <span class=\"tok-kw\">try</span> std.testing.expectEqual(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">3</span>), add(<span class=\"tok-number\">2</span>, <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">1</span>), <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">2</span>)));\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> a + b;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "// This header is generated by zig from mathtest.zig\n#include \"mathtest.h\"\n#include <stdio.h>\n\nint main(int argc, char **argv) {\n    int32_t result = add(42, 1337);\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">build</span>(b: *std.Build) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> lib = b.addSharedLibrary(.{\n        .name = <span class=\"tok-str\">\"mathtest\"</span>,\n        .root_source_file = b.path(<span class=\"tok-str\">\"mathtest.zig\"</span>),\n        .version = .{ .major = <span class=\"tok-number\">1</span>, .minor = <span class=\"tok-number\">0</span>, .patch = <span class=\"tok-number\">0</span> },\n    });\n    <span class=\"tok-kw\">const</span> exe = b.addExecutable(.{\n        .name = <span class=\"tok-str\">\"test\"</span>,\n    });\n    exe.addCSourceFile(.{ .file = b.path(<span class=\"tok-str\">\"test.c\"</span>), .flags = &.{<span class=\"tok-str\">\"-std=c99\"</span>} });\n    exe.linkLibrary(lib);\n    exe.linkSystemLibrary(<span class=\"tok-str\">\"c\"</span>);\n\n    b.default_step.dependOn(&exe.step);\n\n    <span class=\"tok-kw\">const</span> run_cmd = exe.run();\n\n    <span class=\"tok-kw\">const</span> test_step = b.step(<span class=\"tok-str\">\"test\"</span>, <span class=\"tok-str\">\"Test the program\"</span>);\n    test_step.dependOn(&run_cmd.step);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> base64 = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).base64;\n\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">decode_base_64</span>(\n    dest_ptr: [*]<span class=\"tok-type\">u8</span>,\n    dest_len: <span class=\"tok-type\">usize</span>,\n    source_ptr: [*]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>,\n    source_len: <span class=\"tok-type\">usize</span>,\n) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">const</span> src = source_ptr[<span class=\"tok-number\">0</span>..source_len];\n    <span class=\"tok-kw\">const</span> dest = dest_ptr[<span class=\"tok-number\">0</span>..dest_len];\n    <span class=\"tok-kw\">const</span> base64_decoder = base64.standard.Decoder;\n    <span class=\"tok-kw\">const</span> decoded_size = base64_decoder.calcSizeForSlice(src) <span class=\"tok-kw\">catch</span> <span class=\"tok-kw\">unreachable</span>;\n    base64_decoder.decode(dest[<span class=\"tok-number\">0</span>..decoded_size], src) <span class=\"tok-kw\">catch</span> <span class=\"tok-kw\">unreachable</span>;\n    <span class=\"tok-kw\">return</span> decoded_size;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "// This header is generated by zig from base64.zig\n#include \"base64.h\"\n\n#include <string.h>\n#include <stdio.h>\n\nint main(int argc, char **argv) {\n    const char *encoded = \"YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz\";\n    char buf[200];\n\n    size_t len = decode_base_64(buf, 200, encoded, strlen(encoded));\n    buf[len] = 0;\n    puts(buf);\n\n    return 0;\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">build</span>(b: *std.Build) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> obj = b.addObject(.{\n        .name = <span class=\"tok-str\">\"base64\"</span>,\n        .root_source_file = b.path(<span class=\"tok-str\">\"base64.zig\"</span>),\n    });\n\n    <span class=\"tok-kw\">const</span> exe = b.addExecutable(.{\n        .name = <span class=\"tok-str\">\"test\"</span>,\n    });\n    exe.addCSourceFile(.{ .file = b.path(<span class=\"tok-str\">\"test.c\"</span>), .flags = &.{<span class=\"tok-str\">\"-std=c99\"</span>} });\n    exe.addObject(obj);\n    exe.linkSystemLibrary(<span class=\"tok-str\">\"c\"</span>);\n    b.installArtifact(exe);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain C § in Zig 0.14.1",
    "context": "",
    "response": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header File § The @cImport builtin function can be used to directly import symbols from .h files: cImport_builtin.zig Shell The @cImport function takes an expression as a parameter. This expression is evaluated at compile-time and is used to control preprocessor directives and include multiple .h files: @cImport Expression See also: @cImport @cInclude @cDefine @cUndef @import C Translation CLI § Zig's C translation capability is available as a CLI tool via zig translate-c . It requires a single filename ",
    "metadata": {
      "version": "0.14.1",
      "topic": "C §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: WebAssembly §",
    "context": "Zig supports building for WebAssembly out of the box. Freestanding § For host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs. math.zig Shell test.js Shell WASI § Zig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments: wasi_args.zig Shell Shell A more interesting exampl",
    "response": "<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">print</span>(<span class=\"tok-type\">i32</span>) <span class=\"tok-type\">void</span>;\n\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">void</span> {\n    print(a + b);\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "WebAssembly §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: WebAssembly §",
    "context": "Zig supports building for WebAssembly out of the box. Freestanding § For host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs. math.zig Shell test.js Shell WASI § Zig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments: wasi_args.zig Shell Shell A more interesting exampl",
    "response": "const fs = require('fs');\nconst source = fs.readFileSync(\"./math.wasm\");\nconst typedArray = new Uint8Array(source);\n\nWebAssembly.instantiate(typedArray, {\n  env: {\n    print: (result) => { console.log(`The result is ${result}`); }\n  }}).then(result => {\n  const add = result.instance.exports.add;\n  add(1, 2);\n});",
    "metadata": {
      "version": "0.14.1",
      "topic": "WebAssembly §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: WebAssembly §",
    "context": "Zig supports building for WebAssembly out of the box. Freestanding § For host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs. math.zig Shell test.js Shell WASI § Zig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments: wasi_args.zig Shell Shell A more interesting exampl",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> general_purpose_allocator: std.heap.GeneralPurposeAllocator(.{}) = .init;\n    <span class=\"tok-kw\">const</span> gpa = general_purpose_allocator.allocator();\n    <span class=\"tok-kw\">const</span> args = <span class=\"tok-kw\">try</span> std.process.argsAlloc(gpa);\n    <span class=\"tok-kw\">defer</span> std.process.argsFree(gpa, args);\n\n    <span class=\"tok-kw\">for</span> (args, <span class=\"tok-number\">0</span>..) |arg, i| {\n        std.debug.print(<span class=\"tok-str\">\"{}: {s}\\n\"</span>, .{ i, arg });\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "WebAssembly §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: WebAssembly §",
    "context": "Zig supports building for WebAssembly out of the box. Freestanding § For host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs. math.zig Shell test.js Shell WASI § Zig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments: wasi_args.zig Shell Shell A more interesting exampl",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> fs = std.fs;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> general_purpose_allocator: std.heap.GeneralPurposeAllocator(.{}) = .init;\n    <span class=\"tok-kw\">const</span> gpa = general_purpose_allocator.allocator();\n\n    <span class=\"tok-kw\">var</span> arena_instance = std.heap.ArenaAllocator.init(gpa);\n    <span class=\"tok-kw\">defer</span> arena_instance.deinit();\n    <span class=\"tok-kw\">const</span> arena = arena_instance.allocator();\n\n    <span class=\"tok-kw\">const</span> preopens = <span class=\"tok-kw\">try</span> fs.wasi.preopensAlloc(arena);\n\n    <span class=\"tok-kw\">for</span> (preopens.names, <span class=\"tok-number\">0</span>..) |preopen, i| {\n        std.debug.print(<span class=\"tok-str\">\"{}: {s}\\n\"</span>, .{ i, preopen });\n    }\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "WebAssembly §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain WebAssembly § in Zig 0.14.1",
    "context": "",
    "response": "Zig supports building for WebAssembly out of the box. Freestanding § For host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs. math.zig Shell test.js Shell WASI § Zig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments: wasi_args.zig Shell Shell A more interesting example would be extracting the list of preopens from the runtime. This is now supported in the standard library via std.fs.wasi.Preopens : wasi_preopens.zig Shell Shell",
    "metadata": {
      "version": "0.14.1",
      "topic": "WebAssembly §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Targets § in Zig 0.14.1",
    "context": "",
    "response": "Target refers to the computer that will be used to run an executable. It is composed of the CPU architecture, the set of enabled CPU features, operating system, minimum and maximum operating system version, ABI, and ABI version. Zig is a general-purpose programming language which means that it is designed to generate optimal code for a large set of targets. The command zig targets provides information about all of the targets the compiler is aware of. When no target option is provided to the compiler, the default choice is to target the host computer , meaning that the resulting executable will be unsuitable for copying to a different computer . In order to copy an executable to another computer, the compiler needs to know about the target requirements via the -target option. The Zig Standard Library ( @import ( &quot;std&quot; ) ) has cross-platform abstractions, making the same source code viable on many targets. Some code is more portable than other code. In general, Zig code is ext",
    "metadata": {
      "version": "0.14.1",
      "topic": "Targets §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Style Guide §",
    "context": "These coding conventions are not enforced by the compiler, but they are shipped in this documentation along with the compiler in order to provide a point of reference, should anyone wish to point to an authority on agreed upon Zig coding style. Avoid Redundancy in Names § Avoid these words in type names: Value Data Context Manager utils, misc, or somebody's initials Everything is a value, all types are data, everything is context, all logic manages state. Nothing is communicated by using a word ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> json = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> JsonValue = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n        number: <span class=\"tok-type\">f64</span>,\n        boolean: <span class=\"tok-type\">bool</span>,\n        <span class=\"tok-comment\">// ...</span>\n    };\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    std.debug.print(<span class=\"tok-str\">\"{s}\\n\"</span>, .{<span class=\"tok-builtin\">@typeName</span>(json.JsonValue)});\n}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Style Guide §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Style Guide §",
    "context": "These coding conventions are not enforced by the compiler, but they are shipped in this documentation along with the compiler in order to provide a point of reference, should anyone wish to point to an authority on agreed upon Zig coding style. Avoid Redundancy in Names § Avoid these words in type names: Value Data Context Manager utils, misc, or somebody's initials Everything is a value, all types are data, everything is context, all logic manages state. Nothing is communicated by using a word ",
    "response": "<span class=\"tok-kw\">const</span> namespace_name = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"dir_name/file_name.zig\"</span>);\n<span class=\"tok-kw\">const</span> TypeName = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"dir_name/TypeName.zig\"</span>);\n<span class=\"tok-kw\">var</span> global_var: <span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n<span class=\"tok-kw\">const</span> const_name = <span class=\"tok-number\">42</span>;\n<span class=\"tok-kw\">const</span> primitive_type_alias = <span class=\"tok-type\">f32</span>;\n<span class=\"tok-kw\">const</span> string_alias = []<span class=\"tok-type\">u8</span>;\n\n<span class=\"tok-kw\">const</span> StructName = <span class=\"tok-kw\">struct</span> {\n    field: <span class=\"tok-type\">i32</span>,\n};\n<span class=\"tok-kw\">const</span> StructAlias = StructName;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">functionName</span>(param_name: TypeName) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> functionPointer = functionName;\n    functionPointer();\n    functionPointer = otherFunction;\n    functionPointer();\n}\n<span class=\"tok-kw\">const</span> functionAlias = functionName;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">ListTemplateFunction</span>(<span class=\"tok-kw\">comptime</span> ChildType: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> fixed_size: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> List(ChildType, fixed_size);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">ShortList</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> n: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">struct</span> {\n        field_name: [n]T,\n        <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">methodName</span>() <span class=\"tok-type\">void</span> {}\n    };\n}\n\n<span class=\"tok-comment\">// The word XML loses its casing when used in Zig identifiers.</span>\n<span class=\"tok-kw\">const</span> xml_document =\n    <span class=\"tok-str\">\\\\<?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n    <span class=\"tok-str\">\\\\<document></span>\n    <span class=\"tok-str\">\\\\</document></span>\n;\n<span class=\"tok-kw\">const</span> XmlParser = <span class=\"tok-kw\">struct</span> {\n    field: <span class=\"tok-type\">i32</span>,\n};\n\n<span class=\"tok-comment\">// The initials BE (Big Endian) are just another word in Zig identifier names.</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">readU32Be</span>() <span class=\"tok-type\">u32</span> {}",
    "metadata": {
      "version": "0.14.1",
      "topic": "Style Guide §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Style Guide § in Zig 0.14.1",
    "context": "",
    "response": "These coding conventions are not enforced by the compiler, but they are shipped in this documentation along with the compiler in order to provide a point of reference, should anyone wish to point to an authority on agreed upon Zig coding style. Avoid Redundancy in Names § Avoid these words in type names: Value Data Context Manager utils, misc, or somebody's initials Everything is a value, all types are data, everything is context, all logic manages state. Nothing is communicated by using a word that applies to all types. Temptation to use \"utilities\", \"miscellaneous\", or somebody's initials is a failure to categorize, or more commonly, overcategorization. Such declarations can live at the root of a module that needs them with no namespace needed. Avoid Redundant Names in Fully-Qualified Namespaces § Every declaration is assigned a fully qualified namespace by the compiler, creating a tree structure. Choose names based on the fully-qualified namespace, and avoid redundant name segments.",
    "metadata": {
      "version": "0.14.1",
      "topic": "Style Guide §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Source Encoding § in Zig 0.14.1",
    "context": "",
    "response": "Zig source code is encoded in UTF-8. An invalid UTF-8 byte sequence results in a compile error. Throughout all zig source code (including in comments), some code points are never allowed: Ascii control characters, except for U+000a (LF), U+000d (CR), and U+0009 (HT): U+0000 - U+0008, U+000b - U+000c, U+000e - U+0001f, U+007f. Non-Ascii Unicode line endings: U+0085 (NEL), U+2028 (LS), U+2029 (PS). LF (byte value 0x0a, code point U+000a, '\\n' ) is the line terminator in Zig source code. This byte value terminates every line of zig source code except the last line of the file. It is recommended that non-empty source files end with an empty line, which means the last byte would be 0x0a (LF). Each LF may be immediately preceded by a single CR (byte value 0x0d, code point U+000d, '\\r' ) to form a Windows style line ending, but this is discouraged. Note that in multiline strings, CRLF sequences will be encoded as LF when compiled into a zig program. A CR in any other context is not allowed. H",
    "metadata": {
      "version": "0.14.1",
      "topic": "Source Encoding §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">addrspace</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">align</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">allowzero</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">and</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">anyframe</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">asm</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">async</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">await</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">break</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">callconv</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">catch</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">comptime</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">const</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">continue</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">defer</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">else</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">enum</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">errdefer</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">error</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">export</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">extern</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">fn</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">for</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">if</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">inline</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">linksection</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">noalias</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">noinline</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">nosuspend</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">opaque</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">or</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">orelse</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">packed</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">pub</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">resume</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">return</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">struct</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">suspend</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">switch</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">test</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">threadlocal</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">try</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">union</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">unreachable</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">usingnamespace</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">var</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">volatile</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">while</span>",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Keyword Reference § in Zig 0.14.1",
    "context": "",
    "response": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function frames. See also Async Functions Function parameters can be declared with anytype in place of the type. The type will be inferred where the function is called. See also Function Parameter Type Inference asm begins an inline assembly expression. This allows for directly controlling the machine code generated on compilation. See also Assembly async can be used before a function call to get a pointer to the function's frame when it suspends. See also Async Functions await can be used to suspend the cu",
    "metadata": {
      "version": "0.14.1",
      "topic": "Keyword Reference §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.14.1 code for: Appendix §",
    "context": "Containers § A container in Zig is any syntactical construct that acts as a namespace to hold variable and function declarations. Containers are also type definitions which can be instantiated. Structs , enums , unions , opaques , and even Zig source files themselves are containers. Although containers (except Zig source files) use curly braces to surround their definition, they should not be confused with blocks or functions. Containers do not contain statements. Grammar § grammar.y Zen § Commu",
    "response": "Root <- skip container_doc_comment? ContainerMembers eof\n\n# *** Top level ***\nContainerMembers <- ContainerDeclaration* (ContainerField COMMA)* (ContainerField / ContainerDeclaration*)\n\nContainerDeclaration <- TestDecl / ComptimeDecl / doc_comment? KEYWORD_pub? Decl\n\nTestDecl <- KEYWORD_test (STRINGLITERALSINGLE / IDENTIFIER)? Block\n\nComptimeDecl <- KEYWORD_comptime Block\n\nDecl\n    <- (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE? / KEYWORD_inline / KEYWORD_noinline)? FnProto (SEMICOLON / Block)\n     / (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE?)? KEYWORD_threadlocal? GlobalVarDecl\n     / KEYWORD_usingnamespace Expr SEMICOLON\n\nFnProto <- KEYWORD_fn IDENTIFIER? LPAREN ParamDeclList RPAREN ByteAlign? AddrSpace? LinkSection? CallConv? EXCLAMATIONMARK? TypeExpr\n\nVarDeclProto <- (KEYWORD_const / KEYWORD_var) IDENTIFIER (COLON TypeExpr)? ByteAlign? AddrSpace? LinkSection?\n\nGlobalVarDecl <- VarDeclProto (EQUAL Expr)? SEMICOLON\n\nContainerField <- doc_comment? KEYWORD_comptime? !KEYWORD_fn (IDENTIFIER COLON)? TypeExpr ByteAlign? (EQUAL Expr)?\n\n# *** Block Level ***\nStatement\n    <- KEYWORD_comptime ComptimeStatement\n     / KEYWORD_nosuspend BlockExprStatement\n     / KEYWORD_suspend BlockExprStatement\n     / KEYWORD_defer BlockExprStatement\n     / KEYWORD_errdefer Payload? BlockExprStatement\n     / IfStatement\n     / LabeledStatement\n     / SwitchExpr\n     / VarDeclExprStatement\n\nComptimeStatement\n    <- BlockExpr\n     / VarDeclExprStatement\n\nIfStatement\n    <- IfPrefix BlockExpr ( KEYWORD_else Payload? Statement )?\n     / IfPrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )\n\nLabeledStatement <- BlockLabel? (Block / LoopStatement)\n\nLoopStatement <- KEYWORD_inline? (ForStatement / WhileStatement)\n\nForStatement\n    <- ForPrefix BlockExpr ( KEYWORD_else Statement )?\n     / ForPrefix AssignExpr ( SEMICOLON / KEYWORD_else Statement )\n\nWhileStatement\n    <- WhilePrefix BlockExpr ( KEYWORD_else Payload? Statement )?\n     / WhilePrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )\n\nBlockExprStatement\n    <- BlockExpr\n     / AssignExpr SEMICOLON\n\nBlockExpr <- BlockLabel? Block\n\n# An expression, assignment, or any destructure, as a statement.\nVarDeclExprStatement\n    <- VarDeclProto (COMMA (VarDeclProto / Expr))* EQUAL Expr SEMICOLON\n     / Expr (AssignOp Expr / (COMMA (VarDeclProto / Expr))+ EQUAL Expr)? SEMICOLON\n\n# *** Expression Level ***\n\n# An assignment or a destructure whose LHS are all lvalue expressions.\nAssignExpr <- Expr (AssignOp Expr / (COMMA Expr)+ EQUAL Expr)?\n\nSingleAssignExpr <- Expr (AssignOp Expr)?\n\nExpr <- BoolOrExpr\n\nBoolOrExpr <- BoolAndExpr (KEYWORD_or BoolAndExpr)*\n\nBoolAndExpr <- CompareExpr (KEYWORD_and CompareExpr)*\n\nCompareExpr <- BitwiseExpr (CompareOp BitwiseExpr)?\n\nBitwiseExpr <- BitShiftExpr (BitwiseOp BitShiftExpr)*\n\nBitShiftExpr <- AdditionExpr (BitShiftOp AdditionExpr)*\n\nAdditionExpr <- MultiplyExpr (AdditionOp MultiplyExpr)*\n\nMultiplyExpr <- PrefixExpr (MultiplyOp PrefixExpr)*\n\nPrefixExpr <- PrefixOp* PrimaryExpr\n\nPrimaryExpr\n    <- AsmExpr\n     / IfExpr\n     / KEYWORD_break BreakLabel? Expr?\n     / KEYWORD_comptime Expr\n     / KEYWORD_nosuspend Expr\n     / KEYWORD_continue BreakLabel?\n     / KEYWORD_resume Expr\n     / KEYWORD_return Expr?\n     / BlockLabel? LoopExpr\n     / Block\n     / CurlySuffixExpr\n\nIfExpr <- IfPrefix Expr (KEYWORD_else Payload? Expr)?\n\nBlock <- LBRACE Statement* RBRACE\n\nLoopExpr <- KEYWORD_inline? (ForExpr / WhileExpr)\n\nForExpr <- ForPrefix Expr (KEYWORD_else Expr)?\n\nWhileExpr <- WhilePrefix Expr (KEYWORD_else Payload? Expr)?\n\nCurlySuffixExpr <- TypeExpr InitList?\n\nInitList\n    <- LBRACE FieldInit (COMMA FieldInit)* COMMA? RBRACE\n     / LBRACE Expr (COMMA Expr)* COMMA? RBRACE\n     / LBRACE RBRACE\n\nTypeExpr <- PrefixTypeOp* ErrorUnionExpr\n\nErrorUnionExpr <- SuffixExpr (EXCLAMATIONMARK TypeExpr)?\n\nSuffixExpr\n    <- KEYWORD_async PrimaryTypeExpr SuffixOp* FnCallArguments\n     / PrimaryTypeExpr (SuffixOp / FnCallArguments)*\n\nPrimaryTypeExpr\n    <- BUILTINIDENTIFIER FnCallArguments\n     / CHAR_LITERAL\n     / ContainerDecl\n     / DOT IDENTIFIER\n     / DOT InitList\n     / ErrorSetDecl\n     / FLOAT\n     / FnProto\n     / GroupedExpr\n     / LabeledTypeExpr\n     / IDENTIFIER\n     / IfTypeExpr\n     / INTEGER\n     / KEYWORD_comptime TypeExpr\n     / KEYWORD_error DOT IDENTIFIER\n     / KEYWORD_anyframe\n     / KEYWORD_unreachable\n     / STRINGLITERAL\n     / SwitchExpr\n\nContainerDecl <- (KEYWORD_extern / KEYWORD_packed)? ContainerDeclAuto\n\nErrorSetDecl <- KEYWORD_error LBRACE IdentifierList RBRACE\n\nGroupedExpr <- LPAREN Expr RPAREN\n\nIfTypeExpr <- IfPrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?\n\nLabeledTypeExpr\n    <- BlockLabel Block\n     / BlockLabel? LoopTypeExpr\n\nLoopTypeExpr <- KEYWORD_inline? (ForTypeExpr / WhileTypeExpr)\n\nForTypeExpr <- ForPrefix TypeExpr (KEYWORD_else TypeExpr)?\n\nWhileTypeExpr <- WhilePrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?\n\nSwitchExpr <- KEYWORD_switch LPAREN Expr RPAREN LBRACE SwitchProngList RBRACE\n\n# *** Assembly ***\nAsmExpr <- KEYWORD_asm KEYWORD_volatile? LPAREN Expr AsmOutput? RPAREN\n\nAsmOutput <- COLON AsmOutputList AsmInput?\n\nAsmOutputItem <- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN (MINUSRARROW TypeExpr / IDENTIFIER) RPAREN\n\nAsmInput <- COLON AsmInputList AsmClobbers?\n\nAsmInputItem <- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN Expr RPAREN\n\nAsmClobbers <- COLON StringList\n\n# *** Helper grammar ***\nBreakLabel <- COLON IDENTIFIER\n\nBlockLabel <- IDENTIFIER COLON\n\nFieldInit <- DOT IDENTIFIER EQUAL Expr\n\nWhileContinueExpr <- COLON LPAREN AssignExpr RPAREN\n\nLinkSection <- KEYWORD_linksection LPAREN Expr RPAREN\n\nAddrSpace <- KEYWORD_addrspace LPAREN Expr RPAREN\n\n# Fn specific\nCallConv <- KEYWORD_callconv LPAREN Expr RPAREN\n\nParamDecl\n    <- doc_comment? (KEYWORD_noalias / KEYWORD_comptime)? (IDENTIFIER COLON)? ParamType\n     / DOT3\n\nParamType\n    <- KEYWORD_anytype\n     / TypeExpr\n\n# Control flow prefixes\nIfPrefix <- KEYWORD_if LPAREN Expr RPAREN PtrPayload?\n\nWhilePrefix <- KEYWORD_while LPAREN Expr RPAREN PtrPayload? WhileContinueExpr?\n\nForPrefix <- KEYWORD_for LPAREN ForArgumentsList RPAREN PtrListPayload\n\n# Payloads\nPayload <- PIPE IDENTIFIER PIPE\n\nPtrPayload <- PIPE ASTERISK? IDENTIFIER PIPE\n\nPtrIndexPayload <- PIPE ASTERISK? IDENTIFIER (COMMA IDENTIFIER)? PIPE\n\nPtrListPayload <- PIPE ASTERISK? IDENTIFIER (COMMA ASTERISK? IDENTIFIER)* COMMA? PIPE\n\n# Switch specific\nSwitchProng <- KEYWORD_inline? SwitchCase EQUALRARROW PtrIndexPayload? SingleAssignExpr\n\nSwitchCase\n    <- SwitchItem (COMMA SwitchItem)* COMMA?\n     / KEYWORD_else\n\nSwitchItem <- Expr (DOT3 Expr)?\n\n# For specific\nForArgumentsList <- ForItem (COMMA ForItem)* COMMA?\n\nForItem <- Expr (DOT2 Expr?)?\n\n# Operators\nAssignOp\n    <- ASTERISKEQUAL\n     / ASTERISKPIPEEQUAL\n     / SLASHEQUAL\n     / PERCENTEQUAL\n     / PLUSEQUAL\n     / PLUSPIPEEQUAL\n     / MINUSEQUAL\n     / MINUSPIPEEQUAL\n     / LARROW2EQUAL\n     / LARROW2PIPEEQUAL\n     / RARROW2EQUAL\n     / AMPERSANDEQUAL\n     / CARETEQUAL\n     / PIPEEQUAL\n     / ASTERISKPERCENTEQUAL\n     / PLUSPERCENTEQUAL\n     / MINUSPERCENTEQUAL\n     / EQUAL\n\nCompareOp\n    <- EQUALEQUAL\n     / EXCLAMATIONMARKEQUAL\n     / LARROW\n     / RARROW\n     / LARROWEQUAL\n     / RARROWEQUAL\n\nBitwiseOp\n    <- AMPERSAND\n     / CARET\n     / PIPE\n     / KEYWORD_orelse\n     / KEYWORD_catch Payload?\n\nBitShiftOp\n    <- LARROW2\n     / RARROW2\n     / LARROW2PIPE\n\nAdditionOp\n    <- PLUS\n     / MINUS\n     / PLUS2\n     / PLUSPERCENT\n     / MINUSPERCENT\n     / PLUSPIPE\n     / MINUSPIPE\n\nMultiplyOp\n    <- PIPE2\n     / ASTERISK\n     / SLASH\n     / PERCENT\n     / ASTERISK2\n     / ASTERISKPERCENT\n     / ASTERISKPIPE\n\nPrefixOp\n    <- EXCLAMATIONMARK\n     / MINUS\n     / TILDE\n     / MINUSPERCENT\n     / AMPERSAND\n     / KEYWORD_try\n     / KEYWORD_await\n\nPrefixTypeOp\n    <- QUESTIONMARK\n     / KEYWORD_anyframe MINUSRARROW\n     / SliceTypeStart (ByteAlign / AddrSpace / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*\n     / PtrTypeStart (AddrSpace / KEYWORD_align LPAREN Expr (COLON Expr COLON Expr)? RPAREN / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*\n     / ArrayTypeStart\n\nSuffixOp\n    <- LBRACKET Expr (DOT2 (Expr? (COLON Expr)?)?)? RBRACKET\n     / DOT IDENTIFIER\n     / DOTASTERISK\n     / DOTQUESTIONMARK\n\nFnCallArguments <- LPAREN ExprList RPAREN\n\n# Ptr specific\nSliceTypeStart <- LBRACKET (COLON Expr)? RBRACKET\n\nPtrTypeStart\n    <- ASTERISK\n     / ASTERISK2\n     / LBRACKET ASTERISK (LETTERC / COLON Expr)? RBRACKET\n\nArrayTypeStart <- LBRACKET Expr (COLON Expr)? RBRACKET\n\n# ContainerDecl specific\nContainerDeclAuto <- ContainerDeclType LBRACE container_doc_comment? ContainerMembers RBRACE\n\nContainerDeclType\n    <- KEYWORD_struct (LPAREN Expr RPAREN)?\n     / KEYWORD_opaque\n     / KEYWORD_enum (LPAREN Expr RPAREN)?\n     / KEYWORD_union (LPAREN (KEYWORD_enum (LPAREN Expr RPAREN)? / Expr) RPAREN)?\n\n# Alignment\nByteAlign <- KEYWORD_align LPAREN Expr RPAREN\n\n# Lists\nIdentifierList <- (doc_comment? IDENTIFIER COMMA)* (doc_comment? IDENTIFIER)?\n\nSwitchProngList <- (SwitchProng COMMA)* SwitchProng?\n\nAsmOutputList <- (AsmOutputItem COMMA)* AsmOutputItem?\n\nAsmInputList <- (AsmInputItem COMMA)* AsmInputItem?\n\nStringList <- (STRINGLITERAL COMMA)* STRINGLITERAL?\n\nParamDeclList <- (ParamDecl COMMA)* ParamDecl?\n\nExprList <- (Expr COMMA)* Expr?\n\n# *** Tokens ***\neof <- !.\nbin <- [01]\nbin_ <- '_'? bin\noct <- [0-7]\noct_ <- '_'? oct\nhex <- [0-9a-fA-F]\nhex_ <- '_'? hex\ndec <- [0-9]\ndec_ <- '_'? dec\n\nbin_int <- bin bin_*\noct_int <- oct oct_*\ndec_int <- dec dec_*\nhex_int <- hex hex_*\n\nox80_oxBF <- [\\200-\\277]\noxF4 <- '\\364'\nox80_ox8F <- [\\200-\\217]\noxF1_oxF3 <- [\\361-\\363]\noxF0 <- '\\360'\nox90_0xBF <- [\\220-\\277]\noxEE_oxEF <- [\\356-\\357]\noxED <- '\\355'\nox80_ox9F <- [\\200-\\237]\noxE1_oxEC <- [\\341-\\354]\noxE0 <- '\\340'\noxA0_oxBF <- [\\240-\\277]\noxC2_oxDF <- [\\302-\\337]\n\n# From https://lemire.me/blog/2018/05/09/how-quickly-can-you-check-that-a-string-is-valid-unicode-utf-8/\n# First Byte      Second Byte     Third Byte      Fourth Byte\n# [0x00,0x7F]\n# [0xC2,0xDF]     [0x80,0xBF]\n#    0xE0         [0xA0,0xBF]     [0x80,0xBF]\n# [0xE1,0xEC]     [0x80,0xBF]     [0x80,0xBF]\n#    0xED         [0x80,0x9F]     [0x80,0xBF]\n# [0xEE,0xEF]     [0x80,0xBF]     [0x80,0xBF]\n#    0xF0         [0x90,0xBF]     [0x80,0xBF]     [0x80,0xBF]\n# [0xF1,0xF3]     [0x80,0xBF]     [0x80,0xBF]     [0x80,0xBF]\n#    0xF4         [0x80,0x8F]     [0x80,0xBF]     [0x80,0xBF]\n\nmb_utf8_literal <-\n       oxF4      ox80_ox8F ox80_oxBF ox80_oxBF\n     / oxF1_oxF3 ox80_oxBF ox80_oxBF ox80_oxBF\n     / oxF0      ox90_0xBF ox80_oxBF ox80_oxBF\n     / oxEE_oxEF ox80_oxBF ox80_oxBF\n     / oxED      ox80_ox9F ox80_oxBF\n     / oxE1_oxEC ox80_oxBF ox80_oxBF\n     / oxE0      oxA0_oxBF ox80_oxBF\n     / oxC2_oxDF ox80_oxBF\n\nascii_char_not_nl_slash_squote <- [\\000-\\011\\013-\\046\\050-\\133\\135-\\177]\n\nchar_escape\n    <- \"\\\\x\" hex hex\n     / \"\\\\u{\" hex+ \"}\"\n     / \"\\\\\" [nr\\\\t'\"]\nchar_char\n    <- mb_utf8_literal\n     / char_escape\n     / ascii_char_not_nl_slash_squote\n\nstring_char\n    <- char_escape\n     / [^\\\\\"\\n]\n\ncontainer_doc_comment <- ('//!' [^\\n]* [ \\n]* skip)+\ndoc_comment <- ('///' [^\\n]* [ \\n]* skip)+\nline_comment <- '//' ![!/][^\\n]* / '////' [^\\n]*\nline_string <- (\"\\\\\\\\\" [^\\n]* [ \\n]*)+\nskip <- ([ \\n] / line_comment)*\n\nCHAR_LITERAL <- \"'\" char_char \"'\" skip\nFLOAT\n    <- \"0x\" hex_int \".\" hex_int ([pP] [-+]? dec_int)? skip\n     /      dec_int \".\" dec_int ([eE] [-+]? dec_int)? skip\n     / \"0x\" hex_int [pP] [-+]? dec_int skip\n     /      dec_int [eE] [-+]? dec_int skip\nINTEGER\n    <- \"0b\" bin_int skip\n     / \"0o\" oct_int skip\n     / \"0x\" hex_int skip\n     /      dec_int   skip\nSTRINGLITERALSINGLE <- \"\\\"\" string_char* \"\\\"\" skip\nSTRINGLITERAL\n    <- STRINGLITERALSINGLE\n     / (line_string                 skip)+\nIDENTIFIER\n    <- !keyword [A-Za-z_] [A-Za-z0-9_]* skip\n     / \"@\" STRINGLITERALSINGLE\nBUILTINIDENTIFIER <- \"@\"[A-Za-z_][A-Za-z0-9_]* skip\n\n\nAMPERSAND            <- '&'      ![=]      skip\nAMPERSANDEQUAL       <- '&='               skip\nASTERISK             <- '*'      ![*%=|]   skip\nASTERISK2            <- '**'               skip\nASTERISKEQUAL        <- '*='               skip\nASTERISKPERCENT      <- '*%'     ![=]      skip\nASTERISKPERCENTEQUAL <- '*%='              skip\nASTERISKPIPE         <- '*|'     ![=]      skip\nASTERISKPIPEEQUAL    <- '*|='              skip\nCARET                <- '^'      ![=]      skip\nCARETEQUAL           <- '^='               skip\nCOLON                <- ':'                skip\nCOMMA                <- ','                skip\nDOT                  <- '.'      ![*.?]    skip\nDOT2                 <- '..'     ![.]      skip\nDOT3                 <- '...'              skip\nDOTASTERISK          <- '.*'               skip\nDOTQUESTIONMARK      <- '.?'               skip\nEQUAL                <- '='      ![>=]     skip\nEQUALEQUAL           <- '=='               skip\nEQUALRARROW          <- '=>'               skip\nEXCLAMATIONMARK      <- '!'      ![=]      skip\nEXCLAMATIONMARKEQUAL <- '!='               skip\nLARROW               <- '<'      ![<=]     skip\nLARROW2              <- '<<'     ![=|]     skip\nLARROW2EQUAL         <- '<<='              skip\nLARROW2PIPE          <- '<<|'    ![=]      skip\nLARROW2PIPEEQUAL     <- '<<|='             skip\nLARROWEQUAL          <- '<='               skip\nLBRACE               <- '{'                skip\nLBRACKET             <- '['                skip\nLPAREN               <- '('                skip\nMINUS                <- '-'      ![%=>|]   skip\nMINUSEQUAL           <- '-='               skip\nMINUSPERCENT         <- '-%'     ![=]      skip\nMINUSPERCENTEQUAL    <- '-%='              skip\nMINUSPIPE            <- '-|'     ![=]      skip\nMINUSPIPEEQUAL       <- '-|='              skip\nMINUSRARROW          <- '->'               skip\nPERCENT              <- '%'      ![=]      skip\nPERCENTEQUAL         <- '%='               skip\nPIPE                 <- '|'      ![|=]     skip\nPIPE2                <- '||'               skip\nPIPEEQUAL            <- '|='               skip\nPLUS                 <- '+'      ![%+=|]   skip\nPLUS2                <- '++'               skip\nPLUSEQUAL            <- '+='               skip\nPLUSPERCENT          <- '+%'     ![=]      skip\nPLUSPERCENTEQUAL     <- '+%='              skip\nPLUSPIPE             <- '+|'     ![=]      skip\nPLUSPIPEEQUAL        <- '+|='              skip\nLETTERC              <- 'c'                skip\nQUESTIONMARK         <- '?'                skip\nRARROW               <- '>'      ![>=]     skip\nRARROW2              <- '>>'     ![=]      skip\nRARROW2EQUAL         <- '>>='              skip\nRARROWEQUAL          <- '>='               skip\nRBRACE               <- '}'                skip\nRBRACKET             <- ']'                skip\nRPAREN               <- ')'                skip\nSEMICOLON            <- ';'                skip\nSLASH                <- '/'      ![=]      skip\nSLASHEQUAL           <- '/='               skip\nTILDE                <- '~'                skip\n\nend_of_word <- ![a-zA-Z0-9_] skip\nKEYWORD_addrspace   <- 'addrspace'   end_of_word\nKEYWORD_align       <- 'align'       end_of_word\nKEYWORD_allowzero   <- 'allowzero'   end_of_word\nKEYWORD_and         <- 'and'         end_of_word\nKEYWORD_anyframe    <- 'anyframe'    end_of_word\nKEYWORD_anytype     <- 'anytype'     end_of_word\nKEYWORD_asm         <- 'asm'         end_of_word\nKEYWORD_async       <- 'async'       end_of_word\nKEYWORD_await       <- 'await'       end_of_word\nKEYWORD_break       <- 'break'       end_of_word\nKEYWORD_callconv    <- 'callconv'    end_of_word\nKEYWORD_catch       <- 'catch'       end_of_word\nKEYWORD_comptime    <- 'comptime'    end_of_word\nKEYWORD_const       <- 'const'       end_of_word\nKEYWORD_continue    <- 'continue'    end_of_word\nKEYWORD_defer       <- 'defer'       end_of_word\nKEYWORD_else        <- 'else'        end_of_word\nKEYWORD_enum        <- 'enum'        end_of_word\nKEYWORD_errdefer    <- 'errdefer'    end_of_word\nKEYWORD_error       <- 'error'       end_of_word\nKEYWORD_export      <- 'export'      end_of_word\nKEYWORD_extern      <- 'extern'      end_of_word\nKEYWORD_fn          <- 'fn'          end_of_word\nKEYWORD_for         <- 'for'         end_of_word\nKEYWORD_if          <- 'if'          end_of_word\nKEYWORD_inline      <- 'inline'      end_of_word\nKEYWORD_noalias     <- 'noalias'     end_of_word\nKEYWORD_nosuspend   <- 'nosuspend'   end_of_word\nKEYWORD_noinline    <- 'noinline'    end_of_word\nKEYWORD_opaque      <- 'opaque'      end_of_word\nKEYWORD_or          <- 'or'          end_of_word\nKEYWORD_orelse      <- 'orelse'      end_of_word\nKEYWORD_packed      <- 'packed'      end_of_word\nKEYWORD_pub         <- 'pub'         end_of_word\nKEYWORD_resume      <- 'resume'      end_of_word\nKEYWORD_return      <- 'return'      end_of_word\nKEYWORD_linksection <- 'linksection' end_of_word\nKEYWORD_struct      <- 'struct'      end_of_word\nKEYWORD_suspend     <- 'suspend'     end_of_word\nKEYWORD_switch      <- 'switch'      end_of_word\nKEYWORD_test        <- 'test'        end_of_word\nKEYWORD_threadlocal <- 'threadlocal' end_of_word\nKEYWORD_try         <- 'try'         end_of_word\nKEYWORD_union       <- 'union'       end_of_word\nKEYWORD_unreachable <- 'unreachable' end_of_word\nKEYWORD_usingnamespace <- 'usingnamespace' end_of_word\nKEYWORD_var         <- 'var'         end_of_word\nKEYWORD_volatile    <- 'volatile'    end_of_word\nKEYWORD_while       <- 'while'       end_of_word\n\nkeyword <- KEYWORD_addrspace / KEYWORD_align / KEYWORD_allowzero / KEYWORD_and\n         / KEYWORD_anyframe / KEYWORD_anytype / KEYWORD_asm / KEYWORD_async\n         / KEYWORD_await / KEYWORD_break / KEYWORD_callconv / KEYWORD_catch\n         / KEYWORD_comptime / KEYWORD_const / KEYWORD_continue / KEYWORD_defer\n         / KEYWORD_else / KEYWORD_enum / KEYWORD_errdefer / KEYWORD_error / KEYWORD_export\n         / KEYWORD_extern / KEYWORD_fn / KEYWORD_for / KEYWORD_if\n         / KEYWORD_inline / KEYWORD_noalias / KEYWORD_nosuspend / KEYWORD_noinline\n         / KEYWORD_opaque / KEYWORD_or / KEYWORD_orelse / KEYWORD_packed\n         / KEYWORD_pub / KEYWORD_resume / KEYWORD_return / KEYWORD_linksection\n         / KEYWORD_struct / KEYWORD_suspend / KEYWORD_switch / KEYWORD_test\n         / KEYWORD_threadlocal / KEYWORD_try / KEYWORD_union / KEYWORD_unreachable\n         / KEYWORD_usingnamespace / KEYWORD_var / KEYWORD_volatile / KEYWORD_while",
    "metadata": {
      "version": "0.14.1",
      "topic": "Appendix §",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Explain Appendix § in Zig 0.14.1",
    "context": "",
    "response": "Containers § A container in Zig is any syntactical construct that acts as a namespace to hold variable and function declarations. Containers are also type definitions which can be instantiated. Structs , enums , unions , opaques , and even Zig source files themselves are containers. Although containers (except Zig source files) use curly braces to surround their definition, they should not be confused with blocks or functions. Containers do not contain statements. Grammar § grammar.y Zen § Communicate intent precisely. Edge cases matter. Favor reading code over writing code. Only one obvious way to do things. Runtime crashes are better than bugs. Compile errors are better than runtime crashes. Incremental improvements. Avoid local maximums. Reduce the amount one must remember. Focus on code rather than style. Resource allocation may fail; resource deallocation must succeed. Memory is a resource. Together we serve the users.",
    "metadata": {
      "version": "0.14.1",
      "topic": "Appendix §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Zig Version in Zig 0.13.0",
    "context": "",
    "response": "0.1.1 | 0.2.0 | 0.3.0 | 0.4.0 | 0.5.0 | 0.6.0 | 0.7.1 | 0.8.1 | 0.9.1 | 0.10.1 | 0.11.0 | 0.12.1 | 0.13.0 | 0.14.1 | 0.15.2 | master",
    "metadata": {
      "version": "0.13.0",
      "topic": "Zig Version",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Table of Contents in Zig 0.13.0",
    "context": "",
    "response": "Introduction Zig Standard Library Hello World Comments Doc Comments Top-Level Doc Comments Values Primitive Types Primitive Values String Literals and Unicode Code Point Literals Escape Sequences Multiline String Literals Assignment undefined Zig Test Test Declarations Doctests Test Failure Skip Tests Report Memory Leaks Detecting Test Build Test Output and Logging The Testing Namespace Test Tool Documentation Variables Identifiers Container Level Variables Static Local Variables Thread Local Variables Local Variables Integers Integer Literals Runtime Integer Values Floats Float Literals Floating Point Operations Operators Table of Operators Precedence Arrays Multidimensional Arrays Sentinel-Terminated Arrays Vectors Pointers volatile Alignment allowzero Sentinel-Terminated Pointers Slices Sentinel-Terminated Slices struct Default Field Values extern struct packed struct Struct Naming Anonymous Struct Literals Tuples enum extern enum Enum Literals Non-exhaustive enum union Tagged union",
    "metadata": {
      "version": "0.13.0",
      "topic": "Table of Contents",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Introduction § in Zig 0.13.0",
    "context": "",
    "response": "Zig is a general-purpose programming language and toolchain for maintaining robust , optimal , and reusable software. Robust Behavior is correct even for edge cases such as out of memory. Optimal Write programs the best way they can behave and perform. Reusable The same code works in many environments which have different constraints. Maintainable Precisely communicate intent to the compiler and other programmers. The language imposes a low overhead to reading code and is resilient to changing requirements and environments. Often the most efficient way to learn something new is to see examples, so this documentation shows how to use each of Zig's features. It is all on one page so you can search with your browser's search tool. The code samples in this document are compiled and tested as part of the main test suite of Zig. This HTML document depends on no external files, so you can use it offline.",
    "metadata": {
      "version": "0.13.0",
      "topic": "Introduction §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Zig Standard Library § in Zig 0.13.0",
    "context": "",
    "response": "The Zig Standard Library has its own documentation. Zig's Standard Library contains commonly used algorithms, data structures, and definitions to help you build programs or libraries. You will see many examples of Zig's Standard Library used in this documentation. To learn more about the Zig Standard Library, visit the link above.",
    "metadata": {
      "version": "0.13.0",
      "topic": "Zig Standard Library §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Hello World §",
    "context": "hello.zig Shell Most of the time, it is more appropriate to write to stderr rather than stdout, and whether or not the message is successfully written to the stream is irrelevant. For this common case, there is a simpler API: hello_again.zig Shell In this case, the ! may be omitted from the return type because no errors are returned from the function. See also: Values @import Errors Root Source File Source Encoding",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> stdout = std.io.getStdOut().writer();\n    <span class=\"tok-kw\">try</span> stdout.print(<span class=\"tok-str\">\"Hello, {s}!\\n\"</span>, .{<span class=\"tok-str\">\"world\"</span>});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Hello World §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Hello World §",
    "context": "hello.zig Shell Most of the time, it is more appropriate to write to stderr rather than stdout, and whether or not the message is successfully written to the stream is irrelevant. For this common case, there is a simpler API: hello_again.zig Shell In this case, the ! may be omitted from the return type because no errors are returned from the function. See also: Values @import Errors Root Source File Source Encoding",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    std.debug.print(<span class=\"tok-str\">\"Hello, world!\\n\"</span>, .{});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Hello World §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Hello World § in Zig 0.13.0",
    "context": "",
    "response": "hello.zig Shell Most of the time, it is more appropriate to write to stderr rather than stdout, and whether or not the message is successfully written to the stream is irrelevant. For this common case, there is a simpler API: hello_again.zig Shell In this case, the ! may be omitted from the return type because no errors are returned from the function. See also: Values @import Errors Root Source File Source Encoding",
    "metadata": {
      "version": "0.13.0",
      "topic": "Hello World §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Comments §",
    "context": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly t",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-comment\">// Comments in Zig start with \"//\" and end at the next LF byte (end of line).</span>\n    <span class=\"tok-comment\">// The line below is a comment and won't be executed.</span>\n\n    <span class=\"tok-comment\">//print(\"Hello?\", .{});</span>\n\n    print(<span class=\"tok-str\">\"Hello, world!\\n\"</span>, .{}); <span class=\"tok-comment\">// another comment</span>\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Comments §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Comments §",
    "context": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly t",
    "response": "<span class=\"tok-comment\">/// A structure for storing a timestamp, with nanosecond precision (this is a</span>\n<span class=\"tok-comment\">/// multiline doc comment).</span>\n<span class=\"tok-kw\">const</span> Timestamp = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-comment\">/// The number of seconds since the epoch (this is also a doc comment).</span>\n    seconds: <span class=\"tok-type\">i64</span>, <span class=\"tok-comment\">// signed so we can represent pre-1970 (not a doc comment)</span>\n    <span class=\"tok-comment\">/// The number of nanoseconds past the second (doc comment again).</span>\n    nanos: <span class=\"tok-type\">u32</span>,\n\n    <span class=\"tok-comment\">/// Returns a `Timestamp` struct representing the Unix epoch; that is, the</span>\n    <span class=\"tok-comment\">/// moment of 1970 Jan 1 00:00:00 UTC (this is a doc comment too).</span>\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">unixEpoch</span>() Timestamp {\n        <span class=\"tok-kw\">return</span> Timestamp{\n            .seconds = <span class=\"tok-number\">0</span>,\n            .nanos = <span class=\"tok-number\">0</span>,\n        };\n    }\n};",
    "metadata": {
      "version": "0.13.0",
      "topic": "Comments §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Comments §",
    "context": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly t",
    "response": "<span class=\"tok-comment\">/// doc-comment</span>\n<span class=\"tok-comment\">//! top-level doc-comment</span>\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);",
    "metadata": {
      "version": "0.13.0",
      "topic": "Comments §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Comments §",
    "context": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly t",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {}\n\n<span class=\"tok-comment\">/// End of file</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Comments §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Comments §",
    "context": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly t",
    "response": "<span class=\"tok-comment\">//! This module provides functions for retrieving the current date and</span>\n<span class=\"tok-comment\">//! time with varying degrees of precision and accuracy. It does not</span>\n<span class=\"tok-comment\">//! depend on libc, but will use functions from it if available.</span>\n\n<span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-comment\">//! Top level comments are allowed inside a container other than a module,</span>\n    <span class=\"tok-comment\">//! but it is not very useful.  Currently, when producing the package</span>\n    <span class=\"tok-comment\">//! documentation, these comments are ignored.</span>\n};",
    "metadata": {
      "version": "0.13.0",
      "topic": "Comments §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Comments § in Zig 0.13.0",
    "context": "",
    "response": "Zig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation. The generated documentation is still experimental, and can be produced with: Shell comments.zig Shell There are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context. Doc Comments § A doc comment is one that begins with exactly three slashes (i.e. /// but not //// ); multiple doc comments in a row are merged together to form a multiline doc comment. The doc comment documents whatever immediately follows it. doc_comments.zig Doc comments are only allowed in certain places; it is a compile error to have a doc comment in an unexpected place, such as in the middle of an expression, or just before a non-doc comment. invalid_doc-comment.zig Shell unattached_doc-comment.zig Shell Doc comments can be interleaved with normal com",
    "metadata": {
      "version": "0.13.0",
      "topic": "Comments §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-comment\">// Top-level declarations are order-independent:</span>\n<span class=\"tok-kw\">const</span> print = std.debug.print;\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> os = std.os;\n<span class=\"tok-kw\">const</span> assert = std.debug.assert;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-comment\">// integers</span>\n    <span class=\"tok-kw\">const</span> one_plus_one: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span> + <span class=\"tok-number\">1</span>;\n    print(<span class=\"tok-str\">\"1 + 1 = {}\\n\"</span>, .{one_plus_one});\n\n    <span class=\"tok-comment\">// floats</span>\n    <span class=\"tok-kw\">const</span> seven_div_three: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">7.0</span> / <span class=\"tok-number\">3.0</span>;\n    print(<span class=\"tok-str\">\"7.0 / 3.0 = {}\\n\"</span>, .{seven_div_three});\n\n    <span class=\"tok-comment\">// boolean</span>\n    print(<span class=\"tok-str\">\"{}\\n{}\\n{}\\n\"</span>, .{\n        <span class=\"tok-null\">true</span> <span class=\"tok-kw\">and</span> <span class=\"tok-null\">false</span>,\n        <span class=\"tok-null\">true</span> <span class=\"tok-kw\">or</span> <span class=\"tok-null\">false</span>,\n        !<span class=\"tok-null\">true</span>,\n    });\n\n    <span class=\"tok-comment\">// optional</span>\n    <span class=\"tok-kw\">var</span> optional_value: ?[]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-null\">null</span>;\n    assert(optional_value == <span class=\"tok-null\">null</span>);\n\n    print(<span class=\"tok-str\">\"\\noptional 1\\ntype: {}\\nvalue: {?s}\\n\"</span>, .{\n        <span class=\"tok-builtin\">@TypeOf</span>(optional_value), optional_value,\n    });\n\n    optional_value = <span class=\"tok-str\">\"hi\"</span>;\n    assert(optional_value != <span class=\"tok-null\">null</span>);\n\n    print(<span class=\"tok-str\">\"\\noptional 2\\ntype: {}\\nvalue: {?s}\\n\"</span>, .{\n        <span class=\"tok-builtin\">@TypeOf</span>(optional_value), optional_value,\n    });\n\n    <span class=\"tok-comment\">// error union</span>\n    <span class=\"tok-kw\">var</span> number_or_error: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">i32</span> = <span class=\"tok-kw\">error</span>.ArgNotFound;\n\n    print(<span class=\"tok-str\">\"\\nerror union 1\\ntype: {}\\nvalue: {!}\\n\"</span>, .{\n        <span class=\"tok-builtin\">@TypeOf</span>(number_or_error),\n        number_or_error,\n    });\n\n    number_or_error = <span class=\"tok-number\">1234</span>;\n\n    print(<span class=\"tok-str\">\"\\nerror union 2\\ntype: {}\\nvalue: {!}\\n\"</span>, .{\n        <span class=\"tok-builtin\">@TypeOf</span>(number_or_error), number_or_error,\n    });\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Values §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem; <span class=\"tok-comment\">// will be used to compare bytes</span>\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> bytes = <span class=\"tok-str\">\"hello\"</span>;\n    print(<span class=\"tok-str\">\"{}\\n\"</span>, .{<span class=\"tok-builtin\">@TypeOf</span>(bytes)}); <span class=\"tok-comment\">// *const [5:0]u8</span>\n    print(<span class=\"tok-str\">\"{d}\\n\"</span>, .{bytes.len}); <span class=\"tok-comment\">// 5</span>\n    print(<span class=\"tok-str\">\"{c}\\n\"</span>, .{bytes[<span class=\"tok-number\">1</span>]}); <span class=\"tok-comment\">// 'e'</span>\n    print(<span class=\"tok-str\">\"{d}\\n\"</span>, .{bytes[<span class=\"tok-number\">5</span>]}); <span class=\"tok-comment\">// 0</span>\n    print(<span class=\"tok-str\">\"{}\\n\"</span>, .{<span class=\"tok-str\">'e'</span> == <span class=\"tok-str\">'\\x65'</span>}); <span class=\"tok-comment\">// true</span>\n    print(<span class=\"tok-str\">\"{d}\\n\"</span>, .{<span class=\"tok-str\">'\\u{1f4a9}'</span>}); <span class=\"tok-comment\">// 128169</span>\n    print(<span class=\"tok-str\">\"{d}\\n\"</span>, .{<span class=\"tok-str\">'💯'</span>}); <span class=\"tok-comment\">// 128175</span>\n    print(<span class=\"tok-str\">\"{u}\\n\"</span>, .{<span class=\"tok-str\">'⚡'</span>});\n    print(<span class=\"tok-str\">\"{}\\n\"</span>, .{mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-str\">\"hello\"</span>, <span class=\"tok-str\">\"h\\x65llo\"</span>)}); <span class=\"tok-comment\">// true</span>\n    print(<span class=\"tok-str\">\"{}\\n\"</span>, .{mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-str\">\"💯\"</span>, <span class=\"tok-str\">\"\\xf0\\x9f\\x92\\xaf\"</span>)}); <span class=\"tok-comment\">// also true</span>\n    <span class=\"tok-kw\">const</span> invalid_utf8 = <span class=\"tok-str\">\"\\xff\\xfe\"</span>; <span class=\"tok-comment\">// non-UTF-8 strings are possible with \\xNN notation.</span>\n    print(<span class=\"tok-str\">\"0x{x}\\n\"</span>, .{invalid_utf8[<span class=\"tok-number\">1</span>]}); <span class=\"tok-comment\">// indexing them returns individual bytes...</span>\n    print(<span class=\"tok-str\">\"0x{x}\\n\"</span>, .{<span class=\"tok-str\">\"💯\"</span>[<span class=\"tok-number\">1</span>]}); <span class=\"tok-comment\">// ...as does indexing part-way through non-ASCII characters</span>\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Values §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> hello_world_in_c =\n    <span class=\"tok-str\">\\\\#include <stdio.h>\n</span>    <span class=\"tok-str\">\\\\\n</span>    <span class=\"tok-str\">\\\\int main(int argc, char **argv) {\n</span>    <span class=\"tok-str\">\\\\    printf(\"hello world\\n\");\n</span>    <span class=\"tok-str\">\\\\    return 0;\n</span>    <span class=\"tok-str\">\\\\}\n</span>;",
    "metadata": {
      "version": "0.13.0",
      "topic": "Values §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> x = <span class=\"tok-number\">1234</span>;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-comment\">// It works at file scope as well as inside functions.</span>\n    <span class=\"tok-kw\">const</span> y = <span class=\"tok-number\">5678</span>;\n\n    <span class=\"tok-comment\">// Once assigned, an identifier cannot be changed.</span>\n    y += <span class=\"tok-number\">1</span>;\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    foo();\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Values §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">5678</span>;\n\n    y += <span class=\"tok-number\">1</span>;\n\n    print(<span class=\"tok-str\">\"{d}\"</span>, .{y});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Values §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span>;\n\n    x = <span class=\"tok-number\">1</span>;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Values §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Values §",
    "context": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintpt",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n    x = <span class=\"tok-number\">1</span>;\n    print(<span class=\"tok-str\">\"{d}\"</span>, .{x});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Values §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Values § in Zig 0.13.0",
    "context": "",
    "response": "values.zig Shell Primitive Types § Primitive Types Type C Equivalent Description i8 int8_t signed 8-bit integer u8 uint8_t unsigned 8-bit integer i16 int16_t signed 16-bit integer u16 uint16_t unsigned 16-bit integer i32 int32_t signed 32-bit integer u32 uint32_t unsigned 32-bit integer i64 int64_t signed 64-bit integer u64 uint64_t unsigned 64-bit integer i128 __int128 signed 128-bit integer u128 unsigned __int128 unsigned 128-bit integer isize intptr_t signed pointer sized integer usize uintptr_t , size_t unsigned pointer sized integer. Also see #5185 c_char char for ABI compatibility with C c_short short for ABI compatibility with C c_ushort unsigned short for ABI compatibility with C c_int int for ABI compatibility with C c_uint unsigned int for ABI compatibility with C c_long long for ABI compatibility with C c_ulong unsigned long for ABI compatibility with C c_longlong long long for ABI compatibility with C c_ulonglong unsigned long long for ABI compatibility with C c_longdouble ",
    "metadata": {
      "version": "0.13.0",
      "topic": "Values §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"expect addOne adds one to 41\"</span> {\n\n    <span class=\"tok-comment\">// The Standard Library contains useful functions to help create tests.</span>\n    <span class=\"tok-comment\">// `expect` is a function that verifies its argument is true.</span>\n    <span class=\"tok-comment\">// It will return an error if its argument is false to indicate a failure.</span>\n    <span class=\"tok-comment\">// `try` is used to return an error to the test runner to notify it that the test failed.</span>\n    <span class=\"tok-kw\">try</span> std.testing.expect(addOne(<span class=\"tok-number\">41</span>) == <span class=\"tok-number\">42</span>);\n}\n\n<span class=\"tok-kw\">test</span> addOne {\n    <span class=\"tok-comment\">// A test name can also be written using an identifier.</span>\n    <span class=\"tok-comment\">// This is a doctest, and serves as documentation for `addOne`.</span>\n    <span class=\"tok-kw\">try</span> std.testing.expect(addOne(<span class=\"tok-number\">41</span>) == <span class=\"tok-number\">42</span>);\n}\n\n<span class=\"tok-comment\">/// The function `addOne` adds one to the number given as its argument.</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">addOne</span>(number: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> number + <span class=\"tok-number\">1</span>;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"expect this to fail\"</span> {\n    <span class=\"tok-kw\">try</span> std.testing.expect(<span class=\"tok-null\">false</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"expect this to succeed\"</span> {\n    <span class=\"tok-kw\">try</span> std.testing.expect(<span class=\"tok-null\">true</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"this will be skipped\"</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.SkipZigTest;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"detect leak\"</span> {\n    <span class=\"tok-kw\">var</span> list = std.ArrayList(<span class=\"tok-type\">u21</span>).init(std.testing.allocator);\n    <span class=\"tok-comment\">// missing `defer list.deinit();`</span>\n    <span class=\"tok-kw\">try</span> list.append(<span class=\"tok-str\">'☔'</span>);\n\n    <span class=\"tok-kw\">try</span> std.testing.expect(list.items.len == <span class=\"tok-number\">1</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"builtin.is_test\"</span> {\n    <span class=\"tok-kw\">try</span> expect(isATest());\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">isATest</span>() <span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">return</span> builtin.is_test;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Zig Test §",
    "context": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Li",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"expectEqual demo\"</span> {\n    <span class=\"tok-kw\">const</span> expected: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">42</span>;\n    <span class=\"tok-kw\">const</span> actual = <span class=\"tok-number\">42</span>;\n\n    <span class=\"tok-comment\">// The first argument to `expectEqual` is the known, expected, result.</span>\n    <span class=\"tok-comment\">// The second argument is the result of some expression.</span>\n    <span class=\"tok-comment\">// The actual's type is casted to the type of expected.</span>\n    <span class=\"tok-kw\">try</span> std.testing.expectEqual(expected, actual);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"expectError demo\"</span> {\n    <span class=\"tok-kw\">const</span> expected_error = <span class=\"tok-kw\">error</span>.DemoError;\n    <span class=\"tok-kw\">const</span> actual_error_union: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">void</span> = <span class=\"tok-kw\">error</span>.DemoError;\n\n    <span class=\"tok-comment\">// `expectError` will fail when the actual error is different than</span>\n    <span class=\"tok-comment\">// the expected error.</span>\n    <span class=\"tok-kw\">try</span> std.testing.expectError(expected_error, actual_error_union);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Zig Test §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Zig Test § in Zig 0.13.0",
    "context": "",
    "response": "Code written within one or more test declarations can be used to ensure behavior meets expectations: testing_introduction.zig Shell The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41 . From this test's perspective, the addOne function is said to be code under test . zig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Library as its main entry point. During the build, test declarations found while resolving the given Zig source file are included for the default test runner to run and report on. This documentation discusses the features of the default test runner as provided by the Zig Standard Library. Its source code is located in lib/test_runner.zig . The shell output shown above displays two lines after the zig test command. These lines are printed to standard error by the default test runner: 1/2 testing_in",
    "metadata": {
      "version": "0.13.0",
      "topic": "Zig Test §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">const</span> @\"identifier with spaces in it\" = <span class=\"tok-number\">0xff</span>;\n<span class=\"tok-kw\">const</span> @\"1SmallStep4Man\" = <span class=\"tok-number\">112358</span>;\n\n<span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).c;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"c\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">@\"error\"</span>() <span class=\"tok-type\">void</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"c\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">@\"fstat$INODE64\"</span>(fd: c.fd_t, buf: *c.Stat) <span class=\"tok-type\">c_int</span>;\n\n<span class=\"tok-kw\">const</span> Color = <span class=\"tok-kw\">enum</span> {\n    red,\n    @\"really red\",\n};\n<span class=\"tok-kw\">const</span> color: Color = .@\"really red\";",
    "metadata": {
      "version": "0.13.0",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">i32</span> = add(<span class=\"tok-number\">10</span>, x);\n<span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">i32</span> = add(<span class=\"tok-number\">12</span>, <span class=\"tok-number\">34</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"container level variables\"</span> {\n    <span class=\"tok-kw\">try</span> expect(x == <span class=\"tok-number\">46</span>);\n    <span class=\"tok-kw\">try</span> expect(y == <span class=\"tok-number\">56</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> a + b;\n}\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;",
    "metadata": {
      "version": "0.13.0",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"namespaced container level variable\"</span> {\n    <span class=\"tok-kw\">try</span> expect(foo() == <span class=\"tok-number\">1235</span>);\n    <span class=\"tok-kw\">try</span> expect(foo() == <span class=\"tok-number\">1236</span>);\n}\n\n<span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">i32</span> {\n    S.x += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">return</span> S.x;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"static local variable\"</span> {\n    <span class=\"tok-kw\">try</span> expect(foo() == <span class=\"tok-number\">1235</span>);\n    <span class=\"tok-kw\">try</span> expect(foo() == <span class=\"tok-number\">1236</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> {\n        <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    };\n    S.x += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">return</span> S.x;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> assert = std.debug.assert;\n\n<span class=\"tok-kw\">threadlocal</span> <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"thread local storage\"</span> {\n    <span class=\"tok-kw\">const</span> thread1 = <span class=\"tok-kw\">try</span> std.Thread.spawn(.{}, testTls, .{});\n    <span class=\"tok-kw\">const</span> thread2 = <span class=\"tok-kw\">try</span> std.Thread.spawn(.{}, testTls, .{});\n    testTls();\n    thread1.join();\n    thread2.join();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">testTls</span>() <span class=\"tok-type\">void</span> {\n    assert(x == <span class=\"tok-number\">1234</span>);\n    x += <span class=\"tok-number\">1</span>;\n    assert(x == <span class=\"tok-number\">1235</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Variables §",
    "context": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both case",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"comptime vars\"</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n\n    x += <span class=\"tok-number\">1</span>;\n    y += <span class=\"tok-number\">1</span>;\n\n    <span class=\"tok-kw\">try</span> expect(x == <span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">try</span> expect(y == <span class=\"tok-number\">2</span>);\n\n    <span class=\"tok-kw\">if</span> (y != <span class=\"tok-number\">2</span>) {\n        <span class=\"tok-comment\">// This compile error never triggers because y is a comptime variable,</span>\n        <span class=\"tok-comment\">// and so `y != 2` is a comptime value, and this if is statically evaluated.</span>\n        <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"wrong y value\"</span>);\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Variables § in Zig 0.13.0",
    "context": "",
    "response": "A variable is a unit of Memory storage. It is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. The extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both cases, the type of the variable must be C ABI compatible. See also: Exporting a C Library Identifiers § Variable identifiers are never allowed to shadow identifiers from an outer scope. Identifiers must start with an alphabetic character or underscore and may be followed by any number of alphanumeric characters or underscores. They must not overlap with any keywords. See Keyword Reference . If a name that does not fit these requirements is needed, such as for linking with external libraries, the @&q",
    "metadata": {
      "version": "0.13.0",
      "topic": "Variables §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Integers §",
    "context": "Integer Literals § integer_literals.zig Runtime Integer Values § Integer literals have no size limitation, and if any undefined behavior occurs, the compiler catches it. However, once an integer value is no longer known at compile-time, it must have a known size, and is vulnerable to undefined behavior. runtime_vs_comptime.zig In this function, values a and b are known only at runtime, and thus this division operation is vulnerable to both Integer Overflow and Division by Zero . Operators such a",
    "response": "<span class=\"tok-kw\">const</span> decimal_int = <span class=\"tok-number\">98222</span>;\n<span class=\"tok-kw\">const</span> hex_int = <span class=\"tok-number\">0xff</span>;\n<span class=\"tok-kw\">const</span> another_hex_int = <span class=\"tok-number\">0xFF</span>;\n<span class=\"tok-kw\">const</span> octal_int = <span class=\"tok-number\">0o755</span>;\n<span class=\"tok-kw\">const</span> binary_int = <span class=\"tok-number\">0b11110000</span>;\n\n<span class=\"tok-comment\">// underscores may be placed between two digits as a visual separator</span>\n<span class=\"tok-kw\">const</span> one_billion = <span class=\"tok-number\">1_000_000_000</span>;\n<span class=\"tok-kw\">const</span> binary_mask = <span class=\"tok-number\">0b1_1111_1111</span>;\n<span class=\"tok-kw\">const</span> permissions = <span class=\"tok-number\">0o7_5_5</span>;\n<span class=\"tok-kw\">const</span> big_address = <span class=\"tok-number\">0xFF80_0000_0000_0000</span>;",
    "metadata": {
      "version": "0.13.0",
      "topic": "Integers §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Integers §",
    "context": "Integer Literals § integer_literals.zig Runtime Integer Values § Integer literals have no size limitation, and if any undefined behavior occurs, the compiler catches it. However, once an integer value is no longer known at compile-time, it must have a known size, and is vulnerable to undefined behavior. runtime_vs_comptime.zig In this function, values a and b are known only at runtime, and thus this division operation is vulnerable to both Integer Overflow and Division by Zero . Operators such a",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">divide</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> a / b;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Integers §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Integers § in Zig 0.13.0",
    "context": "",
    "response": "Integer Literals § integer_literals.zig Runtime Integer Values § Integer literals have no size limitation, and if any undefined behavior occurs, the compiler catches it. However, once an integer value is no longer known at compile-time, it must have a known size, and is vulnerable to undefined behavior. runtime_vs_comptime.zig In this function, values a and b are known only at runtime, and thus this division operation is vulnerable to both Integer Overflow and Division by Zero . Operators such as + and - cause undefined behavior on integer overflow. Alternative operators are provided for wrapping and saturating arithmetic on all targets. +% and -% perform wrapping arithmetic while +| and -| perform saturating arithmetic. Zig supports arbitrary bit-width integers, referenced by using an identifier of i or u followed by digits. For example, the identifier i7 refers to a signed 7-bit integer. The maximum allowed bit-width of an integer type is 65535 . For signed integer types, Zig uses a ",
    "metadata": {
      "version": "0.13.0",
      "topic": "Integers §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Floats §",
    "context": "Zig has the following floating point types: f16 - IEEE-754-2008 binary16 f32 - IEEE-754-2008 binary32 f64 - IEEE-754-2008 binary64 f80 - IEEE-754-2008 80-bit extended precision f128 - IEEE-754-2008 binary128 c_longdouble - matches long double for the target C ABI Float Literals § Float literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128 . Float literals coerce to any floating point type, and to an",
    "response": "<span class=\"tok-kw\">const</span> floating_point = <span class=\"tok-number\">123.0E+77</span>;\n<span class=\"tok-kw\">const</span> another_float = <span class=\"tok-number\">123.0</span>;\n<span class=\"tok-kw\">const</span> yet_another = <span class=\"tok-number\">123.0e+77</span>;\n\n<span class=\"tok-kw\">const</span> hex_floating_point = <span class=\"tok-number\">0x103.70p-5</span>;\n<span class=\"tok-kw\">const</span> another_hex_float = <span class=\"tok-number\">0x103.70</span>;\n<span class=\"tok-kw\">const</span> yet_another_hex_float = <span class=\"tok-number\">0x103.70P-5</span>;\n\n<span class=\"tok-comment\">// underscores may be placed between two digits as a visual separator</span>\n<span class=\"tok-kw\">const</span> lightspeed = <span class=\"tok-number\">299_792_458.000_000</span>;\n<span class=\"tok-kw\">const</span> nanosecond = <span class=\"tok-number\">0.000_000_001</span>;\n<span class=\"tok-kw\">const</span> more_hex = <span class=\"tok-number\">0x1234_5678.9ABC_CDEFp-10</span>;",
    "metadata": {
      "version": "0.13.0",
      "topic": "Floats §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Floats §",
    "context": "Zig has the following floating point types: f16 - IEEE-754-2008 binary16 f32 - IEEE-754-2008 binary32 f64 - IEEE-754-2008 binary64 f80 - IEEE-754-2008 80-bit extended precision f128 - IEEE-754-2008 binary128 c_longdouble - matches long double for the target C ABI Float Literals § Float literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128 . Float literals coerce to any floating point type, and to an",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> inf = std.math.inf(<span class=\"tok-type\">f32</span>);\n<span class=\"tok-kw\">const</span> negative_inf = -std.math.inf(<span class=\"tok-type\">f64</span>);\n<span class=\"tok-kw\">const</span> nan = std.math.nan(<span class=\"tok-type\">f128</span>);",
    "metadata": {
      "version": "0.13.0",
      "topic": "Floats §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Floats §",
    "context": "Zig has the following floating point types: f16 - IEEE-754-2008 binary16 f32 - IEEE-754-2008 binary32 f64 - IEEE-754-2008 binary64 f80 - IEEE-754-2008 80-bit extended precision f128 - IEEE-754-2008 binary128 c_longdouble - matches long double for the target C ABI Float Literals § Float literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128 . Float literals coerce to any floating point type, and to an",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> big = <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">f64</span>, <span class=\"tok-number\">1</span> << <span class=\"tok-number\">40</span>);\n\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo_strict</span>(x: <span class=\"tok-type\">f64</span>) <span class=\"tok-type\">f64</span> {\n    <span class=\"tok-kw\">return</span> x + big - big;\n}\n\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo_optimized</span>(x: <span class=\"tok-type\">f64</span>) <span class=\"tok-type\">f64</span> {\n    <span class=\"tok-builtin\">@setFloatMode</span>(.optimized);\n    <span class=\"tok-kw\">return</span> x + big - big;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Floats §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Floats §",
    "context": "Zig has the following floating point types: f16 - IEEE-754-2008 binary16 f32 - IEEE-754-2008 binary32 f64 - IEEE-754-2008 binary64 f80 - IEEE-754-2008 80-bit extended precision f128 - IEEE-754-2008 binary128 c_longdouble - matches long double for the target C ABI Float Literals § Float literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128 . Float literals coerce to any floating point type, and to an",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo_strict</span>(x: <span class=\"tok-type\">f64</span>) <span class=\"tok-type\">f64</span>;\n<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo_optimized</span>(x: <span class=\"tok-type\">f64</span>) <span class=\"tok-type\">f64</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> x = <span class=\"tok-number\">0.001</span>;\n    print(<span class=\"tok-str\">\"optimized = {}\\n\"</span>, .{foo_optimized(x)});\n    print(<span class=\"tok-str\">\"strict = {}\\n\"</span>, .{foo_strict(x)});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Floats §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Floats § in Zig 0.13.0",
    "context": "",
    "response": "Zig has the following floating point types: f16 - IEEE-754-2008 binary16 f32 - IEEE-754-2008 binary32 f64 - IEEE-754-2008 binary64 f80 - IEEE-754-2008 80-bit extended precision f128 - IEEE-754-2008 binary128 c_longdouble - matches long double for the target C ABI Float Literals § Float literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128 . Float literals coerce to any floating point type, and to any integer type when there is no fractional component. float_literals.zig There is no syntax for NaN, infinity, or negative infinity. For these special values, one must use the standard library: float_special_values.zig Floating Point Operations § By default floating point operations use Strict mode, but you can switch to Optimized mode on a per-block basis: float_mode_obj.zig Shell For this test we have to separate code into two object files - otherwise the optimizer figures out all the values a",
    "metadata": {
      "version": "0.13.0",
      "topic": "Floats §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a + b\na += b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">2</span> + <span class=\"tok-number\">5</span> == <span class=\"tok-number\">7</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a +% b\na +%= b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-number\">0xffffffff</span>) +% <span class=\"tok-number\">1</span> == <span class=\"tok-number\">0</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a +| b\na +|= b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">255</span>) +| <span class=\"tok-number\">1</span> == <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">255</span>)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a - b\na -= b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">2</span> - <span class=\"tok-number\">5</span> == -<span class=\"tok-number\">3</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a -% b\na -%= b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">0</span>) -% <span class=\"tok-number\">1</span> == <span class=\"tok-number\">255</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a -| b\na -|= b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-number\">0</span>) -| <span class=\"tok-number\">1</span> == <span class=\"tok-number\">0</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "-<span class=\"tok-number\">1</span> == <span class=\"tok-number\">0</span> - <span class=\"tok-number\">1</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "-%<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">i8</span>, -<span class=\"tok-number\">128</span>) == -<span class=\"tok-number\">128</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a * b\na *= b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">2</span> * <span class=\"tok-number\">5</span> == <span class=\"tok-number\">10</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a *% b\na *%= b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">200</span>) *% <span class=\"tok-number\">2</span> == <span class=\"tok-number\">144</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a *| b\na *|= b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">200</span>) *| <span class=\"tok-number\">2</span> == <span class=\"tok-number\">255</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a / b\na /= b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">10</span> / <span class=\"tok-number\">5</span> == <span class=\"tok-number\">2</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a % b\na %= b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">10</span> % <span class=\"tok-number\">3</span> == <span class=\"tok-number\">1</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a << b\na <<= b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">0b1</span> << <span class=\"tok-number\">8</span> == <span class=\"tok-number\">0b100000000</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <<| b\na <<|= b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">1</span>) <<| <span class=\"tok-number\">8</span> == <span class=\"tok-number\">255</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a >> b\na >>= b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">0b1010</span> >> <span class=\"tok-number\">1</span> == <span class=\"tok-number\">0b101</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a & b\na &= b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">0b011</span> & <span class=\"tok-number\">0b101</span> == <span class=\"tok-number\">0b001</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a | b\na |= b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">0b010</span> | <span class=\"tok-number\">0b100</span> == <span class=\"tok-number\">0b110</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a ^ b\na ^= b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-number\">0b011</span> ^ <span class=\"tok-number\">0b101</span> == <span class=\"tok-number\">0b110</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "~<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">0b10101111</span>) == <span class=\"tok-number\">0b01010000</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <span class=\"tok-kw\">orelse</span> b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> value: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-null\">null</span>;\n<span class=\"tok-kw\">const</span> unwrapped = value <span class=\"tok-kw\">orelse</span> <span class=\"tok-number\">1234</span>;\nunwrapped == <span class=\"tok-number\">1234</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <span class=\"tok-kw\">orelse</span> <span class=\"tok-kw\">unreachable</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> value: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">5678</span>;\nvalue.? == <span class=\"tok-number\">5678</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <span class=\"tok-kw\">catch</span> b\na <span class=\"tok-kw\">catch</span> |err| b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> value: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> = <span class=\"tok-kw\">error</span>.Broken;\n<span class=\"tok-kw\">const</span> unwrapped = value <span class=\"tok-kw\">catch</span> <span class=\"tok-number\">1234</span>;\nunwrapped == <span class=\"tok-number\">1234</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <span class=\"tok-kw\">and</span> b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-null\">false</span> <span class=\"tok-kw\">and</span> <span class=\"tok-null\">true</span>) == <span class=\"tok-null\">false</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a <span class=\"tok-kw\">or</span> b",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-null\">false</span> <span class=\"tok-kw\">or</span> <span class=\"tok-null\">true</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "!<span class=\"tok-null\">false</span> == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">1</span> == <span class=\"tok-number\">1</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a == <span class=\"tok-null\">null</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> value: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-null\">null</span>;\n(value == <span class=\"tok-null\">null</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">1</span> != <span class=\"tok-number\">1</span>) == <span class=\"tok-null\">false</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "a != <span class=\"tok-null\">null</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> value: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-null\">null</span>;\n(value != <span class=\"tok-null\">null</span>) == <span class=\"tok-null\">false</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">2</span> > <span class=\"tok-number\">1</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">2</span> >= <span class=\"tok-number\">1</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">1</span> < <span class=\"tok-number\">2</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "(<span class=\"tok-number\">1</span> <= <span class=\"tok-number\">2</span>) == <span class=\"tok-null\">true</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem;\n<span class=\"tok-kw\">const</span> array1 = [_]<span class=\"tok-type\">u32</span>{<span class=\"tok-number\">1</span>,<span class=\"tok-number\">2</span>};\n<span class=\"tok-kw\">const</span> array2 = [_]<span class=\"tok-type\">u32</span>{<span class=\"tok-number\">3</span>,<span class=\"tok-number\">4</span>};\n<span class=\"tok-kw\">const</span> together = array1 ++ array2;\nmem.eql(<span class=\"tok-type\">u32</span>, &together, &[_]<span class=\"tok-type\">u32</span>{<span class=\"tok-number\">1</span>,<span class=\"tok-number\">2</span>,<span class=\"tok-number\">3</span>,<span class=\"tok-number\">4</span>})",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem;\n<span class=\"tok-kw\">const</span> pattern = <span class=\"tok-str\">\"ab\"</span> ** <span class=\"tok-number\">3</span>;\nmem.eql(<span class=\"tok-type\">u8</span>, pattern, <span class=\"tok-str\">\"ababab\"</span>)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">1234</span>;\n<span class=\"tok-kw\">const</span> ptr = &x;\nptr.* == <span class=\"tok-number\">1234</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">1234</span>;\n<span class=\"tok-kw\">const</span> ptr = &x;\nptr.* == <span class=\"tok-number\">1234</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "<span class=\"tok-kw\">const</span> A = <span class=\"tok-kw\">error</span>{One};\n<span class=\"tok-kw\">const</span> B = <span class=\"tok-kw\">error</span>{Two};\n(A || B) == <span class=\"tok-kw\">error</span>{One, Two}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Operators §",
    "context": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes ",
    "response": "x() x[] x.y x.* x.?\na!b\nx{}\n!x -x -%x ~x &x ?x\n* / % ** *% *| ||\n+ - ++ +% -% +| -|\n<< >> <<|\n& ^ | <span class=\"tok-kw\">orelse</span> <span class=\"tok-kw\">catch</span>\n== != < > <= >=\n<span class=\"tok-kw\">and</span>\n<span class=\"tok-kw\">or</span>\n= *= *%= *|= /= %= += +%= +|= -= -%= -|= <<= <<|= >>= &= ^= |=",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Operators § in Zig 0.13.0",
    "context": "",
    "response": "There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. Table of Operators § Name Syntax Types Remarks Example Addition Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Wrapping Addition Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @addWithOverflow . Saturating Addition Integers Invokes Peer Type Resolution for the operands. Subtraction Integers Floats Can cause overflow for integers. Invokes Peer Type Resolution for the operands. See also @subWithOverflow . Wrapping Subtraction Integers Twos-complement wrapping behavior. Invokes Peer Type Resolution for the operands. See also @subWithOverflow . Saturating Subtraction Integers Invokes Peer Type Resolution for the operands. Negation Integers Floats Can cause overflow for integers. Wrapping Negation Integers Twos-complement wrapp",
    "metadata": {
      "version": "0.13.0",
      "topic": "Operators §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Arrays §",
    "context": "test_arrays.zig Shell See also: for Slices Multidimensional Arrays § Multidimensional arrays can be created by nesting arrays: test_multidimensional_arrays.zig Shell Sentinel-Terminated Arrays § The syntax [N:x]T describes an array which has a sentinel element of value x at the index corresponding to the length N . test_null_terminated_array.zig Shell See also: Sentinel-Terminated Pointers Sentinel-Terminated Slices",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n<span class=\"tok-kw\">const</span> assert = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.assert;\n<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem;\n\n<span class=\"tok-comment\">// array literal</span>\n<span class=\"tok-kw\">const</span> message = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'o'</span> };\n\n<span class=\"tok-comment\">// alternative initialization using result location</span>\n<span class=\"tok-kw\">const</span> alt_message: [<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span> = .{ <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'o'</span> };\n\n<span class=\"tok-kw\">comptime</span> {\n    assert(mem.eql(<span class=\"tok-type\">u8</span>, &message, &alt_message));\n}\n\n<span class=\"tok-comment\">// get the size of an array</span>\n<span class=\"tok-kw\">comptime</span> {\n    assert(message.len == <span class=\"tok-number\">5</span>);\n}\n\n<span class=\"tok-comment\">// A string literal is a single-item pointer to an array.</span>\n<span class=\"tok-kw\">const</span> same_message = <span class=\"tok-str\">\"hello\"</span>;\n\n<span class=\"tok-kw\">comptime</span> {\n    assert(mem.eql(<span class=\"tok-type\">u8</span>, &message, same_message));\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"iterate over an array\"</span> {\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">for</span> (message) |byte| {\n        sum += byte;\n    }\n    <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-str\">'h'</span> + <span class=\"tok-str\">'e'</span> + <span class=\"tok-str\">'l'</span> * <span class=\"tok-number\">2</span> + <span class=\"tok-str\">'o'</span>);\n}\n\n<span class=\"tok-comment\">// modifiable array</span>\n<span class=\"tok-kw\">var</span> some_integers: [<span class=\"tok-number\">100</span>]<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"modify an array\"</span> {\n    <span class=\"tok-kw\">for</span> (&some_integers, <span class=\"tok-number\">0</span>..) |*item, i| {\n        item.* = <span class=\"tok-builtin\">@intCast</span>(i);\n    }\n    <span class=\"tok-kw\">try</span> expect(some_integers[<span class=\"tok-number\">10</span>] == <span class=\"tok-number\">10</span>);\n    <span class=\"tok-kw\">try</span> expect(some_integers[<span class=\"tok-number\">99</span>] == <span class=\"tok-number\">99</span>);\n}\n\n<span class=\"tok-comment\">// array concatenation works if the values are known</span>\n<span class=\"tok-comment\">// at compile time</span>\n<span class=\"tok-kw\">const</span> part_one = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n<span class=\"tok-kw\">const</span> part_two = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span> };\n<span class=\"tok-kw\">const</span> all_of_it = part_one ++ part_two;\n<span class=\"tok-kw\">comptime</span> {\n    assert(mem.eql(<span class=\"tok-type\">i32</span>, &all_of_it, &[_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span> }));\n}\n\n<span class=\"tok-comment\">// remember that string literals are arrays</span>\n<span class=\"tok-kw\">const</span> hello = <span class=\"tok-str\">\"hello\"</span>;\n<span class=\"tok-kw\">const</span> world = <span class=\"tok-str\">\"world\"</span>;\n<span class=\"tok-kw\">const</span> hello_world = hello ++ <span class=\"tok-str\">\" \"</span> ++ world;\n<span class=\"tok-kw\">comptime</span> {\n    assert(mem.eql(<span class=\"tok-type\">u8</span>, hello_world, <span class=\"tok-str\">\"hello world\"</span>));\n}\n\n<span class=\"tok-comment\">// ** does repeating patterns</span>\n<span class=\"tok-kw\">const</span> pattern = <span class=\"tok-str\">\"ab\"</span> ** <span class=\"tok-number\">3</span>;\n<span class=\"tok-kw\">comptime</span> {\n    assert(mem.eql(<span class=\"tok-type\">u8</span>, pattern, <span class=\"tok-str\">\"ababab\"</span>));\n}\n\n<span class=\"tok-comment\">// initialize an array to zero</span>\n<span class=\"tok-kw\">const</span> all_zero = [_]<span class=\"tok-type\">u16</span>{<span class=\"tok-number\">0</span>} ** <span class=\"tok-number\">10</span>;\n\n<span class=\"tok-kw\">comptime</span> {\n    assert(all_zero.len == <span class=\"tok-number\">10</span>);\n    assert(all_zero[<span class=\"tok-number\">5</span>] == <span class=\"tok-number\">0</span>);\n}\n\n<span class=\"tok-comment\">// use compile-time code to initialize an array</span>\n<span class=\"tok-kw\">var</span> fancy_array = init: {\n    <span class=\"tok-kw\">var</span> initial_value: [<span class=\"tok-number\">10</span>]Point = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">for</span> (&initial_value, <span class=\"tok-number\">0</span>..) |*pt, i| {\n        pt.* = Point{\n            .x = <span class=\"tok-builtin\">@intCast</span>(i),\n            .y = <span class=\"tok-builtin\">@intCast</span>(i * <span class=\"tok-number\">2</span>),\n        };\n    }\n    <span class=\"tok-kw\">break</span> :init initial_value;\n};\n<span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> {\n    x: <span class=\"tok-type\">i32</span>,\n    y: <span class=\"tok-type\">i32</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"compile-time array initialization\"</span> {\n    <span class=\"tok-kw\">try</span> expect(fancy_array[<span class=\"tok-number\">4</span>].x == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(fancy_array[<span class=\"tok-number\">4</span>].y == <span class=\"tok-number\">8</span>);\n}\n\n<span class=\"tok-comment\">// call a function to initialize an array</span>\n<span class=\"tok-kw\">var</span> more_points = [_]Point{makePoint(<span class=\"tok-number\">3</span>)} ** <span class=\"tok-number\">10</span>;\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">makePoint</span>(x: <span class=\"tok-type\">i32</span>) Point {\n    <span class=\"tok-kw\">return</span> Point{\n        .x = x,\n        .y = x * <span class=\"tok-number\">2</span>,\n    };\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"array initialization with function calls\"</span> {\n    <span class=\"tok-kw\">try</span> expect(more_points[<span class=\"tok-number\">4</span>].x == <span class=\"tok-number\">3</span>);\n    <span class=\"tok-kw\">try</span> expect(more_points[<span class=\"tok-number\">4</span>].y == <span class=\"tok-number\">6</span>);\n    <span class=\"tok-kw\">try</span> expect(more_points.len == <span class=\"tok-number\">10</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Arrays §",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Arrays §",
    "context": "test_arrays.zig Shell See also: for Slices Multidimensional Arrays § Multidimensional arrays can be created by nesting arrays: test_multidimensional_arrays.zig Shell Sentinel-Terminated Arrays § The syntax [N:x]T describes an array which has a sentinel element of value x at the index corresponding to the length N . test_null_terminated_array.zig Shell See also: Sentinel-Terminated Pointers Sentinel-Terminated Slices",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> mat4x4 = [<span class=\"tok-number\">4</span>][<span class=\"tok-number\">4</span>]<span class=\"tok-type\">f32</span>{\n    [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span> },\n    [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span> },\n    [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span> },\n    [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span> },\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"multidimensional arrays\"</span> {\n    <span class=\"tok-comment\">// Access the 2D array by indexing the outer array, and then the inner array.</span>\n    <span class=\"tok-kw\">try</span> expect(mat4x4[<span class=\"tok-number\">1</span>][<span class=\"tok-number\">1</span>] == <span class=\"tok-number\">1.0</span>);\n\n    <span class=\"tok-comment\">// Here we iterate with for loops.</span>\n    <span class=\"tok-kw\">for</span> (mat4x4, <span class=\"tok-number\">0</span>..) |row, row_index| {\n        <span class=\"tok-kw\">for</span> (row, <span class=\"tok-number\">0</span>..) |cell, column_index| {\n            <span class=\"tok-kw\">if</span> (row_index == column_index) {\n                <span class=\"tok-kw\">try</span> expect(cell == <span class=\"tok-number\">1.0</span>);\n            }\n        }\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Arrays §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Arrays §",
    "context": "test_arrays.zig Shell See also: for Slices Multidimensional Arrays § Multidimensional arrays can be created by nesting arrays: test_multidimensional_arrays.zig Shell Sentinel-Terminated Arrays § The syntax [N:x]T describes an array which has a sentinel element of value x at the index corresponding to the length N . test_null_terminated_array.zig Shell See also: Sentinel-Terminated Pointers Sentinel-Terminated Slices",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"0-terminated sentinel array\"</span> {\n    <span class=\"tok-kw\">const</span> array = [_:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(array) == [<span class=\"tok-number\">4</span>:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>);\n    <span class=\"tok-kw\">try</span> expect(array.len == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">4</span>] == <span class=\"tok-number\">0</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"extra 0s in 0-terminated sentinel array\"</span> {\n    <span class=\"tok-comment\">// The sentinel value may appear earlier, but does not influence the compile-time 'len'.</span>\n    <span class=\"tok-kw\">const</span> array = [_:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span>, <span class=\"tok-number\">0</span>, <span class=\"tok-number\">4</span> };\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(array) == [<span class=\"tok-number\">4</span>:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>);\n    <span class=\"tok-kw\">try</span> expect(array.len == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">4</span>] == <span class=\"tok-number\">0</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Arrays §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Arrays § in Zig 0.13.0",
    "context": "",
    "response": "test_arrays.zig Shell See also: for Slices Multidimensional Arrays § Multidimensional arrays can be created by nesting arrays: test_multidimensional_arrays.zig Shell Sentinel-Terminated Arrays § The syntax [N:x]T describes an array which has a sentinel element of value x at the index corresponding to the length N . test_null_terminated_array.zig Shell See also: Sentinel-Terminated Pointers Sentinel-Terminated Slices",
    "metadata": {
      "version": "0.13.0",
      "topic": "Arrays §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Vectors §",
    "context": "A vector is a group of booleans, Integers , Floats , or Pointers which are operated on in parallel, using SIMD instructions if possible. Vector types are created with the builtin function @Vector . Vectors support the same builtin operators as their underlying base types. These operations are performed element-wise, and return a vector of the same length as the input vectors. This includes: Arithmetic ( + , - , / , * , @divFloor , @sqrt , @ceil , @log , etc.) Bitwise operators ( &gt;&gt; , &lt;&",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expectEqual = std.testing.expectEqual;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"Basic vector usage\"</span> {\n    <span class=\"tok-comment\">// Vectors have a compile-time known length and base type.</span>\n    <span class=\"tok-kw\">const</span> a = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">i32</span>){ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">i32</span>){ <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span> };\n\n    <span class=\"tok-comment\">// Math operations take place element-wise.</span>\n    <span class=\"tok-kw\">const</span> c = a + b;\n\n    <span class=\"tok-comment\">// Individual vector elements can be accessed using array indexing syntax.</span>\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">6</span>, c[<span class=\"tok-number\">0</span>]);\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">8</span>, c[<span class=\"tok-number\">1</span>]);\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">10</span>, c[<span class=\"tok-number\">2</span>]);\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">12</span>, c[<span class=\"tok-number\">3</span>]);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"Conversion between vectors, arrays, and slices\"</span> {\n    <span class=\"tok-comment\">// Vectors and fixed-length arrays can be automatically assigned back and forth</span>\n    <span class=\"tok-kw\">const</span> arr1: [<span class=\"tok-number\">4</span>]<span class=\"tok-type\">f32</span> = [_]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.1</span>, <span class=\"tok-number\">3.2</span>, <span class=\"tok-number\">4.5</span>, <span class=\"tok-number\">5.6</span> };\n    <span class=\"tok-kw\">const</span> vec: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">f32</span>) = arr1;\n    <span class=\"tok-kw\">const</span> arr2: [<span class=\"tok-number\">4</span>]<span class=\"tok-type\">f32</span> = vec;\n    <span class=\"tok-kw\">try</span> expectEqual(arr1, arr2);\n\n    <span class=\"tok-comment\">// You can also assign from a slice with comptime-known length to a vector using .*</span>\n    <span class=\"tok-kw\">const</span> vec2: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">2</span>, <span class=\"tok-type\">f32</span>) = arr1[<span class=\"tok-number\">1</span>..<span class=\"tok-number\">3</span>].*;\n\n    <span class=\"tok-kw\">const</span> slice: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">f32</span> = &arr1;\n    <span class=\"tok-kw\">var</span> offset: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">1</span>; <span class=\"tok-comment\">// var to make it runtime-known</span>\n    _ = &offset; <span class=\"tok-comment\">// suppress 'var is never mutated' error</span>\n    <span class=\"tok-comment\">// To extract a comptime-known length from a runtime-known offset,</span>\n    <span class=\"tok-comment\">// first extract a new slice from the starting offset, then an array of</span>\n    <span class=\"tok-comment\">// comptime-known length</span>\n    <span class=\"tok-kw\">const</span> vec3: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">2</span>, <span class=\"tok-type\">f32</span>) = slice[offset..][<span class=\"tok-number\">0</span>..<span class=\"tok-number\">2</span>].*;\n    <span class=\"tok-kw\">try</span> expectEqual(slice[offset], vec2[<span class=\"tok-number\">0</span>]);\n    <span class=\"tok-kw\">try</span> expectEqual(slice[offset + <span class=\"tok-number\">1</span>], vec2[<span class=\"tok-number\">1</span>]);\n    <span class=\"tok-kw\">try</span> expectEqual(vec2, vec3);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Vectors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Vectors § in Zig 0.13.0",
    "context": "",
    "response": "A vector is a group of booleans, Integers , Floats , or Pointers which are operated on in parallel, using SIMD instructions if possible. Vector types are created with the builtin function @Vector . Vectors support the same builtin operators as their underlying base types. These operations are performed element-wise, and return a vector of the same length as the input vectors. This includes: Arithmetic ( + , - , / , * , @divFloor , @sqrt , @ceil , @log , etc.) Bitwise operators ( &gt;&gt; , &lt;&lt; , &amp; , | , ~ , etc.) Comparison operators ( &lt; , &gt; , == , etc.) It is prohibited to use a math operator on a mixture of scalars (individual numbers) and vectors. Zig provides the @splat builtin to easily convert from scalars to vectors, and it supports @reduce and array indexing syntax to convert from vectors to scalars. Vectors also support assignment to and from fixed-length arrays with comptime-known length. For rearranging elements within and between vectors, Zig provides the @sh",
    "metadata": {
      "version": "0.13.0",
      "topic": "Vectors §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer arithmetic: ptr + x , ptr - x T must have a known size, which means that it cannot be anyopaque or any other opaque type . These types are closely related to Arrays and Slices : *[N]T - pointer to N items, same ",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"address of syntax\"</span> {\n    <span class=\"tok-comment\">// Get the address of a variable:</span>\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> x_ptr = &x;\n\n    <span class=\"tok-comment\">// Dereference a pointer:</span>\n    <span class=\"tok-kw\">try</span> expect(x_ptr.* == <span class=\"tok-number\">1234</span>);\n\n    <span class=\"tok-comment\">// When you get the address of a const variable, you get a const single-item pointer.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(x_ptr) == *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span>);\n\n    <span class=\"tok-comment\">// If you want to mutate the value, you'd need an address of a mutable variable:</span>\n    <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">5678</span>;\n    <span class=\"tok-kw\">const</span> y_ptr = &y;\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(y_ptr) == *<span class=\"tok-type\">i32</span>);\n    y_ptr.* += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(y_ptr.* == <span class=\"tok-number\">5679</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer array access\"</span> {\n    <span class=\"tok-comment\">// Taking an address of an individual element gives a</span>\n    <span class=\"tok-comment\">// single-item pointer. This kind of pointer</span>\n    <span class=\"tok-comment\">// does not support pointer arithmetic.</span>\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span>, <span class=\"tok-number\">9</span>, <span class=\"tok-number\">10</span> };\n    <span class=\"tok-kw\">const</span> ptr = &array[<span class=\"tok-number\">2</span>];\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(ptr) == *<span class=\"tok-type\">u8</span>);\n\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">2</span>] == <span class=\"tok-number\">3</span>);\n    ptr.* += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">2</span>] == <span class=\"tok-number\">4</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer arithmetic: ptr + x , ptr - x T must have a known size, which means that it cannot be anyopaque or any other opaque type . These types are closely related to Arrays and Slices : *[N]T - pointer to N items, same ",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer arithmetic with many-item pointer\"</span> {\n    <span class=\"tok-kw\">const</span> array = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n    <span class=\"tok-kw\">var</span> ptr: [*]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span> = &array;\n\n    <span class=\"tok-kw\">try</span> expect(ptr[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1</span>);\n    ptr += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(ptr[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">2</span>);\n\n    <span class=\"tok-comment\">// slicing a many-item pointer without an end is equivalent to</span>\n    <span class=\"tok-comment\">// pointer arithmetic: `ptr[start..] == ptr + start`</span>\n    <span class=\"tok-kw\">try</span> expect(ptr[<span class=\"tok-number\">1</span>..] == ptr + <span class=\"tok-number\">1</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer arithmetic with slices\"</span> {\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n    <span class=\"tok-kw\">var</span> length: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>; <span class=\"tok-comment\">// var to make it runtime-known</span>\n    _ = &length; <span class=\"tok-comment\">// suppress 'var is never mutated' error</span>\n    <span class=\"tok-kw\">var</span> slice = array[length..array.len];\n\n    <span class=\"tok-kw\">try</span> expect(slice[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(slice.len == <span class=\"tok-number\">4</span>);\n\n    slice.ptr += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-comment\">// now the slice is in an bad state since len has not been updated</span>\n\n    <span class=\"tok-kw\">try</span> expect(slice[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">try</span> expect(slice.len == <span class=\"tok-number\">4</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer arithmetic: ptr + x , ptr - x T must have a known size, which means that it cannot be anyopaque or any other opaque type . These types are closely related to Arrays and Slices : *[N]T - pointer to N items, same ",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer slicing\"</span> {\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>, <span class=\"tok-number\">7</span>, <span class=\"tok-number\">8</span>, <span class=\"tok-number\">9</span>, <span class=\"tok-number\">10</span> };\n    <span class=\"tok-kw\">var</span> start: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">2</span>; <span class=\"tok-comment\">// var to make it runtime-known</span>\n    _ = &start; <span class=\"tok-comment\">// suppress 'var is never mutated' error</span>\n    <span class=\"tok-kw\">const</span> slice = array[start..<span class=\"tok-number\">4</span>];\n    <span class=\"tok-kw\">try</span> expect(slice.len == <span class=\"tok-number\">2</span>);\n\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">3</span>] == <span class=\"tok-number\">4</span>);\n    slice[<span class=\"tok-number\">1</span>] += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">3</span>] == <span class=\"tok-number\">5</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer arithmetic: ptr + x , ptr - x T must have a known size, which means that it cannot be anyopaque or any other opaque type . These types are closely related to Arrays and Slices : *[N]T - pointer to N items, same ",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"comptime pointers\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">const</span> ptr = &x;\n        ptr.* += <span class=\"tok-number\">1</span>;\n        x += <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">try</span> expect(ptr.* == <span class=\"tok-number\">3</span>);\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer arithmetic: ptr + x , ptr - x T must have a known size, which means that it cannot be anyopaque or any other opaque type . These types are closely related to Arrays and Slices : *[N]T - pointer to N items, same ",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@intFromPtr and @ptrFromInt\"</span> {\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0xdeadbee0</span>);\n    <span class=\"tok-kw\">const</span> addr = <span class=\"tok-builtin\">@intFromPtr</span>(ptr);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(addr) == <span class=\"tok-type\">usize</span>);\n    <span class=\"tok-kw\">try</span> expect(addr == <span class=\"tok-number\">0xdeadbee0</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer arithmetic: ptr + x , ptr - x T must have a known size, which means that it cannot be anyopaque or any other opaque type . These types are closely related to Arrays and Slices : *[N]T - pointer to N items, same ",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"comptime @ptrFromInt\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-comment\">// Zig is able to do this at compile-time, as long as</span>\n        <span class=\"tok-comment\">// ptr is never dereferenced.</span>\n        <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0xdeadbee0</span>);\n        <span class=\"tok-kw\">const</span> addr = <span class=\"tok-builtin\">@intFromPtr</span>(ptr);\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(addr) == <span class=\"tok-type\">usize</span>);\n        <span class=\"tok-kw\">try</span> expect(addr == <span class=\"tok-number\">0xdeadbee0</span>);\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer arithmetic: ptr + x , ptr - x T must have a known size, which means that it cannot be anyopaque or any other opaque type . These types are closely related to Arrays and Slices : *[N]T - pointer to N items, same ",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"volatile\"</span> {\n    <span class=\"tok-kw\">const</span> mmio_ptr: *<span class=\"tok-kw\">volatile</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0x12345678</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(mmio_ptr) == *<span class=\"tok-kw\">volatile</span> <span class=\"tok-type\">u8</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer arithmetic: ptr + x , ptr - x T must have a known size, which means that it cannot be anyopaque or any other opaque type . These types are closely related to Arrays and Slices : *[N]T - pointer to N items, same ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer casting\"</span> {\n    <span class=\"tok-kw\">const</span> bytes <span class=\"tok-kw\">align</span>(<span class=\"tok-builtin\">@alignOf</span>(<span class=\"tok-type\">u32</span>)) = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">0x12</span>, <span class=\"tok-number\">0x12</span>, <span class=\"tok-number\">0x12</span>, <span class=\"tok-number\">0x12</span> };\n    <span class=\"tok-kw\">const</span> u32_ptr: *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u32</span> = <span class=\"tok-builtin\">@ptrCast</span>(&bytes);\n    <span class=\"tok-kw\">try</span> expect(u32_ptr.* == <span class=\"tok-number\">0x12121212</span>);\n\n    <span class=\"tok-comment\">// Even this example is contrived - there are better ways to do the above than</span>\n    <span class=\"tok-comment\">// pointer casting. For example, using a slice narrowing cast:</span>\n    <span class=\"tok-kw\">const</span> u32_value = std.mem.bytesAsSlice(<span class=\"tok-type\">u32</span>, bytes[<span class=\"tok-number\">0</span>..])[<span class=\"tok-number\">0</span>];\n    <span class=\"tok-kw\">try</span> expect(u32_value == <span class=\"tok-number\">0x12121212</span>);\n\n    <span class=\"tok-comment\">// And even another way, the most straightforward way to do it:</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-builtin\">@bitCast</span>(bytes)) == <span class=\"tok-number\">0x12121212</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer child type\"</span> {\n    <span class=\"tok-comment\">// pointer types have a `child` field which tells you the type they point to.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(*<span class=\"tok-type\">u32</span>).Pointer.child == <span class=\"tok-type\">u32</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer arithmetic: ptr + x , ptr - x T must have a known size, which means that it cannot be anyopaque or any other opaque type . These types are closely related to Arrays and Slices : *[N]T - pointer to N items, same ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"variable alignment\"</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> align_of_i32 = <span class=\"tok-builtin\">@alignOf</span>(<span class=\"tok-builtin\">@TypeOf</span>(x));\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&x) == *<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(*<span class=\"tok-type\">i32</span> == *<span class=\"tok-kw\">align</span>(align_of_i32) <span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">if</span> (builtin.target.cpu.arch == .x86_64) {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(*<span class=\"tok-type\">i32</span>).Pointer.alignment == <span class=\"tok-number\">4</span>);\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer arithmetic: ptr + x , ptr - x T must have a known size, which means that it cannot be anyopaque or any other opaque type . These types are closely related to Arrays and Slices : *[N]T - pointer to N items, same ",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">var</span> foo: <span class=\"tok-type\">u8</span> <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) = <span class=\"tok-number\">100</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"global variable alignment\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(&foo)).Pointer.alignment == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&foo) == *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">u8</span>);\n    <span class=\"tok-kw\">const</span> as_pointer_to_array: *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) [<span class=\"tok-number\">1</span>]<span class=\"tok-type\">u8</span> = &foo;\n    <span class=\"tok-kw\">const</span> as_slice: []<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">u8</span> = as_pointer_to_array;\n    <span class=\"tok-kw\">const</span> as_unaligned_slice: []<span class=\"tok-type\">u8</span> = as_slice;\n    <span class=\"tok-kw\">try</span> expect(as_unaligned_slice[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">100</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">derp</span>() <span class=\"tok-kw\">align</span>(<span class=\"tok-builtin\">@sizeOf</span>(<span class=\"tok-type\">usize</span>) * <span class=\"tok-number\">2</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">1234</span>;\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">noop1</span>() <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">1</span>) <span class=\"tok-type\">void</span> {}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">noop4</span>() <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">void</span> {}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"function alignment\"</span> {\n    <span class=\"tok-kw\">try</span> expect(derp() == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(derp) == <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&derp) == *<span class=\"tok-kw\">align</span>(<span class=\"tok-builtin\">@sizeOf</span>(<span class=\"tok-type\">usize</span>) * <span class=\"tok-number\">2</span>) <span class=\"tok-kw\">const</span> <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">i32</span>);\n\n    noop1();\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(noop1) == <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">void</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&noop1) == *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">1</span>) <span class=\"tok-kw\">const</span> <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">void</span>);\n\n    noop4();\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(noop4) == <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">void</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&noop4) == *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-kw\">const</span> <span class=\"tok-kw\">fn</span> () <span class=\"tok-type\">void</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer arithmetic: ptr + x , ptr - x T must have a known size, which means that it cannot be anyopaque or any other opaque type . These types are closely related to Arrays and Slices : *[N]T - pointer to N items, same ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer alignment safety\"</span> {\n    <span class=\"tok-kw\">var</span> array <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) = [_]<span class=\"tok-type\">u32</span>{ <span class=\"tok-number\">0x11111111</span>, <span class=\"tok-number\">0x11111111</span> };\n    <span class=\"tok-kw\">const</span> bytes = std.mem.sliceAsBytes(array[<span class=\"tok-number\">0</span>..]);\n    <span class=\"tok-kw\">try</span> std.testing.expect(foo(bytes) == <span class=\"tok-number\">0x11111111</span>);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(bytes: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">const</span> slice4 = bytes[<span class=\"tok-number\">1</span>..<span class=\"tok-number\">5</span>];\n    <span class=\"tok-kw\">const</span> int_slice = std.mem.bytesAsSlice(<span class=\"tok-type\">u32</span>, <span class=\"tok-builtin\">@as</span>([]<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">u8</span>, <span class=\"tok-builtin\">@alignCast</span>(slice4)));\n    <span class=\"tok-kw\">return</span> int_slice[<span class=\"tok-number\">0</span>];\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer arithmetic: ptr + x , ptr - x T must have a known size, which means that it cannot be anyopaque or any other opaque type . These types are closely related to Arrays and Slices : *[N]T - pointer to N items, same ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"allowzero\"</span> {\n    <span class=\"tok-kw\">var</span> zero: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>; <span class=\"tok-comment\">// var to make to runtime-known</span>\n    _ = &zero; <span class=\"tok-comment\">// suppress 'var is never mutated' error</span>\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-kw\">allowzero</span> <span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(zero);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromPtr</span>(ptr) == <span class=\"tok-number\">0</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Pointers §",
    "context": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer arithmetic: ptr + x , ptr - x T must have a known size, which means that it cannot be anyopaque or any other opaque type . These types are closely related to Arrays and Slices : *[N]T - pointer to N items, same ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-comment\">// This is also available as `std.c.printf`.</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"c\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">printf</span>(format: [*:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, ...) <span class=\"tok-type\">c_int</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">void</span> {\n    _ = printf(<span class=\"tok-str\">\"Hello, world!\\n\"</span>); <span class=\"tok-comment\">// OK</span>\n\n    <span class=\"tok-kw\">const</span> msg = <span class=\"tok-str\">\"Hello, world!\\n\"</span>;\n    <span class=\"tok-kw\">const</span> non_null_terminated_msg: [msg.len]<span class=\"tok-type\">u8</span> = msg.*;\n    _ = printf(&non_null_terminated_msg);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Pointers §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Pointers § in Zig 0.13.0",
    "context": "",
    "response": "Zig has two kinds of pointers: single-item and many-item. *T - single-item pointer to exactly one item. Supports deref syntax: ptr.* [*]T - many-item pointer to unknown number of items. Supports index syntax: ptr[i] Supports slice syntax: ptr[start..end] and ptr[start..] Supports pointer arithmetic: ptr + x , ptr - x T must have a known size, which means that it cannot be anyopaque or any other opaque type . These types are closely related to Arrays and Slices : *[N]T - pointer to N items, same as single-item pointer to an array. Supports index syntax: array_ptr[i] Supports slice syntax: array_ptr[start..end] Supports len property: array_ptr.len []T - is a slice (a fat pointer, which contains a pointer of type [*]T and a length). Supports index syntax: slice[i] Supports slice syntax: slice[start..end] Supports len property: slice.len Use &amp;x to obtain a single-item pointer: test_single_item_pointer.zig Shell Zig supports pointer arithmetic. It's better to assign the pointer to [*]T ",
    "metadata": {
      "version": "0.13.0",
      "topic": "Pointers §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Slices §",
    "context": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the `len` field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value ",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n<span class=\"tok-kw\">const</span> expectEqualSlices = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expectEqualSlices;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"basic slices\"</span> {\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n    <span class=\"tok-kw\">var</span> known_at_runtime_zero: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    _ = &known_at_runtime_zero;\n    <span class=\"tok-kw\">const</span> slice = array[known_at_runtime_zero..array.len];\n\n    <span class=\"tok-comment\">// alternative initialization using result location</span>\n    <span class=\"tok-kw\">const</span> alt_slice: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span> = &.{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n\n    <span class=\"tok-kw\">try</span> expectEqualSlices(<span class=\"tok-type\">i32</span>, slice, alt_slice);\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(slice) == []<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(&slice[<span class=\"tok-number\">0</span>] == &array[<span class=\"tok-number\">0</span>]);\n    <span class=\"tok-kw\">try</span> expect(slice.len == array.len);\n\n    <span class=\"tok-comment\">// If you slice with comptime-known start and end positions, the result is</span>\n    <span class=\"tok-comment\">// a pointer to an array, rather than a slice.</span>\n    <span class=\"tok-kw\">const</span> array_ptr = array[<span class=\"tok-number\">0</span>..array.len];\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(array_ptr) == *[array.len]<span class=\"tok-type\">i32</span>);\n\n    <span class=\"tok-comment\">// You can perform a slice-by-length by slicing twice. This allows the compiler</span>\n    <span class=\"tok-comment\">// to perform some optimisations like recognising a comptime-known length when</span>\n    <span class=\"tok-comment\">// the start position is only known at runtime.</span>\n    <span class=\"tok-kw\">var</span> runtime_start: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">1</span>;\n    _ = &runtime_start;\n    <span class=\"tok-kw\">const</span> length = <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">const</span> array_ptr_len = array[runtime_start..][<span class=\"tok-number\">0</span>..length];\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(array_ptr_len) == *[length]<span class=\"tok-type\">i32</span>);\n\n    <span class=\"tok-comment\">// Using the address-of operator on a slice gives a single-item pointer.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(&slice[<span class=\"tok-number\">0</span>]) == *<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-comment\">// Using the `ptr` field gives a many-item pointer.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(slice.ptr) == [*]<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromPtr</span>(slice.ptr) == <span class=\"tok-builtin\">@intFromPtr</span>(&slice[<span class=\"tok-number\">0</span>]));\n\n    <span class=\"tok-comment\">// Slices have array bounds checking. If you try to access something out</span>\n    <span class=\"tok-comment\">// of bounds, you'll get a safety check failure:</span>\n    slice[<span class=\"tok-number\">10</span>] += <span class=\"tok-number\">1</span>;\n\n    <span class=\"tok-comment\">// Note that `slice.ptr` does not invoke safety checking, while `&slice[0]`</span>\n    <span class=\"tok-comment\">// asserts that the slice has len > 0.</span>\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Slices §",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Slices §",
    "context": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the `len` field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> mem = std.mem;\n<span class=\"tok-kw\">const</span> fmt = std.fmt;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"using slices for strings\"</span> {\n    <span class=\"tok-comment\">// Zig has no concept of strings. String literals are const pointers</span>\n    <span class=\"tok-comment\">// to null-terminated arrays of u8, and by convention parameters</span>\n    <span class=\"tok-comment\">// that are \"strings\" are expected to be UTF-8 encoded slices of u8.</span>\n    <span class=\"tok-comment\">// Here we coerce *const [5:0]u8 and *const [6:0]u8 to []const u8</span>\n    <span class=\"tok-kw\">const</span> hello: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>;\n    <span class=\"tok-kw\">const</span> world: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"世界\"</span>;\n\n    <span class=\"tok-kw\">var</span> all_together: [<span class=\"tok-number\">100</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-comment\">// You can use slice syntax with at least one runtime-known index on an</span>\n    <span class=\"tok-comment\">// array to convert an array into a slice.</span>\n    <span class=\"tok-kw\">var</span> start: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    _ = &start;\n    <span class=\"tok-kw\">const</span> all_together_slice = all_together[start..];\n    <span class=\"tok-comment\">// String concatenation example.</span>\n    <span class=\"tok-kw\">const</span> hello_world = <span class=\"tok-kw\">try</span> fmt.bufPrint(all_together_slice, <span class=\"tok-str\">\"{s} {s}\"</span>, .{ hello, world });\n\n    <span class=\"tok-comment\">// Generally, you can use UTF-8 and not worry about whether something is a</span>\n    <span class=\"tok-comment\">// string. If you don't need to deal with individual characters, no need</span>\n    <span class=\"tok-comment\">// to decode.</span>\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, hello_world, <span class=\"tok-str\">\"hello 世界\"</span>));\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"slice pointer\"</span> {\n    <span class=\"tok-kw\">var</span> array: [<span class=\"tok-number\">10</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">const</span> ptr = &array;\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(ptr) == *[<span class=\"tok-number\">10</span>]<span class=\"tok-type\">u8</span>);\n\n    <span class=\"tok-comment\">// A pointer to an array can be sliced just like an array:</span>\n    <span class=\"tok-kw\">var</span> start: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">var</span> end: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">5</span>;\n    _ = .{ &start, &end };\n    <span class=\"tok-kw\">const</span> slice = ptr[start..end];\n    <span class=\"tok-comment\">// The slice is mutable because we sliced a mutable pointer.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(slice) == []<span class=\"tok-type\">u8</span>);\n    slice[<span class=\"tok-number\">2</span>] = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">try</span> expect(array[<span class=\"tok-number\">2</span>] == <span class=\"tok-number\">3</span>);\n\n    <span class=\"tok-comment\">// Again, slicing with comptime-known indexes will produce another pointer</span>\n    <span class=\"tok-comment\">// to an array:</span>\n    <span class=\"tok-kw\">const</span> ptr2 = slice[<span class=\"tok-number\">2</span>..<span class=\"tok-number\">3</span>];\n    <span class=\"tok-kw\">try</span> expect(ptr2.len == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(ptr2[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">3</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(ptr2) == *[<span class=\"tok-number\">1</span>]<span class=\"tok-type\">u8</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Slices §",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Slices §",
    "context": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the `len` field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"0-terminated slice\"</span> {\n    <span class=\"tok-kw\">const</span> slice: [:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>;\n\n    <span class=\"tok-kw\">try</span> expect(slice.len == <span class=\"tok-number\">5</span>);\n    <span class=\"tok-kw\">try</span> expect(slice[<span class=\"tok-number\">5</span>] == <span class=\"tok-number\">0</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Slices §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Slices §",
    "context": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the `len` field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"0-terminated slicing\"</span> {\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">3</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span> };\n    <span class=\"tok-kw\">var</span> runtime_length: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">3</span>;\n    _ = &runtime_length;\n    <span class=\"tok-kw\">const</span> slice = array[<span class=\"tok-number\">0</span>..runtime_length :<span class=\"tok-number\">0</span>];\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(slice) == [:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>);\n    <span class=\"tok-kw\">try</span> expect(slice.len == <span class=\"tok-number\">3</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Slices §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Slices §",
    "context": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the `len` field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"sentinel mismatch\"</span> {\n    <span class=\"tok-kw\">var</span> array = [_]<span class=\"tok-type\">u8</span>{ <span class=\"tok-number\">3</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span> };\n\n    <span class=\"tok-comment\">// Creating a sentinel-terminated slice from the array with a length of 2</span>\n    <span class=\"tok-comment\">// will result in the value `1` occupying the sentinel element position.</span>\n    <span class=\"tok-comment\">// This does not match the indicated sentinel value of `0` and will lead</span>\n    <span class=\"tok-comment\">// to a runtime panic.</span>\n    <span class=\"tok-kw\">var</span> runtime_length: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">2</span>;\n    _ = &runtime_length;\n    <span class=\"tok-kw\">const</span> slice = array[<span class=\"tok-number\">0</span>..runtime_length :<span class=\"tok-number\">0</span>];\n\n    _ = slice;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Slices §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Slices § in Zig 0.13.0",
    "context": "",
    "response": "A slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the `len` field. test_basic_slices.zig Shell This is one reason we prefer slices to pointers. test_slices.zig Shell See also: Pointers for Arrays Sentinel-Terminated Slices § The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value at the element indexed by the length. The type does not guarantee that there are no sentinel elements before that. Sentinel-terminated slices allow element access to the len index. test_null_terminated_slice.zig Shell Sentinel-terminated slices can also be created using a variation of the slice syntax data[start..end :x] , where data is a many-item pointer, array or slice and x is the sentinel value. test_null_terminated_slicing.zig Shell Sentinel-terminated slicing asserts that the element in t",
    "metadata": {
      "version": "0.13.0",
      "topic": "Slices §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: ba",
    "response": "<span class=\"tok-comment\">// Declare a struct.</span>\n<span class=\"tok-comment\">// Zig gives no guarantees about the order of fields and the size of</span>\n<span class=\"tok-comment\">// the struct but the fields are guaranteed to be ABI-aligned.</span>\n<span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> {\n    x: <span class=\"tok-type\">f32</span>,\n    y: <span class=\"tok-type\">f32</span>,\n};\n\n<span class=\"tok-comment\">// Maybe we want to pass it to OpenGL so we want to be particular about</span>\n<span class=\"tok-comment\">// how the bytes are arranged.</span>\n<span class=\"tok-kw\">const</span> Point2 = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    x: <span class=\"tok-type\">f32</span>,\n    y: <span class=\"tok-type\">f32</span>,\n};\n\n<span class=\"tok-comment\">// Declare an instance of a struct.</span>\n<span class=\"tok-kw\">const</span> p = Point{\n    .x = <span class=\"tok-number\">0.12</span>,\n    .y = <span class=\"tok-number\">0.34</span>,\n};\n\n<span class=\"tok-comment\">// Maybe we're not ready to fill out some of the fields.</span>\n<span class=\"tok-kw\">var</span> p2 = Point{\n    .x = <span class=\"tok-number\">0.12</span>,\n    .y = <span class=\"tok-null\">undefined</span>,\n};\n\n<span class=\"tok-comment\">// Structs can have methods</span>\n<span class=\"tok-comment\">// Struct methods are not special, they are only namespaced</span>\n<span class=\"tok-comment\">// functions that you can call with dot syntax.</span>\n<span class=\"tok-kw\">const</span> Vec3 = <span class=\"tok-kw\">struct</span> {\n    x: <span class=\"tok-type\">f32</span>,\n    y: <span class=\"tok-type\">f32</span>,\n    z: <span class=\"tok-type\">f32</span>,\n\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">init</span>(x: <span class=\"tok-type\">f32</span>, y: <span class=\"tok-type\">f32</span>, z: <span class=\"tok-type\">f32</span>) Vec3 {\n        <span class=\"tok-kw\">return</span> Vec3{\n            .x = x,\n            .y = y,\n            .z = z,\n        };\n    }\n\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">dot</span>(self: Vec3, other: Vec3) <span class=\"tok-type\">f32</span> {\n        <span class=\"tok-kw\">return</span> self.x * other.x + self.y * other.y + self.z * other.z;\n    }\n};\n\n<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"dot product\"</span> {\n    <span class=\"tok-kw\">const</span> v1 = Vec3.init(<span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">0.0</span>);\n    <span class=\"tok-kw\">const</span> v2 = Vec3.init(<span class=\"tok-number\">0.0</span>, <span class=\"tok-number\">1.0</span>, <span class=\"tok-number\">0.0</span>);\n    <span class=\"tok-kw\">try</span> expect(v1.dot(v2) == <span class=\"tok-number\">0.0</span>);\n\n    <span class=\"tok-comment\">// Other than being available to call with dot syntax, struct methods are</span>\n    <span class=\"tok-comment\">// not special. You can reference them as any other declaration inside</span>\n    <span class=\"tok-comment\">// the struct:</span>\n    <span class=\"tok-kw\">try</span> expect(Vec3.dot(v1, v2) == <span class=\"tok-number\">0.0</span>);\n}\n\n<span class=\"tok-comment\">// Structs can have declarations.</span>\n<span class=\"tok-comment\">// Structs can have 0 fields.</span>\n<span class=\"tok-kw\">const</span> Empty = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> PI = <span class=\"tok-number\">3.14</span>;\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"struct namespaced variable\"</span> {\n    <span class=\"tok-kw\">try</span> expect(Empty.PI == <span class=\"tok-number\">3.14</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@sizeOf</span>(Empty) == <span class=\"tok-number\">0</span>);\n\n    <span class=\"tok-comment\">// you can still instantiate an empty struct</span>\n    <span class=\"tok-kw\">const</span> does_nothing = Empty{};\n\n    _ = does_nothing;\n}\n\n<span class=\"tok-comment\">// struct field order is determined by the compiler for optimal performance.</span>\n<span class=\"tok-comment\">// however, you can still calculate a struct base pointer given a field pointer:</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">setYBasedOnX</span>(x: *<span class=\"tok-type\">f32</span>, y: <span class=\"tok-type\">f32</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> point: *Point = <span class=\"tok-builtin\">@fieldParentPtr</span>(<span class=\"tok-str\">\"x\"</span>, x);\n    point.y = y;\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"field parent pointer\"</span> {\n    <span class=\"tok-kw\">var</span> point = Point{\n        .x = <span class=\"tok-number\">0.1234</span>,\n        .y = <span class=\"tok-number\">0.5678</span>,\n    };\n    setYBasedOnX(&point.x, <span class=\"tok-number\">0.9</span>);\n    <span class=\"tok-kw\">try</span> expect(point.y == <span class=\"tok-number\">0.9</span>);\n}\n\n<span class=\"tok-comment\">// You can return a struct from a function. This is how we do generics</span>\n<span class=\"tok-comment\">// in Zig:</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">LinkedList</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">struct</span> {\n        <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> Node = <span class=\"tok-kw\">struct</span> {\n            prev: ?*Node,\n            next: ?*Node,\n            data: T,\n        };\n\n        first: ?*Node,\n        last: ?*Node,\n        len: <span class=\"tok-type\">usize</span>,\n    };\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"linked list\"</span> {\n    <span class=\"tok-comment\">// Functions called at compile-time are memoized. This means you can</span>\n    <span class=\"tok-comment\">// do this:</span>\n    <span class=\"tok-kw\">try</span> expect(LinkedList(<span class=\"tok-type\">i32</span>) == LinkedList(<span class=\"tok-type\">i32</span>));\n\n    <span class=\"tok-kw\">const</span> list = LinkedList(<span class=\"tok-type\">i32</span>){\n        .first = <span class=\"tok-null\">null</span>,\n        .last = <span class=\"tok-null\">null</span>,\n        .len = <span class=\"tok-number\">0</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(list.len == <span class=\"tok-number\">0</span>);\n\n    <span class=\"tok-comment\">// Since types are first class values you can instantiate the type</span>\n    <span class=\"tok-comment\">// by assigning it to a variable:</span>\n    <span class=\"tok-kw\">const</span> ListOfInts = LinkedList(<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(ListOfInts == LinkedList(<span class=\"tok-type\">i32</span>));\n\n    <span class=\"tok-kw\">var</span> node = ListOfInts.Node{\n        .prev = <span class=\"tok-null\">null</span>,\n        .next = <span class=\"tok-null\">null</span>,\n        .data = <span class=\"tok-number\">1234</span>,\n    };\n    <span class=\"tok-kw\">const</span> list2 = LinkedList(<span class=\"tok-type\">i32</span>){\n        .first = &node,\n        .last = &node,\n        .len = <span class=\"tok-number\">1</span>,\n    };\n\n    <span class=\"tok-comment\">// When using a pointer to a struct, fields can be accessed directly,</span>\n    <span class=\"tok-comment\">// without explicitly dereferencing the pointer.</span>\n    <span class=\"tok-comment\">// So you can do</span>\n    <span class=\"tok-kw\">try</span> expect(list2.first.?.data == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-comment\">// instead of try expect(list2.first.?.*.data == 1234);</span>\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: ba",
    "response": "<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>,\n    b: <span class=\"tok-type\">i32</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"default struct initialization fields\"</span> {\n    <span class=\"tok-kw\">const</span> x: Foo = .{\n        .b = <span class=\"tok-number\">5</span>,\n    };\n    <span class=\"tok-kw\">if</span> (x.a + x.b != <span class=\"tok-number\">1239</span>) {\n        <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">unreachable</span>;\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: ba",
    "response": "<span class=\"tok-kw\">const</span> Threshold = <span class=\"tok-kw\">struct</span> {\n    minimum: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">0.25</span>,\n    maximum: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">0.75</span>,\n\n    <span class=\"tok-kw\">const</span> Category = <span class=\"tok-kw\">enum</span> { low, medium, high };\n\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">categorize</span>(t: Threshold, value: <span class=\"tok-type\">f32</span>) Category {\n        assert(t.maximum >= t.minimum);\n        <span class=\"tok-kw\">if</span> (value < t.minimum) <span class=\"tok-kw\">return</span> .low;\n        <span class=\"tok-kw\">if</span> (value > t.maximum) <span class=\"tok-kw\">return</span> .high;\n        <span class=\"tok-kw\">return</span> .medium;\n    }\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> threshold: Threshold = .{\n        .maximum = <span class=\"tok-number\">0.20</span>,\n    };\n    <span class=\"tok-kw\">const</span> category = threshold.categorize(<span class=\"tok-number\">0.90</span>);\n    <span class=\"tok-kw\">try</span> std.io.getStdOut().writeAll(<span class=\"tok-builtin\">@tagName</span>(category));\n}\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> assert = std.debug.assert;",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: ba",
    "response": "<span class=\"tok-kw\">const</span> Threshold = <span class=\"tok-kw\">struct</span> {\n    minimum: <span class=\"tok-type\">f32</span>,\n    maximum: <span class=\"tok-type\">f32</span>,\n\n    <span class=\"tok-kw\">const</span> default: Threshold = .{\n        .minimum = <span class=\"tok-number\">0.25</span>,\n        .maximum = <span class=\"tok-number\">0.75</span>,\n    };\n};",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: ba",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> native_endian = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>).target.cpu.arch.endian();\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Full = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    number: <span class=\"tok-type\">u16</span>,\n};\n<span class=\"tok-kw\">const</span> Divided = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    half1: <span class=\"tok-type\">u8</span>,\n    quarter3: <span class=\"tok-type\">u4</span>,\n    quarter4: <span class=\"tok-type\">u4</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@bitCast between packed structs\"</span> {\n    <span class=\"tok-kw\">try</span> doTheTest();\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> doTheTest();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doTheTest</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@sizeOf</span>(Full) == <span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@sizeOf</span>(Divided) == <span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">const</span> full = Full{ .number = <span class=\"tok-number\">0x1234</span> };\n    <span class=\"tok-kw\">const</span> divided: Divided = <span class=\"tok-builtin\">@bitCast</span>(full);\n    <span class=\"tok-kw\">try</span> expect(divided.half1 == <span class=\"tok-number\">0x34</span>);\n    <span class=\"tok-kw\">try</span> expect(divided.quarter3 == <span class=\"tok-number\">0x2</span>);\n    <span class=\"tok-kw\">try</span> expect(divided.quarter4 == <span class=\"tok-number\">0x1</span>);\n\n    <span class=\"tok-kw\">const</span> ordered: [<span class=\"tok-number\">2</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@bitCast</span>(full);\n    <span class=\"tok-kw\">switch</span> (native_endian) {\n        .big => {\n            <span class=\"tok-kw\">try</span> expect(ordered[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">0x12</span>);\n            <span class=\"tok-kw\">try</span> expect(ordered[<span class=\"tok-number\">1</span>] == <span class=\"tok-number\">0x34</span>);\n        },\n        .little => {\n            <span class=\"tok-kw\">try</span> expect(ordered[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">0x34</span>);\n            <span class=\"tok-kw\">try</span> expect(ordered[<span class=\"tok-number\">1</span>] == <span class=\"tok-number\">0x12</span>);\n        },\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: ba",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"missized packed struct\"</span> {\n    <span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span>(<span class=\"tok-type\">u32</span>) { a: <span class=\"tok-type\">u16</span>, b: <span class=\"tok-type\">u8</span> };\n    _ = S{ .a = <span class=\"tok-number\">4</span>, .b = <span class=\"tok-number\">2</span> };\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: ba",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> BitField = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">u3</span>,\n    b: <span class=\"tok-type\">u3</span>,\n    c: <span class=\"tok-type\">u2</span>,\n};\n\n<span class=\"tok-kw\">var</span> foo = BitField{\n    .a = <span class=\"tok-number\">1</span>,\n    .b = <span class=\"tok-number\">2</span>,\n    .c = <span class=\"tok-number\">3</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer to non-byte-aligned field\"</span> {\n    <span class=\"tok-kw\">const</span> ptr = &foo.b;\n    <span class=\"tok-kw\">try</span> expect(ptr.* == <span class=\"tok-number\">2</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: ba",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> BitField = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">u3</span>,\n    b: <span class=\"tok-type\">u3</span>,\n    c: <span class=\"tok-type\">u2</span>,\n};\n\n<span class=\"tok-kw\">var</span> bit_field = BitField{\n    .a = <span class=\"tok-number\">1</span>,\n    .b = <span class=\"tok-number\">2</span>,\n    .c = <span class=\"tok-number\">3</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointer to non-byte-aligned field\"</span> {\n    <span class=\"tok-kw\">try</span> expect(bar(&bit_field.b) == <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>(x: *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u3</span>) <span class=\"tok-type\">u3</span> {\n    <span class=\"tok-kw\">return</span> x.*;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: ba",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> BitField = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">u3</span>,\n    b: <span class=\"tok-type\">u3</span>,\n    c: <span class=\"tok-type\">u2</span>,\n};\n\n<span class=\"tok-kw\">var</span> bit_field = BitField{\n    .a = <span class=\"tok-number\">1</span>,\n    .b = <span class=\"tok-number\">2</span>,\n    .c = <span class=\"tok-number\">3</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pointers of sub-byte-aligned fields share addresses\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromPtr</span>(&bit_field.a) == <span class=\"tok-builtin\">@intFromPtr</span>(&bit_field.b));\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromPtr</span>(&bit_field.a) == <span class=\"tok-builtin\">@intFromPtr</span>(&bit_field.c));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: ba",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> BitField = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">u3</span>,\n    b: <span class=\"tok-type\">u3</span>,\n    c: <span class=\"tok-type\">u2</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"offsets of non-byte-aligned fields\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@bitOffsetOf</span>(BitField, <span class=\"tok-str\">\"a\"</span>) == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@bitOffsetOf</span>(BitField, <span class=\"tok-str\">\"b\"</span>) == <span class=\"tok-number\">3</span>);\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@bitOffsetOf</span>(BitField, <span class=\"tok-str\">\"c\"</span>) == <span class=\"tok-number\">6</span>);\n\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@offsetOf</span>(BitField, <span class=\"tok-str\">\"a\"</span>) == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@offsetOf</span>(BitField, <span class=\"tok-str\">\"b\"</span>) == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@offsetOf</span>(BitField, <span class=\"tok-str\">\"c\"</span>) == <span class=\"tok-number\">0</span>);\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: ba",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">packed</span> <span class=\"tok-kw\">struct</span> {\n    a: <span class=\"tok-type\">u32</span>,\n    b: <span class=\"tok-type\">u32</span>,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"overaligned pointer to packed struct\"</span> {\n    <span class=\"tok-kw\">var</span> foo: S <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) = .{ .a = <span class=\"tok-number\">1</span>, .b = <span class=\"tok-number\">2</span> };\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) S = &foo;\n    <span class=\"tok-kw\">const</span> ptr_to_b: *<span class=\"tok-type\">u32</span> = &ptr.b;\n    <span class=\"tok-kw\">try</span> expect(ptr_to_b.* == <span class=\"tok-number\">2</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: ba",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expectEqual = std.testing.expectEqual;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"aligned struct fields\"</span> {\n    <span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> {\n        a: <span class=\"tok-type\">u32</span> <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">2</span>),\n        b: <span class=\"tok-type\">u32</span> <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">64</span>),\n    };\n    <span class=\"tok-kw\">var</span> foo = S{ .a = <span class=\"tok-number\">1</span>, .b = <span class=\"tok-number\">2</span> };\n\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-number\">64</span>, <span class=\"tok-builtin\">@alignOf</span>(S));\n    <span class=\"tok-kw\">try</span> expectEqual(*<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">2</span>) <span class=\"tok-type\">u32</span>, <span class=\"tok-builtin\">@TypeOf</span>(&foo.a));\n    <span class=\"tok-kw\">try</span> expectEqual(*<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">64</span>) <span class=\"tok-type\">u32</span>, <span class=\"tok-builtin\">@TypeOf</span>(&foo.b));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: ba",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">struct</span> {};\n    std.debug.print(<span class=\"tok-str\">\"variable: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@typeName</span>(Foo)});\n    std.debug.print(<span class=\"tok-str\">\"anonymous: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@typeName</span>(<span class=\"tok-kw\">struct</span> {})});\n    std.debug.print(<span class=\"tok-str\">\"function: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@typeName</span>(List(<span class=\"tok-type\">i32</span>))});\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">List</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">struct</span> {\n        x: T,\n    };\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: ba",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> { x: <span class=\"tok-type\">i32</span>, y: <span class=\"tok-type\">i32</span> };\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"anonymous struct literal\"</span> {\n    <span class=\"tok-kw\">const</span> pt: Point = .{\n        .x = <span class=\"tok-number\">13</span>,\n        .y = <span class=\"tok-number\">67</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(pt.x == <span class=\"tok-number\">13</span>);\n    <span class=\"tok-kw\">try</span> expect(pt.y == <span class=\"tok-number\">67</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: ba",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fully anonymous struct\"</span> {\n    <span class=\"tok-kw\">try</span> check(.{\n        .int = <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-number\">1234</span>),\n        .float = <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">f64</span>, <span class=\"tok-number\">12.34</span>),\n        .b = <span class=\"tok-null\">true</span>,\n        .s = <span class=\"tok-str\">\"hi\"</span>,\n    });\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">check</span>(args: <span class=\"tok-kw\">anytype</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> expect(args.int == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> expect(args.float == <span class=\"tok-number\">12.34</span>);\n    <span class=\"tok-kw\">try</span> expect(args.b);\n    <span class=\"tok-kw\">try</span> expect(args.s[<span class=\"tok-number\">0</span>] == <span class=\"tok-str\">'h'</span>);\n    <span class=\"tok-kw\">try</span> expect(args.s[<span class=\"tok-number\">1</span>] == <span class=\"tok-str\">'i'</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: struct §",
    "context": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: ba",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"tuple\"</span> {\n    <span class=\"tok-kw\">const</span> values = .{\n        <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-number\">1234</span>),\n        <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">f64</span>, <span class=\"tok-number\">12.34</span>),\n        <span class=\"tok-null\">true</span>,\n        <span class=\"tok-str\">\"hi\"</span>,\n    } ++ .{<span class=\"tok-null\">false</span>} ** <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">try</span> expect(values[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> expect(values[<span class=\"tok-number\">4</span>] == <span class=\"tok-null\">false</span>);\n    <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">for</span> (values, <span class=\"tok-number\">0</span>..) |v, i| {\n        <span class=\"tok-kw\">if</span> (i != <span class=\"tok-number\">2</span>) <span class=\"tok-kw\">continue</span>;\n        <span class=\"tok-kw\">try</span> expect(v);\n    }\n    <span class=\"tok-kw\">try</span> expect(values.len == <span class=\"tok-number\">6</span>);\n    <span class=\"tok-kw\">try</span> expect(values.@\"3\"[<span class=\"tok-number\">0</span>] == <span class=\"tok-str\">'h'</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain struct § in Zig 0.13.0",
    "context": "",
    "response": "test_structs.zig Shell Default Field Values § Each struct field may have an expression indicating the default field value. Such expressions are executed at comptime , and allow the field to be omitted in a struct literal expression: struct_default_field_values.zig Shell Default field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization. For example, here is an inappropriate use of default struct field initialization: bad_default_value.zig Shell Above you can see the danger of ignoring this principle. The default field values caused the data invariant to be violated, causing illegal behavior. To fix this, remove the default values from all the struct fields, and provide a named default value: struct_default_value.zig If a struct value requires a runtime-known value in order to be initialized without violating data invariants, then use an initialization method that accepts those runtime values, and populates the",
    "metadata": {
      "version": "0.13.0",
      "topic": "struct §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: enum §",
    "context": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum mus",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem;\n\n<span class=\"tok-comment\">// Declare an enum.</span>\n<span class=\"tok-kw\">const</span> Type = <span class=\"tok-kw\">enum</span> {\n    ok,\n    not_ok,\n};\n\n<span class=\"tok-comment\">// Declare a specific enum field.</span>\n<span class=\"tok-kw\">const</span> c = Type.ok;\n\n<span class=\"tok-comment\">// If you want access to the ordinal value of an enum, you</span>\n<span class=\"tok-comment\">// can specify the tag type.</span>\n<span class=\"tok-kw\">const</span> Value = <span class=\"tok-kw\">enum</span>(<span class=\"tok-type\">u2</span>) {\n    zero,\n    one,\n    two,\n};\n<span class=\"tok-comment\">// Now you can cast between u2 and Value.</span>\n<span class=\"tok-comment\">// The ordinal value starts from 0, counting up by 1 from the previous member.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum ordinal value\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value.zero) == <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value.one) == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value.two) == <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-comment\">// You can override the ordinal value for an enum.</span>\n<span class=\"tok-kw\">const</span> Value2 = <span class=\"tok-kw\">enum</span>(<span class=\"tok-type\">u32</span>) {\n    hundred = <span class=\"tok-number\">100</span>,\n    thousand = <span class=\"tok-number\">1000</span>,\n    million = <span class=\"tok-number\">1000000</span>,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"set enum ordinal value\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value2.hundred) == <span class=\"tok-number\">100</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value2.thousand) == <span class=\"tok-number\">1000</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value2.million) == <span class=\"tok-number\">1000000</span>);\n}\n\n<span class=\"tok-comment\">// You can also override only some values.</span>\n<span class=\"tok-kw\">const</span> Value3 = <span class=\"tok-kw\">enum</span>(<span class=\"tok-type\">u4</span>) {\n    a,\n    b = <span class=\"tok-number\">8</span>,\n    c,\n    d = <span class=\"tok-number\">4</span>,\n    e,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum implicit ordinal values and overridden values\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value3.a) == <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value3.b) == <span class=\"tok-number\">8</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value3.c) == <span class=\"tok-number\">9</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value3.d) == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@intFromEnum</span>(Value3.e) == <span class=\"tok-number\">5</span>);\n}\n\n<span class=\"tok-comment\">// Enums can have methods, the same as structs and unions.</span>\n<span class=\"tok-comment\">// Enum methods are not special, they are only namespaced</span>\n<span class=\"tok-comment\">// functions that you can call with dot syntax.</span>\n<span class=\"tok-kw\">const</span> Suit = <span class=\"tok-kw\">enum</span> {\n    clubs,\n    spades,\n    diamonds,\n    hearts,\n\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">isClubs</span>(self: Suit) <span class=\"tok-type\">bool</span> {\n        <span class=\"tok-kw\">return</span> self == Suit.clubs;\n    }\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum method\"</span> {\n    <span class=\"tok-kw\">const</span> p = Suit.spades;\n    <span class=\"tok-kw\">try</span> expect(!p.isClubs());\n}\n\n<span class=\"tok-comment\">// An enum can be switched upon.</span>\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">enum</span> {\n    string,\n    number,\n    none,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum switch\"</span> {\n    <span class=\"tok-kw\">const</span> p = Foo.number;\n    <span class=\"tok-kw\">const</span> what_is_it = <span class=\"tok-kw\">switch</span> (p) {\n        Foo.string => <span class=\"tok-str\">\"this is a string\"</span>,\n        Foo.number => <span class=\"tok-str\">\"this is a number\"</span>,\n        Foo.none => <span class=\"tok-str\">\"this is a none\"</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, what_is_it, <span class=\"tok-str\">\"this is a number\"</span>));\n}\n\n<span class=\"tok-comment\">// @typeInfo can be used to access the integer tag type of an enum.</span>\n<span class=\"tok-kw\">const</span> Small = <span class=\"tok-kw\">enum</span> {\n    one,\n    two,\n    three,\n    four,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"std.meta.Tag\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(Small).Enum.tag_type == <span class=\"tok-type\">u2</span>);\n}\n\n<span class=\"tok-comment\">// @typeInfo tells us the field count and the fields names:</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@typeInfo\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(Small).Enum.fields.len == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-builtin\">@typeInfo</span>(Small).Enum.fields[<span class=\"tok-number\">1</span>].name, <span class=\"tok-str\">\"two\"</span>));\n}\n\n<span class=\"tok-comment\">// @tagName gives a [:0]const u8 representation of an enum value:</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@tagName\"</span> {\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-builtin\">@tagName</span>(Small.three), <span class=\"tok-str\">\"three\"</span>));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "enum §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: enum §",
    "context": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum mus",
    "response": "<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">enum</span> { a, b, c };\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">entry</span>(foo: Foo) <span class=\"tok-type\">void</span> {\n    _ = foo;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "enum §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: enum §",
    "context": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum mus",
    "response": "<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">enum</span>(<span class=\"tok-type\">c_int</span>) { a, b, c };\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">entry</span>(foo: Foo) <span class=\"tok-type\">void</span> {\n    _ = foo;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "enum §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: enum §",
    "context": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum mus",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Color = <span class=\"tok-kw\">enum</span> {\n    auto,\n    off,\n    on,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum literals\"</span> {\n    <span class=\"tok-kw\">const</span> color1: Color = .auto;\n    <span class=\"tok-kw\">const</span> color2 = Color.auto;\n    <span class=\"tok-kw\">try</span> expect(color1 == color2);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch using enum literals\"</span> {\n    <span class=\"tok-kw\">const</span> color = Color.on;\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">switch</span> (color) {\n        .auto => <span class=\"tok-null\">false</span>,\n        .on => <span class=\"tok-null\">true</span>,\n        .off => <span class=\"tok-null\">false</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(result);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "enum §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: enum §",
    "context": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum mus",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Number = <span class=\"tok-kw\">enum</span>(<span class=\"tok-type\">u8</span>) {\n    one,\n    two,\n    three,\n    _,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch on non-exhaustive enum\"</span> {\n    <span class=\"tok-kw\">const</span> number = Number.one;\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">switch</span> (number) {\n        .one => <span class=\"tok-null\">true</span>,\n        .two, .three => <span class=\"tok-null\">false</span>,\n        _ => <span class=\"tok-null\">false</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(result);\n    <span class=\"tok-kw\">const</span> is_one = <span class=\"tok-kw\">switch</span> (number) {\n        .one => <span class=\"tok-null\">true</span>,\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-null\">false</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(is_one);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "enum §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain enum § in Zig 0.13.0",
    "context": "",
    "response": "test_enums.zig Shell See also: @typeInfo @tagName @sizeOf extern enum § By default, enums are not guaranteed to be compatible with the C ABI: enum_export_error.zig Shell For a C-ABI-compatible enum, provide an explicit tag type to the enum: enum_export.zig Shell Enum Literals § Enum literals allow specifying the name of an enum field without specifying the enum type: test_enum_literals.zig Shell Non-exhaustive enum § A non-exhaustive enum can be created by adding a trailing _ field. The enum must specify a tag type and cannot consume every enumeration value. @enumFromInt on a non-exhaustive enum involves the safety semantics of @intCast to the integer tag type, but beyond that always results in a well-defined enum value. A switch on a non-exhaustive enum can include a _ prong as an alternative to an else prong. With a _ prong the compiler errors if all the known tag names are not handled by the switch. test_switch_non-exhaustive.zig Shell",
    "metadata": {
      "version": "0.13.0",
      "topic": "enum §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Undefined Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the ent",
    "response": "<span class=\"tok-kw\">const</span> Payload = <span class=\"tok-kw\">union</span> {\n    int: <span class=\"tok-type\">i64</span>,\n    float: <span class=\"tok-type\">f64</span>,\n    boolean: <span class=\"tok-type\">bool</span>,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"simple union\"</span> {\n    <span class=\"tok-kw\">var</span> payload = Payload{ .int = <span class=\"tok-number\">1234</span> };\n    payload.float = <span class=\"tok-number\">12.34</span>;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "union §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Undefined Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the ent",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Payload = <span class=\"tok-kw\">union</span> {\n    int: <span class=\"tok-type\">i64</span>,\n    float: <span class=\"tok-type\">f64</span>,\n    boolean: <span class=\"tok-type\">bool</span>,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"simple union\"</span> {\n    <span class=\"tok-kw\">var</span> payload = Payload{ .int = <span class=\"tok-number\">1234</span> };\n    <span class=\"tok-kw\">try</span> expect(payload.int == <span class=\"tok-number\">1234</span>);\n    payload = Payload{ .float = <span class=\"tok-number\">12.34</span> };\n    <span class=\"tok-kw\">try</span> expect(payload.float == <span class=\"tok-number\">12.34</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Undefined Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the ent",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> ComplexTypeTag = <span class=\"tok-kw\">enum</span> {\n    ok,\n    not_ok,\n};\n<span class=\"tok-kw\">const</span> ComplexType = <span class=\"tok-kw\">union</span>(ComplexTypeTag) {\n    ok: <span class=\"tok-type\">u8</span>,\n    not_ok: <span class=\"tok-type\">void</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch on tagged union\"</span> {\n    <span class=\"tok-kw\">const</span> c = ComplexType{ .ok = <span class=\"tok-number\">42</span> };\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@as</span>(ComplexTypeTag, c) == ComplexTypeTag.ok);\n\n    <span class=\"tok-kw\">switch</span> (c) {\n        ComplexTypeTag.ok => |value| <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">42</span>),\n        ComplexTypeTag.not_ok => <span class=\"tok-kw\">unreachable</span>,\n    }\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"get tag type\"</span> {\n    <span class=\"tok-kw\">try</span> expect(std.meta.Tag(ComplexType) == ComplexTypeTag);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Undefined Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the ent",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> ComplexTypeTag = <span class=\"tok-kw\">enum</span> {\n    ok,\n    not_ok,\n};\n<span class=\"tok-kw\">const</span> ComplexType = <span class=\"tok-kw\">union</span>(ComplexTypeTag) {\n    ok: <span class=\"tok-type\">u8</span>,\n    not_ok: <span class=\"tok-type\">void</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"modify tagged union in switch\"</span> {\n    <span class=\"tok-kw\">var</span> c = ComplexType{ .ok = <span class=\"tok-number\">42</span> };\n\n    <span class=\"tok-kw\">switch</span> (c) {\n        ComplexTypeTag.ok => |*value| value.* += <span class=\"tok-number\">1</span>,\n        ComplexTypeTag.not_ok => <span class=\"tok-kw\">unreachable</span>,\n    }\n\n    <span class=\"tok-kw\">try</span> expect(c.ok == <span class=\"tok-number\">43</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Undefined Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the ent",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Variant = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n    int: <span class=\"tok-type\">i32</span>,\n    boolean: <span class=\"tok-type\">bool</span>,\n\n    <span class=\"tok-comment\">// void can be omitted when inferring enum tag type.</span>\n    none,\n\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">truthy</span>(self: Variant) <span class=\"tok-type\">bool</span> {\n        <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (self) {\n            Variant.int => |x_int| x_int != <span class=\"tok-number\">0</span>,\n            Variant.boolean => |x_bool| x_bool,\n            Variant.none => <span class=\"tok-null\">false</span>,\n        };\n    }\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"union method\"</span> {\n    <span class=\"tok-kw\">var</span> v1 = Variant{ .int = <span class=\"tok-number\">1</span> };\n    <span class=\"tok-kw\">var</span> v2 = Variant{ .boolean = <span class=\"tok-null\">false</span> };\n\n    <span class=\"tok-kw\">try</span> expect(v1.truthy());\n    <span class=\"tok-kw\">try</span> expect(!v2.truthy());\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Undefined Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the ent",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Small2 = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n    a: <span class=\"tok-type\">i32</span>,\n    b: <span class=\"tok-type\">bool</span>,\n    c: <span class=\"tok-type\">u8</span>,\n};\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@tagName\"</span> {\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-builtin\">@tagName</span>(Small2.a), <span class=\"tok-str\">\"a\"</span>));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: union §",
    "context": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Undefined Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the ent",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Number = <span class=\"tok-kw\">union</span> {\n    int: <span class=\"tok-type\">i32</span>,\n    float: <span class=\"tok-type\">f64</span>,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"anonymous union literal syntax\"</span> {\n    <span class=\"tok-kw\">const</span> i: Number = .{ .int = <span class=\"tok-number\">42</span> };\n    <span class=\"tok-kw\">const</span> f = makeNumber();\n    <span class=\"tok-kw\">try</span> expect(i.int == <span class=\"tok-number\">42</span>);\n    <span class=\"tok-kw\">try</span> expect(f.float == <span class=\"tok-number\">12.34</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">makeNumber</span>() Number {\n    <span class=\"tok-kw\">return</span> .{ .float = <span class=\"tok-number\">12.34</span> };\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "union §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain union § in Zig 0.13.0",
    "context": "",
    "response": "A bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast , or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Undefined Behavior : test_wrong_union_access.zig Shell You can activate another field by assigning the entire union: test_simple_union.zig Shell In order to use switch with a union, it must be a Tagged union . To initialize a union when the tag is a comptime -known name, see @unionInit . Tagged union § Unions can be declared with an enum tag type. This turns the union into a tagged union, which makes it eligible to use with switch expressions. Tagged unions coerce to their tag type: Type Coercion: Unions and Enums . test_tagged_union.zig Shell In order to modify the payload of a tagged union in a sw",
    "metadata": {
      "version": "0.13.0",
      "topic": "union §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: opaque §",
    "context": "opaque {} declares a new type with an unknown (but non-zero) size and alignment. It can contain declarations the same as structs , unions , and enums . This is typically used for type safety when interacting with C code that does not expose struct details. Example: test_opaque.zig Shell",
    "response": "<span class=\"tok-kw\">const</span> Derp = <span class=\"tok-kw\">opaque</span> {};\n<span class=\"tok-kw\">const</span> Wat = <span class=\"tok-kw\">opaque</span> {};\n\n<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>(d: *Derp) <span class=\"tok-type\">void</span>;\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(w: *Wat) <span class=\"tok-kw\">callconv</span>(.C) <span class=\"tok-type\">void</span> {\n    bar(w);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"call foo\"</span> {\n    foo(<span class=\"tok-null\">undefined</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "opaque §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain opaque § in Zig 0.13.0",
    "context": "",
    "response": "opaque {} declares a new type with an unknown (but non-zero) size and alignment. It can contain declarations the same as structs , unions , and enums . This is typically used for type safety when interacting with C code that does not expose struct details. Example: test_opaque.zig Shell",
    "metadata": {
      "version": "0.13.0",
      "topic": "opaque §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Blocks §",
    "context": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing wit",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"access variable after block scope\"</span> {\n    {\n        <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n        _ = &x;\n    }\n    x += <span class=\"tok-number\">1</span>;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Blocks §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Blocks §",
    "context": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing wit",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"labeled break from labeled block expression\"</span> {\n    <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">123</span>;\n\n    <span class=\"tok-kw\">const</span> x = blk: {\n        y += <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">break</span> :blk y;\n    };\n    <span class=\"tok-kw\">try</span> expect(x == <span class=\"tok-number\">124</span>);\n    <span class=\"tok-kw\">try</span> expect(y == <span class=\"tok-number\">124</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Blocks §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Blocks §",
    "context": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing wit",
    "response": "<span class=\"tok-kw\">const</span> pi = <span class=\"tok-number\">3.14</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inside test block\"</span> {\n    <span class=\"tok-comment\">// Let's even go inside another block</span>\n    {\n        <span class=\"tok-kw\">var</span> pi: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Blocks §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Blocks §",
    "context": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing wit",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"separate scopes\"</span> {\n    {\n        <span class=\"tok-kw\">const</span> pi = <span class=\"tok-number\">3.14</span>;\n        _ = pi;\n    }\n    {\n        <span class=\"tok-kw\">var</span> pi: <span class=\"tok-type\">bool</span> = <span class=\"tok-null\">true</span>;\n        _ = &pi;\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Blocks §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Blocks §",
    "context": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing wit",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> {\n    <span class=\"tok-kw\">const</span> a = {};\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-type\">void</span>{};\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(a) == <span class=\"tok-type\">void</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(b) == <span class=\"tok-type\">void</span>);\n    <span class=\"tok-kw\">try</span> expect(a == b);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Blocks §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Blocks § in Zig 0.13.0",
    "context": "",
    "response": "Blocks are used to limit the scope of variable declarations: test_blocks.zig Shell Blocks are expressions. When labeled, break can be used to return a value from the block: test_labeled_break.zig Shell Here, blk can be any name. See also: Labeled while Labeled for Shadowing § Identifiers are never allowed to \"hide\" other identifiers by using the same name: test_shadowing.zig Shell Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing within the scope it is defined. Note that you can, however, use the same name if the scopes are separate: test_scopes.zig Shell Empty Blocks § An empty block is equivalent to void {} : test_empty_block.zig Shell",
    "metadata": {
      "version": "0.13.0",
      "topic": "Blocks §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch simple\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">const</span> zz: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">103</span>;\n\n    <span class=\"tok-comment\">// All branches of a switch expression must be able to be coerced to a</span>\n    <span class=\"tok-comment\">// common type.</span>\n    <span class=\"tok-comment\">//</span>\n    <span class=\"tok-comment\">// Branches cannot fallthrough. If fallthrough behavior is desired, combine</span>\n    <span class=\"tok-comment\">// the cases and use an if.</span>\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-kw\">switch</span> (a) {\n        <span class=\"tok-comment\">// Multiple cases can be combined via a ','</span>\n        <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span> => <span class=\"tok-number\">0</span>,\n\n        <span class=\"tok-comment\">// Ranges can be specified using the ... syntax. These are inclusive</span>\n        <span class=\"tok-comment\">// of both ends.</span>\n        <span class=\"tok-number\">5</span>...<span class=\"tok-number\">100</span> => <span class=\"tok-number\">1</span>,\n\n        <span class=\"tok-comment\">// Branches can be arbitrarily complex.</span>\n        <span class=\"tok-number\">101</span> => blk: {\n            <span class=\"tok-kw\">const</span> c: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">5</span>;\n            <span class=\"tok-kw\">break</span> :blk c * <span class=\"tok-number\">2</span> + <span class=\"tok-number\">1</span>;\n        },\n\n        <span class=\"tok-comment\">// Switching on arbitrary expressions is allowed as long as the</span>\n        <span class=\"tok-comment\">// expression is known at compile-time.</span>\n        zz => zz,\n        blk: {\n            <span class=\"tok-kw\">const</span> d: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">5</span>;\n            <span class=\"tok-kw\">const</span> e: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">100</span>;\n            <span class=\"tok-kw\">break</span> :blk d + e;\n        } => <span class=\"tok-number\">107</span>,\n\n        <span class=\"tok-comment\">// The else branch catches everything not already captured.</span>\n        <span class=\"tok-comment\">// Else branches are mandatory unless the entire range of values</span>\n        <span class=\"tok-comment\">// is handled.</span>\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-number\">9</span>,\n    };\n\n    <span class=\"tok-kw\">try</span> expect(b == <span class=\"tok-number\">1</span>);\n}\n\n<span class=\"tok-comment\">// Switch expressions can be used outside a function:</span>\n<span class=\"tok-kw\">const</span> os_msg = <span class=\"tok-kw\">switch</span> (builtin.target.os.tag) {\n    .linux => <span class=\"tok-str\">\"we found a linux user\"</span>,\n    <span class=\"tok-kw\">else</span> => <span class=\"tok-str\">\"not a linux user\"</span>,\n};\n\n<span class=\"tok-comment\">// Inside a function, switch statements implicitly are compile-time</span>\n<span class=\"tok-comment\">// evaluated if the target expression is compile-time known.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch inside function\"</span> {\n    <span class=\"tok-kw\">switch</span> (builtin.target.os.tag) {\n        .fuchsia => {\n            <span class=\"tok-comment\">// On an OS other than fuchsia, block is not even analyzed,</span>\n            <span class=\"tok-comment\">// so this compile error is not triggered.</span>\n            <span class=\"tok-comment\">// On fuchsia this compile error would be triggered.</span>\n            <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"fuchsia not supported\"</span>);\n        },\n        <span class=\"tok-kw\">else</span> => {},\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"switch on tagged union\"</span> {\n    <span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> {\n        x: <span class=\"tok-type\">u8</span>,\n        y: <span class=\"tok-type\">u8</span>,\n    };\n    <span class=\"tok-kw\">const</span> Item = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n        a: <span class=\"tok-type\">u32</span>,\n        c: Point,\n        d,\n        e: <span class=\"tok-type\">u32</span>,\n    };\n\n    <span class=\"tok-kw\">var</span> a = Item{ .c = Point{ .x = <span class=\"tok-number\">1</span>, .y = <span class=\"tok-number\">2</span> } };\n\n    <span class=\"tok-comment\">// Switching on more complex enums is allowed.</span>\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-kw\">switch</span> (a) {\n        <span class=\"tok-comment\">// A capture group is allowed on a match, and will return the enum</span>\n        <span class=\"tok-comment\">// value matched. If the payload types of both cases are the same</span>\n        <span class=\"tok-comment\">// they can be put into the same switch prong.</span>\n        Item.a, Item.e => |item| item,\n\n        <span class=\"tok-comment\">// A reference to the matched value can be obtained using `*` syntax.</span>\n        Item.c => |*item| blk: {\n            item.*.x += <span class=\"tok-number\">1</span>;\n            <span class=\"tok-kw\">break</span> :blk <span class=\"tok-number\">6</span>;\n        },\n\n        <span class=\"tok-comment\">// No else is required if the types cases was exhaustively handled</span>\n        Item.d => <span class=\"tok-number\">8</span>,\n    };\n\n    <span class=\"tok-kw\">try</span> expect(b == <span class=\"tok-number\">6</span>);\n    <span class=\"tok-kw\">try</span> expect(a.c.x == <span class=\"tok-number\">2</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> Color = <span class=\"tok-kw\">enum</span> {\n    auto,\n    off,\n    on,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"exhaustive switching\"</span> {\n    <span class=\"tok-kw\">const</span> color = Color.off;\n    <span class=\"tok-kw\">switch</span> (color) {\n        Color.auto => {},\n        Color.on => {},\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "switch §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Color = <span class=\"tok-kw\">enum</span> {\n    auto,\n    off,\n    on,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"enum literals with switch\"</span> {\n    <span class=\"tok-kw\">const</span> color = Color.off;\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">switch</span> (color) {\n        .auto => <span class=\"tok-null\">false</span>,\n        .on => <span class=\"tok-null\">false</span>,\n        .off => <span class=\"tok-null\">true</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(result);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> expectError = std.testing.expectError;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">isFieldOptional</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, field_index: <span class=\"tok-type\">usize</span>) !<span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">const</span> fields = <span class=\"tok-builtin\">@typeInfo</span>(T).Struct.fields;\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (field_index) {\n        <span class=\"tok-comment\">// This prong is analyzed twice with `idx` being a</span>\n        <span class=\"tok-comment\">// comptime-known value each time.</span>\n        <span class=\"tok-kw\">inline</span> <span class=\"tok-number\">0</span>, <span class=\"tok-number\">1</span> => |idx| <span class=\"tok-builtin\">@typeInfo</span>(fields[idx].<span class=\"tok-type\">type</span>) == .Optional,\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.IndexOutOfBounds,\n    };\n}\n\n<span class=\"tok-kw\">const</span> Struct1 = <span class=\"tok-kw\">struct</span> { a: <span class=\"tok-type\">u32</span>, b: ?<span class=\"tok-type\">u32</span> };\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"using @typeInfo with runtime values\"</span> {\n    <span class=\"tok-kw\">var</span> index: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">try</span> expect(!<span class=\"tok-kw\">try</span> isFieldOptional(Struct1, index));\n    index += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-kw\">try</span> isFieldOptional(Struct1, index));\n    index += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expectError(<span class=\"tok-kw\">error</span>.IndexOutOfBounds, isFieldOptional(Struct1, index));\n}\n\n<span class=\"tok-comment\">// Calls to `isFieldOptional` on `Struct1` get unrolled to an equivalent</span>\n<span class=\"tok-comment\">// of this function:</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">isFieldOptionalUnrolled</span>(field_index: <span class=\"tok-type\">usize</span>) !<span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (field_index) {\n        <span class=\"tok-number\">0</span> => <span class=\"tok-null\">false</span>,\n        <span class=\"tok-number\">1</span> => <span class=\"tok-null\">true</span>,\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.IndexOutOfBounds,\n    };\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">isFieldOptional</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, field_index: <span class=\"tok-type\">usize</span>) !<span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">const</span> fields = <span class=\"tok-builtin\">@typeInfo</span>(T).Struct.fields;\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (field_index) {\n        <span class=\"tok-kw\">inline</span> <span class=\"tok-number\">0</span>...fields.len - <span class=\"tok-number\">1</span> => |idx| <span class=\"tok-builtin\">@typeInfo</span>(fields[idx].<span class=\"tok-type\">type</span>) == .Optional,\n        <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.IndexOutOfBounds,\n    };\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> SliceTypeA = <span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">struct</span> {\n    len: <span class=\"tok-type\">usize</span>,\n    ptr: [*]<span class=\"tok-type\">u32</span>,\n};\n<span class=\"tok-kw\">const</span> SliceTypeB = <span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">struct</span> {\n    ptr: [*]SliceTypeA,\n    len: <span class=\"tok-type\">usize</span>,\n};\n<span class=\"tok-kw\">const</span> AnySlice = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n    a: SliceTypeA,\n    b: SliceTypeB,\n    c: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>,\n    d: []AnySlice,\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">withFor</span>(any: AnySlice) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">const</span> Tag = <span class=\"tok-builtin\">@typeInfo</span>(AnySlice).Union.tag_type.?;\n    <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">for</span> (<span class=\"tok-builtin\">@typeInfo</span>(Tag).Enum.fields) |field| {\n        <span class=\"tok-comment\">// With `inline for` the function gets generated as</span>\n        <span class=\"tok-comment\">// a series of `if` statements relying on the optimizer</span>\n        <span class=\"tok-comment\">// to convert it to a switch.</span>\n        <span class=\"tok-kw\">if</span> (field.value == <span class=\"tok-builtin\">@intFromEnum</span>(any)) {\n            <span class=\"tok-kw\">return</span> <span class=\"tok-builtin\">@field</span>(any, field.name).len;\n        }\n    }\n    <span class=\"tok-comment\">// When using `inline for` the compiler doesn't know that every</span>\n    <span class=\"tok-comment\">// possible case has been handled requiring an explicit `unreachable`.</span>\n    <span class=\"tok-kw\">unreachable</span>;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">withSwitch</span>(any: AnySlice) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (any) {\n        <span class=\"tok-comment\">// With `inline else` the function is explicitly generated</span>\n        <span class=\"tok-comment\">// as the desired switch and the compiler can check that</span>\n        <span class=\"tok-comment\">// every possible case is handled.</span>\n        <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">else</span> => |slice| slice.len,\n    };\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inline for and inline else similarity\"</span> {\n    <span class=\"tok-kw\">const</span> any = AnySlice{ .c = <span class=\"tok-str\">\"hello\"</span> };\n    <span class=\"tok-kw\">try</span> expect(withFor(any) == <span class=\"tok-number\">5</span>);\n    <span class=\"tok-kw\">try</span> expect(withSwitch(any) == <span class=\"tok-number\">5</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: switch §",
    "context": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> U = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n    a: <span class=\"tok-type\">u32</span>,\n    b: <span class=\"tok-type\">f32</span>,\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">getNum</span>(u: U) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">switch</span> (u) {\n        <span class=\"tok-comment\">// Here `num` is a runtime-known value that is either</span>\n        <span class=\"tok-comment\">// `u.a` or `u.b` and `tag` is `u`'s comptime-known tag value.</span>\n        <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">else</span> => |num, tag| {\n            <span class=\"tok-kw\">if</span> (tag == .b) {\n                <span class=\"tok-kw\">return</span> <span class=\"tok-builtin\">@intFromFloat</span>(num);\n            }\n            <span class=\"tok-kw\">return</span> num;\n        },\n    }\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"test\"</span> {\n    <span class=\"tok-kw\">const</span> u = U{ .b = <span class=\"tok-number\">42</span> };\n    <span class=\"tok-kw\">try</span> expect(getNum(u) == <span class=\"tok-number\">42</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "switch §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain switch § in Zig 0.13.0",
    "context": "",
    "response": "test_switch.zig Shell switch can be used to capture the field values of a Tagged union . Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer. test_switch_tagged_union.zig Shell See also: comptime enum @compileError Compile Variables Exhaustive Switching § When a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error: test_unhandled_enumeration_value.zig Shell Switching with Enum Literals § Enum Literals can be useful to use with switch to avoid repetitively specifying enum or union types: test_exhaustive_switch.zig Shell Inline Switch Prongs § Switch prongs can be marked as inline to generate the prong's body for each possible value it could have, making the captured value comptime . test_inline_switch.zig Shell The inline keyword may also be combined with ranges: inline_prong_range.zig inline else prongs can be used as a type safe alterna",
    "metadata": {
      "version": "0.13.0",
      "topic": "switch §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while basic\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">10</span>) {\n        i += <span class=\"tok-number\">1</span>;\n    }\n    <span class=\"tok-kw\">try</span> expect(i == <span class=\"tok-number\">10</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while break\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n        <span class=\"tok-kw\">if</span> (i == <span class=\"tok-number\">10</span>)\n            <span class=\"tok-kw\">break</span>;\n        i += <span class=\"tok-number\">1</span>;\n    }\n    <span class=\"tok-kw\">try</span> expect(i == <span class=\"tok-number\">10</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while continue\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n        i += <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">if</span> (i < <span class=\"tok-number\">10</span>)\n            <span class=\"tok-kw\">continue</span>;\n        <span class=\"tok-kw\">break</span>;\n    }\n    <span class=\"tok-kw\">try</span> expect(i == <span class=\"tok-number\">10</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while loop continue expression\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">10</span>) : (i += <span class=\"tok-number\">1</span>) {}\n    <span class=\"tok-kw\">try</span> expect(i == <span class=\"tok-number\">10</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while loop continue expression, more complicated\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">var</span> j: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">while</span> (i * j < <span class=\"tok-number\">2000</span>) : ({\n        i *= <span class=\"tok-number\">2</span>;\n        j *= <span class=\"tok-number\">3</span>;\n    }) {\n        <span class=\"tok-kw\">const</span> my_ij = i * j;\n        <span class=\"tok-kw\">try</span> expect(my_ij < <span class=\"tok-number\">2000</span>);\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while else\"</span> {\n    <span class=\"tok-kw\">try</span> expect(rangeHasNumber(<span class=\"tok-number\">0</span>, <span class=\"tok-number\">10</span>, <span class=\"tok-number\">5</span>));\n    <span class=\"tok-kw\">try</span> expect(!rangeHasNumber(<span class=\"tok-number\">0</span>, <span class=\"tok-number\">10</span>, <span class=\"tok-number\">15</span>));\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">rangeHasNumber</span>(begin: <span class=\"tok-type\">usize</span>, end: <span class=\"tok-type\">usize</span>, number: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">var</span> i = begin;\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">while</span> (i < end) : (i += <span class=\"tok-number\">1</span>) {\n        <span class=\"tok-kw\">if</span> (i == number) {\n            <span class=\"tok-kw\">break</span> <span class=\"tok-null\">true</span>;\n        }\n    } <span class=\"tok-kw\">else</span> <span class=\"tok-null\">false</span>;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"nested break\"</span> {\n    outer: <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n        <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n            <span class=\"tok-kw\">break</span> :outer;\n        }\n    }\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"nested continue\"</span> {\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    outer: <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">10</span>) : (i += <span class=\"tok-number\">1</span>) {\n        <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {\n            <span class=\"tok-kw\">continue</span> :outer;\n        }\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "while §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while null capture\"</span> {\n    <span class=\"tok-kw\">var</span> sum1: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    numbers_left = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">while</span> (eventuallyNullSequence()) |value| {\n        sum1 += value;\n    }\n    <span class=\"tok-kw\">try</span> expect(sum1 == <span class=\"tok-number\">3</span>);\n\n    <span class=\"tok-comment\">// null capture with an else block</span>\n    <span class=\"tok-kw\">var</span> sum2: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    numbers_left = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">while</span> (eventuallyNullSequence()) |value| {\n        sum2 += value;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">try</span> expect(sum2 == <span class=\"tok-number\">3</span>);\n    }\n\n    <span class=\"tok-comment\">// null capture with a continue expression</span>\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">var</span> sum3: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    numbers_left = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">while</span> (eventuallyNullSequence()) |value| : (i += <span class=\"tok-number\">1</span>) {\n        sum3 += value;\n    }\n    <span class=\"tok-kw\">try</span> expect(i == <span class=\"tok-number\">3</span>);\n}\n\n<span class=\"tok-kw\">var</span> numbers_left: <span class=\"tok-type\">u32</span> = <span class=\"tok-null\">undefined</span>;\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">eventuallyNullSequence</span>() ?<span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (numbers_left == <span class=\"tok-number\">0</span>) <span class=\"tok-null\">null</span> <span class=\"tok-kw\">else</span> blk: {\n        numbers_left -= <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">break</span> :blk numbers_left;\n    };\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"while error union capture\"</span> {\n    <span class=\"tok-kw\">var</span> sum1: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    numbers_left = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">while</span> (eventuallyErrorSequence()) |value| {\n        sum1 += value;\n    } <span class=\"tok-kw\">else</span> |err| {\n        <span class=\"tok-kw\">try</span> expect(err == <span class=\"tok-kw\">error</span>.ReachedZero);\n    }\n}\n\n<span class=\"tok-kw\">var</span> numbers_left: <span class=\"tok-type\">u32</span> = <span class=\"tok-null\">undefined</span>;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">eventuallyErrorSequence</span>() <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (numbers_left == <span class=\"tok-number\">0</span>) <span class=\"tok-kw\">error</span>.ReachedZero <span class=\"tok-kw\">else</span> blk: {\n        numbers_left -= <span class=\"tok-number\">1</span>;\n        <span class=\"tok-kw\">break</span> :blk numbers_left;\n    };\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: while §",
    "context": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expressi",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inline while loop\"</span> {\n    <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> i = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">3</span>) : (i += <span class=\"tok-number\">1</span>) {\n        <span class=\"tok-kw\">const</span> T = <span class=\"tok-kw\">switch</span> (i) {\n            <span class=\"tok-number\">0</span> => <span class=\"tok-type\">f32</span>,\n            <span class=\"tok-number\">1</span> => <span class=\"tok-type\">i8</span>,\n            <span class=\"tok-number\">2</span> => <span class=\"tok-type\">bool</span>,\n            <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">unreachable</span>,\n        };\n        sum += typeNameLength(T);\n    }\n    <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-number\">9</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">typeNameLength</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-builtin\">@typeName</span>(T).len;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "while §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain while § in Zig 0.13.0",
    "context": "",
    "response": "A while loop is used to repeatedly execute an expression until some condition is no longer true. test_while.zig Shell Use break to exit a while loop early. test_while_break.zig Shell Use continue to jump back to the beginning of the loop. test_while_continue.zig Shell While loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression. test_while_continue_expression.zig Shell While loops are expressions. The result of the expression is the result of the else clause of a while loop, which is executed when the condition of the while loop is tested as false. break , like return , accepts a value parameter. This is the result of the while expression. When you break from a while loop, the else branch is not evaluated. test_while_else.zig Shell Labeled while § When a while loop is labeled, it can be referenced from a break or continue from within a nested loop: test_while_nested_break.zig Shell while with Optionals § Just like",
    "metadata": {
      "version": "0.13.0",
      "topic": "while §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: for §",
    "context": "test_for.zig Shell Labeled for § When a for loop is labeled, it can be referenced from a break or continue from within a nested loop: test_for_nested_break.zig Shell inline for § For loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known. test_inline_for.zig Shell It is recommended to use inline loop",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"for basics\"</span> {\n    <span class=\"tok-kw\">const</span> items = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">0</span> };\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n\n    <span class=\"tok-comment\">// For loops iterate over slices and arrays.</span>\n    <span class=\"tok-kw\">for</span> (items) |value| {\n        <span class=\"tok-comment\">// Break and continue are supported.</span>\n        <span class=\"tok-kw\">if</span> (value == <span class=\"tok-number\">0</span>) {\n            <span class=\"tok-kw\">continue</span>;\n        }\n        sum += value;\n    }\n    <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-number\">16</span>);\n\n    <span class=\"tok-comment\">// To iterate over a portion of a slice, reslice.</span>\n    <span class=\"tok-kw\">for</span> (items[<span class=\"tok-number\">0</span>..<span class=\"tok-number\">1</span>]) |value| {\n        sum += value;\n    }\n    <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-number\">20</span>);\n\n    <span class=\"tok-comment\">// To access the index of iteration, specify a second condition as well</span>\n    <span class=\"tok-comment\">// as a second capture value.</span>\n    <span class=\"tok-kw\">var</span> sum2: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">for</span> (items, <span class=\"tok-number\">0</span>..) |_, i| {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(i) == <span class=\"tok-type\">usize</span>);\n        sum2 += <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">i32</span>, <span class=\"tok-builtin\">@intCast</span>(i));\n    }\n    <span class=\"tok-kw\">try</span> expect(sum2 == <span class=\"tok-number\">10</span>);\n\n    <span class=\"tok-comment\">// To iterate over consecutive integers, use the range syntax.</span>\n    <span class=\"tok-comment\">// Unbounded range is always a compile error.</span>\n    <span class=\"tok-kw\">var</span> sum3: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">for</span> (<span class=\"tok-number\">0</span>..<span class=\"tok-number\">5</span>) |i| {\n        sum3 += i;\n    }\n    <span class=\"tok-kw\">try</span> expect(sum3 == <span class=\"tok-number\">10</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"multi object for\"</span> {\n    <span class=\"tok-kw\">const</span> items = [_]<span class=\"tok-type\">usize</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span> };\n    <span class=\"tok-kw\">const</span> items2 = [_]<span class=\"tok-type\">usize</span>{ <span class=\"tok-number\">4</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span> };\n    <span class=\"tok-kw\">var</span> count: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n\n    <span class=\"tok-comment\">// Iterate over multiple objects.</span>\n    <span class=\"tok-comment\">// All lengths must be equal at the start of the loop, otherwise detectable</span>\n    <span class=\"tok-comment\">// illegal behavior occurs.</span>\n    <span class=\"tok-kw\">for</span> (items, items2) |i, j| {\n        count += i + j;\n    }\n\n    <span class=\"tok-kw\">try</span> expect(count == <span class=\"tok-number\">21</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"for reference\"</span> {\n    <span class=\"tok-kw\">var</span> items = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">2</span> };\n\n    <span class=\"tok-comment\">// Iterate over the slice by reference by</span>\n    <span class=\"tok-comment\">// specifying that the capture value is a pointer.</span>\n    <span class=\"tok-kw\">for</span> (&items) |*value| {\n        value.* += <span class=\"tok-number\">1</span>;\n    }\n\n    <span class=\"tok-kw\">try</span> expect(items[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(items[<span class=\"tok-number\">1</span>] == <span class=\"tok-number\">5</span>);\n    <span class=\"tok-kw\">try</span> expect(items[<span class=\"tok-number\">2</span>] == <span class=\"tok-number\">3</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"for else\"</span> {\n    <span class=\"tok-comment\">// For allows an else attached to it, the same as a while loop.</span>\n    <span class=\"tok-kw\">const</span> items = [_]?<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-null\">null</span>, <span class=\"tok-number\">5</span> };\n\n    <span class=\"tok-comment\">// For loops can also be used as expressions.</span>\n    <span class=\"tok-comment\">// Similar to while loops, when you break from a for loop, the else branch is not evaluated.</span>\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">for</span> (items) |value| {\n        <span class=\"tok-kw\">if</span> (value != <span class=\"tok-null\">null</span>) {\n            sum += value.?;\n        }\n    } <span class=\"tok-kw\">else</span> blk: {\n        <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-number\">12</span>);\n        <span class=\"tok-kw\">break</span> :blk sum;\n    };\n    <span class=\"tok-kw\">try</span> expect(result == <span class=\"tok-number\">12</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "for §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: for §",
    "context": "test_for.zig Shell Labeled for § When a for loop is labeled, it can be referenced from a break or continue from within a nested loop: test_for_nested_break.zig Shell inline for § For loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known. test_inline_for.zig Shell It is recommended to use inline loop",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"nested break\"</span> {\n    <span class=\"tok-kw\">var</span> count: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    outer: <span class=\"tok-kw\">for</span> (<span class=\"tok-number\">1</span>..<span class=\"tok-number\">6</span>) |_| {\n        <span class=\"tok-kw\">for</span> (<span class=\"tok-number\">1</span>..<span class=\"tok-number\">6</span>) |_| {\n            count += <span class=\"tok-number\">1</span>;\n            <span class=\"tok-kw\">break</span> :outer;\n        }\n    }\n    <span class=\"tok-kw\">try</span> expect(count == <span class=\"tok-number\">1</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"nested continue\"</span> {\n    <span class=\"tok-kw\">var</span> count: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    outer: <span class=\"tok-kw\">for</span> (<span class=\"tok-number\">1</span>..<span class=\"tok-number\">9</span>) |_| {\n        <span class=\"tok-kw\">for</span> (<span class=\"tok-number\">1</span>..<span class=\"tok-number\">6</span>) |_| {\n            count += <span class=\"tok-number\">1</span>;\n            <span class=\"tok-kw\">continue</span> :outer;\n        }\n    }\n\n    <span class=\"tok-kw\">try</span> expect(count == <span class=\"tok-number\">8</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "for §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: for §",
    "context": "test_for.zig Shell Labeled for § When a for loop is labeled, it can be referenced from a break or continue from within a nested loop: test_for_nested_break.zig Shell inline for § For loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known. test_inline_for.zig Shell It is recommended to use inline loop",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inline for loop\"</span> {\n    <span class=\"tok-kw\">const</span> nums = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">2</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">6</span> };\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">for</span> (nums) |i| {\n        <span class=\"tok-kw\">const</span> T = <span class=\"tok-kw\">switch</span> (i) {\n            <span class=\"tok-number\">2</span> => <span class=\"tok-type\">f32</span>,\n            <span class=\"tok-number\">4</span> => <span class=\"tok-type\">i8</span>,\n            <span class=\"tok-number\">6</span> => <span class=\"tok-type\">bool</span>,\n            <span class=\"tok-kw\">else</span> => <span class=\"tok-kw\">unreachable</span>,\n        };\n        sum += typeNameLength(T);\n    }\n    <span class=\"tok-kw\">try</span> expect(sum == <span class=\"tok-number\">9</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">typeNameLength</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-builtin\">@typeName</span>(T).len;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "for §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain for § in Zig 0.13.0",
    "context": "",
    "response": "test_for.zig Shell Labeled for § When a for loop is labeled, it can be referenced from a break or continue from within a nested loop: test_for_nested_break.zig Shell inline for § For loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known. test_inline_for.zig Shell It is recommended to use inline loops only for one of these reasons: You need the loop to execute at comptime for the semantics to work. You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster. See also: while comptime Arrays Slices",
    "metadata": {
      "version": "0.13.0",
      "topic": "for §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: if §",
    "context": "test_if.zig Shell if with Optionals § test_if_optionals.zig Shell See also: Optionals Errors",
    "response": "<span class=\"tok-comment\">// If expressions have three uses, corresponding to the three types:</span>\n<span class=\"tok-comment\">// * bool</span>\n<span class=\"tok-comment\">// * ?T</span>\n<span class=\"tok-comment\">// * anyerror!T</span>\n\n<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"if expression\"</span> {\n    <span class=\"tok-comment\">// If expressions are used instead of a ternary expression.</span>\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">5</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">4</span>;\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">if</span> (a != b) <span class=\"tok-number\">47</span> <span class=\"tok-kw\">else</span> <span class=\"tok-number\">3089</span>;\n    <span class=\"tok-kw\">try</span> expect(result == <span class=\"tok-number\">47</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"if boolean\"</span> {\n    <span class=\"tok-comment\">// If expressions test boolean conditions.</span>\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">5</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">4</span>;\n    <span class=\"tok-kw\">if</span> (a != b) {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-null\">true</span>);\n    } <span class=\"tok-kw\">else</span> <span class=\"tok-kw\">if</span> (a == <span class=\"tok-number\">9</span>) {\n        <span class=\"tok-kw\">unreachable</span>;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"if error union\"</span> {\n    <span class=\"tok-comment\">// If expressions test for errors.</span>\n    <span class=\"tok-comment\">// Note the |err| capture on the else.</span>\n\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">if</span> (a) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">0</span>);\n    } <span class=\"tok-kw\">else</span> |err| {\n        _ = err;\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> = <span class=\"tok-kw\">error</span>.BadValue;\n    <span class=\"tok-kw\">if</span> (b) |value| {\n        _ = value;\n        <span class=\"tok-kw\">unreachable</span>;\n    } <span class=\"tok-kw\">else</span> |err| {\n        <span class=\"tok-kw\">try</span> expect(err == <span class=\"tok-kw\">error</span>.BadValue);\n    }\n\n    <span class=\"tok-comment\">// The else and |err| capture is strictly required.</span>\n    <span class=\"tok-kw\">if</span> (a) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">0</span>);\n    } <span class=\"tok-kw\">else</span> |_| {}\n\n    <span class=\"tok-comment\">// To check only the error value, use an empty block expression.</span>\n    <span class=\"tok-kw\">if</span> (b) |_| {} <span class=\"tok-kw\">else</span> |err| {\n        <span class=\"tok-kw\">try</span> expect(err == <span class=\"tok-kw\">error</span>.BadValue);\n    }\n\n    <span class=\"tok-comment\">// Access the value by reference using a pointer capture.</span>\n    <span class=\"tok-kw\">var</span> c: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">if</span> (c) |*value| {\n        value.* = <span class=\"tok-number\">9</span>;\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">if</span> (c) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">9</span>);\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "if §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: if §",
    "context": "test_if.zig Shell if with Optionals § test_if_optionals.zig Shell See also: Optionals Errors",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"if optional\"</span> {\n    <span class=\"tok-comment\">// If expressions test for null.</span>\n\n    <span class=\"tok-kw\">const</span> a: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">if</span> (a) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">0</span>);\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">const</span> b: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-null\">null</span>;\n    <span class=\"tok-kw\">if</span> (b) |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-null\">true</span>);\n    }\n\n    <span class=\"tok-comment\">// The else is not required.</span>\n    <span class=\"tok-kw\">if</span> (a) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">0</span>);\n    }\n\n    <span class=\"tok-comment\">// To test against null only, use the binary equality operator.</span>\n    <span class=\"tok-kw\">if</span> (b == <span class=\"tok-null\">null</span>) {\n        <span class=\"tok-kw\">try</span> expect(<span class=\"tok-null\">true</span>);\n    }\n\n    <span class=\"tok-comment\">// Access the value by reference using a pointer capture.</span>\n    <span class=\"tok-kw\">var</span> c: ?<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">if</span> (c) |*value| {\n        value.* = <span class=\"tok-number\">2</span>;\n    }\n\n    <span class=\"tok-kw\">if</span> (c) |value| {\n        <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">2</span>);\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"if error union with optional\"</span> {\n    <span class=\"tok-comment\">// If expressions test for errors before unwrapping optionals.</span>\n    <span class=\"tok-comment\">// The |optional_value| capture's type is ?u32.</span>\n\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">if</span> (a) |optional_value| {\n        <span class=\"tok-kw\">try</span> expect(optional_value.? == <span class=\"tok-number\">0</span>);\n    } <span class=\"tok-kw\">else</span> |err| {\n        _ = err;\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">u32</span> = <span class=\"tok-null\">null</span>;\n    <span class=\"tok-kw\">if</span> (b) |optional_value| {\n        <span class=\"tok-kw\">try</span> expect(optional_value == <span class=\"tok-null\">null</span>);\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">const</span> c: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">u32</span> = <span class=\"tok-kw\">error</span>.BadValue;\n    <span class=\"tok-kw\">if</span> (c) |optional_value| {\n        _ = optional_value;\n        <span class=\"tok-kw\">unreachable</span>;\n    } <span class=\"tok-kw\">else</span> |err| {\n        <span class=\"tok-kw\">try</span> expect(err == <span class=\"tok-kw\">error</span>.BadValue);\n    }\n\n    <span class=\"tok-comment\">// Access the value by reference by using a pointer capture each time.</span>\n    <span class=\"tok-kw\">var</span> d: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">if</span> (d) |*optional_value| {\n        <span class=\"tok-kw\">if</span> (optional_value.*) |*value| {\n            value.* = <span class=\"tok-number\">9</span>;\n        }\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n\n    <span class=\"tok-kw\">if</span> (d) |optional_value| {\n        <span class=\"tok-kw\">try</span> expect(optional_value.? == <span class=\"tok-number\">9</span>);\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "if §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: defer §",
    "context": "Executes an expression unconditionally at scope exit. test_defer.zig Shell Defer expressions are evaluated in reverse order. defer_unwind.zig Shell Inside a defer expression the return statement is not allowed. test_invalid_defer.zig Shell See also: Errors",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> print = std.debug.print;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">deferExample</span>() !<span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">1</span>;\n\n    {\n        <span class=\"tok-kw\">defer</span> a = <span class=\"tok-number\">2</span>;\n        a = <span class=\"tok-number\">1</span>;\n    }\n    <span class=\"tok-kw\">try</span> expect(a == <span class=\"tok-number\">2</span>);\n\n    a = <span class=\"tok-number\">5</span>;\n    <span class=\"tok-kw\">return</span> a;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"defer basics\"</span> {\n    <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> deferExample()) == <span class=\"tok-number\">5</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "defer §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: defer §",
    "context": "Executes an expression unconditionally at scope exit. test_defer.zig Shell Defer expressions are evaluated in reverse order. defer_unwind.zig Shell Inside a defer expression the return statement is not allowed. test_invalid_defer.zig Shell See also: Errors",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> print = std.debug.print;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"defer unwinding\"</span> {\n    print(<span class=\"tok-str\">\"\\n\"</span>, .{});\n\n    <span class=\"tok-kw\">defer</span> {\n        print(<span class=\"tok-str\">\"1 \"</span>, .{});\n    }\n    <span class=\"tok-kw\">defer</span> {\n        print(<span class=\"tok-str\">\"2 \"</span>, .{});\n    }\n    <span class=\"tok-kw\">if</span> (<span class=\"tok-null\">false</span>) {\n        <span class=\"tok-comment\">// defers are not run if they are never executed.</span>\n        <span class=\"tok-kw\">defer</span> {\n            print(<span class=\"tok-str\">\"3 \"</span>, .{});\n        }\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "defer §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: defer §",
    "context": "Executes an expression unconditionally at scope exit. test_defer.zig Shell Defer expressions are evaluated in reverse order. defer_unwind.zig Shell Inside a defer expression the return statement is not allowed. test_invalid_defer.zig Shell See also: Errors",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">deferInvalidExample</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">defer</span> {\n        <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.DeferError;\n    }\n\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.DeferError;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "defer §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain defer § in Zig 0.13.0",
    "context": "",
    "response": "Executes an expression unconditionally at scope exit. test_defer.zig Shell Defer expressions are evaluated in reverse order. defer_unwind.zig Shell Inside a defer expression the return statement is not allowed. test_invalid_defer.zig Shell See also: Errors",
    "metadata": {
      "version": "0.13.0",
      "topic": "defer §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: unreachable §",
    "context": "In Debug and ReleaseSafe mode unreachable emits a call to panic with the message reached unreachable code . In ReleaseFast and ReleaseSmall mode, the optimizer uses the assumption that unreachable code will never be hit to perform optimizations. Basics § test_unreachable.zig Shell In fact, this is how std.debug.assert is implemented: test_assertion_failure.zig Shell At Compile-Time § test_comptime_unreachable.zig Shell See also: Zig Test Build Mode comptime",
    "response": "<span class=\"tok-comment\">// unreachable is used to assert that control flow will never reach a</span>\n<span class=\"tok-comment\">// particular location:</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"basic math\"</span> {\n    <span class=\"tok-kw\">const</span> x = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> y = <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">if</span> (x + y != <span class=\"tok-number\">3</span>) {\n        <span class=\"tok-kw\">unreachable</span>;\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "unreachable §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: unreachable §",
    "context": "In Debug and ReleaseSafe mode unreachable emits a call to panic with the message reached unreachable code . In ReleaseFast and ReleaseSmall mode, the optimizer uses the assumption that unreachable code will never be hit to perform optimizations. Basics § test_unreachable.zig Shell In fact, this is how std.debug.assert is implemented: test_assertion_failure.zig Shell At Compile-Time § test_comptime_unreachable.zig Shell See also: Zig Test Build Mode comptime",
    "response": "<span class=\"tok-comment\">// This is how std.debug.assert is implemented</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">assert</span>(ok: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (!ok) <span class=\"tok-kw\">unreachable</span>; <span class=\"tok-comment\">// assertion failure</span>\n}\n\n<span class=\"tok-comment\">// This test will fail because we hit unreachable.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"this will fail\"</span> {\n    assert(<span class=\"tok-null\">false</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "unreachable §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: unreachable §",
    "context": "In Debug and ReleaseSafe mode unreachable emits a call to panic with the message reached unreachable code . In ReleaseFast and ReleaseSmall mode, the optimizer uses the assumption that unreachable code will never be hit to perform optimizations. Basics § test_unreachable.zig Shell In fact, this is how std.debug.assert is implemented: test_assertion_failure.zig Shell At Compile-Time § test_comptime_unreachable.zig Shell See also: Zig Test Build Mode comptime",
    "response": "<span class=\"tok-kw\">const</span> assert = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.assert;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"type of unreachable\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-comment\">// The type of unreachable is noreturn.</span>\n\n        <span class=\"tok-comment\">// However this assertion will still fail to compile because</span>\n        <span class=\"tok-comment\">// unreachable expressions are compile errors.</span>\n\n        assert(<span class=\"tok-builtin\">@TypeOf</span>(<span class=\"tok-kw\">unreachable</span>) == <span class=\"tok-type\">noreturn</span>);\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "unreachable §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain unreachable § in Zig 0.13.0",
    "context": "",
    "response": "In Debug and ReleaseSafe mode unreachable emits a call to panic with the message reached unreachable code . In ReleaseFast and ReleaseSmall mode, the optimizer uses the assumption that unreachable code will never be hit to perform optimizations. Basics § test_unreachable.zig Shell In fact, this is how std.debug.assert is implemented: test_assertion_failure.zig Shell At Compile-Time § test_comptime_unreachable.zig Shell See also: Zig Test Build Mode comptime",
    "metadata": {
      "version": "0.13.0",
      "topic": "unreachable §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: noreturn §",
    "context": "noreturn is the type of: break continue return unreachable while ( true ) {} When resolving types together, such as if clauses or switch prongs, the noreturn type is compatible with every other type. Consider: test_noreturn.zig Shell Another use case for noreturn is the exit function: test_noreturn_from_exit.zig Shell",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(condition: <span class=\"tok-type\">bool</span>, b: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> a = <span class=\"tok-kw\">if</span> (condition) b <span class=\"tok-kw\">else</span> <span class=\"tok-kw\">return</span>;\n    _ = a;\n    <span class=\"tok-builtin\">@panic</span>(<span class=\"tok-str\">\"do something with a\"</span>);\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"noreturn\"</span> {\n    foo(<span class=\"tok-null\">false</span>, <span class=\"tok-number\">1</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "noreturn §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: noreturn §",
    "context": "noreturn is the type of: break continue return unreachable while ( true ) {} When resolving types together, such as if clauses or switch prongs, the noreturn type is compatible with every other type. Consider: test_noreturn.zig Shell Another use case for noreturn is the exit function: test_noreturn_from_exit.zig Shell",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> native_arch = builtin.cpu.arch;\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> WINAPI: std.builtin.CallingConvention = <span class=\"tok-kw\">if</span> (native_arch == .x86) .Stdcall <span class=\"tok-kw\">else</span> .C;\n<span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"kernel32\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">ExitProcess</span>(exit_code: <span class=\"tok-type\">c_uint</span>) <span class=\"tok-kw\">callconv</span>(WINAPI) <span class=\"tok-type\">noreturn</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"foo\"</span> {\n    <span class=\"tok-kw\">const</span> value = bar() <span class=\"tok-kw\">catch</span> ExitProcess(<span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(value == <span class=\"tok-number\">1234</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>() <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">1234</span>;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "noreturn §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain noreturn § in Zig 0.13.0",
    "context": "",
    "response": "noreturn is the type of: break continue return unreachable while ( true ) {} When resolving types together, such as if clauses or switch prongs, the noreturn type is compatible with every other type. Consider: test_noreturn.zig Shell Another use case for noreturn is the exit function: test_noreturn_from_exit.zig Shell",
    "metadata": {
      "version": "0.13.0",
      "topic": "noreturn §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Functions §",
    "context": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, an",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> native_arch = builtin.cpu.arch;\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-comment\">// Functions are declared like this</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(a: <span class=\"tok-type\">i8</span>, b: <span class=\"tok-type\">i8</span>) <span class=\"tok-type\">i8</span> {\n    <span class=\"tok-kw\">if</span> (a == <span class=\"tok-number\">0</span>) {\n        <span class=\"tok-kw\">return</span> b;\n    }\n\n    <span class=\"tok-kw\">return</span> a + b;\n}\n\n<span class=\"tok-comment\">// The export specifier makes a function externally visible in the generated</span>\n<span class=\"tok-comment\">// object file, and makes it use the C ABI.</span>\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">sub</span>(a: <span class=\"tok-type\">i8</span>, b: <span class=\"tok-type\">i8</span>) <span class=\"tok-type\">i8</span> {\n    <span class=\"tok-kw\">return</span> a - b;\n}\n\n<span class=\"tok-comment\">// The extern specifier is used to declare a function that will be resolved</span>\n<span class=\"tok-comment\">// at link time, when linking statically, or at runtime, when linking</span>\n<span class=\"tok-comment\">// dynamically. The quoted identifier after the extern keyword specifies</span>\n<span class=\"tok-comment\">// the library that has the function. (e.g. \"c\" -> libc.so)</span>\n<span class=\"tok-comment\">// The callconv specifier changes the calling convention of the function.</span>\n<span class=\"tok-kw\">const</span> WINAPI: std.builtin.CallingConvention = <span class=\"tok-kw\">if</span> (native_arch == .x86) .Stdcall <span class=\"tok-kw\">else</span> .C;\n<span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"kernel32\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">ExitProcess</span>(exit_code: <span class=\"tok-type\">u32</span>) <span class=\"tok-kw\">callconv</span>(WINAPI) <span class=\"tok-type\">noreturn</span>;\n<span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"c\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">atan2</span>(a: <span class=\"tok-type\">f64</span>, b: <span class=\"tok-type\">f64</span>) <span class=\"tok-type\">f64</span>;\n\n<span class=\"tok-comment\">// The @setCold builtin tells the optimizer that a function is rarely called.</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">abort</span>() <span class=\"tok-type\">noreturn</span> {\n    <span class=\"tok-builtin\">@setCold</span>(<span class=\"tok-null\">true</span>);\n    <span class=\"tok-kw\">while</span> (<span class=\"tok-null\">true</span>) {}\n}\n\n<span class=\"tok-comment\">// The naked calling convention makes a function not have any function prologue or epilogue.</span>\n<span class=\"tok-comment\">// This can be useful when integrating with assembly.</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">_start</span>() <span class=\"tok-kw\">callconv</span>(.Naked) <span class=\"tok-type\">noreturn</span> {\n    abort();\n}\n\n<span class=\"tok-comment\">// The inline calling convention forces a function to be inlined at all call sites.</span>\n<span class=\"tok-comment\">// If the function cannot be inlined, it is a compile-time error.</span>\n<span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">shiftLeftOne</span>(a: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">return</span> a << <span class=\"tok-number\">1</span>;\n}\n\n<span class=\"tok-comment\">// The pub specifier allows the function to be visible when importing.</span>\n<span class=\"tok-comment\">// Another file can use @import and call sub2</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">sub2</span>(a: <span class=\"tok-type\">i8</span>, b: <span class=\"tok-type\">i8</span>) <span class=\"tok-type\">i8</span> {\n    <span class=\"tok-kw\">return</span> a - b;\n}\n\n<span class=\"tok-comment\">// Function pointers are prefixed with `*const `.</span>\n<span class=\"tok-kw\">const</span> Call2Op = *<span class=\"tok-kw\">const</span> <span class=\"tok-kw\">fn</span> (a: <span class=\"tok-type\">i8</span>, b: <span class=\"tok-type\">i8</span>) <span class=\"tok-type\">i8</span>;\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doOp</span>(fnCall: Call2Op, op1: <span class=\"tok-type\">i8</span>, op2: <span class=\"tok-type\">i8</span>) <span class=\"tok-type\">i8</span> {\n    <span class=\"tok-kw\">return</span> fnCall(op1, op2);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"function\"</span> {\n    <span class=\"tok-kw\">try</span> expect(doOp(add, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>) == <span class=\"tok-number\">11</span>);\n    <span class=\"tok-kw\">try</span> expect(doOp(sub2, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span>) == -<span class=\"tok-number\">1</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Functions §",
    "context": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, an",
    "response": "<span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> {\n    x: <span class=\"tok-type\">i32</span>,\n    y: <span class=\"tok-type\">i32</span>,\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(point: Point) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-comment\">// Here, `point` could be a reference, or a copy. The function body</span>\n    <span class=\"tok-comment\">// can ignore the difference and treat it as a value. Be very careful</span>\n    <span class=\"tok-comment\">// taking the address of the parameter - it should be treated as if</span>\n    <span class=\"tok-comment\">// the address will become invalid when the function returns.</span>\n    <span class=\"tok-kw\">return</span> point.x + point.y;\n}\n\n<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"pass struct to function\"</span> {\n    <span class=\"tok-kw\">try</span> expect(foo(Point{ .x = <span class=\"tok-number\">1</span>, .y = <span class=\"tok-number\">2</span> }) == <span class=\"tok-number\">3</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Functions §",
    "context": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, an",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">addFortyTwo</span>(x: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(x) {\n    <span class=\"tok-kw\">return</span> x + <span class=\"tok-number\">42</span>;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fn type inference\"</span> {\n    <span class=\"tok-kw\">try</span> expect(addFortyTwo(<span class=\"tok-number\">1</span>) == <span class=\"tok-number\">43</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(addFortyTwo(<span class=\"tok-number\">1</span>)) == <span class=\"tok-type\">comptime_int</span>);\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-type\">i64</span> = <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">try</span> expect(addFortyTwo(y) == <span class=\"tok-number\">44</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(addFortyTwo(y)) == <span class=\"tok-type\">i64</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Functions §",
    "context": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, an",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inline function call\"</span> {\n    <span class=\"tok-kw\">if</span> (foo(<span class=\"tok-number\">1200</span>, <span class=\"tok-number\">34</span>) != <span class=\"tok-number\">1234</span>) {\n        <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"bad\"</span>);\n    }\n}\n\n<span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> a + b;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Functions §",
    "context": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, an",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> math = std.math;\n<span class=\"tok-kw\">const</span> testing = std.testing;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fn reflection\"</span> {\n    <span class=\"tok-kw\">try</span> testing.expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(testing.expect)).Fn.params[<span class=\"tok-number\">0</span>].<span class=\"tok-type\">type</span>.? == <span class=\"tok-type\">bool</span>);\n    <span class=\"tok-kw\">try</span> testing.expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(testing.tmpDir)).Fn.return_type.? == testing.TmpDir);\n\n    <span class=\"tok-kw\">try</span> testing.expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(math.Log2Int)).Fn.is_generic);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Functions § in Zig 0.13.0",
    "context": "",
    "response": "test_functions.zig Shell There is a difference between a function body and a function pointer . Function bodies are comptime -only types while function Pointers may be runtime-known. Pass-by-value Parameters § Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register. Structs, unions, and arrays can sometimes be more efficiently passed as a reference, since a copy could be arbitrarily expensive depending on the size. When these types are passed as parameters, Zig may choose to copy and pass by value, or pass by reference, whichever way Zig decides will be faster. This is made possible, in part, by the fact that parameters are immutable. test_pass_by_reference_or_value.zig Shell For extern functions, Zig follows the C ABI for passing structs and unions by value. Function Paramet",
    "metadata": {
      "version": "0.13.0",
      "topic": "Functions §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> FileOpenError = <span class=\"tok-kw\">error</span>{\n    AccessDenied,\n    OutOfMemory,\n    FileNotFound,\n};\n\n<span class=\"tok-kw\">const</span> AllocationError = <span class=\"tok-kw\">error</span>{\n    OutOfMemory,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coerce subset to superset\"</span> {\n    <span class=\"tok-kw\">const</span> err = foo(AllocationError.OutOfMemory);\n    <span class=\"tok-kw\">try</span> std.testing.expect(err == FileOpenError.OutOfMemory);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(err: AllocationError) FileOpenError {\n    <span class=\"tok-kw\">return</span> err;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> FileOpenError = <span class=\"tok-kw\">error</span>{\n    AccessDenied,\n    OutOfMemory,\n    FileNotFound,\n};\n\n<span class=\"tok-kw\">const</span> AllocationError = <span class=\"tok-kw\">error</span>{\n    OutOfMemory,\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coerce superset to subset\"</span> {\n    foo(FileOpenError.OutOfMemory) <span class=\"tok-kw\">catch</span> {};\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(err: FileOpenError) AllocationError {\n    <span class=\"tok-kw\">return</span> err;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> err = <span class=\"tok-kw\">error</span>.FileNotFound;",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> err = (<span class=\"tok-kw\">error</span>{FileNotFound}).FileNotFound;",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> maxInt = std.math.maxInt;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">parseU64</span>(buf: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, radix: <span class=\"tok-type\">u8</span>) !<span class=\"tok-type\">u64</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">0</span>;\n\n    <span class=\"tok-kw\">for</span> (buf) |c| {\n        <span class=\"tok-kw\">const</span> digit = charToDigit(c);\n\n        <span class=\"tok-kw\">if</span> (digit >= radix) {\n            <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.InvalidChar;\n        }\n\n        <span class=\"tok-comment\">// x *= radix</span>\n        <span class=\"tok-kw\">var</span> ov = <span class=\"tok-builtin\">@mulWithOverflow</span>(x, radix);\n        <span class=\"tok-kw\">if</span> (ov[<span class=\"tok-number\">1</span>] != <span class=\"tok-number\">0</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.OverFlow;\n\n        <span class=\"tok-comment\">// x += digit</span>\n        ov = <span class=\"tok-builtin\">@addWithOverflow</span>(ov[<span class=\"tok-number\">0</span>], digit);\n        <span class=\"tok-kw\">if</span> (ov[<span class=\"tok-number\">1</span>] != <span class=\"tok-number\">0</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.OverFlow;\n        x = ov[<span class=\"tok-number\">0</span>];\n    }\n\n    <span class=\"tok-kw\">return</span> x;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">charToDigit</span>(c: <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">switch</span> (c) {\n        <span class=\"tok-str\">'0'</span>...<span class=\"tok-str\">'9'</span> => c - <span class=\"tok-str\">'0'</span>,\n        <span class=\"tok-str\">'A'</span>...<span class=\"tok-str\">'Z'</span> => c - <span class=\"tok-str\">'A'</span> + <span class=\"tok-number\">10</span>,\n        <span class=\"tok-str\">'a'</span>...<span class=\"tok-str\">'z'</span> => c - <span class=\"tok-str\">'a'</span> + <span class=\"tok-number\">10</span>,\n        <span class=\"tok-kw\">else</span> => maxInt(<span class=\"tok-type\">u8</span>),\n    };\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"parse u64\"</span> {\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">try</span> parseU64(<span class=\"tok-str\">\"1234\"</span>, <span class=\"tok-number\">10</span>);\n    <span class=\"tok-kw\">try</span> std.testing.expect(result == <span class=\"tok-number\">1234</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> parseU64 = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"error_union_parsing_u64.zig\"</span>).parseU64;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(str: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> number = parseU64(str, <span class=\"tok-number\">10</span>) <span class=\"tok-kw\">catch</span> <span class=\"tok-number\">13</span>;\n    _ = number; <span class=\"tok-comment\">// ...</span>\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> parseU64 = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"error_union_parsing_u64.zig\"</span>).parseU64;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(str: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> number = parseU64(str, <span class=\"tok-number\">10</span>) <span class=\"tok-kw\">catch</span> blk: {\n        <span class=\"tok-comment\">// do things</span>\n        <span class=\"tok-kw\">break</span> :blk <span class=\"tok-number\">13</span>;\n    };\n    _ = number; <span class=\"tok-comment\">// number is now initialized</span>\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> parseU64 = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"error_union_parsing_u64.zig\"</span>).parseU64;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(str: []<span class=\"tok-type\">u8</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> number = parseU64(str, <span class=\"tok-number\">10</span>) <span class=\"tok-kw\">catch</span> |err| <span class=\"tok-kw\">return</span> err;\n    _ = number; <span class=\"tok-comment\">// ...</span>\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> parseU64 = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"error_union_parsing_u64.zig\"</span>).parseU64;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(str: []<span class=\"tok-type\">u8</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> number = <span class=\"tok-kw\">try</span> parseU64(str, <span class=\"tok-number\">10</span>);\n    _ = number; <span class=\"tok-comment\">// ...</span>\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(str: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (parseU64(str, <span class=\"tok-number\">10</span>)) |number| {\n        doSomethingWithNumber(number);\n    } <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.Overflow => {\n            <span class=\"tok-comment\">// handle overflow...</span>\n        },\n        <span class=\"tok-comment\">// we promise that InvalidChar won't happen (or crash in debug mode if it does)</span>\n        <span class=\"tok-kw\">error</span>.InvalidChar => <span class=\"tok-kw\">unreachable</span>,\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAnotherThing</span>(str: []<span class=\"tok-type\">u8</span>) <span class=\"tok-kw\">error</span>{InvalidChar}!<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (parseU64(str, <span class=\"tok-number\">10</span>)) |number| {\n        doSomethingWithNumber(number);\n    } <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.Overflow => {\n            <span class=\"tok-comment\">// handle overflow...</span>\n        },\n        <span class=\"tok-kw\">else</span> => |leftover_err| <span class=\"tok-kw\">return</span> leftover_err,\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doADifferentThing</span>(str: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (parseU64(str, <span class=\"tok-number\">10</span>)) |number| {\n        doSomethingWithNumber(number);\n    } <span class=\"tok-kw\">else</span> |_| {\n        <span class=\"tok-comment\">// do as you'd like</span>\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">createFoo</span>(param: <span class=\"tok-type\">i32</span>) !Foo {\n    <span class=\"tok-kw\">const</span> foo = <span class=\"tok-kw\">try</span> tryToAllocateFoo();\n    <span class=\"tok-comment\">// now we have allocated foo. we need to free it if the function fails.</span>\n    <span class=\"tok-comment\">// but we want to return it if the function succeeds.</span>\n    <span class=\"tok-kw\">errdefer</span> deallocateFoo(foo);\n\n    <span class=\"tok-kw\">const</span> tmp_buf = allocateTmpBuffer() <span class=\"tok-kw\">orelse</span> <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.OutOfMemory;\n    <span class=\"tok-comment\">// tmp_buf is truly a temporary resource, and we for sure want to clean it up</span>\n    <span class=\"tok-comment\">// before this block leaves scope</span>\n    <span class=\"tok-kw\">defer</span> deallocateTmpBuffer(tmp_buf);\n\n    <span class=\"tok-kw\">if</span> (param > <span class=\"tok-number\">1337</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.InvalidParam;\n\n    <span class=\"tok-comment\">// here the errdefer will not run since we're returning success from the function.</span>\n    <span class=\"tok-comment\">// but the defer will run!</span>\n    <span class=\"tok-kw\">return</span> foo;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> Allocator = std.mem.Allocator;\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">struct</span> {\n    data: <span class=\"tok-type\">u32</span>,\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">tryToAllocateFoo</span>(allocator: Allocator) !*Foo {\n    <span class=\"tok-kw\">return</span> allocator.create(Foo);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">deallocateFoo</span>(allocator: Allocator, foo: *Foo) <span class=\"tok-type\">void</span> {\n    allocator.destroy(foo);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">getFooData</span>() !<span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">666</span>;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">createFoo</span>(allocator: Allocator, param: <span class=\"tok-type\">i32</span>) !*Foo {\n    <span class=\"tok-kw\">const</span> foo = getFoo: {\n        <span class=\"tok-kw\">var</span> foo = <span class=\"tok-kw\">try</span> tryToAllocateFoo(allocator);\n        <span class=\"tok-kw\">errdefer</span> deallocateFoo(allocator, foo); <span class=\"tok-comment\">// Only lasts until the end of getFoo</span>\n\n        <span class=\"tok-comment\">// Calls deallocateFoo on error</span>\n        foo.data = <span class=\"tok-kw\">try</span> getFooData();\n\n        <span class=\"tok-kw\">break</span> :getFoo foo;\n    };\n\n    <span class=\"tok-comment\">// Outside of the scope of the errdefer, so</span>\n    <span class=\"tok-comment\">// deallocateFoo will not be called here</span>\n    <span class=\"tok-kw\">if</span> (param > <span class=\"tok-number\">1337</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.InvalidParam;\n\n    <span class=\"tok-kw\">return</span> foo;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"createFoo\"</span> {\n    <span class=\"tok-kw\">try</span> std.testing.expectError(<span class=\"tok-kw\">error</span>.InvalidParam, createFoo(std.testing.allocator, <span class=\"tok-number\">2468</span>));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> Allocator = std.mem.Allocator;\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">struct</span> {\n    data: <span class=\"tok-type\">u32</span>,\n};\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">tryToAllocateFoo</span>(allocator: Allocator) !*Foo {\n    <span class=\"tok-kw\">return</span> allocator.create(Foo);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">deallocateFoo</span>(allocator: Allocator, foo: *Foo) <span class=\"tok-type\">void</span> {\n    allocator.destroy(foo);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">getFooData</span>() !<span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">666</span>;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">createFoo</span>(allocator: Allocator, param: <span class=\"tok-type\">i32</span>) !*Foo {\n    <span class=\"tok-kw\">const</span> foo = getFoo: {\n        <span class=\"tok-kw\">var</span> foo = <span class=\"tok-kw\">try</span> tryToAllocateFoo(allocator);\n        <span class=\"tok-kw\">errdefer</span> deallocateFoo(allocator, foo);\n\n        foo.data = <span class=\"tok-kw\">try</span> getFooData();\n\n        <span class=\"tok-kw\">break</span> :getFoo foo;\n    };\n    <span class=\"tok-comment\">// This lasts for the rest of the function</span>\n    <span class=\"tok-kw\">errdefer</span> deallocateFoo(allocator, foo);\n\n    <span class=\"tok-comment\">// Error is now properly handled by errdefer</span>\n    <span class=\"tok-kw\">if</span> (param > <span class=\"tok-number\">1337</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.InvalidParam;\n\n    <span class=\"tok-kw\">return</span> foo;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"createFoo\"</span> {\n    <span class=\"tok-kw\">try</span> std.testing.expectError(<span class=\"tok-kw\">error</span>.InvalidParam, createFoo(std.testing.allocator, <span class=\"tok-number\">2468</span>));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> Allocator = std.mem.Allocator;\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">struct</span> { data: *<span class=\"tok-type\">u32</span> };\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">getData</span>() !<span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">666</span>;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">genFoos</span>(allocator: Allocator, num: <span class=\"tok-type\">usize</span>) ![]Foo {\n    <span class=\"tok-kw\">const</span> foos = <span class=\"tok-kw\">try</span> allocator.alloc(Foo, num);\n    <span class=\"tok-kw\">errdefer</span> allocator.free(foos);\n\n    <span class=\"tok-kw\">for</span> (foos, <span class=\"tok-number\">0</span>..) |*foo, i| {\n        foo.data = <span class=\"tok-kw\">try</span> allocator.create(<span class=\"tok-type\">u32</span>);\n        <span class=\"tok-comment\">// This errdefer does not last between iterations</span>\n        <span class=\"tok-kw\">errdefer</span> allocator.destroy(foo.data);\n\n        <span class=\"tok-comment\">// The data for the first 3 foos will be leaked</span>\n        <span class=\"tok-kw\">if</span> (i >= <span class=\"tok-number\">3</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.TooManyFoos;\n\n        foo.data.* = <span class=\"tok-kw\">try</span> getData();\n    }\n\n    <span class=\"tok-kw\">return</span> foos;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"genFoos\"</span> {\n    <span class=\"tok-kw\">try</span> std.testing.expectError(<span class=\"tok-kw\">error</span>.TooManyFoos, genFoos(std.testing.allocator, <span class=\"tok-number\">5</span>));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> Allocator = std.mem.Allocator;\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">struct</span> { data: *<span class=\"tok-type\">u32</span> };\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">getData</span>() !<span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">666</span>;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">genFoos</span>(allocator: Allocator, num: <span class=\"tok-type\">usize</span>) ![]Foo {\n    <span class=\"tok-kw\">const</span> foos = <span class=\"tok-kw\">try</span> allocator.alloc(Foo, num);\n    <span class=\"tok-kw\">errdefer</span> allocator.free(foos);\n\n    <span class=\"tok-comment\">// Used to track how many foos have been initialized</span>\n    <span class=\"tok-comment\">// (including their data being allocated)</span>\n    <span class=\"tok-kw\">var</span> num_allocated: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">errdefer</span> <span class=\"tok-kw\">for</span> (foos[<span class=\"tok-number\">0</span>..num_allocated]) |foo| {\n        allocator.destroy(foo.data);\n    };\n    <span class=\"tok-kw\">for</span> (foos, <span class=\"tok-number\">0</span>..) |*foo, i| {\n        foo.data = <span class=\"tok-kw\">try</span> allocator.create(<span class=\"tok-type\">u32</span>);\n        num_allocated += <span class=\"tok-number\">1</span>;\n\n        <span class=\"tok-kw\">if</span> (i >= <span class=\"tok-number\">3</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.TooManyFoos;\n\n        foo.data.* = <span class=\"tok-kw\">try</span> getData();\n    }\n\n    <span class=\"tok-kw\">return</span> foos;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"genFoos\"</span> {\n    <span class=\"tok-kw\">try</span> std.testing.expectError(<span class=\"tok-kw\">error</span>.TooManyFoos, genFoos(std.testing.allocator, <span class=\"tok-number\">5</span>));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"error union\"</span> {\n    <span class=\"tok-kw\">var</span> foo: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n\n    <span class=\"tok-comment\">// Coerce from child type of an error union:</span>\n    foo = <span class=\"tok-number\">1234</span>;\n\n    <span class=\"tok-comment\">// Coerce from an error set:</span>\n    foo = <span class=\"tok-kw\">error</span>.SomeError;\n\n    <span class=\"tok-comment\">// Use compile-time reflection to access the payload type of an error union:</span>\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(foo)).ErrorUnion.payload == <span class=\"tok-type\">i32</span>);\n\n    <span class=\"tok-comment\">// Use compile-time reflection to access the error set type of an error union:</span>\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(foo)).ErrorUnion.error_set == <span class=\"tok-type\">anyerror</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">const</span> A = <span class=\"tok-kw\">error</span>{\n    NotDir,\n\n    <span class=\"tok-comment\">/// A doc comment</span>\n    PathNotFound,\n};\n<span class=\"tok-kw\">const</span> B = <span class=\"tok-kw\">error</span>{\n    OutOfMemory,\n\n    <span class=\"tok-comment\">/// B doc comment</span>\n    PathNotFound,\n};\n\n<span class=\"tok-kw\">const</span> C = A || B;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() C!<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.NotDir;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"merge error sets\"</span> {\n    <span class=\"tok-kw\">if</span> (foo()) {\n        <span class=\"tok-builtin\">@panic</span>(<span class=\"tok-str\">\"unexpected\"</span>);\n    } <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.OutOfMemory => <span class=\"tok-builtin\">@panic</span>(<span class=\"tok-str\">\"unexpected\"</span>),\n        <span class=\"tok-kw\">error</span>.PathNotFound => <span class=\"tok-builtin\">@panic</span>(<span class=\"tok-str\">\"unexpected\"</span>),\n        <span class=\"tok-kw\">error</span>.NotDir => {},\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-comment\">// With an inferred error set</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add_inferred</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) !T {\n    <span class=\"tok-kw\">const</span> ov = <span class=\"tok-builtin\">@addWithOverflow</span>(a, b);\n    <span class=\"tok-kw\">if</span> (ov[<span class=\"tok-number\">1</span>] != <span class=\"tok-number\">0</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.Overflow;\n    <span class=\"tok-kw\">return</span> ov[<span class=\"tok-number\">0</span>];\n}\n\n<span class=\"tok-comment\">// With an explicit error set</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add_explicit</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) Error!T {\n    <span class=\"tok-kw\">const</span> ov = <span class=\"tok-builtin\">@addWithOverflow</span>(a, b);\n    <span class=\"tok-kw\">if</span> (ov[<span class=\"tok-number\">1</span>] != <span class=\"tok-number\">0</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.Overflow;\n    <span class=\"tok-kw\">return</span> ov[<span class=\"tok-number\">0</span>];\n}\n\n<span class=\"tok-kw\">const</span> Error = <span class=\"tok-kw\">error</span>{\n    Overflow,\n};\n\n<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"inferred error set\"</span> {\n    <span class=\"tok-kw\">if</span> (add_inferred(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">255</span>, <span class=\"tok-number\">1</span>)) |_| <span class=\"tok-kw\">unreachable</span> <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.Overflow => {}, <span class=\"tok-comment\">// ok</span>\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> foo(<span class=\"tok-number\">12</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(x: <span class=\"tok-type\">i32</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (x >= <span class=\"tok-number\">5</span>) {\n        <span class=\"tok-kw\">try</span> bar();\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">try</span> bang2();\n    }\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (baz()) {\n        <span class=\"tok-kw\">try</span> quux();\n    } <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.FileNotFound => <span class=\"tok-kw\">try</span> hello(),\n    }\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">baz</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> bang1();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">quux</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> bang2();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">hello</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> bang2();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bang1</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.FileNotFound;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bang2</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.PermissionDenied;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    foo(<span class=\"tok-number\">12</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(x: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (x >= <span class=\"tok-number\">5</span>) {\n        bar();\n    } <span class=\"tok-kw\">else</span> {\n        bang2();\n    }\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (baz()) {\n        quux();\n    } <span class=\"tok-kw\">else</span> {\n        hello();\n    }\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">baz</span>() <span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">return</span> bang1();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">quux</span>() <span class=\"tok-type\">void</span> {\n    bang2();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">hello</span>() <span class=\"tok-type\">void</span> {\n    bang2();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bang1</span>() <span class=\"tok-type\">bool</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-null\">false</span>;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bang2</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-builtin\">@panic</span>(<span class=\"tok-str\">\"PermissionDenied\"</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> StackTrace = <span class=\"tok-kw\">struct</span> {\n    index: <span class=\"tok-type\">usize</span>,\n    instruction_addresses: [N]<span class=\"tok-type\">usize</span>,\n};",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Errors §",
    "context": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent al",
    "response": "<span class=\"tok-comment\">// marked as \"no-inline\" in LLVM IR</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">__zig_return_error</span>(stack_trace: *StackTrace) <span class=\"tok-type\">void</span> {\n    stack_trace.instruction_addresses[stack_trace.index] = <span class=\"tok-builtin\">@returnAddress</span>();\n    stack_trace.index = (stack_trace.index + <span class=\"tok-number\">1</span>) % N;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Errors § in Zig 0.13.0",
    "context": "",
    "response": "Error Set Type § An error set is like an enum . However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. The error set type defaults to a u16 , though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent all of the error values will be used. You can coerce an error from a subset to a superset: test_coerce_error_subset_to_superset.zig Shell But you cannot coerce an error from a superset to a subset: test_coerce_error_superset_to_subset.zig Shell There is a shortcut for declaring an error set with only 1 value, and then getting that value: single_value_error_set_shortcut.zig This is equivalent to: single_value_error_set.zig This becomes useful when using Inferred Error Sets . The Global Error Set § ",
    "metadata": {
      "version": "0.13.0",
      "topic": "Errors §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-comment\">// normal integer</span>\n<span class=\"tok-kw\">const</span> normal_int: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n\n<span class=\"tok-comment\">// optional integer</span>\n<span class=\"tok-kw\">const</span> optional_int: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-number\">5678</span>;",
    "metadata": {
      "version": "0.13.0",
      "topic": "Optionals §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "// malloc prototype included for reference\nvoid *malloc(size_t size);\n\nstruct Foo *do_a_thing(void) {\n    char *ptr = malloc(1234);\n    if (!ptr) return NULL;\n    // ...\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Optionals §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-comment\">// malloc prototype included for reference</span>\n<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">malloc</span>(size: <span class=\"tok-type\">usize</span>) ?[*]<span class=\"tok-type\">u8</span>;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>() ?*Foo {\n    <span class=\"tok-kw\">const</span> ptr = malloc(<span class=\"tok-number\">1234</span>) <span class=\"tok-kw\">orelse</span> <span class=\"tok-kw\">return</span> <span class=\"tok-null\">null</span>;\n    _ = ptr; <span class=\"tok-comment\">// ...</span>\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Optionals §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "void do_a_thing(struct Foo *foo) {\n    // do some stuff\n\n    if (foo) {\n        do_something_with_foo(foo);\n    }\n\n    // do some stuff\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Optionals §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">struct</span> {};\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doSomethingWithFoo</span>(foo: *Foo) <span class=\"tok-type\">void</span> {\n    _ = foo;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doAThing</span>(optional_foo: ?*Foo) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-comment\">// do some stuff</span>\n\n    <span class=\"tok-kw\">if</span> (optional_foo) |foo| {\n        doSomethingWithFoo(foo);\n    }\n\n    <span class=\"tok-comment\">// do some stuff</span>\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Optionals §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"optional type\"</span> {\n    <span class=\"tok-comment\">// Declare an optional and coerce from null:</span>\n    <span class=\"tok-kw\">var</span> foo: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-comment\">// Coerce from child type of an optional</span>\n    foo = <span class=\"tok-number\">1234</span>;\n\n    <span class=\"tok-comment\">// Use compile-time reflection to access the child type of the optional:</span>\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(foo)).Optional.child == <span class=\"tok-type\">i32</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Optionals §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-kw\">const</span> optional_value: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;",
    "metadata": {
      "version": "0.13.0",
      "topic": "Optionals §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Optionals §",
    "context": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"optional pointers\"</span> {\n    <span class=\"tok-comment\">// Pointers cannot be null. If you want a null pointer, use the optional</span>\n    <span class=\"tok-comment\">// prefix `?` to make the pointer type optional.</span>\n    <span class=\"tok-kw\">var</span> ptr: ?*<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n    ptr = &x;\n\n    <span class=\"tok-kw\">try</span> expect(ptr.?.* == <span class=\"tok-number\">1</span>);\n\n    <span class=\"tok-comment\">// Optional pointers are the same size as normal pointers, because pointer</span>\n    <span class=\"tok-comment\">// value 0 is used as the null value.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@sizeOf</span>(?*<span class=\"tok-type\">i32</span>) == <span class=\"tok-builtin\">@sizeOf</span>(*<span class=\"tok-type\">i32</span>));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Optionals §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Optionals § in Zig 0.13.0",
    "context": "",
    "response": "One area that Zig provides safety without compromising efficiency or readability is with the optional type. The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: optional_integer.zig Now the variable optional_int could be an i32 , or null . Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer science . Zig does not have them. Instead, you can use an optional pointer. This secretly compiles down to a normal pointer, since we know we can use 0 as the null value for the optional type. But the compiler can check your work and make sure you don't assign null to something that can't be null. Typically the downside of not having null is that it makes the code more verbose to write. But, let's compare some equivalent C code and Zig code. Task: call malloc, if the result is null, return null",
    "metadata": {
      "version": "0.13.0",
      "topic": "Optionals §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"type coercion - variable declaration\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u16</span> = a;\n    _ = b;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"type coercion - function call\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">1</span>;\n    foo(a);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(b: <span class=\"tok-type\">u16</span>) <span class=\"tok-type\">void</span> {\n    _ = b;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"type coercion - @as builtin\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u16</span>, a);\n    _ = b;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Casting §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"type coercion - const qualification\"</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> b: *<span class=\"tok-type\">i32</span> = &a;\n    foo(b);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(_: *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">void</span> {}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Casting §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> mem = std.mem;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"cast *[1][*]const u8 to [*]const ?[*]const u8\"</span> {\n    <span class=\"tok-kw\">const</span> window_name = [<span class=\"tok-number\">1</span>][*]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>{<span class=\"tok-str\">\"window name\"</span>};\n    <span class=\"tok-kw\">const</span> x: [*]<span class=\"tok-kw\">const</span> ?[*]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = &window_name;\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, std.mem.sliceTo(<span class=\"tok-builtin\">@as</span>([*:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, <span class=\"tok-builtin\">@ptrCast</span>(x[<span class=\"tok-number\">0</span>].?)), <span class=\"tok-number\">0</span>), <span class=\"tok-str\">\"window name\"</span>));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> mem = std.mem;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"integer widening\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">250</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u16</span> = a;\n    <span class=\"tok-kw\">const</span> c: <span class=\"tok-type\">u32</span> = b;\n    <span class=\"tok-kw\">const</span> d: <span class=\"tok-type\">u64</span> = c;\n    <span class=\"tok-kw\">const</span> e: <span class=\"tok-type\">u64</span> = d;\n    <span class=\"tok-kw\">const</span> f: <span class=\"tok-type\">u128</span> = e;\n    <span class=\"tok-kw\">try</span> expect(f == a);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"implicit unsigned integer to signed integer\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">250</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">i16</span> = a;\n    <span class=\"tok-kw\">try</span> expect(b == <span class=\"tok-number\">250</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"float widening\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">f16</span> = <span class=\"tok-number\">12.34</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">f32</span> = a;\n    <span class=\"tok-kw\">const</span> c: <span class=\"tok-type\">f64</span> = b;\n    <span class=\"tok-kw\">const</span> d: <span class=\"tok-type\">f128</span> = c;\n    <span class=\"tok-kw\">try</span> expect(d == a);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-comment\">// Compile time coercion of float to int</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"implicit cast to comptime_int\"</span> {\n    <span class=\"tok-kw\">const</span> f: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">54.0</span> / <span class=\"tok-number\">5</span>;\n    _ = f;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-comment\">// You can assign constant pointers to arrays to a slice with</span>\n<span class=\"tok-comment\">// const modifier on the element type. Useful in particular for</span>\n<span class=\"tok-comment\">// String literals.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*const [N]T to []const T\"</span> {\n    <span class=\"tok-kw\">const</span> x1: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>;\n    <span class=\"tok-kw\">const</span> x2: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = &[<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span>{ <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-number\">111</span> };\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, x1, x2));\n\n    <span class=\"tok-kw\">const</span> y: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">f32</span> = &[<span class=\"tok-number\">2</span>]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.2</span>, <span class=\"tok-number\">3.4</span> };\n    <span class=\"tok-kw\">try</span> expect(y[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1.2</span>);\n}\n\n<span class=\"tok-comment\">// Likewise, it works when the destination type is an error union.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*const [N]T to E![]const T\"</span> {\n    <span class=\"tok-kw\">const</span> x1: <span class=\"tok-type\">anyerror</span>![]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>;\n    <span class=\"tok-kw\">const</span> x2: <span class=\"tok-type\">anyerror</span>![]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = &[<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span>{ <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-number\">111</span> };\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-kw\">try</span> x1, <span class=\"tok-kw\">try</span> x2));\n\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-type\">anyerror</span>![]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">f32</span> = &[<span class=\"tok-number\">2</span>]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.2</span>, <span class=\"tok-number\">3.4</span> };\n    <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> y)[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1.2</span>);\n}\n\n<span class=\"tok-comment\">// Likewise, it works when the destination type is an optional.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*const [N]T to ?[]const T\"</span> {\n    <span class=\"tok-kw\">const</span> x1: ?[]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>;\n    <span class=\"tok-kw\">const</span> x2: ?[]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> = &[<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span>{ <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-number\">111</span> };\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, x1.?, x2.?));\n\n    <span class=\"tok-kw\">const</span> y: ?[]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">f32</span> = &[<span class=\"tok-number\">2</span>]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.2</span>, <span class=\"tok-number\">3.4</span> };\n    <span class=\"tok-kw\">try</span> expect(y.?[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1.2</span>);\n}\n\n<span class=\"tok-comment\">// In this cast, the array length becomes the slice length.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*[N]T to []T\"</span> {\n    <span class=\"tok-kw\">var</span> buf: [<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>.*;\n    <span class=\"tok-kw\">const</span> x: []<span class=\"tok-type\">u8</span> = &buf;\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, x, <span class=\"tok-str\">\"hello\"</span>));\n\n    <span class=\"tok-kw\">const</span> buf2 = [<span class=\"tok-number\">2</span>]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.2</span>, <span class=\"tok-number\">3.4</span> };\n    <span class=\"tok-kw\">const</span> x2: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">f32</span> = &buf2;\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">f32</span>, x2, &[<span class=\"tok-number\">2</span>]<span class=\"tok-type\">f32</span>{ <span class=\"tok-number\">1.2</span>, <span class=\"tok-number\">3.4</span> }));\n}\n\n<span class=\"tok-comment\">// Single-item pointers to arrays can be coerced to many-item pointers.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*[N]T to [*]T\"</span> {\n    <span class=\"tok-kw\">var</span> buf: [<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>.*;\n    <span class=\"tok-kw\">const</span> x: [*]<span class=\"tok-type\">u8</span> = &buf;\n    <span class=\"tok-kw\">try</span> expect(x[<span class=\"tok-number\">4</span>] == <span class=\"tok-str\">'o'</span>);\n    <span class=\"tok-comment\">// x[5] would be an uncaught out of bounds pointer dereference!</span>\n}\n\n<span class=\"tok-comment\">// Likewise, it works when the destination type is an optional.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*[N]T to ?[*]T\"</span> {\n    <span class=\"tok-kw\">var</span> buf: [<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>.*;\n    <span class=\"tok-kw\">const</span> x: ?[*]<span class=\"tok-type\">u8</span> = &buf;\n    <span class=\"tok-kw\">try</span> expect(x.?[<span class=\"tok-number\">4</span>] == <span class=\"tok-str\">'o'</span>);\n}\n\n<span class=\"tok-comment\">// Single-item pointers can be cast to len-1 single-item arrays.</span>\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"*T to *[1]T\"</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> y: *[<span class=\"tok-number\">1</span>]<span class=\"tok-type\">i32</span> = &x;\n    <span class=\"tok-kw\">const</span> z: [*]<span class=\"tok-type\">i32</span> = y;\n    <span class=\"tok-kw\">try</span> expect(z[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">1234</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coerce to optionals\"</span> {\n    <span class=\"tok-kw\">const</span> x: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> y: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-kw\">try</span> expect(x.? == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> expect(y == <span class=\"tok-null\">null</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coerce to optionals wrapped in error union\"</span> {\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-type\">anyerror</span>!?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> x).? == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> y) == <span class=\"tok-null\">null</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coercion to error unions\"</span> {\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">i32</span> = <span class=\"tok-kw\">error</span>.Failure;\n\n    <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> x) == <span class=\"tok-number\">1234</span>);\n    <span class=\"tok-kw\">try</span> std.testing.expectError(<span class=\"tok-kw\">error</span>.Failure, y);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coercing large integer type to smaller one when value is comptime-known to fit\"</span> {\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">255</span>;\n    <span class=\"tok-kw\">const</span> y: <span class=\"tok-type\">u8</span> = x;\n    <span class=\"tok-kw\">try</span> expect(y == <span class=\"tok-number\">255</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> E = <span class=\"tok-kw\">enum</span> {\n    one,\n    two,\n    three,\n};\n\n<span class=\"tok-kw\">const</span> U = <span class=\"tok-kw\">union</span>(E) {\n    one: <span class=\"tok-type\">i32</span>,\n    two: <span class=\"tok-type\">f32</span>,\n    three,\n};\n\n<span class=\"tok-kw\">const</span> U2 = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n    a: <span class=\"tok-type\">void</span>,\n    b: <span class=\"tok-type\">f32</span>,\n\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">tag</span>(self: U2) <span class=\"tok-type\">usize</span> {\n        <span class=\"tok-kw\">switch</span> (self) {\n            .a => <span class=\"tok-kw\">return</span> <span class=\"tok-number\">1</span>,\n            .b => <span class=\"tok-kw\">return</span> <span class=\"tok-number\">2</span>,\n        }\n    }\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coercion between unions and enums\"</span> {\n    <span class=\"tok-kw\">const</span> u = U{ .two = <span class=\"tok-number\">12.34</span> };\n    <span class=\"tok-kw\">const</span> e: E = u; <span class=\"tok-comment\">// coerce union to enum</span>\n    <span class=\"tok-kw\">try</span> expect(e == E.two);\n\n    <span class=\"tok-kw\">const</span> three = E.three;\n    <span class=\"tok-kw\">const</span> u_2: U = three; <span class=\"tok-comment\">// coerce enum to union</span>\n    <span class=\"tok-kw\">try</span> expect(u_2 == E.three);\n\n    <span class=\"tok-kw\">const</span> u_3: U = .three; <span class=\"tok-comment\">// coerce enum literal to union</span>\n    <span class=\"tok-kw\">try</span> expect(u_3 == E.three);\n\n    <span class=\"tok-kw\">const</span> u_4: U2 = .a; <span class=\"tok-comment\">// coerce enum literal to union with inferred enum tag type.</span>\n    <span class=\"tok-kw\">try</span> expect(u_4.tag() == <span class=\"tok-number\">1</span>);\n\n    <span class=\"tok-comment\">// The following example is invalid.</span>\n    <span class=\"tok-comment\">// error: coercion from enum '@TypeOf(.enum_literal)' to union 'test_coerce_unions_enum.U2' must initialize 'f32' field 'b'</span>\n    <span class=\"tok-comment\">//var u_5: U2 = .b;</span>\n    <span class=\"tok-comment\">//try expect(u_5.tag() == 2);</span>\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Casting §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Tuple = <span class=\"tok-kw\">struct</span> { <span class=\"tok-type\">u8</span>, <span class=\"tok-type\">u8</span> };\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"coercion from homogenous tuple to array\"</span> {\n    <span class=\"tok-kw\">const</span> tuple: Tuple = .{ <span class=\"tok-number\">5</span>, <span class=\"tok-number\">6</span> };\n    <span class=\"tok-kw\">const</span> array: [<span class=\"tok-number\">2</span>]<span class=\"tok-type\">u8</span> = tuple;\n    _ = array;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Casting §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Casting §",
    "context": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Sh",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> mem = std.mem;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer resolve int widening\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">i8</span> = <span class=\"tok-number\">12</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">i16</span> = <span class=\"tok-number\">34</span>;\n    <span class=\"tok-kw\">const</span> c = a + b;\n    <span class=\"tok-kw\">try</span> expect(c == <span class=\"tok-number\">46</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(c) == <span class=\"tok-type\">i16</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer resolve arrays of different size to const slice\"</span> {\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, boolToStr(<span class=\"tok-null\">true</span>), <span class=\"tok-str\">\"true\"</span>));\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, boolToStr(<span class=\"tok-null\">false</span>), <span class=\"tok-str\">\"false\"</span>));\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, boolToStr(<span class=\"tok-null\">true</span>), <span class=\"tok-str\">\"true\"</span>));\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, boolToStr(<span class=\"tok-null\">false</span>), <span class=\"tok-str\">\"false\"</span>));\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">boolToStr</span>(b: <span class=\"tok-type\">bool</span>) []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (b) <span class=\"tok-str\">\"true\"</span> <span class=\"tok-kw\">else</span> <span class=\"tok-str\">\"false\"</span>;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer resolve array and const slice\"</span> {\n    <span class=\"tok-kw\">try</span> testPeerResolveArrayConstSlice(<span class=\"tok-null\">true</span>);\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> testPeerResolveArrayConstSlice(<span class=\"tok-null\">true</span>);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">testPeerResolveArrayConstSlice</span>(b: <span class=\"tok-type\">bool</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> value1 = <span class=\"tok-kw\">if</span> (b) <span class=\"tok-str\">\"aoeu\"</span> <span class=\"tok-kw\">else</span> <span class=\"tok-builtin\">@as</span>([]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, <span class=\"tok-str\">\"zz\"</span>);\n    <span class=\"tok-kw\">const</span> value2 = <span class=\"tok-kw\">if</span> (b) <span class=\"tok-builtin\">@as</span>([]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, <span class=\"tok-str\">\"zz\"</span>) <span class=\"tok-kw\">else</span> <span class=\"tok-str\">\"aoeu\"</span>;\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, value1, <span class=\"tok-str\">\"aoeu\"</span>));\n    <span class=\"tok-kw\">try</span> expect(mem.eql(<span class=\"tok-type\">u8</span>, value2, <span class=\"tok-str\">\"zz\"</span>));\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer type resolution: ?T and T\"</span> {\n    <span class=\"tok-kw\">try</span> expect(peerTypeTAndOptionalT(<span class=\"tok-null\">true</span>, <span class=\"tok-null\">false</span>).? == <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(peerTypeTAndOptionalT(<span class=\"tok-null\">false</span>, <span class=\"tok-null\">false</span>).? == <span class=\"tok-number\">3</span>);\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">try</span> expect(peerTypeTAndOptionalT(<span class=\"tok-null\">true</span>, <span class=\"tok-null\">false</span>).? == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect(peerTypeTAndOptionalT(<span class=\"tok-null\">false</span>, <span class=\"tok-null\">false</span>).? == <span class=\"tok-number\">3</span>);\n    }\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">peerTypeTAndOptionalT</span>(c: <span class=\"tok-type\">bool</span>, b: <span class=\"tok-type\">bool</span>) ?<span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">if</span> (c) {\n        <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (b) <span class=\"tok-null\">null</span> <span class=\"tok-kw\">else</span> <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">usize</span>, <span class=\"tok-number\">0</span>);\n    }\n\n    <span class=\"tok-kw\">return</span> <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">usize</span>, <span class=\"tok-number\">3</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer type resolution: *[0]u8 and []const u8\"</span> {\n    <span class=\"tok-kw\">try</span> expect(peerTypeEmptyArrayAndSlice(<span class=\"tok-null\">true</span>, <span class=\"tok-str\">\"hi\"</span>).len == <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(peerTypeEmptyArrayAndSlice(<span class=\"tok-null\">false</span>, <span class=\"tok-str\">\"hi\"</span>).len == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">try</span> expect(peerTypeEmptyArrayAndSlice(<span class=\"tok-null\">true</span>, <span class=\"tok-str\">\"hi\"</span>).len == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect(peerTypeEmptyArrayAndSlice(<span class=\"tok-null\">false</span>, <span class=\"tok-str\">\"hi\"</span>).len == <span class=\"tok-number\">1</span>);\n    }\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">peerTypeEmptyArrayAndSlice</span>(a: <span class=\"tok-type\">bool</span>, slice: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">if</span> (a) {\n        <span class=\"tok-kw\">return</span> &[_]<span class=\"tok-type\">u8</span>{};\n    }\n\n    <span class=\"tok-kw\">return</span> slice[<span class=\"tok-number\">0</span>..<span class=\"tok-number\">1</span>];\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer type resolution: *[0]u8, []const u8, and anyerror![]u8\"</span> {\n    {\n        <span class=\"tok-kw\">var</span> data = <span class=\"tok-str\">\"hi\"</span>.*;\n        <span class=\"tok-kw\">const</span> slice = data[<span class=\"tok-number\">0</span>..];\n        <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> peerTypeEmptyArrayAndSliceAndError(<span class=\"tok-null\">true</span>, slice)).len == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> peerTypeEmptyArrayAndSliceAndError(<span class=\"tok-null\">false</span>, slice)).len == <span class=\"tok-number\">1</span>);\n    }\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">var</span> data = <span class=\"tok-str\">\"hi\"</span>.*;\n        <span class=\"tok-kw\">const</span> slice = data[<span class=\"tok-number\">0</span>..];\n        <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> peerTypeEmptyArrayAndSliceAndError(<span class=\"tok-null\">true</span>, slice)).len == <span class=\"tok-number\">0</span>);\n        <span class=\"tok-kw\">try</span> expect((<span class=\"tok-kw\">try</span> peerTypeEmptyArrayAndSliceAndError(<span class=\"tok-null\">false</span>, slice)).len == <span class=\"tok-number\">1</span>);\n    }\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">peerTypeEmptyArrayAndSliceAndError</span>(a: <span class=\"tok-type\">bool</span>, slice: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">anyerror</span>![]<span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">if</span> (a) {\n        <span class=\"tok-kw\">return</span> &[_]<span class=\"tok-type\">u8</span>{};\n    }\n\n    <span class=\"tok-kw\">return</span> slice[<span class=\"tok-number\">0</span>..<span class=\"tok-number\">1</span>];\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer type resolution: *const T and ?*T\"</span> {\n    <span class=\"tok-kw\">const</span> a: *<span class=\"tok-kw\">const</span> <span class=\"tok-type\">usize</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0x123456780</span>);\n    <span class=\"tok-kw\">const</span> b: ?*<span class=\"tok-type\">usize</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0x123456780</span>);\n    <span class=\"tok-kw\">try</span> expect(a == b);\n    <span class=\"tok-kw\">try</span> expect(b == a);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"peer type resolution: error union switch\"</span> {\n    <span class=\"tok-comment\">// The non-error and error cases are only peers if the error case is just a switch expression;</span>\n    <span class=\"tok-comment\">// the pattern `if (x) {...} else |err| blk: { switch (err) {...} }` does not consider the</span>\n    <span class=\"tok-comment\">// non-error and error case to be peers.</span>\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-kw\">error</span>{ A, B, C }!<span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    _ = &a;\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-kw\">if</span> (a) |x|\n        x + <span class=\"tok-number\">3</span>\n    <span class=\"tok-kw\">else</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.A => <span class=\"tok-number\">0</span>,\n        <span class=\"tok-kw\">error</span>.B => <span class=\"tok-number\">1</span>,\n        <span class=\"tok-kw\">error</span>.C => <span class=\"tok-null\">null</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(b) == ?<span class=\"tok-type\">u32</span>);\n\n    <span class=\"tok-comment\">// The non-error and error cases are only peers if the error case is just a switch expression;</span>\n    <span class=\"tok-comment\">// the pattern `x catch |err| blk: { switch (err) {...} }` does not consider the unwrapped `x`</span>\n    <span class=\"tok-comment\">// and error case to be peers.</span>\n    <span class=\"tok-kw\">const</span> c = a <span class=\"tok-kw\">catch</span> |err| <span class=\"tok-kw\">switch</span> (err) {\n        <span class=\"tok-kw\">error</span>.A => <span class=\"tok-number\">0</span>,\n        <span class=\"tok-kw\">error</span>.B => <span class=\"tok-number\">1</span>,\n        <span class=\"tok-kw\">error</span>.C => <span class=\"tok-null\">null</span>,\n    };\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(c) == ?<span class=\"tok-type\">u32</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Casting §",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Explain Casting § in Zig 0.13.0",
    "context": "",
    "response": "A type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types. Type Coercion § Type coercion occurs when one type is expected, but different type is provided: test_type_coercion.zig Shell Type coercions are only allowed when it is completely unambiguous how to get from one type to another, and the transformation is guaranteed to be safe. There is one exception, which is C Pointers . Type Coercion: Stricter Qualification § Values which have the same representation at runtime can be cast to increase the strictness of the qualifiers, no matter how nested the qualifiers are: const - non-const to const is allowed volatile - non-volatile to volatile is allowed align - bigger to sma",
    "metadata": {
      "version": "0.13.0",
      "topic": "Casting §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Zero Bit Types §",
    "context": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no c",
    "response": "<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">entry</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">void</span> = {};\n    <span class=\"tok-kw\">var</span> y: <span class=\"tok-type\">void</span> = {};\n    x = y;\n    y = x;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Zero Bit Types §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Zero Bit Types §",
    "context": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no c",
    "response": "0000000000000010 <entry>:\n  10:\t55                   \tpush   %rbp\n  11:\t48 89 e5             \tmov    %rsp,%rbp\n  14:\t5d                   \tpop    %rbp\n  15:\tc3                   \tretq",
    "metadata": {
      "version": "0.13.0",
      "topic": "Zero Bit Types §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Zero Bit Types §",
    "context": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no c",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"turn HashMap into a set with void\"</span> {\n    <span class=\"tok-kw\">var</span> map = std.AutoHashMap(<span class=\"tok-type\">i32</span>, <span class=\"tok-type\">void</span>).init(std.testing.allocator);\n    <span class=\"tok-kw\">defer</span> map.deinit();\n\n    <span class=\"tok-kw\">try</span> map.put(<span class=\"tok-number\">1</span>, {});\n    <span class=\"tok-kw\">try</span> map.put(<span class=\"tok-number\">2</span>, {});\n\n    <span class=\"tok-kw\">try</span> expect(map.contains(<span class=\"tok-number\">2</span>));\n    <span class=\"tok-kw\">try</span> expect(!map.contains(<span class=\"tok-number\">3</span>));\n\n    _ = map.remove(<span class=\"tok-number\">2</span>);\n    <span class=\"tok-kw\">try</span> expect(!map.contains(<span class=\"tok-number\">2</span>));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Zero Bit Types §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Zero Bit Types §",
    "context": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no c",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"ignoring expression value\"</span> {\n    foo();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">1234</span>;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Zero Bit Types §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Zero Bit Types §",
    "context": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no c",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"void is ignored\"</span> {\n    returnsVoid();\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"explicitly ignoring expression value\"</span> {\n    _ = foo();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">returnsVoid</span>() <span class=\"tok-type\">void</span> {}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-number\">1234</span>;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Zero Bit Types §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Zero Bit Types § in Zig 0.13.0",
    "context": "",
    "response": "For some types, @sizeOf is 0: void The Integers u0 and i0 . Arrays and Vectors with len 0, or with an element type that is a zero bit type. An enum with only 1 tag. A struct with all fields being zero bit types. A union with only 1 field which is a zero bit type. These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: zero_bit_types.zig When this turns into machine code, there is no code generated in the body of entry , even in Debug mode. For example, on x86_64: These assembly instructions do not have any code associated with the void values - they only perform the function call prologue and epilogue. void § void can be useful for instantiating generic types. For example, given a Map(Key, Value) , one can pass void for the Value type to make it into a Set : test_void_in_hashmap.zig Shell Note that this is different from using a dummy value for the hash map value. By using v",
    "metadata": {
      "version": "0.13.0",
      "topic": "Zero Bit Types §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Result Location Semantics §",
    "context": "During compilation, every Zig expression and sub-expression is assigned optional result location information. This information dictates what type the expression should have (its result type), and where the resulting value should be placed in memory (its result location). The information is optional in the sense that not every expression has this information: assignment to _ , for instance, does not provide any information about the type of an expression, nor does it provide a concrete memory loc",
    "response": "<span class=\"tok-kw\">const</span> expectEqual = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expectEqual;\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"result type propagates through struct initializer\"</span> {\n    <span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> { x: <span class=\"tok-type\">u32</span> };\n    <span class=\"tok-kw\">const</span> val: <span class=\"tok-type\">u64</span> = <span class=\"tok-number\">123</span>;\n    <span class=\"tok-kw\">const</span> s: S = .{ .x = <span class=\"tok-builtin\">@intCast</span>(val) };\n    <span class=\"tok-comment\">// .{ .x = @intCast(val) }   has result type `S` due to the type annotation</span>\n    <span class=\"tok-comment\">//         @intCast(val)     has result type `u32` due to the type of the field `S.x`</span>\n    <span class=\"tok-comment\">//                  val      has no result type, as it is permitted to be any integer type</span>\n    <span class=\"tok-kw\">try</span> expectEqual(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u32</span>, <span class=\"tok-number\">123</span>), s.x);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Result Location Semantics §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Result Location Semantics §",
    "context": "During compilation, every Zig expression and sub-expression is assigned optional result location information. This information dictates what type the expression should have (its result type), and where the resulting value should be placed in memory (its result location). The information is optional in the sense that not every expression has this information: assignment to _ , for instance, does not provide any information about the type of an expression, nor does it provide a concrete memory loc",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"attempt to swap array elements with array initializer\"</span> {\n    <span class=\"tok-kw\">var</span> arr: [<span class=\"tok-number\">2</span>]<span class=\"tok-type\">u32</span> = .{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span> };\n    arr = .{ arr[<span class=\"tok-number\">1</span>], arr[<span class=\"tok-number\">0</span>] };\n    <span class=\"tok-comment\">// The previous line is equivalent to the following two lines:</span>\n    <span class=\"tok-comment\">//   arr[0] = arr[1];</span>\n    <span class=\"tok-comment\">//   arr[1] = arr[0];</span>\n    <span class=\"tok-comment\">// So this fails!</span>\n    <span class=\"tok-kw\">try</span> expect(arr[<span class=\"tok-number\">0</span>] == <span class=\"tok-number\">2</span>); <span class=\"tok-comment\">// succeeds</span>\n    <span class=\"tok-kw\">try</span> expect(arr[<span class=\"tok-number\">1</span>] == <span class=\"tok-number\">1</span>); <span class=\"tok-comment\">// fails</span>\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Result Location Semantics §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Result Location Semantics § in Zig 0.13.0",
    "context": "",
    "response": "During compilation, every Zig expression and sub-expression is assigned optional result location information. This information dictates what type the expression should have (its result type), and where the resulting value should be placed in memory (its result location). The information is optional in the sense that not every expression has this information: assignment to _ , for instance, does not provide any information about the type of an expression, nor does it provide a concrete memory location to place it in. As a motivating example, consider the statement const x: u32 = 42 ; . The type annotation here provides a result type of u32 to the initialization expression 42 , instructing the compiler to coerce this integer (initally of type comptime_int ) to this type. We will see more examples shortly. This is not an implementation detail: the logic outlined above is codified into the Zig language specification, and is the primary mechanism of type inference in the language. This syst",
    "metadata": {
      "version": "0.13.0",
      "topic": "Result Location Semantics §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: usingnamespace §",
    "context": "usingnamespace is a declaration that mixes all the public declarations of the operand, which must be a struct , union , enum , or opaque , into the namespace: test_usingnamespace.zig Shell usingnamespace has an important use case when organizing the public API of a file or package. For example, one might have c.zig with all of the C imports : c.zig The above example demonstrates using pub to qualify the usingnamespace additionally makes the imported declarations pub . This can be used to forward",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"using std namespace\"</span> {\n    <span class=\"tok-kw\">const</span> S = <span class=\"tok-kw\">struct</span> {\n        <span class=\"tok-kw\">usingnamespace</span> <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n    };\n    <span class=\"tok-kw\">try</span> S.testing.expect(<span class=\"tok-null\">true</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "usingnamespace §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: usingnamespace §",
    "context": "usingnamespace is a declaration that mixes all the public declarations of the operand, which must be a struct , union , enum , or opaque , into the namespace: test_usingnamespace.zig Shell usingnamespace has an important use case when organizing the public API of a file or package. For example, one might have c.zig with all of the C imports : c.zig The above example demonstrates using pub to qualify the usingnamespace additionally makes the imported declarations pub . This can be used to forward",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">usingnamespace</span> <span class=\"tok-builtin\">@cImport</span>({\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"epoxy/gl.h\"</span>);\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"GLFW/glfw3.h\"</span>);\n    <span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"STBI_ONLY_PNG\"</span>, <span class=\"tok-str\">\"\"</span>);\n    <span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"STBI_NO_STDIO\"</span>, <span class=\"tok-str\">\"\"</span>);\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"stb_image.h\"</span>);\n});",
    "metadata": {
      "version": "0.13.0",
      "topic": "usingnamespace §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain usingnamespace § in Zig 0.13.0",
    "context": "",
    "response": "usingnamespace is a declaration that mixes all the public declarations of the operand, which must be a struct , union , enum , or opaque , into the namespace: test_usingnamespace.zig Shell usingnamespace has an important use case when organizing the public API of a file or package. For example, one might have c.zig with all of the C imports : c.zig The above example demonstrates using pub to qualify the usingnamespace additionally makes the imported declarations pub . This can be used to forward declarations, giving precise control over what declarations a given file exposes.",
    "metadata": {
      "version": "0.13.0",
      "topic": "usingnamespace §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">max</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) T {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (a > b) a <span class=\"tok-kw\">else</span> b;\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">gimmeTheBiggerFloat</span>(a: <span class=\"tok-type\">f32</span>, b: <span class=\"tok-type\">f32</span>) <span class=\"tok-type\">f32</span> {\n    <span class=\"tok-kw\">return</span> max(<span class=\"tok-type\">f32</span>, a, b);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">gimmeTheBiggerInteger</span>(a: <span class=\"tok-type\">u64</span>, b: <span class=\"tok-type\">u64</span>) <span class=\"tok-type\">u64</span> {\n    <span class=\"tok-kw\">return</span> max(<span class=\"tok-type\">u64</span>, a, b);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">max</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) T {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (a > b) a <span class=\"tok-kw\">else</span> b;\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"try to pass a runtime type\"</span> {\n    foo(<span class=\"tok-null\">false</span>);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(condition: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> result = max(<span class=\"tok-kw\">if</span> (condition) <span class=\"tok-type\">f32</span> <span class=\"tok-kw\">else</span> <span class=\"tok-type\">u64</span>, <span class=\"tok-number\">1234</span>, <span class=\"tok-number\">5678</span>);\n    _ = result;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">max</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) T {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">if</span> (a > b) a <span class=\"tok-kw\">else</span> b;\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"try to compare bools\"</span> {\n    _ = max(<span class=\"tok-type\">bool</span>, <span class=\"tok-null\">true</span>, <span class=\"tok-null\">false</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">max</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T) T {\n    <span class=\"tok-kw\">if</span> (T == <span class=\"tok-type\">bool</span>) {\n        <span class=\"tok-kw\">return</span> a <span class=\"tok-kw\">or</span> b;\n    } <span class=\"tok-kw\">else</span> <span class=\"tok-kw\">if</span> (a > b) {\n        <span class=\"tok-kw\">return</span> a;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">return</span> b;\n    }\n}\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"try to compare bools\"</span> {\n    <span class=\"tok-kw\">try</span> <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect(max(<span class=\"tok-type\">bool</span>, <span class=\"tok-null\">false</span>, <span class=\"tok-null\">true</span>) == <span class=\"tok-null\">true</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">max</span>(a: <span class=\"tok-type\">bool</span>, b: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">bool</span> {\n    {\n        <span class=\"tok-kw\">return</span> a <span class=\"tok-kw\">or</span> b;\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">const</span> CmdFn = <span class=\"tok-kw\">struct</span> {\n    name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>,\n    func: <span class=\"tok-kw\">fn</span> (<span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span>,\n};\n\n<span class=\"tok-kw\">const</span> cmd_fns = [_]CmdFn{\n    CmdFn{ .name = <span class=\"tok-str\">\"one\"</span>, .func = one },\n    CmdFn{ .name = <span class=\"tok-str\">\"two\"</span>, .func = two },\n    CmdFn{ .name = <span class=\"tok-str\">\"three\"</span>, .func = three },\n};\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">one</span>(value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> value + <span class=\"tok-number\">1</span>;\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">two</span>(value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> value + <span class=\"tok-number\">2</span>;\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">three</span>(value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> value + <span class=\"tok-number\">3</span>;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">performFn</span>(<span class=\"tok-kw\">comptime</span> prefix_char: <span class=\"tok-type\">u8</span>, start_value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> result: <span class=\"tok-type\">i32</span> = start_value;\n    <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> i = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">while</span> (i < cmd_fns.len) : (i += <span class=\"tok-number\">1</span>) {\n        <span class=\"tok-kw\">if</span> (cmd_fns[i].name[<span class=\"tok-number\">0</span>] == prefix_char) {\n            result = cmd_fns[i].func(result);\n        }\n    }\n    <span class=\"tok-kw\">return</span> result;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"perform fn\"</span> {\n    <span class=\"tok-kw\">try</span> expect(performFn(<span class=\"tok-str\">'t'</span>, <span class=\"tok-number\">1</span>) == <span class=\"tok-number\">6</span>);\n    <span class=\"tok-kw\">try</span> expect(performFn(<span class=\"tok-str\">'o'</span>, <span class=\"tok-number\">0</span>) == <span class=\"tok-number\">1</span>);\n    <span class=\"tok-kw\">try</span> expect(performFn(<span class=\"tok-str\">'w'</span>, <span class=\"tok-number\">99</span>) == <span class=\"tok-number\">99</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-comment\">// From the line:</span>\n<span class=\"tok-comment\">// expect(performFn('t', 1) == 6);</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">performFn</span>(start_value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> result: <span class=\"tok-type\">i32</span> = start_value;\n    result = two(result);\n    result = three(result);\n    <span class=\"tok-kw\">return</span> result;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-comment\">// From the line:</span>\n<span class=\"tok-comment\">// expect(performFn('o', 0) == 1);</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">performFn</span>(start_value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> result: <span class=\"tok-type\">i32</span> = start_value;\n    result = one(result);\n    <span class=\"tok-kw\">return</span> result;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-comment\">// From the line:</span>\n<span class=\"tok-comment\">// expect(performFn('w', 99) == 99);</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">performFn</span>(start_value: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> result: <span class=\"tok-type\">i32</span> = start_value;\n    _ = &result;\n    <span class=\"tok-kw\">return</span> result;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">exit</span>() <span class=\"tok-type\">noreturn</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"foo\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        exit();\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">fibonacci</span>(index: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">if</span> (index < <span class=\"tok-number\">2</span>) <span class=\"tok-kw\">return</span> index;\n    <span class=\"tok-kw\">return</span> fibonacci(index - <span class=\"tok-number\">1</span>) + fibonacci(index - <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fibonacci\"</span> {\n    <span class=\"tok-comment\">// test fibonacci at run-time</span>\n    <span class=\"tok-kw\">try</span> expect(fibonacci(<span class=\"tok-number\">7</span>) == <span class=\"tok-number\">13</span>);\n\n    <span class=\"tok-comment\">// test fibonacci at compile-time</span>\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(fibonacci(<span class=\"tok-number\">7</span>) == <span class=\"tok-number\">13</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">fibonacci</span>(index: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-comment\">//if (index < 2) return index;</span>\n    <span class=\"tok-kw\">return</span> fibonacci(index - <span class=\"tok-number\">1</span>) + fibonacci(index - <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fibonacci\"</span> {\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(fibonacci(<span class=\"tok-number\">7</span>) == <span class=\"tok-number\">13</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> assert = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.assert;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">fibonacci</span>(index: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-comment\">//if (index < 2) return index;</span>\n    <span class=\"tok-kw\">return</span> fibonacci(index - <span class=\"tok-number\">1</span>) + fibonacci(index - <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fibonacci\"</span> {\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> assert(fibonacci(<span class=\"tok-number\">7</span>) == <span class=\"tok-number\">13</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> assert = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.assert;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">fibonacci</span>(index: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">if</span> (index < <span class=\"tok-number\">2</span>) <span class=\"tok-kw\">return</span> index;\n    <span class=\"tok-kw\">return</span> fibonacci(index - <span class=\"tok-number\">1</span>) + fibonacci(index - <span class=\"tok-number\">2</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"fibonacci\"</span> {\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> assert(fibonacci(<span class=\"tok-number\">7</span>) == <span class=\"tok-number\">99999</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> first_25_primes = firstNPrimes(<span class=\"tok-number\">25</span>);\n<span class=\"tok-kw\">const</span> sum_of_first_25_primes = sum(&first_25_primes);\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">firstNPrimes</span>(<span class=\"tok-kw\">comptime</span> n: <span class=\"tok-type\">usize</span>) [n]<span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> prime_list: [n]<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">var</span> next_index: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">var</span> test_number: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">while</span> (next_index < prime_list.len) : (test_number += <span class=\"tok-number\">1</span>) {\n        <span class=\"tok-kw\">var</span> test_prime_index: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n        <span class=\"tok-kw\">var</span> is_prime = <span class=\"tok-null\">true</span>;\n        <span class=\"tok-kw\">while</span> (test_prime_index < next_index) : (test_prime_index += <span class=\"tok-number\">1</span>) {\n            <span class=\"tok-kw\">if</span> (test_number % prime_list[test_prime_index] == <span class=\"tok-number\">0</span>) {\n                is_prime = <span class=\"tok-null\">false</span>;\n                <span class=\"tok-kw\">break</span>;\n            }\n        }\n        <span class=\"tok-kw\">if</span> (is_prime) {\n            prime_list[next_index] = test_number;\n            next_index += <span class=\"tok-number\">1</span>;\n        }\n    }\n    <span class=\"tok-kw\">return</span> prime_list;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">sum</span>(numbers: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">var</span> result: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">for</span> (numbers) |x| {\n        result += x;\n    }\n    <span class=\"tok-kw\">return</span> result;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"variable values\"</span> {\n    <span class=\"tok-kw\">try</span> <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect(sum_of_first_25_primes == <span class=\"tok-number\">1060</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "@0 = internal unnamed_addr constant [25 x i32] [i32 2, i32 3, i32 5, i32 7, i32 11, i32 13, i32 17, i32 19, i32 23, i32 29, i32 31, i32 37, i32 41, i32 43, i32 47, i32 53, i32 59, i32 61, i32 67, i32 71, i32 73, i32 79, i32 83, i32 89, i32 97]\n@1 = internal unnamed_addr constant i32 1060",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">List</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">struct</span> {\n        items: []T,\n        len: <span class=\"tok-type\">usize</span>,\n    };\n}\n\n<span class=\"tok-comment\">// The generic List data structure can be instantiated by passing in a type:</span>\n<span class=\"tok-kw\">var</span> buffer: [<span class=\"tok-number\">10</span>]<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n<span class=\"tok-kw\">var</span> list = List(<span class=\"tok-type\">i32</span>){\n    .items = &buffer,\n    .len = <span class=\"tok-number\">0</span>,\n};",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> Node = <span class=\"tok-kw\">struct</span> {\n    next: ?*Node,\n    name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>,\n};\n\n<span class=\"tok-kw\">var</span> node_a = Node{\n    .next = <span class=\"tok-null\">null</span>,\n    .name = <span class=\"tok-str\">\"Node A\"</span>,\n};\n\n<span class=\"tok-kw\">var</span> node_b = Node{\n    .next = &node_a,\n    .name = <span class=\"tok-str\">\"Node B\"</span>,\n};",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">const</span> a_number: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n<span class=\"tok-kw\">const</span> a_string = <span class=\"tok-str\">\"foobar\"</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    print(<span class=\"tok-str\">\"here is a string: '{s}' here is a number: {}\\n\"</span>, .{ a_string, a_number });\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> Writer = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-comment\">/// Calls print and then flushes the buffer.</span>\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">print</span>(self: *Writer, <span class=\"tok-kw\">comptime</span> format: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, args: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-type\">anyerror</span>!<span class=\"tok-type\">void</span> {\n        <span class=\"tok-kw\">const</span> State = <span class=\"tok-kw\">enum</span> {\n            start,\n            open_brace,\n            close_brace,\n        };\n\n        <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> start_index: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n        <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> state = State.start;\n        <span class=\"tok-kw\">comptime</span> <span class=\"tok-kw\">var</span> next_arg: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n\n        <span class=\"tok-kw\">inline</span> <span class=\"tok-kw\">for</span> (format, <span class=\"tok-number\">0</span>..) |c, i| {\n            <span class=\"tok-kw\">switch</span> (state) {\n                State.start => <span class=\"tok-kw\">switch</span> (c) {\n                    <span class=\"tok-str\">'{'</span> => {\n                        <span class=\"tok-kw\">if</span> (start_index < i) <span class=\"tok-kw\">try</span> self.write(format[start_index..i]);\n                        state = State.open_brace;\n                    },\n                    <span class=\"tok-str\">'}'</span> => {\n                        <span class=\"tok-kw\">if</span> (start_index < i) <span class=\"tok-kw\">try</span> self.write(format[start_index..i]);\n                        state = State.close_brace;\n                    },\n                    <span class=\"tok-kw\">else</span> => {},\n                },\n                State.open_brace => <span class=\"tok-kw\">switch</span> (c) {\n                    <span class=\"tok-str\">'{'</span> => {\n                        state = State.start;\n                        start_index = i;\n                    },\n                    <span class=\"tok-str\">'}'</span> => {\n                        <span class=\"tok-kw\">try</span> self.printValue(args[next_arg]);\n                        next_arg += <span class=\"tok-number\">1</span>;\n                        state = State.start;\n                        start_index = i + <span class=\"tok-number\">1</span>;\n                    },\n                    <span class=\"tok-str\">'s'</span> => {\n                        <span class=\"tok-kw\">continue</span>;\n                    },\n                    <span class=\"tok-kw\">else</span> => <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"Unknown format character: \"</span> ++ [<span class=\"tok-number\">1</span>]<span class=\"tok-type\">u8</span>{c}),\n                },\n                State.close_brace => <span class=\"tok-kw\">switch</span> (c) {\n                    <span class=\"tok-str\">'}'</span> => {\n                        state = State.start;\n                        start_index = i;\n                    },\n                    <span class=\"tok-kw\">else</span> => <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"Single '}' encountered in format string\"</span>),\n                },\n            }\n        }\n        <span class=\"tok-kw\">comptime</span> {\n            <span class=\"tok-kw\">if</span> (args.len != next_arg) {\n                <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"Unused arguments\"</span>);\n            }\n            <span class=\"tok-kw\">if</span> (state != State.start) {\n                <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"Incomplete format string: \"</span> ++ format);\n            }\n        }\n        <span class=\"tok-kw\">if</span> (start_index < format.len) {\n            <span class=\"tok-kw\">try</span> self.write(format[start_index..format.len]);\n        }\n        <span class=\"tok-kw\">try</span> self.flush();\n    }\n\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">write</span>(self: *Writer, value: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) !<span class=\"tok-type\">void</span> {\n        _ = self;\n        _ = value;\n    }\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">printValue</span>(self: *Writer, value: <span class=\"tok-kw\">anytype</span>) !<span class=\"tok-type\">void</span> {\n        _ = self;\n        _ = value;\n    }\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">flush</span>(self: *Writer) !<span class=\"tok-type\">void</span> {\n        _ = self;\n    }\n};",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">print</span>(self: *Writer, arg0: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, arg1: <span class=\"tok-type\">i32</span>) !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">try</span> self.write(<span class=\"tok-str\">\"here is a string: '\"</span>);\n    <span class=\"tok-kw\">try</span> self.printValue(arg0);\n    <span class=\"tok-kw\">try</span> self.write(<span class=\"tok-str\">\"' here is a number: \"</span>);\n    <span class=\"tok-kw\">try</span> self.printValue(arg1);\n    <span class=\"tok-kw\">try</span> self.write(<span class=\"tok-str\">\"\\n\"</span>);\n    <span class=\"tok-kw\">try</span> self.flush();\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> Writer = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">printValue</span>(self: *Writer, value: <span class=\"tok-kw\">anytype</span>) !<span class=\"tok-type\">void</span> {\n        <span class=\"tok-kw\">switch</span> (<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(value))) {\n            .Int => {\n                <span class=\"tok-kw\">return</span> self.writeInt(value);\n            },\n            .Float => {\n                <span class=\"tok-kw\">return</span> self.writeFloat(value);\n            },\n            .Pointer => {\n                <span class=\"tok-kw\">return</span> self.write(value);\n            },\n            <span class=\"tok-kw\">else</span> => {\n                <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"Unable to print type '\"</span> ++ <span class=\"tok-builtin\">@typeName</span>(<span class=\"tok-builtin\">@TypeOf</span>(value)) ++ <span class=\"tok-str\">\"'\"</span>);\n            },\n        }\n    }\n\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">write</span>(self: *Writer, value: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) !<span class=\"tok-type\">void</span> {\n        _ = self;\n        _ = value;\n    }\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">writeInt</span>(self: *Writer, value: <span class=\"tok-kw\">anytype</span>) !<span class=\"tok-type\">void</span> {\n        _ = self;\n        _ = value;\n    }\n    <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">writeFloat</span>(self: *Writer, value: <span class=\"tok-kw\">anytype</span>) !<span class=\"tok-type\">void</span> {\n        _ = self;\n        _ = value;\n    }\n};",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">const</span> a_number: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n<span class=\"tok-kw\">const</span> a_string = <span class=\"tok-str\">\"foobar\"</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"print too many arguments\"</span> {\n    print(<span class=\"tok-str\">\"here is a string: '{s}' here is a number: {}\\n\"</span>, .{\n        a_string,\n        a_number,\n        a_number,\n    });\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: comptime §",
    "context": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as par",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">const</span> a_number: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1234</span>;\n<span class=\"tok-kw\">const</span> a_string = <span class=\"tok-str\">\"foobar\"</span>;\n<span class=\"tok-kw\">const</span> fmt = <span class=\"tok-str\">\"here is a string: '{s}' here is a number: {}\\n\"</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    print(fmt, .{ a_string, a_number });\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain comptime § in Zig 0.13.0",
    "context": "",
    "response": "Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. Introducing the Compile-Time Concept § Compile-Time Parameters § Compile-time parameters is how Zig implements generics. It is compile-time duck typing. compile-time_duck_typing.zig In Zig, types are first-class citizens. They can be assigned to variables, passed as parameters to functions, and returned from functions. However, they can only be used in expressions which are known at compile-time , which is why the parameter T in the above snippet must be marked with comptime . A comptime parameter means that: At the callsite, the value must be known at compile-time, or it is a compile error. In the function definition, the value is known at compile-time. For example, if we were to introduce another function to the above snippet: test_unresolved_comptime_value.",
    "metadata": {
      "version": "0.13.0",
      "topic": "comptime §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Assembly §",
    "context": "For some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly: inline_assembly.zig Shell Dissecting the syntax: Assembly Syntax Explained.zig For x86 and x86_64 targets, the syntax is AT&amp;T syntax, rather than the more popular Intel syntax. This is due to technical constraints",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">noreturn</span> {\n    <span class=\"tok-kw\">const</span> msg = <span class=\"tok-str\">\"hello world\\n\"</span>;\n    _ = syscall3(SYS_write, STDOUT_FILENO, <span class=\"tok-builtin\">@intFromPtr</span>(msg), msg.len);\n    _ = syscall1(SYS_exit, <span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">unreachable</span>;\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> SYS_write = <span class=\"tok-number\">1</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> SYS_exit = <span class=\"tok-number\">60</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> STDOUT_FILENO = <span class=\"tok-number\">1</span>;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">syscall1</span>(number: <span class=\"tok-type\">usize</span>, arg1: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">asm</span> <span class=\"tok-kw\">volatile</span> (<span class=\"tok-str\">\"syscall\"</span>\n        : [ret] <span class=\"tok-str\">\"={rax}\"</span> (-> <span class=\"tok-type\">usize</span>),\n        : [number] <span class=\"tok-str\">\"{rax}\"</span> (number),\n          [arg1] <span class=\"tok-str\">\"{rdi}\"</span> (arg1),\n        : <span class=\"tok-str\">\"rcx\"</span>, <span class=\"tok-str\">\"r11\"</span>\n    );\n}\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">syscall3</span>(number: <span class=\"tok-type\">usize</span>, arg1: <span class=\"tok-type\">usize</span>, arg2: <span class=\"tok-type\">usize</span>, arg3: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">asm</span> <span class=\"tok-kw\">volatile</span> (<span class=\"tok-str\">\"syscall\"</span>\n        : [ret] <span class=\"tok-str\">\"={rax}\"</span> (-> <span class=\"tok-type\">usize</span>),\n        : [number] <span class=\"tok-str\">\"{rax}\"</span> (number),\n          [arg1] <span class=\"tok-str\">\"{rdi}\"</span> (arg1),\n          [arg2] <span class=\"tok-str\">\"{rsi}\"</span> (arg2),\n          [arg3] <span class=\"tok-str\">\"{rdx}\"</span> (arg3),\n        : <span class=\"tok-str\">\"rcx\"</span>, <span class=\"tok-str\">\"r11\"</span>\n    );\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Assembly §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Assembly §",
    "context": "For some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly: inline_assembly.zig Shell Dissecting the syntax: Assembly Syntax Explained.zig For x86 and x86_64 targets, the syntax is AT&amp;T syntax, rather than the more popular Intel syntax. This is due to technical constraints",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">syscall1</span>(number: <span class=\"tok-type\">usize</span>, arg1: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-comment\">// Inline assembly is an expression which returns a value.</span>\n    <span class=\"tok-comment\">// the `asm` keyword begins the expression.</span>\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">asm</span>\n    <span class=\"tok-comment\">// `volatile` is an optional modifier that tells Zig this</span>\n    <span class=\"tok-comment\">// inline assembly expression has side-effects. Without</span>\n    <span class=\"tok-comment\">// `volatile`, Zig is allowed to delete the inline assembly</span>\n    <span class=\"tok-comment\">// code if the result is unused.</span>\n    <span class=\"tok-kw\">volatile</span> (\n    <span class=\"tok-comment\">// Next is a comptime string which is the assembly code.</span>\n    <span class=\"tok-comment\">// Inside this string one may use `%[ret]`, `%[number]`,</span>\n    <span class=\"tok-comment\">// or `%[arg1]` where a register is expected, to specify</span>\n    <span class=\"tok-comment\">// the register that Zig uses for the argument or return value,</span>\n    <span class=\"tok-comment\">// if the register constraint strings are used. However in</span>\n    <span class=\"tok-comment\">// the below code, this is not used. A literal `%` can be</span>\n    <span class=\"tok-comment\">// obtained by escaping it with a double percent: `%%`.</span>\n    <span class=\"tok-comment\">// Often multiline string syntax comes in handy here.</span>\n        <span class=\"tok-str\">\\\\syscall\n</span>        <span class=\"tok-comment\">// Next is the output. It is possible in the future Zig will</span>\n        <span class=\"tok-comment\">// support multiple outputs, depending on how</span>\n        <span class=\"tok-comment\">// https://github.com/ziglang/zig/issues/215 is resolved.</span>\n        <span class=\"tok-comment\">// It is allowed for there to be no outputs, in which case</span>\n        <span class=\"tok-comment\">// this colon would be directly followed by the colon for the inputs.</span>\n        :\n        <span class=\"tok-comment\">// This specifies the name to be used in `%[ret]` syntax in</span>\n        <span class=\"tok-comment\">// the above assembly string. This example does not use it,</span>\n        <span class=\"tok-comment\">// but the syntax is mandatory.</span>\n          [ret]\n          <span class=\"tok-comment\">// Next is the output constraint string. This feature is still</span>\n          <span class=\"tok-comment\">// considered unstable in Zig, and so LLVM/GCC documentation</span>\n          <span class=\"tok-comment\">// must be used to understand the semantics.</span>\n          <span class=\"tok-comment\">// http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string</span>\n          <span class=\"tok-comment\">// https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html</span>\n          <span class=\"tok-comment\">// In this example, the constraint string means \"the result value of</span>\n          <span class=\"tok-comment\">// this inline assembly instruction is whatever is in $rax\".</span>\n          <span class=\"tok-str\">\"={rax}\"</span>\n          <span class=\"tok-comment\">// Next is either a value binding, or `->` and then a type. The</span>\n          <span class=\"tok-comment\">// type is the result type of the inline assembly expression.</span>\n          <span class=\"tok-comment\">// If it is a value binding, then `%[ret]` syntax would be used</span>\n          <span class=\"tok-comment\">// to refer to the register bound to the value.</span>\n          (-> <span class=\"tok-type\">usize</span>),\n          <span class=\"tok-comment\">// Next is the list of inputs.</span>\n          <span class=\"tok-comment\">// The constraint for these inputs means, \"when the assembly code is</span>\n          <span class=\"tok-comment\">// executed, $rax shall have the value of `number` and $rdi shall have</span>\n          <span class=\"tok-comment\">// the value of `arg1`\". Any number of input parameters is allowed,</span>\n          <span class=\"tok-comment\">// including none.</span>\n        : [number] <span class=\"tok-str\">\"{rax}\"</span> (number),\n          [arg1] <span class=\"tok-str\">\"{rdi}\"</span> (arg1),\n          <span class=\"tok-comment\">// Next is the list of clobbers. These declare a set of registers whose</span>\n          <span class=\"tok-comment\">// values will not be preserved by the execution of this assembly code.</span>\n          <span class=\"tok-comment\">// These do not include output or input registers. The special clobber</span>\n          <span class=\"tok-comment\">// value of \"memory\" means that the assembly writes to arbitrary undeclared</span>\n          <span class=\"tok-comment\">// memory locations - not only the memory pointed to by a declared indirect</span>\n          <span class=\"tok-comment\">// output. In this example we list $rcx and $r11 because it is known the</span>\n          <span class=\"tok-comment\">// kernel syscall does not preserve these registers.</span>\n        : <span class=\"tok-str\">\"rcx\"</span>, <span class=\"tok-str\">\"r11\"</span>\n    );\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Assembly §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Assembly §",
    "context": "For some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly: inline_assembly.zig Shell Dissecting the syntax: Assembly Syntax Explained.zig For x86 and x86_64 targets, the syntax is AT&amp;T syntax, rather than the more popular Intel syntax. This is due to technical constraints",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">asm</span> (\n        <span class=\"tok-str\">\\\\.global my_func;\n</span>        <span class=\"tok-str\">\\\\.type my_func, @function;\n</span>        <span class=\"tok-str\">\\\\my_func:\n</span>        <span class=\"tok-str\">\\\\  lea (%rdi,%rsi,1),%eax\n</span>        <span class=\"tok-str\">\\\\  retq\n</span>    );\n}\n\n<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">my_func</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"global assembly\"</span> {\n    <span class=\"tok-kw\">try</span> expect(my_func(<span class=\"tok-number\">12</span>, <span class=\"tok-number\">34</span>) == <span class=\"tok-number\">46</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Assembly §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Assembly § in Zig 0.13.0",
    "context": "",
    "response": "For some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly: inline_assembly.zig Shell Dissecting the syntax: Assembly Syntax Explained.zig For x86 and x86_64 targets, the syntax is AT&amp;T syntax, rather than the more popular Intel syntax. This is due to technical constraints; assembly parsing is provided by LLVM and its support for Intel syntax is buggy and not well tested. Some day Zig may have its own assembler. This would allow it to integrate more seamlessly into the language, as well as be compatible with the popular NASM syntax. This documentation section will be updated before 1.0.0 is released, with a conclusive statement about the status of AT&amp;T vs Intel/NASM syntax. Output Constraints § Output constraints are still considered to be unstable in Zig, an",
    "metadata": {
      "version": "0.13.0",
      "topic": "Assembly §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Atomics § in Zig 0.13.0",
    "context": "",
    "response": "TODO: @fence() TODO: @atomic rmw TODO: builtin atomic memory ordering enum See also: @atomicLoad @atomicStore @atomicRmw @fence @cmpxchgWeak @cmpxchgStrong",
    "metadata": {
      "version": "0.13.0",
      "topic": "Atomics §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Async Functions § in Zig 0.13.0",
    "context": "",
    "response": "Async functions regressed with the release of 0.11.0. Their future in the Zig language is unclear due to multiple unsolved problems: LLVM's lack of ability to optimize them. Third-party debuggers' lack of ability to debug them. The cancellation problem . Async function pointers preventing the stack size from being known. These problems are surmountable, but it will take time. The Zig team is currently focused on other priorities.",
    "metadata": {
      "version": "0.13.0",
      "topic": "Async Functions §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@addrSpaceCast</span>(ptr: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@addWithOverflow</span>(a: <span class=\"tok-kw\">anytype</span>, b: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">struct</span> { <span class=\"tok-builtin\">@TypeOf</span>(a, b), <span class=\"tok-type\">u1</span> }",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@alignCast</span>(ptr: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@alignOf</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">comptime_int</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> assert = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.assert;\n<span class=\"tok-kw\">comptime</span> {\n    assert(*<span class=\"tok-type\">u32</span> == *<span class=\"tok-kw\">align</span>(<span class=\"tok-builtin\">@alignOf</span>(<span class=\"tok-type\">u32</span>)) <span class=\"tok-type\">u32</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@as</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, expression) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@atomicLoad</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *<span class=\"tok-kw\">const</span> T, <span class=\"tok-kw\">comptime</span> ordering: AtomicOrder) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@atomicRmw</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, <span class=\"tok-kw\">comptime</span> op: AtomicRmwOp, operand: T, <span class=\"tok-kw\">comptime</span> ordering: AtomicOrder) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@atomicStore</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, value: T, <span class=\"tok-kw\">comptime</span> ordering: AtomicOrder) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@bitCast</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@bitOffsetOf</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">comptime_int</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@bitSizeOf</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">comptime_int</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@breakpoint</span>() <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@mulAdd</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, a: T, b: T, c: T) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@byteSwap</span>(operand: <span class=\"tok-kw\">anytype</span>) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@bitReverse</span>(integer: <span class=\"tok-kw\">anytype</span>) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@offsetOf</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">comptime_int</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@call</span>(modifier: std.builtin.CallModifier, function: <span class=\"tok-kw\">anytype</span>, args: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> expect = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"noinline function call\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@call</span>(.auto, add, .{ <span class=\"tok-number\">3</span>, <span class=\"tok-number\">9</span> }) == <span class=\"tok-number\">12</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> a + b;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> CallModifier = <span class=\"tok-kw\">enum</span> {\n    <span class=\"tok-comment\">/// Equivalent to function call syntax.</span>\n    auto,\n\n    <span class=\"tok-comment\">/// Equivalent to async keyword used with function call syntax.</span>\n    async_kw,\n\n    <span class=\"tok-comment\">/// Prevents tail call optimization. This guarantees that the return</span>\n    <span class=\"tok-comment\">/// address will point to the callsite, as opposed to the callsite's</span>\n    <span class=\"tok-comment\">/// callsite. If the call is otherwise required to be tail-called</span>\n    <span class=\"tok-comment\">/// or inlined, a compile error is emitted instead.</span>\n    never_tail,\n\n    <span class=\"tok-comment\">/// Guarantees that the call will not be inlined. If the call is</span>\n    <span class=\"tok-comment\">/// otherwise required to be inlined, a compile error is emitted instead.</span>\n    never_inline,\n\n    <span class=\"tok-comment\">/// Asserts that the function call will not suspend. This allows a</span>\n    <span class=\"tok-comment\">/// non-async function to call an async function.</span>\n    no_async,\n\n    <span class=\"tok-comment\">/// Guarantees that the call will be generated with tail call optimization.</span>\n    <span class=\"tok-comment\">/// If this is not possible, a compile error is emitted instead.</span>\n    always_tail,\n\n    <span class=\"tok-comment\">/// Guarantees that the call will inlined at the callsite.</span>\n    <span class=\"tok-comment\">/// If this is not possible, a compile error is emitted instead.</span>\n    always_inline,\n\n    <span class=\"tok-comment\">/// Evaluates the call at compile-time. If the call cannot be completed at</span>\n    <span class=\"tok-comment\">/// compile-time, a compile error is emitted instead.</span>\n    compile_time,\n};",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-kw\">comptime</span> name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, value) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "#define _GNU_SOURCE",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"_GNU_SOURCE\"</span>, {})",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cImport</span>(expression) <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-kw\">comptime</span> path: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@clz</span>(operand: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cmpxchgStrong</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">cmpxchgStrongButNotAtomic</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, expected_value: T, new_value: T) ?T {\n    <span class=\"tok-kw\">const</span> old_value = ptr.*;\n    <span class=\"tok-kw\">if</span> (old_value == expected_value) {\n        ptr.* = new_value;\n        <span class=\"tok-kw\">return</span> <span class=\"tok-null\">null</span>;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">return</span> old_value;\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cmpxchgWeak</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">cmpxchgWeakButNotAtomic</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T, expected_value: T, new_value: T) ?T {\n    <span class=\"tok-kw\">const</span> old_value = ptr.*;\n    <span class=\"tok-kw\">if</span> (old_value == expected_value <span class=\"tok-kw\">and</span> usuallyTrueButSometimesFalse()) {\n        ptr.* = new_value;\n        <span class=\"tok-kw\">return</span> <span class=\"tok-null\">null</span>;\n    } <span class=\"tok-kw\">else</span> {\n        <span class=\"tok-kw\">return</span> old_value;\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-kw\">comptime</span> msg: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">noreturn</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@compileLog</span>(args: ...) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">const</span> num1 = blk: {\n    <span class=\"tok-kw\">var</span> val1: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">99</span>;\n    <span class=\"tok-builtin\">@compileLog</span>(<span class=\"tok-str\">\"comptime val1 = \"</span>, val1);\n    val1 = val1 + <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">break</span> :blk val1;\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"main\"</span> {\n    <span class=\"tok-builtin\">@compileLog</span>(<span class=\"tok-str\">\"comptime in main\"</span>);\n\n    print(<span class=\"tok-str\">\"Runtime in main, num1 = {}.\\n\"</span>, .{num1});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@constCast</span>(value: <span class=\"tok-kw\">anytype</span>) DestType",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@ctz</span>(operand: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cUndef</span>(<span class=\"tok-kw\">comptime</span> name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cVaArg</span>(operand: *std.builtin.VaList, <span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cVaCopy</span>(src: *std.builtin.VaList) std.builtin.VaList",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cVaEnd</span>(src: *std.builtin.VaList) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cVaStart</span>() std.builtin.VaList",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@divExact</span>(numerator: T, denominator: T) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@divFloor</span>(numerator: T, denominator: T) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@divTrunc</span>(numerator: T, denominator: T) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@embedFile</span>(<span class=\"tok-kw\">comptime</span> path: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) *<span class=\"tok-kw\">const</span> [N:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@enumFromInt</span>(integer: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@errorFromInt</span>(value: std.meta.Int(.unsigned, <span class=\"tok-builtin\">@bitSizeOf</span>(<span class=\"tok-type\">anyerror</span>))) <span class=\"tok-type\">anyerror</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@errorName</span>(err: <span class=\"tok-type\">anyerror</span>) [:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@errorReturnTrace</span>() ?*builtin.StackTrace",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@errorCast</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@export</span>(declaration, <span class=\"tok-kw\">comptime</span> options: std.builtin.ExportOptions) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-builtin\">@export</span>(internalName, .{ .name = <span class=\"tok-str\">\"foo\"</span>, .linkage = .strong });\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">internalName</span>() <span class=\"tok-kw\">callconv</span>(.C) <span class=\"tok-type\">void</span> {}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">void</span> {}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">@\"A function name that is a complete sentence.\"</span>() <span class=\"tok-type\">void</span> {}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "00000000000001f0 T A function name that is a complete sentence.",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@extern</span>(T: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> options: std.builtin.ExternOptions) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@fence</span>(order: AtomicOrder) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@field</span>(lhs: <span class=\"tok-kw\">anytype</span>, <span class=\"tok-kw\">comptime</span> field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) (field)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Point = <span class=\"tok-kw\">struct</span> {\n    x: <span class=\"tok-type\">u32</span>,\n    y: <span class=\"tok-type\">u32</span>,\n\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">var</span> z: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">1</span>;\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"field access by string\"</span> {\n    <span class=\"tok-kw\">const</span> expect = std.testing.expect;\n    <span class=\"tok-kw\">var</span> p = Point{ .x = <span class=\"tok-number\">0</span>, .y = <span class=\"tok-number\">0</span> };\n\n    <span class=\"tok-builtin\">@field</span>(p, <span class=\"tok-str\">\"x\"</span>) = <span class=\"tok-number\">4</span>;\n    <span class=\"tok-builtin\">@field</span>(p, <span class=\"tok-str\">\"y\"</span>) = <span class=\"tok-builtin\">@field</span>(p, <span class=\"tok-str\">\"x\"</span>) + <span class=\"tok-number\">1</span>;\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@field</span>(p, <span class=\"tok-str\">\"x\"</span>) == <span class=\"tok-number\">4</span>);\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@field</span>(p, <span class=\"tok-str\">\"y\"</span>) == <span class=\"tok-number\">5</span>);\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"decl access by string\"</span> {\n    <span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@field</span>(Point, <span class=\"tok-str\">\"z\"</span>) == <span class=\"tok-number\">1</span>);\n\n    <span class=\"tok-builtin\">@field</span>(Point, <span class=\"tok-str\">\"z\"</span>) = <span class=\"tok-number\">2</span>;\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@field</span>(Point, <span class=\"tok-str\">\"z\"</span>) == <span class=\"tok-number\">2</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@fieldParentPtr</span>(<span class=\"tok-kw\">comptime</span> field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, field_ptr: *T) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@floatCast</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@floatFromInt</span>(int: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@frameAddress</span>() <span class=\"tok-type\">usize</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@hasDecl</span>(<span class=\"tok-kw\">comptime</span> Container: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">bool</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">struct</span> {\n    nope: <span class=\"tok-type\">i32</span>,\n\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">var</span> blah = <span class=\"tok-str\">\"xxx\"</span>;\n    <span class=\"tok-kw\">const</span> hi = <span class=\"tok-number\">1</span>;\n};\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@hasDecl\"</span> {\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@hasDecl</span>(Foo, <span class=\"tok-str\">\"blah\"</span>));\n\n    <span class=\"tok-comment\">// Even though `hi` is private, @hasDecl returns true because this test is</span>\n    <span class=\"tok-comment\">// in the same file scope as Foo. It would return false if Foo was declared</span>\n    <span class=\"tok-comment\">// in a different file.</span>\n    <span class=\"tok-kw\">try</span> expect(<span class=\"tok-builtin\">@hasDecl</span>(Foo, <span class=\"tok-str\">\"hi\"</span>));\n\n    <span class=\"tok-comment\">// @hasDecl is for declarations; not fields.</span>\n    <span class=\"tok-kw\">try</span> expect(!<span class=\"tok-builtin\">@hasDecl</span>(Foo, <span class=\"tok-str\">\"nope\"</span>));\n    <span class=\"tok-kw\">try</span> expect(!<span class=\"tok-builtin\">@hasDecl</span>(Foo, <span class=\"tok-str\">\"nope1234\"</span>));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@hasField</span>(<span class=\"tok-kw\">comptime</span> Container: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">bool</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@import</span>(<span class=\"tok-kw\">comptime</span> path: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@inComptime</span>() <span class=\"tok-type\">bool</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intCast</span>(int: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"integer cast panic\"</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">u16</span> = <span class=\"tok-number\">0xabcd</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &a;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@intCast</span>(a);\n    _ = b;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intFromBool</span>(value: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">u1</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intFromEnum</span>(enum_or_tagged_union: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intFromError</span>(err: <span class=\"tok-kw\">anytype</span>) std.meta.Int(.unsigned, <span class=\"tok-builtin\">@bitSizeOf</span>(<span class=\"tok-type\">anyerror</span>))",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intFromFloat</span>(float: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@intFromPtr</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-type\">usize</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@max</span>(a: T, b: T) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@memcpy</span>(<span class=\"tok-kw\">noalias</span> dest, <span class=\"tok-kw\">noalias</span> source) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@memset</span>(dest, elem) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@min</span>(a: T, b: T) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@wasmMemorySize</span>(index: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">usize</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@wasmMemoryGrow</span>(index: <span class=\"tok-type\">u32</span>, delta: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">isize</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> native_arch = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>).target.cpu.arch;\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@wasmMemoryGrow\"</span> {\n    <span class=\"tok-kw\">if</span> (native_arch != .wasm32) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.SkipZigTest;\n\n    <span class=\"tok-kw\">const</span> prev = <span class=\"tok-builtin\">@wasmMemorySize</span>(<span class=\"tok-number\">0</span>);\n    <span class=\"tok-kw\">try</span> expect(prev == <span class=\"tok-builtin\">@wasmMemoryGrow</span>(<span class=\"tok-number\">0</span>, <span class=\"tok-number\">1</span>));\n    <span class=\"tok-kw\">try</span> expect(prev + <span class=\"tok-number\">1</span> == <span class=\"tok-builtin\">@wasmMemorySize</span>(<span class=\"tok-number\">0</span>));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@mod</span>(numerator: T, denominator: T) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@mulWithOverflow</span>(a: <span class=\"tok-kw\">anytype</span>, b: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">struct</span> { <span class=\"tok-builtin\">@TypeOf</span>(a, b), <span class=\"tok-type\">u1</span> }",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@panic</span>(message: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">noreturn</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@popCount</span>(operand: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@prefetch</span>(ptr: <span class=\"tok-kw\">anytype</span>, <span class=\"tok-kw\">comptime</span> options: PrefetchOptions) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@ptrCast</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@ptrFromInt</span>(address: <span class=\"tok-type\">usize</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@rem</span>(numerator: T, denominator: T) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@returnAddress</span>() <span class=\"tok-type\">usize</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@select</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, pred: <span class=\"tok-builtin\">@Vector</span>(len, <span class=\"tok-type\">bool</span>), a: <span class=\"tok-builtin\">@Vector</span>(len, T), b: <span class=\"tok-builtin\">@Vector</span>(len, T)) <span class=\"tok-builtin\">@Vector</span>(len, T)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@setAlignStack</span>(<span class=\"tok-kw\">comptime</span> alignment: <span class=\"tok-type\">u29</span>) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@setCold</span>(<span class=\"tok-kw\">comptime</span> is_cold: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@setEvalBranchQuota</span>(<span class=\"tok-kw\">comptime</span> new_quota: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"foo\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-kw\">var</span> i = <span class=\"tok-number\">0</span>;\n        <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">1001</span>) : (i += <span class=\"tok-number\">1</span>) {}\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"foo\"</span> {\n    <span class=\"tok-kw\">comptime</span> {\n        <span class=\"tok-builtin\">@setEvalBranchQuota</span>(<span class=\"tok-number\">1001</span>);\n        <span class=\"tok-kw\">var</span> i = <span class=\"tok-number\">0</span>;\n        <span class=\"tok-kw\">while</span> (i < <span class=\"tok-number\">1001</span>) : (i += <span class=\"tok-number\">1</span>) {}\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@setFloatMode</span>(<span class=\"tok-kw\">comptime</span> mode: FloatMode) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@setRuntimeSafety</span>(<span class=\"tok-kw\">comptime</span> safety_on: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">void</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@setRuntimeSafety\"</span> {\n    <span class=\"tok-comment\">// The builtin applies to the scope that it is called in. So here, integer overflow</span>\n    <span class=\"tok-comment\">// will not be caught in ReleaseFast and ReleaseSmall modes:</span>\n    <span class=\"tok-comment\">// var x: u8 = 255;</span>\n    <span class=\"tok-comment\">// x += 1; // undefined behavior in ReleaseFast/ReleaseSmall modes.</span>\n    {\n        <span class=\"tok-comment\">// However this block has safety enabled, so safety checks happen here,</span>\n        <span class=\"tok-comment\">// even in ReleaseFast and ReleaseSmall modes.</span>\n        <span class=\"tok-builtin\">@setRuntimeSafety</span>(<span class=\"tok-null\">true</span>);\n        <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n        x += <span class=\"tok-number\">1</span>;\n\n        {\n            <span class=\"tok-comment\">// The value can be overridden at any scope. So here integer overflow</span>\n            <span class=\"tok-comment\">// would not be caught in any build mode.</span>\n            <span class=\"tok-builtin\">@setRuntimeSafety</span>(<span class=\"tok-null\">false</span>);\n            <span class=\"tok-comment\">// var x: u8 = 255;</span>\n            <span class=\"tok-comment\">// x += 1; // undefined behavior in all build modes.</span>\n        }\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@shlExact</span>(value: T, shift_amt: Log2T) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@shlWithOverflow</span>(a: <span class=\"tok-kw\">anytype</span>, shift_amt: Log2T) <span class=\"tok-kw\">struct</span> { <span class=\"tok-builtin\">@TypeOf</span>(a), <span class=\"tok-type\">u1</span> }",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@shrExact</span>(value: T, shift_amt: Log2T) T",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@shuffle</span>(<span class=\"tok-kw\">comptime</span> E: <span class=\"tok-type\">type</span>, a: <span class=\"tok-builtin\">@Vector</span>(a_len, E), b: <span class=\"tok-builtin\">@Vector</span>(b_len, E), <span class=\"tok-kw\">comptime</span> mask: <span class=\"tok-builtin\">@Vector</span>(mask_len, <span class=\"tok-type\">i32</span>)) <span class=\"tok-builtin\">@Vector</span>(mask_len, E)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"vector @shuffle\"</span> {\n    <span class=\"tok-kw\">const</span> a = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">7</span>, <span class=\"tok-type\">u8</span>){ <span class=\"tok-str\">'o'</span>, <span class=\"tok-str\">'l'</span>, <span class=\"tok-str\">'h'</span>, <span class=\"tok-str\">'e'</span>, <span class=\"tok-str\">'r'</span>, <span class=\"tok-str\">'z'</span>, <span class=\"tok-str\">'w'</span> };\n    <span class=\"tok-kw\">const</span> b = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">u8</span>){ <span class=\"tok-str\">'w'</span>, <span class=\"tok-str\">'d'</span>, <span class=\"tok-str\">'!'</span>, <span class=\"tok-str\">'x'</span> };\n\n    <span class=\"tok-comment\">// To shuffle within a single vector, pass undefined as the second argument.</span>\n    <span class=\"tok-comment\">// Notice that we can re-order, duplicate, or omit elements of the input vector</span>\n    <span class=\"tok-kw\">const</span> mask1 = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">5</span>, <span class=\"tok-type\">i32</span>){ <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">1</span>, <span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span> };\n    <span class=\"tok-kw\">const</span> res1: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">5</span>, <span class=\"tok-type\">u8</span>) = <span class=\"tok-builtin\">@shuffle</span>(<span class=\"tok-type\">u8</span>, a, <span class=\"tok-null\">undefined</span>, mask1);\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, &<span class=\"tok-builtin\">@as</span>([<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span>, res1), <span class=\"tok-str\">\"hello\"</span>));\n\n    <span class=\"tok-comment\">// Combining two vectors</span>\n    <span class=\"tok-kw\">const</span> mask2 = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">6</span>, <span class=\"tok-type\">i32</span>){ -<span class=\"tok-number\">1</span>, <span class=\"tok-number\">0</span>, <span class=\"tok-number\">4</span>, <span class=\"tok-number\">1</span>, -<span class=\"tok-number\">2</span>, -<span class=\"tok-number\">3</span> };\n    <span class=\"tok-kw\">const</span> res2: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">6</span>, <span class=\"tok-type\">u8</span>) = <span class=\"tok-builtin\">@shuffle</span>(<span class=\"tok-type\">u8</span>, a, b, mask2);\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, &<span class=\"tok-builtin\">@as</span>([<span class=\"tok-number\">6</span>]<span class=\"tok-type\">u8</span>, res2), <span class=\"tok-str\">\"world!\"</span>));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@sizeOf</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">comptime_int</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@splat</span>(scalar: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"vector @splat\"</span> {\n    <span class=\"tok-kw\">const</span> scalar: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">5</span>;\n    <span class=\"tok-kw\">const</span> result: <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">u32</span>) = <span class=\"tok-builtin\">@splat</span>(scalar);\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u32</span>, &<span class=\"tok-builtin\">@as</span>([<span class=\"tok-number\">4</span>]<span class=\"tok-type\">u32</span>, result), &[_]<span class=\"tok-type\">u32</span>{ <span class=\"tok-number\">5</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">5</span>, <span class=\"tok-number\">5</span> }));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@reduce</span>(<span class=\"tok-kw\">comptime</span> op: std.builtin.ReduceOp, value: <span class=\"tok-kw\">anytype</span>) E",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"vector @reduce\"</span> {\n    <span class=\"tok-kw\">const</span> V = <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">const</span> value = V{ <span class=\"tok-number\">1</span>, -<span class=\"tok-number\">1</span>, <span class=\"tok-number\">1</span>, -<span class=\"tok-number\">1</span> };\n    <span class=\"tok-kw\">const</span> result = value > <span class=\"tok-builtin\">@as</span>(V, <span class=\"tok-builtin\">@splat</span>(<span class=\"tok-number\">0</span>));\n    <span class=\"tok-comment\">// result is { true, false, true, false };</span>\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(result) == <span class=\"tok-builtin\">@Vector</span>(<span class=\"tok-number\">4</span>, <span class=\"tok-type\">bool</span>));\n    <span class=\"tok-kw\">const</span> is_all_true = <span class=\"tok-builtin\">@reduce</span>(.And, result);\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(<span class=\"tok-builtin\">@TypeOf</span>(is_all_true) == <span class=\"tok-type\">bool</span>);\n    <span class=\"tok-kw\">try</span> expect(is_all_true == <span class=\"tok-null\">false</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@src</span>() std.builtin.SourceLocation",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@src\"</span> {\n    <span class=\"tok-kw\">try</span> doTheTest();\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">doTheTest</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> src = <span class=\"tok-builtin\">@src</span>();\n\n    <span class=\"tok-kw\">try</span> expect(src.line == <span class=\"tok-number\">9</span>);\n    <span class=\"tok-kw\">try</span> expect(src.column == <span class=\"tok-number\">17</span>);\n    <span class=\"tok-kw\">try</span> expect(std.mem.endsWith(<span class=\"tok-type\">u8</span>, src.fn_name, <span class=\"tok-str\">\"doTheTest\"</span>));\n    <span class=\"tok-kw\">try</span> expect(std.mem.endsWith(<span class=\"tok-type\">u8</span>, src.file, <span class=\"tok-str\">\"test_src_builtin.zig\"</span>));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@sqrt</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@sin</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@cos</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@tan</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@exp</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@exp2</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@log</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@log2</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@log10</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@abs</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@floor</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@ceil</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@trunc</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@round</span>(value: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-builtin\">@TypeOf</span>(value)",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@subWithOverflow</span>(a: <span class=\"tok-kw\">anytype</span>, b: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">struct</span> { <span class=\"tok-builtin\">@TypeOf</span>(a, b), <span class=\"tok-type\">u1</span> }",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@tagName</span>(value: <span class=\"tok-kw\">anytype</span>) [:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@This</span>() <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"@This()\"</span> {\n    <span class=\"tok-kw\">var</span> items = [_]<span class=\"tok-type\">i32</span>{ <span class=\"tok-number\">1</span>, <span class=\"tok-number\">2</span>, <span class=\"tok-number\">3</span>, <span class=\"tok-number\">4</span> };\n    <span class=\"tok-kw\">const</span> list = List(<span class=\"tok-type\">i32</span>){ .items = items[<span class=\"tok-number\">0</span>..] };\n    <span class=\"tok-kw\">try</span> expect(list.length() == <span class=\"tok-number\">4</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">List</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">struct</span> {\n        <span class=\"tok-kw\">const</span> Self = <span class=\"tok-builtin\">@This</span>();\n\n        items: []T,\n\n        <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">length</span>(self: Self) <span class=\"tok-type\">usize</span> {\n            <span class=\"tok-kw\">return</span> self.items.len;\n        }\n    };\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@trap</span>() <span class=\"tok-type\">noreturn</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@truncate</span>(integer: <span class=\"tok-kw\">anytype</span>) <span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"integer truncation\"</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u16</span> = <span class=\"tok-number\">0xabcd</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@truncate</span>(a);\n    <span class=\"tok-kw\">try</span> expect(b == <span class=\"tok-number\">0xcd</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@Type</span>(<span class=\"tok-kw\">comptime</span> info: std.builtin.Type) <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>) std.builtin.Type",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@typeName</span>(T: <span class=\"tok-type\">type</span>) *<span class=\"tok-kw\">const</span> [N:<span class=\"tok-number\">0</span>]<span class=\"tok-type\">u8</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@TypeOf</span>(...) <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"no runtime side effects\"</span> {\n    <span class=\"tok-kw\">var</span> data: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">const</span> T = <span class=\"tok-builtin\">@TypeOf</span>(foo(<span class=\"tok-type\">i32</span>, &data));\n    <span class=\"tok-kw\">try</span> <span class=\"tok-kw\">comptime</span> expect(T == <span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">try</span> expect(data == <span class=\"tok-number\">0</span>);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, ptr: *T) T {\n    ptr.* += <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">return</span> ptr.*;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@unionInit</span>(<span class=\"tok-kw\">comptime</span> Union: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> active_field_name: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, init_expr) Union",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@Vector</span>(len: <span class=\"tok-type\">comptime_int</span>, Element: <span class=\"tok-type\">type</span>) <span class=\"tok-type\">type</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@volatileCast</span>(value: <span class=\"tok-kw\">anytype</span>) DestType",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@workGroupId</span>(<span class=\"tok-kw\">comptime</span> dimension: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@workGroupSize</span>(<span class=\"tok-kw\">comptime</span> dimension: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Builtin Functions §",
    "context": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the po",
    "response": "<span class=\"tok-builtin\">@workItemId</span>(<span class=\"tok-kw\">comptime</span> dimension: <span class=\"tok-type\">u32</span>) <span class=\"tok-type\">u32</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Builtin Functions § in Zig 0.13.0",
    "context": "",
    "response": "Builtin functions are provided by the compiler and are prefixed with @ . The comptime keyword on a parameter means that the parameter must be known at compile time. @addrSpaceCast § Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the pointer operand. It is always valid to cast a pointer between the same address spaces. @addWithOverflow § Performs a + b and returns a tuple with the result and a possible overflow bit. @alignCast § ptr can be *T , ?*T , or []T . Changes the alignment of a pointer. The alignment to use is inferred based on the result type. A pointer alignment safety check is added to the generated code to make sure the pointer is aligned as promised. @alignOf § This function returns the number of bytes that this t",
    "metadata": {
      "version": "0.13.0",
      "topic": "Builtin Functions §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Build Mode §",
    "context": "Zig has four build modes: Debug (default) ReleaseFast ReleaseSafe ReleaseSmall To add standard build options to a build.zig file: build.zig This causes these options to be available: -Doptimize=Debug Optimizations off and safety on (default) -Doptimize=ReleaseSafe Optimizations on and safety on -Doptimize=ReleaseFast Optimizations on and safety off -Doptimize=ReleaseSmall Size optimizations on and safety off Debug § Shell Fast compilation speed Safety checks enabled Slow runtime performance Larg",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">build</span>(b: *std.Build) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> optimize = b.standardOptimizeOption(.{});\n    <span class=\"tok-kw\">const</span> exe = b.addExecutable(.{\n        .name = <span class=\"tok-str\">\"example\"</span>,\n        .root_source_file = b.path(<span class=\"tok-str\">\"example.zig\"</span>),\n        .optimize = optimize,\n    });\n    b.default_step.dependOn(&exe.step);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Build Mode §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Build Mode § in Zig 0.13.0",
    "context": "",
    "response": "Zig has four build modes: Debug (default) ReleaseFast ReleaseSafe ReleaseSmall To add standard build options to a build.zig file: build.zig This causes these options to be available: -Doptimize=Debug Optimizations off and safety on (default) -Doptimize=ReleaseSafe Optimizations on and safety on -Doptimize=ReleaseFast Optimizations on and safety off -Doptimize=ReleaseSmall Size optimizations on and safety off Debug § Shell Fast compilation speed Safety checks enabled Slow runtime performance Large binary size No reproducible build requirement ReleaseFast § Shell Fast runtime performance Safety checks disabled Slow compilation speed Large binary size Reproducible build ReleaseSafe § Shell Medium runtime performance Safety checks enabled Slow compilation speed Large binary size Reproducible build ReleaseSmall § Shell Medium runtime performance Safety checks disabled Slow compilation speed Small binary size Reproducible build See also: Compile Variables Zig Build System Undefined Behavior",
    "metadata": {
      "version": "0.13.0",
      "topic": "Build Mode §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Single Threaded Builds § in Zig 0.13.0",
    "context": "",
    "response": "Zig has a compile option -fsingle-threaded which has the following effects: All Thread Local Variables are treated as regular Container Level Variables . The overhead of Async Functions becomes equivalent to function call overhead. The @import ( &quot;builtin&quot; ).single_threaded becomes true and therefore various userland APIs which read this variable become more efficient. For example std.Mutex becomes an empty data structure and all of its functions become no-ops.",
    "metadata": {
      "version": "0.13.0",
      "topic": "Single Threaded Builds §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"safety check\"</span> {\n    <span class=\"tok-kw\">unreachable</span>;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    assert(<span class=\"tok-null\">false</span>);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">assert</span>(ok: <span class=\"tok-type\">bool</span>) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">if</span> (!ok) <span class=\"tok-kw\">unreachable</span>; <span class=\"tok-comment\">// assertion failure</span>\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    std.debug.assert(<span class=\"tok-null\">false</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> array: [<span class=\"tok-number\">5</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-str\">\"hello\"</span>.*;\n    <span class=\"tok-kw\">const</span> garbage = array[<span class=\"tok-number\">5</span>];\n    _ = garbage;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> x = foo(<span class=\"tok-str\">\"hello\"</span>);\n    _ = x;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(x: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">return</span> x[<span class=\"tok-number\">5</span>];\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> value: <span class=\"tok-type\">i32</span> = -<span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> unsigned: <span class=\"tok-type\">u32</span> = <span class=\"tok-builtin\">@intCast</span>(value);\n    _ = unsigned;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> value: <span class=\"tok-type\">i32</span> = -<span class=\"tok-number\">1</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &value;\n    <span class=\"tok-kw\">const</span> unsigned: <span class=\"tok-type\">u32</span> = <span class=\"tok-builtin\">@intCast</span>(value);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{unsigned});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> spartan_count: <span class=\"tok-type\">u16</span> = <span class=\"tok-number\">300</span>;\n    <span class=\"tok-kw\">const</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@intCast</span>(spartan_count);\n    _ = byte;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> spartan_count: <span class=\"tok-type\">u16</span> = <span class=\"tok-number\">300</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &spartan_count;\n    <span class=\"tok-kw\">const</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-builtin\">@intCast</span>(spartan_count);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{byte});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">var</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n    byte += <span class=\"tok-number\">1</span>;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n    byte += <span class=\"tok-number\">1</span>;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{byte});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> math = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).math;\n<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n\n    byte = <span class=\"tok-kw\">if</span> (math.add(<span class=\"tok-type\">u8</span>, byte, <span class=\"tok-number\">1</span>)) |result| result <span class=\"tok-kw\">else</span> |err| {\n        print(<span class=\"tok-str\">\"unable to add one: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@errorName</span>(err)});\n        <span class=\"tok-kw\">return</span> err;\n    };\n\n    print(<span class=\"tok-str\">\"result: {}\\n\"</span>, .{byte});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> byte: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">255</span>;\n\n    <span class=\"tok-kw\">const</span> ov = <span class=\"tok-builtin\">@addWithOverflow</span>(byte, <span class=\"tok-number\">10</span>);\n    <span class=\"tok-kw\">if</span> (ov[<span class=\"tok-number\">1</span>] != <span class=\"tok-number\">0</span>) {\n        print(<span class=\"tok-str\">\"overflowed result: {}\\n\"</span>, .{ov[<span class=\"tok-number\">0</span>]});\n    } <span class=\"tok-kw\">else</span> {\n        print(<span class=\"tok-str\">\"result: {}\\n\"</span>, .{ov[<span class=\"tok-number\">0</span>]});\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n<span class=\"tok-kw\">const</span> minInt = std.math.minInt;\n<span class=\"tok-kw\">const</span> maxInt = std.math.maxInt;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"wraparound addition and subtraction\"</span> {\n    <span class=\"tok-kw\">const</span> x: <span class=\"tok-type\">i32</span> = maxInt(<span class=\"tok-type\">i32</span>);\n    <span class=\"tok-kw\">const</span> min_val = x +% <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(min_val == minInt(<span class=\"tok-type\">i32</span>));\n    <span class=\"tok-kw\">const</span> max_val = min_val -% <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">try</span> expect(max_val == maxInt(<span class=\"tok-type\">i32</span>));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> x = <span class=\"tok-builtin\">@shlExact</span>(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">0b01010101</span>), <span class=\"tok-number\">2</span>);\n    _ = x;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">0b01010101</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &x;\n    <span class=\"tok-kw\">const</span> y = <span class=\"tok-builtin\">@shlExact</span>(x, <span class=\"tok-number\">2</span>);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{y});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> x = <span class=\"tok-builtin\">@shrExact</span>(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">u8</span>, <span class=\"tok-number\">0b10101010</span>), <span class=\"tok-number\">2</span>);\n    _ = x;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> x: <span class=\"tok-type\">u8</span> = <span class=\"tok-number\">0b10101010</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &x;\n    <span class=\"tok-kw\">const</span> y = <span class=\"tok-builtin\">@shrExact</span>(x, <span class=\"tok-number\">2</span>);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{y});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">const</span> c = a / b;\n    _ = c;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">1</span>;\n    <span class=\"tok-kw\">var</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    _ = .{ &a, &b };\n    <span class=\"tok-kw\">const</span> c = a / b;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{c});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">i32</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">const</span> c = a % b;\n    _ = c;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">var</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">0</span>;\n    _ = .{ &a, &b };\n    <span class=\"tok-kw\">const</span> c = a % b;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{c});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">const</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@divExact</span>(a, b);\n    _ = c;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">var</span> b: <span class=\"tok-type\">u32</span> = <span class=\"tok-number\">3</span>;\n    _ = .{ &a, &b };\n    <span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@divExact</span>(a, b);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{c});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> optional_number: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n    <span class=\"tok-kw\">const</span> number = optional_number.?;\n    _ = number;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> optional_number: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n    _ = &optional_number;\n    <span class=\"tok-kw\">const</span> number = optional_number.?;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{number});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> optional_number: ?<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n\n    <span class=\"tok-kw\">if</span> (optional_number) |number| {\n        print(<span class=\"tok-str\">\"got number: {}\\n\"</span>, .{number});\n    } <span class=\"tok-kw\">else</span> {\n        print(<span class=\"tok-str\">\"it's null\\n\"</span>, .{});\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> number = getNumberOrFail() <span class=\"tok-kw\">catch</span> <span class=\"tok-kw\">unreachable</span>;\n    _ = number;\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">getNumberOrFail</span>() !<span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.UnableToReturnNumber;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> number = getNumberOrFail() <span class=\"tok-kw\">catch</span> <span class=\"tok-kw\">unreachable</span>;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{number});\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">getNumberOrFail</span>() !<span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.UnableToReturnNumber;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> print = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).debug.print;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> result = getNumberOrFail();\n\n    <span class=\"tok-kw\">if</span> (result) |number| {\n        print(<span class=\"tok-str\">\"got number: {}\\n\"</span>, .{number});\n    } <span class=\"tok-kw\">else</span> |err| {\n        print(<span class=\"tok-str\">\"got error: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@errorName</span>(err)});\n    }\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">getNumberOrFail</span>() !<span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.UnableToReturnNumber;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> err = <span class=\"tok-kw\">error</span>.AnError;\n    <span class=\"tok-kw\">const</span> number = <span class=\"tok-builtin\">@intFromError</span>(err) + <span class=\"tok-number\">10</span>;\n    <span class=\"tok-kw\">const</span> invalid_err = <span class=\"tok-builtin\">@errorFromInt</span>(number);\n    _ = invalid_err;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> err = <span class=\"tok-kw\">error</span>.AnError;\n    <span class=\"tok-kw\">var</span> number = <span class=\"tok-builtin\">@intFromError</span>(err) + <span class=\"tok-number\">500</span>;\n    _ = &number;\n    <span class=\"tok-kw\">const</span> invalid_err = <span class=\"tok-builtin\">@errorFromInt</span>(number);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{invalid_err});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">enum</span> {\n    a,\n    b,\n    c,\n};\n<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> a: <span class=\"tok-type\">u2</span> = <span class=\"tok-number\">3</span>;\n    <span class=\"tok-kw\">const</span> b: Foo = <span class=\"tok-builtin\">@enumFromInt</span>(a);\n    _ = b;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">enum</span> {\n    a,\n    b,\n    c,\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">u2</span> = <span class=\"tok-number\">3</span>;\n    _ = &a;\n    <span class=\"tok-kw\">const</span> b: Foo = <span class=\"tok-builtin\">@enumFromInt</span>(a);\n    std.debug.print(<span class=\"tok-str\">\"value: {s}\\n\"</span>, .{<span class=\"tok-builtin\">@tagName</span>(b)});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> Set1 = <span class=\"tok-kw\">error</span>{\n    A,\n    B,\n};\n<span class=\"tok-kw\">const</span> Set2 = <span class=\"tok-kw\">error</span>{\n    A,\n    C,\n};\n<span class=\"tok-kw\">comptime</span> {\n    _ = <span class=\"tok-builtin\">@as</span>(Set2, <span class=\"tok-builtin\">@errorCast</span>(Set1.B));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Set1 = <span class=\"tok-kw\">error</span>{\n    A,\n    B,\n};\n<span class=\"tok-kw\">const</span> Set2 = <span class=\"tok-kw\">error</span>{\n    A,\n    C,\n};\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    foo(Set1.B);\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(set1: Set1) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> x: Set2 = <span class=\"tok-builtin\">@errorCast</span>(set1);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{x});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">1</span>) <span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrFromInt</span>(<span class=\"tok-number\">0x1</span>);\n    <span class=\"tok-kw\">const</span> aligned: *<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@alignCast</span>(ptr);\n    _ = aligned;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> mem = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).mem;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> array <span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) = [_]<span class=\"tok-type\">u32</span>{ <span class=\"tok-number\">0x11111111</span>, <span class=\"tok-number\">0x11111111</span> };\n    <span class=\"tok-kw\">const</span> bytes = mem.sliceAsBytes(array[<span class=\"tok-number\">0</span>..]);\n    <span class=\"tok-kw\">if</span> (foo(bytes) != <span class=\"tok-number\">0x11111111</span>) <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.Wrong;\n}\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(bytes: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">u32</span> {\n    <span class=\"tok-kw\">const</span> slice4 = bytes[<span class=\"tok-number\">1</span>..<span class=\"tok-number\">5</span>];\n    <span class=\"tok-kw\">const</span> int_slice = mem.bytesAsSlice(<span class=\"tok-type\">u32</span>, <span class=\"tok-builtin\">@as</span>([]<span class=\"tok-kw\">align</span>(<span class=\"tok-number\">4</span>) <span class=\"tok-type\">u8</span>, <span class=\"tok-builtin\">@alignCast</span>(slice4)));\n    <span class=\"tok-kw\">return</span> int_slice[<span class=\"tok-number\">0</span>];\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">var</span> f = Foo{ .int = <span class=\"tok-number\">42</span> };\n    f.float = <span class=\"tok-number\">12.34</span>;\n}\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">union</span> {\n    float: <span class=\"tok-type\">f32</span>,\n    int: <span class=\"tok-type\">u32</span>,\n};",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">union</span> {\n    float: <span class=\"tok-type\">f32</span>,\n    int: <span class=\"tok-type\">u32</span>,\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> f = Foo{ .int = <span class=\"tok-number\">42</span> };\n    bar(&f);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>(f: *Foo) <span class=\"tok-type\">void</span> {\n    f.float = <span class=\"tok-number\">12.34</span>;\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{f.float});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">union</span> {\n    float: <span class=\"tok-type\">f32</span>,\n    int: <span class=\"tok-type\">u32</span>,\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> f = Foo{ .int = <span class=\"tok-number\">42</span> };\n    bar(&f);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>(f: *Foo) <span class=\"tok-type\">void</span> {\n    f.* = Foo{ .float = <span class=\"tok-number\">12.34</span> };\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{f.float});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">const</span> Foo = <span class=\"tok-kw\">union</span> {\n    float: <span class=\"tok-type\">f32</span>,\n    int: <span class=\"tok-type\">u32</span>,\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> f = Foo{ .int = <span class=\"tok-number\">42</span> };\n    f = Foo{ .float = <span class=\"tok-null\">undefined</span> };\n    bar(&f);\n    std.debug.print(<span class=\"tok-str\">\"value: {}\\n\"</span>, .{f.float});\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">bar</span>(f: *Foo) <span class=\"tok-type\">void</span> {\n    f.float = <span class=\"tok-number\">12.34</span>;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> float: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">4294967296</span>;\n    <span class=\"tok-kw\">const</span> int: <span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@intFromFloat</span>(float);\n    _ = int;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> float: <span class=\"tok-type\">f32</span> = <span class=\"tok-number\">4294967296</span>; <span class=\"tok-comment\">// runtime-known</span>\n    _ = &float;\n    <span class=\"tok-kw\">const</span> int: <span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@intFromFloat</span>(float);\n    _ = int;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">comptime</span> {\n    <span class=\"tok-kw\">const</span> opt_ptr: ?*<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrCast</span>(opt_ptr);\n    _ = ptr;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Undefined Behavior §",
    "context": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate opt",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> opt_ptr: ?*<span class=\"tok-type\">i32</span> = <span class=\"tok-null\">null</span>;\n    _ = &opt_ptr;\n    <span class=\"tok-kw\">const</span> ptr: *<span class=\"tok-type\">i32</span> = <span class=\"tok-builtin\">@ptrCast</span>(opt_ptr);\n    _ = ptr;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Undefined Behavior § in Zig 0.13.0",
    "context": "",
    "response": "Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with @setRuntimeSafety . The ReleaseFast and ReleaseSmall build modes disable all safety checks (except where overridden by @setRuntimeSafety ) in order to facilitate optimizations. When a safety check fails, Zig crashes with a stack trace, like this: test_undefined_behavior.zig Shell Reaching Unreachable Code § At compile-time: test_comptime_reaching_unreachable.zig Shell At runtime: runtime_reaching_unreachable.zig Shell Index out of Bounds § At compile-time: test_comptime_index_out_of_bounds.zig Shell At runtime: runtime_index_out_of_bounds.zig Shell Cast Negative Number to Unsigned Integer § At compile-time: test_comptime_invalid_cast.zig Shell At runtime: r",
    "metadata": {
      "version": "0.13.0",
      "topic": "Undefined Behavior §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Memory §",
    "context": "The Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question: Where are the bytes? Like Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - malloc , realloc , ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> Allocator = std.mem.Allocator;\n<span class=\"tok-kw\">const</span> expect = std.testing.expect;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"using an allocator\"</span> {\n    <span class=\"tok-kw\">var</span> buffer: [<span class=\"tok-number\">100</span>]<span class=\"tok-type\">u8</span> = <span class=\"tok-null\">undefined</span>;\n    <span class=\"tok-kw\">var</span> fba = std.heap.FixedBufferAllocator.init(&buffer);\n    <span class=\"tok-kw\">const</span> allocator = fba.allocator();\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">try</span> concat(allocator, <span class=\"tok-str\">\"foo\"</span>, <span class=\"tok-str\">\"bar\"</span>);\n    <span class=\"tok-kw\">try</span> expect(std.mem.eql(<span class=\"tok-type\">u8</span>, <span class=\"tok-str\">\"foobar\"</span>, result));\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">concat</span>(allocator: Allocator, a: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, b: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) ![]<span class=\"tok-type\">u8</span> {\n    <span class=\"tok-kw\">const</span> result = <span class=\"tok-kw\">try</span> allocator.alloc(<span class=\"tok-type\">u8</span>, a.len + b.len);\n    <span class=\"tok-builtin\">@memcpy</span>(result[<span class=\"tok-number\">0</span>..a.len], a);\n    <span class=\"tok-builtin\">@memcpy</span>(result[a.len..], b);\n    <span class=\"tok-kw\">return</span> result;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Memory §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Memory §",
    "context": "The Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question: Where are the bytes? Like Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - malloc , realloc , ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    <span class=\"tok-kw\">defer</span> arena.deinit();\n\n    <span class=\"tok-kw\">const</span> allocator = arena.allocator();\n\n    <span class=\"tok-kw\">const</span> ptr = <span class=\"tok-kw\">try</span> allocator.create(<span class=\"tok-type\">i32</span>);\n    std.debug.print(<span class=\"tok-str\">\"ptr={*}\\n\"</span>, .{ptr});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Memory §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Memory §",
    "context": "The Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question: Where are the bytes? Like Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - malloc , realloc , ",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(s: []<span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    _ = s;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"string literal to mutable slice\"</span> {\n    foo(<span class=\"tok-str\">\"hello\"</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Memory §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Memory §",
    "context": "The Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question: Where are the bytes? Like Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - malloc , realloc , ",
    "response": "<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>(s: []<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>) <span class=\"tok-type\">void</span> {\n    _ = s;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"string literal to constant slice\"</span> {\n    foo(<span class=\"tok-str\">\"hello\"</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Memory §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Memory § in Zig 0.13.0",
    "context": "",
    "response": "The Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question: Where are the bytes? Like Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - malloc , realloc , and free . When linking against libc, Zig exposes this allocator with std.heap.c_allocator . However, by convention, there is no default allocator in Zig. Instead, functions which need to allocate accept an Allocator parameter. Likewise, data structures such as std.ArrayList accept an Allocator parameter in their initialization functions: test_allocator.zig Shell In the above example, 100 bytes of stack memory are used to initialize a FixedBufferAllocator , which is then passed to a function. As",
    "metadata": {
      "version": "0.13.0",
      "topic": "Memory §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Compile Variables §",
    "context": "Compile variables are accessible by importing the &quot;builtin&quot; package, which the compiler makes available to every Zig source file. It contains compile-time constants such as the current target, endianness, and release mode. compile_variables.zig Example of what is imported with @import ( &quot;builtin&quot; ) : @import(\"builtin\") See also: Build Mode",
    "response": "<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n<span class=\"tok-kw\">const</span> separator = <span class=\"tok-kw\">if</span> (builtin.os.tag == .windows) <span class=\"tok-str\">'\\\\'</span> <span class=\"tok-kw\">else</span> <span class=\"tok-str\">'/'</span>;",
    "metadata": {
      "version": "0.13.0",
      "topic": "Compile Variables §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Compile Variables §",
    "context": "Compile variables are accessible by importing the &quot;builtin&quot; package, which the compiler makes available to every Zig source file. It contains compile-time constants such as the current target, endianness, and release mode. compile_variables.zig Example of what is imported with @import ( &quot;builtin&quot; ) : @import(\"builtin\") See also: Build Mode",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-comment\">/// Zig version. When writing code that supports multiple versions of Zig, prefer</span>\n<span class=\"tok-comment\">/// feature detection (i.e. with `@hasDecl` or `@hasField`) over version checks.</span>\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> zig_version = std.SemanticVersion.parse(zig_version_string) <span class=\"tok-kw\">catch</span> <span class=\"tok-kw\">unreachable</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> zig_version_string = <span class=\"tok-str\">\"0.13.0\"</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> zig_backend = std.builtin.CompilerBackend.stage2_llvm;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> output_mode = std.builtin.OutputMode.Exe;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> link_mode = std.builtin.LinkMode.static;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> is_test = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> single_threaded = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> abi = std.Target.Abi.gnu;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> cpu: std.Target.Cpu = .{\n    .arch = .x86_64,\n    .model = &std.Target.x86.cpu.znver4,\n    .features = std.Target.x86.featureSet(&[_]std.Target.x86.Feature{\n        .@\"64bit\",\n        .adx,\n        .aes,\n        .allow_light_256_bit,\n        .avx,\n        .avx2,\n        .avx512bf16,\n        .avx512bitalg,\n        .avx512bw,\n        .avx512cd,\n        .avx512dq,\n        .avx512f,\n        .avx512ifma,\n        .avx512vbmi,\n        .avx512vbmi2,\n        .avx512vl,\n        .avx512vnni,\n        .avx512vpopcntdq,\n        .bmi,\n        .bmi2,\n        .branchfusion,\n        .clflushopt,\n        .clwb,\n        .clzero,\n        .cmov,\n        .crc32,\n        .cx16,\n        .cx8,\n        .evex512,\n        .f16c,\n        .fast_15bytenop,\n        .fast_bextr,\n        .fast_lzcnt,\n        .fast_movbe,\n        .fast_scalar_fsqrt,\n        .fast_scalar_shift_masks,\n        .fast_variable_perlane_shuffle,\n        .fast_vector_fsqrt,\n        .fma,\n        .fsgsbase,\n        .fsrm,\n        .fxsr,\n        .gfni,\n        .invpcid,\n        .lzcnt,\n        .macrofusion,\n        .mmx,\n        .movbe,\n        .mwaitx,\n        .nopl,\n        .pclmul,\n        .pku,\n        .popcnt,\n        .prfchw,\n        .rdpid,\n        .rdpru,\n        .rdrnd,\n        .rdseed,\n        .sahf,\n        .sbb_dep_breaking,\n        .sha,\n        .shstk,\n        .slow_shld,\n        .sse,\n        .sse2,\n        .sse3,\n        .sse4_1,\n        .sse4_2,\n        .sse4a,\n        .ssse3,\n        .vaes,\n        .vpclmulqdq,\n        .vzeroupper,\n        .wbnoinvd,\n        .x87,\n        .xsave,\n        .xsavec,\n        .xsaveopt,\n        .xsaves,\n    }),\n};\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> os = std.Target.Os{\n    .tag = .linux,\n    .version_range = .{ .linux = .{\n        .range = .{\n            .min = .{\n                .major = <span class=\"tok-number\">6</span>,\n                .minor = <span class=\"tok-number\">9</span>,\n                .patch = <span class=\"tok-number\">2</span>,\n            },\n            .max = .{\n                .major = <span class=\"tok-number\">6</span>,\n                .minor = <span class=\"tok-number\">9</span>,\n                .patch = <span class=\"tok-number\">2</span>,\n            },\n        },\n        .glibc = .{\n            .major = <span class=\"tok-number\">2</span>,\n            .minor = <span class=\"tok-number\">39</span>,\n            .patch = <span class=\"tok-number\">0</span>,\n        },\n    }},\n};\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> target: std.Target = .{\n    .cpu = cpu,\n    .os = os,\n    .abi = abi,\n    .ofmt = object_format,\n    .dynamic_linker = std.Target.DynamicLinker.init(<span class=\"tok-str\">\"/nix/store/k7zgvzp2r31zkg9xqgjim7mbknryv6bs-glibc-2.39-52/lib/ld-linux-x86-64.so.2\"</span>),\n};\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> object_format = std.Target.ObjectFormat.elf;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> mode = std.builtin.OptimizeMode.Debug;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> link_libc = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> link_libcpp = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> have_error_return_tracing = <span class=\"tok-null\">true</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> valgrind_support = <span class=\"tok-null\">true</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> sanitize_thread = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> position_independent_code = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> position_independent_executable = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> strip_debug_info = <span class=\"tok-null\">false</span>;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> code_model = std.builtin.CodeModel.default;\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> omit_frame_pointer = <span class=\"tok-null\">false</span>;",
    "metadata": {
      "version": "0.13.0",
      "topic": "Compile Variables §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Compile Variables § in Zig 0.13.0",
    "context": "",
    "response": "Compile variables are accessible by importing the &quot;builtin&quot; package, which the compiler makes available to every Zig source file. It contains compile-time constants such as the current target, endianness, and release mode. compile_variables.zig Example of what is imported with @import ( &quot;builtin&quot; ) : @import(\"builtin\") See also: Build Mode",
    "metadata": {
      "version": "0.13.0",
      "topic": "Compile Variables §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Root Source File § in Zig 0.13.0",
    "context": "",
    "response": "TODO: explain how root source file finds other files TODO: pub fn main TODO: pub fn panic TODO: if linking with libc you can use export fn main TODO: order independent top level declarations TODO: lazy analysis TODO: using comptime { _ = @import() }",
    "metadata": {
      "version": "0.13.0",
      "topic": "Root Source File §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Zig Build System § in Zig 0.13.0",
    "context": "",
    "response": "The Zig Build System provides a cross-platform, dependency-free way to declare the logic required to build a project. With this system, the logic to build a project is written in a build.zig file, using the Zig Build System API to declare and configure build artifacts and other tasks. Some examples of tasks the build system can help with: Performing tasks in parallel and caching the results. Depending on other projects. Providing a package for other projects to depend on. Creating build artifacts by executing the Zig compiler. This includes building Zig source code as well as C and C++ source code. Capturing user-configured options and using those options to configure the build. Surfacing build configuration as comptime values by providing a file that can be imported by Zig code. Caching build artifacts to avoid unnecessarily repeating steps. Executing build artifacts or system-installed tools. Running tests and verifying the output of executing a build artifact matches the expected va",
    "metadata": {
      "version": "0.13.0",
      "topic": "Zig Build System §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@cImport</span>({\n    <span class=\"tok-comment\">// See https://github.com/ziglang/zig/issues/515</span>\n    <span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"_NO_CRT_STDIO_INLINE\"</span>, <span class=\"tok-str\">\"1\"</span>);\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"stdio.h\"</span>);\n});\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    _ = c.printf(<span class=\"tok-str\">\"hello\\n\"</span>);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n\n<span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@cImport</span>({\n    <span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"NDEBUG\"</span>, builtin.mode == .ReleaseFast);\n    <span class=\"tok-kw\">if</span> (something) {\n        <span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"_GNU_SOURCE\"</span>, {});\n    }\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"stdlib.h\"</span>);\n    <span class=\"tok-kw\">if</span> (something) {\n        <span class=\"tok-builtin\">@cUndef</span>(<span class=\"tok-str\">\"_GNU_SOURCE\"</span>);\n    }\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"soundio.h\"</span>);\n});",
    "metadata": {
      "version": "0.13.0",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "long FOO = __LONG_MAX__;",
    "metadata": {
      "version": "0.13.0",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "enum FOO { BAR };\nint do_something(enum FOO foo);",
    "metadata": {
      "version": "0.13.0",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> c = <span class=\"tok-builtin\">@cImport</span>({\n    <span class=\"tok-builtin\">@cDefine</span>(<span class=\"tok-str\">\"_NO_CRT_STDIO_INLINE\"</span>, <span class=\"tok-str\">\"1\"</span>);\n    <span class=\"tok-builtin\">@cInclude</span>(<span class=\"tok-str\">\"stdio.h\"</span>);\n});\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    _ = c;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "#define MAKELOCAL(NAME, INIT) int NAME = INIT\nint foo(void) {\n   MAKELOCAL(a, 1);\n   MAKELOCAL(b, 2);\n   return a + b;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">foo</span>() <span class=\"tok-type\">c_int</span> {\n    <span class=\"tok-kw\">var</span> a: <span class=\"tok-type\">c_int</span> = <span class=\"tok-number\">1</span>;\n    _ = &a;\n    <span class=\"tok-kw\">var</span> b: <span class=\"tok-type\">c_int</span> = <span class=\"tok-number\">2</span>;\n    _ = &b;\n    <span class=\"tok-kw\">return</span> a + b;\n}\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> MAKELOCAL = <span class=\"tok-builtin\">@compileError</span>(<span class=\"tok-str\">\"unable to translate C expr: unexpected token .Equal\"</span>); <span class=\"tok-comment\">// macro.c:1:9</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> testing = std.testing;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">extern</span> <span class=\"tok-str\">\"c\"</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">printf</span>(format: [*:<span class=\"tok-number\">0</span>]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>, ...) <span class=\"tok-type\">c_int</span>;\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"variadic function\"</span> {\n    <span class=\"tok-kw\">try</span> testing.expect(printf(<span class=\"tok-str\">\"Hello, world!\\n\"</span>) == <span class=\"tok-number\">14</span>);\n    <span class=\"tok-kw\">try</span> testing.expect(<span class=\"tok-builtin\">@typeInfo</span>(<span class=\"tok-builtin\">@TypeOf</span>(printf)).Fn.is_var_args);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> testing = std.testing;\n<span class=\"tok-kw\">const</span> builtin = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"builtin\"</span>);\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(count: <span class=\"tok-type\">c_int</span>, ...) <span class=\"tok-kw\">callconv</span>(.C) <span class=\"tok-type\">c_int</span> {\n    <span class=\"tok-kw\">var</span> ap = <span class=\"tok-builtin\">@cVaStart</span>();\n    <span class=\"tok-kw\">defer</span> <span class=\"tok-builtin\">@cVaEnd</span>(&ap);\n    <span class=\"tok-kw\">var</span> i: <span class=\"tok-type\">usize</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">var</span> sum: <span class=\"tok-type\">c_int</span> = <span class=\"tok-number\">0</span>;\n    <span class=\"tok-kw\">while</span> (i < count) : (i += <span class=\"tok-number\">1</span>) {\n        sum += <span class=\"tok-builtin\">@cVaArg</span>(&ap, <span class=\"tok-type\">c_int</span>);\n    }\n    <span class=\"tok-kw\">return</span> sum;\n}\n\n<span class=\"tok-kw\">test</span> <span class=\"tok-str\">\"defining a variadic function\"</span> {\n    <span class=\"tok-kw\">if</span> (builtin.cpu.arch == .aarch64 <span class=\"tok-kw\">and</span> builtin.os.tag != .macos) {\n        <span class=\"tok-comment\">// https://github.com/ziglang/zig/issues/14096</span>\n        <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.SkipZigTest;\n    }\n    <span class=\"tok-kw\">if</span> (builtin.cpu.arch == .x86_64 <span class=\"tok-kw\">and</span> builtin.os.tag == .windows) {\n        <span class=\"tok-comment\">// https://github.com/ziglang/zig/issues/16961</span>\n        <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">error</span>.SkipZigTest;\n    }\n\n    <span class=\"tok-kw\">try</span> std.testing.expectEqual(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">0</span>), add(<span class=\"tok-number\">0</span>));\n    <span class=\"tok-kw\">try</span> std.testing.expectEqual(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">1</span>), add(<span class=\"tok-number\">1</span>, <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">1</span>)));\n    <span class=\"tok-kw\">try</span> std.testing.expectEqual(<span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">3</span>), add(<span class=\"tok-number\">2</span>, <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">1</span>), <span class=\"tok-builtin\">@as</span>(<span class=\"tok-type\">c_int</span>, <span class=\"tok-number\">2</span>)));\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">i32</span> {\n    <span class=\"tok-kw\">return</span> a + b;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "C §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "// This header is generated by zig from mathtest.zig\n#include \"mathtest.h\"\n#include <stdio.h>\n\nint main(int argc, char **argv) {\n    int32_t result = add(42, 1337);\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">build</span>(b: *std.Build) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> lib = b.addSharedLibrary(.{\n        .name = <span class=\"tok-str\">\"mathtest\"</span>,\n        .root_source_file = b.path(<span class=\"tok-str\">\"mathtest.zig\"</span>),\n        .version = .{ .major = <span class=\"tok-number\">1</span>, .minor = <span class=\"tok-number\">0</span>, .patch = <span class=\"tok-number\">0</span> },\n    });\n    <span class=\"tok-kw\">const</span> exe = b.addExecutable(.{\n        .name = <span class=\"tok-str\">\"test\"</span>,\n    });\n    exe.addCSourceFile(.{ .file = b.path(<span class=\"tok-str\">\"test.c\"</span>), .flags = &.{<span class=\"tok-str\">\"-std=c99\"</span>} });\n    exe.linkLibrary(lib);\n    exe.linkSystemLibrary(<span class=\"tok-str\">\"c\"</span>);\n\n    b.default_step.dependOn(&exe.step);\n\n    <span class=\"tok-kw\">const</span> run_cmd = exe.run();\n\n    <span class=\"tok-kw\">const</span> test_step = b.step(<span class=\"tok-str\">\"test\"</span>, <span class=\"tok-str\">\"Test the program\"</span>);\n    test_step.dependOn(&run_cmd.step);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> base64 = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>).base64;\n\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">decode_base_64</span>(\n    dest_ptr: [*]<span class=\"tok-type\">u8</span>,\n    dest_len: <span class=\"tok-type\">usize</span>,\n    source_ptr: [*]<span class=\"tok-kw\">const</span> <span class=\"tok-type\">u8</span>,\n    source_len: <span class=\"tok-type\">usize</span>,\n) <span class=\"tok-type\">usize</span> {\n    <span class=\"tok-kw\">const</span> src = source_ptr[<span class=\"tok-number\">0</span>..source_len];\n    <span class=\"tok-kw\">const</span> dest = dest_ptr[<span class=\"tok-number\">0</span>..dest_len];\n    <span class=\"tok-kw\">const</span> base64_decoder = base64.standard.Decoder;\n    <span class=\"tok-kw\">const</span> decoded_size = base64_decoder.calcSizeForSlice(src) <span class=\"tok-kw\">catch</span> <span class=\"tok-kw\">unreachable</span>;\n    base64_decoder.decode(dest[<span class=\"tok-number\">0</span>..decoded_size], src) <span class=\"tok-kw\">catch</span> <span class=\"tok-kw\">unreachable</span>;\n    <span class=\"tok-kw\">return</span> decoded_size;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "// This header is generated by zig from base64.zig\n#include \"base64.h\"\n\n#include <string.h>\n#include <stdio.h>\n\nint main(int argc, char **argv) {\n    const char *encoded = \"YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz\";\n    char buf[200];\n\n    size_t len = decode_base_64(buf, 200, encoded, strlen(encoded));\n    buf[len] = 0;\n    puts(buf);\n\n    return 0;\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: C §",
    "context": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header Fi",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">build</span>(b: *std.Build) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">const</span> obj = b.addObject(.{\n        .name = <span class=\"tok-str\">\"base64\"</span>,\n        .root_source_file = b.path(<span class=\"tok-str\">\"base64.zig\"</span>),\n    });\n\n    <span class=\"tok-kw\">const</span> exe = b.addExecutable(.{\n        .name = <span class=\"tok-str\">\"test\"</span>,\n    });\n    exe.addCSourceFile(.{ .file = b.path(<span class=\"tok-str\">\"test.c\"</span>), .flags = &.{<span class=\"tok-str\">\"-std=c99\"</span>} });\n    exe.addObject(obj);\n    exe.linkSystemLibrary(<span class=\"tok-str\">\"c\"</span>);\n    b.installArtifact(exe);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "C §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain C § in Zig 0.13.0",
    "context": "",
    "response": "Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. There are a few ways that Zig facilitates C interop. C Type Primitives § These have guaranteed C ABI compatibility and can be used like any other type. c_char c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong c_longdouble To interop with the C void type, use anyopaque . See also: Primitive Types Import from C Header File § The @cImport builtin function can be used to directly import symbols from .h files: cImport_builtin.zig Shell The @cImport function takes an expression as a parameter. This expression is evaluated at compile-time and is used to control preprocessor directives and include multiple .h files: @cImport Expression See also: @cImport @cInclude @cDefine @cUndef @import C Translation CLI § Zig's C translation capability is available as a CLI tool via zig translate-c . It requires a single filename ",
    "metadata": {
      "version": "0.13.0",
      "topic": "C §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: WebAssembly §",
    "context": "Zig supports building for WebAssembly out of the box. Freestanding § For host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs. math.zig Shell test.js Shell WASI § Zig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments: wasi_args.zig Shell Shell A more interesting exampl",
    "response": "<span class=\"tok-kw\">extern</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">print</span>(<span class=\"tok-type\">i32</span>) <span class=\"tok-type\">void</span>;\n\n<span class=\"tok-kw\">export</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">add</span>(a: <span class=\"tok-type\">i32</span>, b: <span class=\"tok-type\">i32</span>) <span class=\"tok-type\">void</span> {\n    print(a + b);\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "WebAssembly §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: WebAssembly §",
    "context": "Zig supports building for WebAssembly out of the box. Freestanding § For host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs. math.zig Shell test.js Shell WASI § Zig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments: wasi_args.zig Shell Shell A more interesting exampl",
    "response": "const fs = require('fs');\nconst source = fs.readFileSync(\"./math.wasm\");\nconst typedArray = new Uint8Array(source);\n\nWebAssembly.instantiate(typedArray, {\n  env: {\n    print: (result) => { console.log(`The result is ${result}`); }\n  }}).then(result => {\n  const add = result.instance.exports.add;\n  add(1, 2);\n});",
    "metadata": {
      "version": "0.13.0",
      "topic": "WebAssembly §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: WebAssembly §",
    "context": "Zig supports building for WebAssembly out of the box. Freestanding § For host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs. math.zig Shell test.js Shell WASI § Zig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments: wasi_args.zig Shell Shell A more interesting exampl",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};\n    <span class=\"tok-kw\">const</span> gpa = general_purpose_allocator.allocator();\n    <span class=\"tok-kw\">const</span> args = <span class=\"tok-kw\">try</span> std.process.argsAlloc(gpa);\n    <span class=\"tok-kw\">defer</span> std.process.argsFree(gpa, args);\n\n    <span class=\"tok-kw\">for</span> (args, <span class=\"tok-number\">0</span>..) |arg, i| {\n        std.debug.print(<span class=\"tok-str\">\"{}: {s}\\n\"</span>, .{ i, arg });\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "WebAssembly §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: WebAssembly §",
    "context": "Zig supports building for WebAssembly out of the box. Freestanding § For host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs. math.zig Shell test.js Shell WASI § Zig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments: wasi_args.zig Shell Shell A more interesting exampl",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n<span class=\"tok-kw\">const</span> fs = std.fs;\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() !<span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};\n    <span class=\"tok-kw\">const</span> gpa = general_purpose_allocator.allocator();\n\n    <span class=\"tok-kw\">var</span> arena_instance = std.heap.ArenaAllocator.init(gpa);\n    <span class=\"tok-kw\">defer</span> arena_instance.deinit();\n    <span class=\"tok-kw\">const</span> arena = arena_instance.allocator();\n\n    <span class=\"tok-kw\">const</span> preopens = <span class=\"tok-kw\">try</span> fs.wasi.preopensAlloc(arena);\n\n    <span class=\"tok-kw\">for</span> (preopens.names, <span class=\"tok-number\">0</span>..) |preopen, i| {\n        std.debug.print(<span class=\"tok-str\">\"{}: {s}\\n\"</span>, .{ i, preopen });\n    }\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "WebAssembly §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain WebAssembly § in Zig 0.13.0",
    "context": "",
    "response": "Zig supports building for WebAssembly out of the box. Freestanding § For host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs. math.zig Shell test.js Shell WASI § Zig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments: wasi_args.zig Shell Shell A more interesting example would be extracting the list of preopens from the runtime. This is now supported in the standard library via std.fs.wasi.Preopens : wasi_preopens.zig Shell Shell",
    "metadata": {
      "version": "0.13.0",
      "topic": "WebAssembly §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Targets § in Zig 0.13.0",
    "context": "",
    "response": "Target refers to the computer that will be used to run an executable. It is composed of the CPU architecture, the set of enabled CPU features, operating system, minimum and maximum operating system version, ABI, and ABI version. Zig is a general-purpose programming language which means that it is designed to generate optimal code for a large set of targets. The command zig targets provides information about all of the targets the compiler is aware of. When no target option is provided to the compiler, the default choice is to target the host computer , meaning that the resulting executable will be unsuitable for copying to a different computer . In order to copy an executable to another computer, the compiler needs to know about the target requirements via the -target option. The Zig Standard Library ( @import ( &quot;std&quot; ) ) has cross-platform abstractions, making the same source code viable on many targets. Some code is more portable than other code. In general, Zig code is ext",
    "metadata": {
      "version": "0.13.0",
      "topic": "Targets §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Style Guide §",
    "context": "These coding conventions are not enforced by the compiler, but they are shipped in this documentation along with the compiler in order to provide a point of reference, should anyone wish to point to an authority on agreed upon Zig coding style. Avoid Redundancy in Names § Avoid these words in type names: Value Data Context Manager utils, misc, or somebody's initials Everything is a value, all types are data, everything is context, all logic manages state. Nothing is communicated by using a word ",
    "response": "<span class=\"tok-kw\">const</span> std = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"std\"</span>);\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> json = <span class=\"tok-kw\">struct</span> {\n    <span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">const</span> JsonValue = <span class=\"tok-kw\">union</span>(<span class=\"tok-kw\">enum</span>) {\n        number: <span class=\"tok-type\">f64</span>,\n        boolean: <span class=\"tok-type\">bool</span>,\n        <span class=\"tok-comment\">// ...</span>\n    };\n};\n\n<span class=\"tok-kw\">pub</span> <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">main</span>() <span class=\"tok-type\">void</span> {\n    std.debug.print(<span class=\"tok-str\">\"{s}\\n\"</span>, .{<span class=\"tok-builtin\">@typeName</span>(json.JsonValue)});\n}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Style Guide §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Style Guide §",
    "context": "These coding conventions are not enforced by the compiler, but they are shipped in this documentation along with the compiler in order to provide a point of reference, should anyone wish to point to an authority on agreed upon Zig coding style. Avoid Redundancy in Names § Avoid these words in type names: Value Data Context Manager utils, misc, or somebody's initials Everything is a value, all types are data, everything is context, all logic manages state. Nothing is communicated by using a word ",
    "response": "<span class=\"tok-kw\">const</span> namespace_name = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"dir_name/file_name.zig\"</span>);\n<span class=\"tok-kw\">const</span> TypeName = <span class=\"tok-builtin\">@import</span>(<span class=\"tok-str\">\"dir_name/TypeName.zig\"</span>);\n<span class=\"tok-kw\">var</span> global_var: <span class=\"tok-type\">i32</span> = <span class=\"tok-null\">undefined</span>;\n<span class=\"tok-kw\">const</span> const_name = <span class=\"tok-number\">42</span>;\n<span class=\"tok-kw\">const</span> primitive_type_alias = <span class=\"tok-type\">f32</span>;\n<span class=\"tok-kw\">const</span> string_alias = []<span class=\"tok-type\">u8</span>;\n\n<span class=\"tok-kw\">const</span> StructName = <span class=\"tok-kw\">struct</span> {\n    field: <span class=\"tok-type\">i32</span>,\n};\n<span class=\"tok-kw\">const</span> StructAlias = StructName;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">functionName</span>(param_name: TypeName) <span class=\"tok-type\">void</span> {\n    <span class=\"tok-kw\">var</span> functionPointer = functionName;\n    functionPointer();\n    functionPointer = otherFunction;\n    functionPointer();\n}\n<span class=\"tok-kw\">const</span> functionAlias = functionName;\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">ListTemplateFunction</span>(<span class=\"tok-kw\">comptime</span> ChildType: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> fixed_size: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> List(ChildType, fixed_size);\n}\n\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">ShortList</span>(<span class=\"tok-kw\">comptime</span> T: <span class=\"tok-type\">type</span>, <span class=\"tok-kw\">comptime</span> n: <span class=\"tok-type\">usize</span>) <span class=\"tok-type\">type</span> {\n    <span class=\"tok-kw\">return</span> <span class=\"tok-kw\">struct</span> {\n        field_name: [n]T,\n        <span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">methodName</span>() <span class=\"tok-type\">void</span> {}\n    };\n}\n\n<span class=\"tok-comment\">// The word XML loses its casing when used in Zig identifiers.</span>\n<span class=\"tok-kw\">const</span> xml_document =\n    <span class=\"tok-str\">\\\\<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n</span>    <span class=\"tok-str\">\\\\<document>\n</span>    <span class=\"tok-str\">\\\\</document>\n</span>;\n<span class=\"tok-kw\">const</span> XmlParser = <span class=\"tok-kw\">struct</span> {\n    field: <span class=\"tok-type\">i32</span>,\n};\n\n<span class=\"tok-comment\">// The initials BE (Big Endian) are just another word in Zig identifier names.</span>\n<span class=\"tok-kw\">fn</span> <span class=\"tok-fn\">readU32Be</span>() <span class=\"tok-type\">u32</span> {}",
    "metadata": {
      "version": "0.13.0",
      "topic": "Style Guide §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Explain Style Guide § in Zig 0.13.0",
    "context": "",
    "response": "These coding conventions are not enforced by the compiler, but they are shipped in this documentation along with the compiler in order to provide a point of reference, should anyone wish to point to an authority on agreed upon Zig coding style. Avoid Redundancy in Names § Avoid these words in type names: Value Data Context Manager utils, misc, or somebody's initials Everything is a value, all types are data, everything is context, all logic manages state. Nothing is communicated by using a word that applies to all types. Temptation to use \"utilities\", \"miscellaneous\", or somebody's initials is a failure to categorize, or more commonly, overcategorization. Such declarations can live at the root of a module that needs them with no namespace needed. Avoid Redundant Names in Fully-Qualified Namespaces § Every declaration is assigned a fully qualified namespace by the compiler, creating a tree structure. Choose names based on the fully-qualified namespace, and avoid redundant name segments.",
    "metadata": {
      "version": "0.13.0",
      "topic": "Style Guide §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Explain Source Encoding § in Zig 0.13.0",
    "context": "",
    "response": "Zig source code is encoded in UTF-8. An invalid UTF-8 byte sequence results in a compile error. Throughout all zig source code (including in comments), some code points are never allowed: Ascii control characters, except for U+000a (LF), U+000d (CR), and U+0009 (HT): U+0000 - U+0008, U+000b - U+000c, U+000e - U+0001f, U+007f. Non-Ascii Unicode line endings: U+0085 (NEL), U+2028 (LS), U+2029 (PS). LF (byte value 0x0a, code point U+000a, '\\n' ) is the line terminator in Zig source code. This byte value terminates every line of zig source code except the last line of the file. It is recommended that non-empty source files end with an empty line, which means the last byte would be 0x0a (LF). Each LF may be immediately preceded by a single CR (byte value 0x0d, code point U+000d, '\\r' ) to form a Windows style line ending, but this is discouraged. Note that in multiline strings, CRLF sequences will be encoded as LF when compiled into a zig program. A CR in any other context is not allowed. H",
    "metadata": {
      "version": "0.13.0",
      "topic": "Source Encoding §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">addrspace</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">align</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">allowzero</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">and</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">anyframe</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">anytype</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">asm</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">async</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">await</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">break</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">callconv</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">catch</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">comptime</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">const</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">continue</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">defer</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">else</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">enum</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">errdefer</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">error</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">export</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">extern</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">fn</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">for</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">if</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">inline</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">linksection</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">noalias</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">noinline</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">nosuspend</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">opaque</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">or</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">orelse</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">packed</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">pub</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">resume</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">return</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">struct</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">suspend</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">switch</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">test</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">threadlocal</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">try</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "medium"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">union</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">unreachable</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">usingnamespace</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">var</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">volatile</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Keyword Reference §",
    "context": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function fra",
    "response": "<span class=\"tok-kw\">while</span>",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "difficulty": "easy"
    }
  },
  {
    "instruction": "Explain Keyword Reference § in Zig 0.13.0",
    "context": "",
    "response": "Keyword Description The addrspace keyword. TODO add documentation for addrspace align can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. See also Alignment The pointer attribute allowzero allows a pointer to have address zero. See also allowzero The boolean operator and . See also Operators anyframe can be used as a type for variables which hold pointers to function frames. See also Async Functions Function parameters can be declared with anytype in place of the type. The type will be inferred where the function is called. See also Function Parameter Type Inference asm begins an inline assembly expression. This allows for directly controlling the machine code generated on compilation. See also Assembly async can be used before a function call to get a pointer to the function's frame when it suspends. See also Async Functions await can be used to suspend the cu",
    "metadata": {
      "version": "0.13.0",
      "topic": "Keyword Reference §",
      "type": "explanation"
    }
  },
  {
    "instruction": "Write Zig 0.13.0 code for: Appendix §",
    "context": "Containers § A container in Zig is any syntactical construct that acts as a namespace to hold variable and function declarations. Containers are also type definitions which can be instantiated. Structs , enums , unions , opaques , and even Zig source files themselves are containers. Although containers (except Zig source files) use curly braces to surround their definition, they should not be confused with blocks or functions. Containers do not contain statements. Grammar § grammar.peg Zen § Com",
    "response": "Root <- skip container_doc_comment? ContainerMembers eof\n\n# *** Top level ***\nContainerMembers <- ContainerDeclaration* (ContainerField COMMA)* (ContainerField / ContainerDeclaration*)\n\nContainerDeclaration <- TestDecl / ComptimeDecl / doc_comment? KEYWORD_pub? Decl\n\nTestDecl <- KEYWORD_test (STRINGLITERALSINGLE / IDENTIFIER)? Block\n\nComptimeDecl <- KEYWORD_comptime Block\n\nDecl\n    <- (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE? / KEYWORD_inline / KEYWORD_noinline)? FnProto (SEMICOLON / Block)\n     / (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE?)? KEYWORD_threadlocal? GlobalVarDecl\n     / KEYWORD_usingnamespace Expr SEMICOLON\n\nFnProto <- KEYWORD_fn IDENTIFIER? LPAREN ParamDeclList RPAREN ByteAlign? AddrSpace? LinkSection? CallConv? EXCLAMATIONMARK? TypeExpr\n\nVarDeclProto <- (KEYWORD_const / KEYWORD_var) IDENTIFIER (COLON TypeExpr)? ByteAlign? AddrSpace? LinkSection?\n\nGlobalVarDecl <- VarDeclProto (EQUAL Expr)? SEMICOLON\n\nContainerField <- doc_comment? KEYWORD_comptime? !KEYWORD_fn (IDENTIFIER COLON)? TypeExpr ByteAlign? (EQUAL Expr)?\n\n# *** Block Level ***\nStatement\n    <- KEYWORD_comptime ComptimeStatement\n     / KEYWORD_nosuspend BlockExprStatement\n     / KEYWORD_suspend BlockExprStatement\n     / KEYWORD_defer BlockExprStatement\n     / KEYWORD_errdefer Payload? BlockExprStatement\n     / IfStatement\n     / LabeledStatement\n     / SwitchExpr\n     / VarDeclExprStatement\n\nComptimeStatement\n    <- BlockExpr\n     / VarDeclExprStatement\n\nIfStatement\n    <- IfPrefix BlockExpr ( KEYWORD_else Payload? Statement )?\n     / IfPrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )\n\nLabeledStatement <- BlockLabel? (Block / LoopStatement)\n\nLoopStatement <- KEYWORD_inline? (ForStatement / WhileStatement)\n\nForStatement\n    <- ForPrefix BlockExpr ( KEYWORD_else Statement )?\n     / ForPrefix AssignExpr ( SEMICOLON / KEYWORD_else Statement )\n\nWhileStatement\n    <- WhilePrefix BlockExpr ( KEYWORD_else Payload? Statement )?\n     / WhilePrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )\n\nBlockExprStatement\n    <- BlockExpr\n     / AssignExpr SEMICOLON\n\nBlockExpr <- BlockLabel? Block\n\n# An expression, assignment, or any destructure, as a statement.\nVarDeclExprStatement\n    <- VarDeclProto (COMMA (VarDeclProto / Expr))* EQUAL Expr SEMICOLON\n     / Expr (AssignOp Expr / (COMMA (VarDeclProto / Expr))+ EQUAL Expr)? SEMICOLON\n\n# *** Expression Level ***\n\n# An assignment or a destructure whose LHS are all lvalue expressions.\nAssignExpr <- Expr (AssignOp Expr / (COMMA Expr)+ EQUAL Expr)?\n\nSingleAssignExpr <- Expr (AssignOp Expr)?\n\nExpr <- BoolOrExpr\n\nBoolOrExpr <- BoolAndExpr (KEYWORD_or BoolAndExpr)*\n\nBoolAndExpr <- CompareExpr (KEYWORD_and CompareExpr)*\n\nCompareExpr <- BitwiseExpr (CompareOp BitwiseExpr)?\n\nBitwiseExpr <- BitShiftExpr (BitwiseOp BitShiftExpr)*\n\nBitShiftExpr <- AdditionExpr (BitShiftOp AdditionExpr)*\n\nAdditionExpr <- MultiplyExpr (AdditionOp MultiplyExpr)*\n\nMultiplyExpr <- PrefixExpr (MultiplyOp PrefixExpr)*\n\nPrefixExpr <- PrefixOp* PrimaryExpr\n\nPrimaryExpr\n    <- AsmExpr\n     / IfExpr\n     / KEYWORD_break BreakLabel? Expr?\n     / KEYWORD_comptime Expr\n     / KEYWORD_nosuspend Expr\n     / KEYWORD_continue BreakLabel?\n     / KEYWORD_resume Expr\n     / KEYWORD_return Expr?\n     / BlockLabel? LoopExpr\n     / Block\n     / CurlySuffixExpr\n\nIfExpr <- IfPrefix Expr (KEYWORD_else Payload? Expr)?\n\nBlock <- LBRACE Statement* RBRACE\n\nLoopExpr <- KEYWORD_inline? (ForExpr / WhileExpr)\n\nForExpr <- ForPrefix Expr (KEYWORD_else Expr)?\n\nWhileExpr <- WhilePrefix Expr (KEYWORD_else Payload? Expr)?\n\nCurlySuffixExpr <- TypeExpr InitList?\n\nInitList\n    <- LBRACE FieldInit (COMMA FieldInit)* COMMA? RBRACE\n     / LBRACE Expr (COMMA Expr)* COMMA? RBRACE\n     / LBRACE RBRACE\n\nTypeExpr <- PrefixTypeOp* ErrorUnionExpr\n\nErrorUnionExpr <- SuffixExpr (EXCLAMATIONMARK TypeExpr)?\n\nSuffixExpr\n    <- KEYWORD_async PrimaryTypeExpr SuffixOp* FnCallArguments\n     / PrimaryTypeExpr (SuffixOp / FnCallArguments)*\n\nPrimaryTypeExpr\n    <- BUILTINIDENTIFIER FnCallArguments\n     / CHAR_LITERAL\n     / ContainerDecl\n     / DOT IDENTIFIER\n     / DOT InitList\n     / ErrorSetDecl\n     / FLOAT\n     / FnProto\n     / GroupedExpr\n     / LabeledTypeExpr\n     / IDENTIFIER\n     / IfTypeExpr\n     / INTEGER\n     / KEYWORD_comptime TypeExpr\n     / KEYWORD_error DOT IDENTIFIER\n     / KEYWORD_anyframe\n     / KEYWORD_unreachable\n     / STRINGLITERAL\n     / SwitchExpr\n\nContainerDecl <- (KEYWORD_extern / KEYWORD_packed)? ContainerDeclAuto\n\nErrorSetDecl <- KEYWORD_error LBRACE IdentifierList RBRACE\n\nGroupedExpr <- LPAREN Expr RPAREN\n\nIfTypeExpr <- IfPrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?\n\nLabeledTypeExpr\n    <- BlockLabel Block\n     / BlockLabel? LoopTypeExpr\n\nLoopTypeExpr <- KEYWORD_inline? (ForTypeExpr / WhileTypeExpr)\n\nForTypeExpr <- ForPrefix TypeExpr (KEYWORD_else TypeExpr)?\n\nWhileTypeExpr <- WhilePrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?\n\nSwitchExpr <- KEYWORD_switch LPAREN Expr RPAREN LBRACE SwitchProngList RBRACE\n\n# *** Assembly ***\nAsmExpr <- KEYWORD_asm KEYWORD_volatile? LPAREN Expr AsmOutput? RPAREN\n\nAsmOutput <- COLON AsmOutputList AsmInput?\n\nAsmOutputItem <- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN (MINUSRARROW TypeExpr / IDENTIFIER) RPAREN\n\nAsmInput <- COLON AsmInputList AsmClobbers?\n\nAsmInputItem <- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN Expr RPAREN\n\nAsmClobbers <- COLON StringList\n\n# *** Helper grammar ***\nBreakLabel <- COLON IDENTIFIER\n\nBlockLabel <- IDENTIFIER COLON\n\nFieldInit <- DOT IDENTIFIER EQUAL Expr\n\nWhileContinueExpr <- COLON LPAREN AssignExpr RPAREN\n\nLinkSection <- KEYWORD_linksection LPAREN Expr RPAREN\n\nAddrSpace <- KEYWORD_addrspace LPAREN Expr RPAREN\n\n# Fn specific\nCallConv <- KEYWORD_callconv LPAREN Expr RPAREN\n\nParamDecl\n    <- doc_comment? (KEYWORD_noalias / KEYWORD_comptime)? (IDENTIFIER COLON)? ParamType\n     / DOT3\n\nParamType\n    <- KEYWORD_anytype\n     / TypeExpr\n\n# Control flow prefixes\nIfPrefix <- KEYWORD_if LPAREN Expr RPAREN PtrPayload?\n\nWhilePrefix <- KEYWORD_while LPAREN Expr RPAREN PtrPayload? WhileContinueExpr?\n\nForPrefix <- KEYWORD_for LPAREN ForArgumentsList RPAREN PtrListPayload\n\n# Payloads\nPayload <- PIPE IDENTIFIER PIPE\n\nPtrPayload <- PIPE ASTERISK? IDENTIFIER PIPE\n\nPtrIndexPayload <- PIPE ASTERISK? IDENTIFIER (COMMA IDENTIFIER)? PIPE\n\nPtrListPayload <- PIPE ASTERISK? IDENTIFIER (COMMA ASTERISK? IDENTIFIER)* COMMA? PIPE\n\n# Switch specific\nSwitchProng <- KEYWORD_inline? SwitchCase EQUALRARROW PtrIndexPayload? SingleAssignExpr\n\nSwitchCase\n    <- SwitchItem (COMMA SwitchItem)* COMMA?\n     / KEYWORD_else\n\nSwitchItem <- Expr (DOT3 Expr)?\n\n# For specific\nForArgumentsList <- ForItem (COMMA ForItem)* COMMA?\n\nForItem <- Expr (DOT2 Expr?)?\n\n# Operators\nAssignOp\n    <- ASTERISKEQUAL\n     / ASTERISKPIPEEQUAL\n     / SLASHEQUAL\n     / PERCENTEQUAL\n     / PLUSEQUAL\n     / PLUSPIPEEQUAL\n     / MINUSEQUAL\n     / MINUSPIPEEQUAL\n     / LARROW2EQUAL\n     / LARROW2PIPEEQUAL\n     / RARROW2EQUAL\n     / AMPERSANDEQUAL\n     / CARETEQUAL\n     / PIPEEQUAL\n     / ASTERISKPERCENTEQUAL\n     / PLUSPERCENTEQUAL\n     / MINUSPERCENTEQUAL\n     / EQUAL\n\nCompareOp\n    <- EQUALEQUAL\n     / EXCLAMATIONMARKEQUAL\n     / LARROW\n     / RARROW\n     / LARROWEQUAL\n     / RARROWEQUAL\n\nBitwiseOp\n    <- AMPERSAND\n     / CARET\n     / PIPE\n     / KEYWORD_orelse\n     / KEYWORD_catch Payload?\n\nBitShiftOp\n    <- LARROW2\n     / RARROW2\n     / LARROW2PIPE\n\nAdditionOp\n    <- PLUS\n     / MINUS\n     / PLUS2\n     / PLUSPERCENT\n     / MINUSPERCENT\n     / PLUSPIPE\n     / MINUSPIPE\n\nMultiplyOp\n    <- PIPE2\n     / ASTERISK\n     / SLASH\n     / PERCENT\n     / ASTERISK2\n     / ASTERISKPERCENT\n     / ASTERISKPIPE\n\nPrefixOp\n    <- EXCLAMATIONMARK\n     / MINUS\n     / TILDE\n     / MINUSPERCENT\n     / AMPERSAND\n     / KEYWORD_try\n     / KEYWORD_await\n\nPrefixTypeOp\n    <- QUESTIONMARK\n     / KEYWORD_anyframe MINUSRARROW\n     / SliceTypeStart (ByteAlign / AddrSpace / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*\n     / PtrTypeStart (AddrSpace / KEYWORD_align LPAREN Expr (COLON Expr COLON Expr)? RPAREN / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*\n     / ArrayTypeStart\n\nSuffixOp\n    <- LBRACKET Expr (DOT2 (Expr? (COLON Expr)?)?)? RBRACKET\n     / DOT IDENTIFIER\n     / DOTASTERISK\n     / DOTQUESTIONMARK\n\nFnCallArguments <- LPAREN ExprList RPAREN\n\n# Ptr specific\nSliceTypeStart <- LBRACKET (COLON Expr)? RBRACKET\n\nPtrTypeStart\n    <- ASTERISK\n     / ASTERISK2\n     / LBRACKET ASTERISK (LETTERC / COLON Expr)? RBRACKET\n\nArrayTypeStart <- LBRACKET Expr (COLON Expr)? RBRACKET\n\n# ContainerDecl specific\nContainerDeclAuto <- ContainerDeclType LBRACE container_doc_comment? ContainerMembers RBRACE\n\nContainerDeclType\n    <- KEYWORD_struct (LPAREN Expr RPAREN)?\n     / KEYWORD_opaque\n     / KEYWORD_enum (LPAREN Expr RPAREN)?\n     / KEYWORD_union (LPAREN (KEYWORD_enum (LPAREN Expr RPAREN)? / Expr) RPAREN)?\n\n# Alignment\nByteAlign <- KEYWORD_align LPAREN Expr RPAREN\n\n# Lists\nIdentifierList <- (doc_comment? IDENTIFIER COMMA)* (doc_comment? IDENTIFIER)?\n\nSwitchProngList <- (SwitchProng COMMA)* SwitchProng?\n\nAsmOutputList <- (AsmOutputItem COMMA)* AsmOutputItem?\n\nAsmInputList <- (AsmInputItem COMMA)* AsmInputItem?\n\nStringList <- (STRINGLITERAL COMMA)* STRINGLITERAL?\n\nParamDeclList <- (ParamDecl COMMA)* ParamDecl?\n\nExprList <- (Expr COMMA)* Expr?\n\n# *** Tokens ***\neof <- !.\nbin <- [01]\nbin_ <- '_'? bin\noct <- [0-7]\noct_ <- '_'? oct\nhex <- [0-9a-fA-F]\nhex_ <- '_'? hex\ndec <- [0-9]\ndec_ <- '_'? dec\n\nbin_int <- bin bin_*\noct_int <- oct oct_*\ndec_int <- dec dec_*\nhex_int <- hex hex_*\n\nox80_oxBF <- [\\200-\\277]\noxF4 <- '\\364'\nox80_ox8F <- [\\200-\\217]\noxF1_oxF3 <- [\\361-\\363]\noxF0 <- '\\360'\nox90_0xBF <- [\\220-\\277]\noxEE_oxEF <- [\\356-\\357]\noxED <- '\\355'\nox80_ox9F <- [\\200-\\237]\noxE1_oxEC <- [\\341-\\354]\noxE0 <- '\\340'\noxA0_oxBF <- [\\240-\\277]\noxC2_oxDF <- [\\302-\\337]\n\n# From https://lemire.me/blog/2018/05/09/how-quickly-can-you-check-that-a-string-is-valid-unicode-utf-8/\n# First Byte      Second Byte     Third Byte      Fourth Byte\n# [0x00,0x7F]\n# [0xC2,0xDF]     [0x80,0xBF]\n#    0xE0         [0xA0,0xBF]     [0x80,0xBF]\n# [0xE1,0xEC]     [0x80,0xBF]     [0x80,0xBF]\n#    0xED         [0x80,0x9F]     [0x80,0xBF]\n# [0xEE,0xEF]     [0x80,0xBF]     [0x80,0xBF]\n#    0xF0         [0x90,0xBF]     [0x80,0xBF]     [0x80,0xBF]\n# [0xF1,0xF3]     [0x80,0xBF]     [0x80,0xBF]     [0x80,0xBF]\n#    0xF4         [0x80,0x8F]     [0x80,0xBF]     [0x80,0xBF]\n\nmb_utf8_literal <-\n       oxF4      ox80_ox8F ox80_oxBF ox80_oxBF\n     / oxF1_oxF3 ox80_oxBF ox80_oxBF ox80_oxBF\n     / oxF0      ox90_0xBF ox80_oxBF ox80_oxBF\n     / oxEE_oxEF ox80_oxBF ox80_oxBF\n     / oxED      ox80_ox9F ox80_oxBF\n     / oxE1_oxEC ox80_oxBF ox80_oxBF\n     / oxE0      oxA0_oxBF ox80_oxBF\n     / oxC2_oxDF ox80_oxBF\n\nascii_char_not_nl_slash_squote <- [\\000-\\011\\013-\\046\\050-\\133\\135-\\177]\n\nchar_escape\n    <- \"\\\\x\" hex hex\n     / \"\\\\u{\" hex+ \"}\"\n     / \"\\\\\" [nr\\\\t'\"]\nchar_char\n    <- mb_utf8_literal\n     / char_escape\n     / ascii_char_not_nl_slash_squote\n\nstring_char\n    <- char_escape\n     / [^\\\\\"\\n]\n\ncontainer_doc_comment <- ('//!' [^\\n]* [ \\n]* skip)+\ndoc_comment <- ('///' [^\\n]* [ \\n]* skip)+\nline_comment <- '//' ![!/][^\\n]* / '////' [^\\n]*\nline_string <- (\"\\\\\\\\\" [^\\n]* [ \\n]*)+\nskip <- ([ \\n] / line_comment)*\n\nCHAR_LITERAL <- \"'\" char_char \"'\" skip\nFLOAT\n    <- \"0x\" hex_int \".\" hex_int ([pP] [-+]? dec_int)? skip\n     /      dec_int \".\" dec_int ([eE] [-+]? dec_int)? skip\n     / \"0x\" hex_int [pP] [-+]? dec_int skip\n     /      dec_int [eE] [-+]? dec_int skip\nINTEGER\n    <- \"0b\" bin_int skip\n     / \"0o\" oct_int skip\n     / \"0x\" hex_int skip\n     /      dec_int   skip\nSTRINGLITERALSINGLE <- \"\\\"\" string_char* \"\\\"\" skip\nSTRINGLITERAL\n    <- STRINGLITERALSINGLE\n     / (line_string                 skip)+\nIDENTIFIER\n    <- !keyword [A-Za-z_] [A-Za-z0-9_]* skip\n     / \"@\" STRINGLITERALSINGLE\nBUILTINIDENTIFIER <- \"@\"[A-Za-z_][A-Za-z0-9_]* skip\n\n\nAMPERSAND            <- '&'      ![=]      skip\nAMPERSANDEQUAL       <- '&='               skip\nASTERISK             <- '*'      ![*%=|]   skip\nASTERISK2            <- '**'               skip\nASTERISKEQUAL        <- '*='               skip\nASTERISKPERCENT      <- '*%'     ![=]      skip\nASTERISKPERCENTEQUAL <- '*%='              skip\nASTERISKPIPE         <- '*|'     ![=]      skip\nASTERISKPIPEEQUAL    <- '*|='              skip\nCARET                <- '^'      ![=]      skip\nCARETEQUAL           <- '^='               skip\nCOLON                <- ':'                skip\nCOMMA                <- ','                skip\nDOT                  <- '.'      ![*.?]    skip\nDOT2                 <- '..'     ![.]      skip\nDOT3                 <- '...'              skip\nDOTASTERISK          <- '.*'               skip\nDOTQUESTIONMARK      <- '.?'               skip\nEQUAL                <- '='      ![>=]     skip\nEQUALEQUAL           <- '=='               skip\nEQUALRARROW          <- '=>'               skip\nEXCLAMATIONMARK      <- '!'      ![=]      skip\nEXCLAMATIONMARKEQUAL <- '!='               skip\nLARROW               <- '<'      ![<=]     skip\nLARROW2              <- '<<'     ![=|]     skip\nLARROW2EQUAL         <- '<<='              skip\nLARROW2PIPE          <- '<<|'    ![=]      skip\nLARROW2PIPEEQUAL     <- '<<|='             skip\nLARROWEQUAL          <- '<='               skip\nLBRACE               <- '{'                skip\nLBRACKET             <- '['                skip\nLPAREN               <- '('                skip\nMINUS                <- '-'      ![%=>|]   skip\nMINUSEQUAL           <- '-='               skip\nMINUSPERCENT         <- '-%'     ![=]      skip\nMINUSPERCENTEQUAL    <- '-%='              skip\nMINUSPIPE            <- '-|'     ![=]      skip\nMINUSPIPEEQUAL       <- '-|='              skip\nMINUSRARROW          <- '->'               skip\nPERCENT              <- '%'      ![=]      skip\nPERCENTEQUAL         <- '%='               skip\nPIPE                 <- '|'      ![|=]     skip\nPIPE2                <- '||'               skip\nPIPEEQUAL            <- '|='               skip\nPLUS                 <- '+'      ![%+=|]   skip\nPLUS2                <- '++'               skip\nPLUSEQUAL            <- '+='               skip\nPLUSPERCENT          <- '+%'     ![=]      skip\nPLUSPERCENTEQUAL     <- '+%='              skip\nPLUSPIPE             <- '+|'     ![=]      skip\nPLUSPIPEEQUAL        <- '+|='              skip\nLETTERC              <- 'c'                skip\nQUESTIONMARK         <- '?'                skip\nRARROW               <- '>'      ![>=]     skip\nRARROW2              <- '>>'     ![=]      skip\nRARROW2EQUAL         <- '>>='              skip\nRARROWEQUAL          <- '>='               skip\nRBRACE               <- '}'                skip\nRBRACKET             <- ']'                skip\nRPAREN               <- ')'                skip\nSEMICOLON            <- ';'                skip\nSLASH                <- '/'      ![=]      skip\nSLASHEQUAL           <- '/='               skip\nTILDE                <- '~'                skip\n\nend_of_word <- ![a-zA-Z0-9_] skip\nKEYWORD_addrspace   <- 'addrspace'   end_of_word\nKEYWORD_align       <- 'align'       end_of_word\nKEYWORD_allowzero   <- 'allowzero'   end_of_word\nKEYWORD_and         <- 'and'         end_of_word\nKEYWORD_anyframe    <- 'anyframe'    end_of_word\nKEYWORD_anytype     <- 'anytype'     end_of_word\nKEYWORD_asm         <- 'asm'         end_of_word\nKEYWORD_async       <- 'async'       end_of_word\nKEYWORD_await       <- 'await'       end_of_word\nKEYWORD_break       <- 'break'       end_of_word\nKEYWORD_callconv    <- 'callconv'    end_of_word\nKEYWORD_catch       <- 'catch'       end_of_word\nKEYWORD_comptime    <- 'comptime'    end_of_word\nKEYWORD_const       <- 'const'       end_of_word\nKEYWORD_continue    <- 'continue'    end_of_word\nKEYWORD_defer       <- 'defer'       end_of_word\nKEYWORD_else        <- 'else'        end_of_word\nKEYWORD_enum        <- 'enum'        end_of_word\nKEYWORD_errdefer    <- 'errdefer'    end_of_word\nKEYWORD_error       <- 'error'       end_of_word\nKEYWORD_export      <- 'export'      end_of_word\nKEYWORD_extern      <- 'extern'      end_of_word\nKEYWORD_fn          <- 'fn'          end_of_word\nKEYWORD_for         <- 'for'         end_of_word\nKEYWORD_if          <- 'if'          end_of_word\nKEYWORD_inline      <- 'inline'      end_of_word\nKEYWORD_noalias     <- 'noalias'     end_of_word\nKEYWORD_nosuspend   <- 'nosuspend'   end_of_word\nKEYWORD_noinline    <- 'noinline'    end_of_word\nKEYWORD_opaque      <- 'opaque'      end_of_word\nKEYWORD_or          <- 'or'          end_of_word\nKEYWORD_orelse      <- 'orelse'      end_of_word\nKEYWORD_packed      <- 'packed'      end_of_word\nKEYWORD_pub         <- 'pub'         end_of_word\nKEYWORD_resume      <- 'resume'      end_of_word\nKEYWORD_return      <- 'return'      end_of_word\nKEYWORD_linksection <- 'linksection' end_of_word\nKEYWORD_struct      <- 'struct'      end_of_word\nKEYWORD_suspend     <- 'suspend'     end_of_word\nKEYWORD_switch      <- 'switch'      end_of_word\nKEYWORD_test        <- 'test'        end_of_word\nKEYWORD_threadlocal <- 'threadlocal' end_of_word\nKEYWORD_try         <- 'try'         end_of_word\nKEYWORD_union       <- 'union'       end_of_word\nKEYWORD_unreachable <- 'unreachable' end_of_word\nKEYWORD_usingnamespace <- 'usingnamespace' end_of_word\nKEYWORD_var         <- 'var'         end_of_word\nKEYWORD_volatile    <- 'volatile'    end_of_word\nKEYWORD_while       <- 'while'       end_of_word\n\nkeyword <- KEYWORD_addrspace / KEYWORD_align / KEYWORD_allowzero / KEYWORD_and\n         / KEYWORD_anyframe / KEYWORD_anytype / KEYWORD_asm / KEYWORD_async\n         / KEYWORD_await / KEYWORD_break / KEYWORD_callconv / KEYWORD_catch\n         / KEYWORD_comptime / KEYWORD_const / KEYWORD_continue / KEYWORD_defer\n         / KEYWORD_else / KEYWORD_enum / KEYWORD_errdefer / KEYWORD_error / KEYWORD_export\n         / KEYWORD_extern / KEYWORD_fn / KEYWORD_for / KEYWORD_if\n         / KEYWORD_inline / KEYWORD_noalias / KEYWORD_nosuspend / KEYWORD_noinline\n         / KEYWORD_opaque / KEYWORD_or / KEYWORD_orelse / KEYWORD_packed\n         / KEYWORD_pub / KEYWORD_resume / KEYWORD_return / KEYWORD_linksection\n         / KEYWORD_struct / KEYWORD_suspend / KEYWORD_switch / KEYWORD_test\n         / KEYWORD_threadlocal / KEYWORD_try / KEYWORD_union / KEYWORD_unreachable\n         / KEYWORD_usingnamespace / KEYWORD_var / KEYWORD_volatile / KEYWORD_while",
    "metadata": {
      "version": "0.13.0",
      "topic": "Appendix §",
      "difficulty": "hard"
    }
  },
  {
    "instruction": "Explain Appendix § in Zig 0.13.0",
    "context": "",
    "response": "Containers § A container in Zig is any syntactical construct that acts as a namespace to hold variable and function declarations. Containers are also type definitions which can be instantiated. Structs , enums , unions , opaques , and even Zig source files themselves are containers. Although containers (except Zig source files) use curly braces to surround their definition, they should not be confused with blocks or functions. Containers do not contain statements. Grammar § grammar.peg Zen § Communicate intent precisely. Edge cases matter. Favor reading code over writing code. Only one obvious way to do things. Runtime crashes are better than bugs. Compile errors are better than runtime crashes. Incremental improvements. Avoid local maximums. Reduce the amount one must remember. Focus on code rather than style. Resource allocation may fail; resource deallocation must succeed. Memory is a resource. Together we serve the users.",
    "metadata": {
      "version": "0.13.0",
      "topic": "Appendix §",
      "type": "explanation"
    }
  }
]